import { ref as ZP, onMounted as ww, provide as XP, openBlock as qP, createElementBlock as YP, renderSlot as JP, createElementVNode as KP, inject as QP, toRaw as $y, watch as Tw, onBeforeUnmount as sv } from "vue";
var Hh = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Fs(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var Aw = { exports: {} };
(function(i) {
  (function(t) {
    var e, r, n = "fulfilled", s = "undefined", o = function() {
      var u = [], c = 0;
      function f() {
        for (; u.length - c; ) {
          try {
            u[c]();
          } catch (p) {
            t.console && t.console.error(p);
          }
          u[c++] = r, c == 1024 && (u.splice(0, 1024), c = 0);
        }
      }
      var d = function() {
        if (typeof MutationObserver === s) return typeof process !== s && typeof process.nextTick == "function" ? function() {
          process.nextTick(f);
        } : typeof setImmediate !== s ? function() {
          setImmediate(f);
        } : function() {
          setTimeout(f, 0);
        };
        var p = document.createElement("div");
        return new MutationObserver(f).observe(p, { attributes: !0 }), function() {
          p.setAttribute("a", 0);
        };
      }();
      return function(p) {
        u.push(p), u.length - c == 1 && d();
      };
    }();
    function a(u) {
      if (!(this instanceof a)) throw new TypeError("Zousan must be created with the new keyword");
      if (typeof u == "function") {
        var c = this;
        try {
          u(function(f) {
            c.resolve(f);
          }, function(f) {
            c.reject(f);
          });
        } catch (f) {
          c.reject(f);
        }
      } else if (0 < arguments.length) throw new TypeError("Zousan resolver " + u + " is not a function");
    }
    function l(u, c) {
      if (typeof u.y == "function") try {
        var f = u.y.call(r, c);
        u.p.resolve(f);
      } catch (d) {
        u.p.reject(d);
      }
      else u.p.resolve(c);
    }
    function h(u, c) {
      if (typeof u.n == "function") try {
        var f = u.n.call(r, c);
        u.p.resolve(f);
      } catch (d) {
        u.p.reject(d);
      }
      else u.p.reject(c);
    }
    a.prototype = { resolve: function(u) {
      if (this.state === e) {
        if (u === this) return this.reject(new TypeError("Attempt to resolve promise with self"));
        var c = this;
        if (u && (typeof u == "function" || typeof u == "object")) try {
          var f = !0, d = u.then;
          if (typeof d == "function") return void d.call(u, function(p) {
            f && (f = !1, c.resolve(p));
          }, function(p) {
            f && (f = !1, c.reject(p));
          });
        } catch (p) {
          return void (f && this.reject(p));
        }
        this.state = n, this.v = u, c.c && o(function() {
          for (var p = 0, g = c.c.length; p < g; p++) l(c.c[p], u);
        });
      }
    }, reject: function(u) {
      if (this.state === e) {
        var c = this;
        this.state = "rejected", this.v = u;
        var f = this.c;
        o(f ? function() {
          for (var d = 0, p = f.length; d < p; d++) h(f[d], u);
        } : function() {
          c.handled || !a.suppressUncaughtRejectionError && t.console && a.warn("You upset Zousan. Please catch rejections: ", u, u ? u.stack : null);
        });
      }
    }, then: function(u, c) {
      var f = new a(), d = { y: u, n: c, p: f };
      if (this.state === e) this.c ? this.c.push(d) : this.c = [d];
      else {
        var p = this.state, g = this.v;
        this.handled = !0, o(function() {
          p === n ? l(d, g) : h(d, g);
        });
      }
      return f;
    }, catch: function(u) {
      return this.then(null, u);
    }, finally: function(u) {
      return this.then(u, u);
    }, timeout: function(u, c) {
      c = c || "Timeout";
      var f = this;
      return new a(function(d, p) {
        setTimeout(function() {
          p(Error(c));
        }, u), f.then(function(g) {
          d(g);
        }, function(g) {
          p(g);
        });
      });
    } }, a.resolve = function(u) {
      var c = new a();
      return c.resolve(u), c;
    }, a.reject = function(u) {
      var c = new a();
      return c.c = [], c.reject(u), c;
    }, a.all = function(u) {
      var c = [], f = 0, d = new a();
      function p(m, v) {
        m && typeof m.then == "function" || (m = a.resolve(m)), m.then(function(_) {
          c[v] = _, ++f == u.length && d.resolve(c);
        }, function(_) {
          d.reject(_);
        });
      }
      for (var g = 0; g < u.length; g++) p(u[g], g);
      return u.length || d.resolve(c), d;
    }, a.warn = console.warn, i.exports && (i.exports = a), t.define && t.define.amd && t.define([], function() {
      return a;
    }), (t.Zousan = a).soon = o;
  })(Hh);
})(Aw);
var t3 = Aw.exports;
const e3 = /* @__PURE__ */ Fs(t3);
var ov = { exports: {} }, Mw = { exports: {} };
(function(i, t) {
  (function(e, r) {
    i.exports = r();
  })(Hh, function() {
    function e(o, a, l, h, u) {
      r(o, a, l || 0, h || o.length - 1, u || s);
    }
    function r(o, a, l, h, u) {
      for (; h > l; ) {
        if (h - l > 600) {
          var c = h - l + 1, f = a - l + 1, d = Math.log(c), p = 0.5 * Math.exp(2 * d / 3), g = 0.5 * Math.sqrt(d * p * (c - p) / c) * (f - c / 2 < 0 ? -1 : 1), m = Math.max(l, Math.floor(a - f * p / c + g)), v = Math.min(h, Math.floor(a + (c - f) * p / c + g));
          r(o, a, m, v, u);
        }
        var _ = o[a], y = l, x = h;
        for (n(o, l, a), u(o[h], _) > 0 && n(o, l, h); y < x; ) {
          for (n(o, y, x), y++, x--; u(o[y], _) < 0; ) y++;
          for (; u(o[x], _) > 0; ) x--;
        }
        u(o[l], _) === 0 ? n(o, l, x) : (x++, n(o, x, h)), x <= a && (l = x + 1), a <= x && (h = x - 1);
      }
    }
    function n(o, a, l) {
      var h = o[a];
      o[a] = o[l], o[l] = h;
    }
    function s(o, a) {
      return o < a ? -1 : o > a ? 1 : 0;
    }
    return e;
  });
})(Mw);
var Sw = Mw.exports;
const n3 = /* @__PURE__ */ Fs(Sw);
ov.exports = Yh;
ov.exports.default = Yh;
var r3 = Sw;
function Yh(i, t) {
  if (!(this instanceof Yh)) return new Yh(i, t);
  this._maxEntries = Math.max(4, i || 9), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), t && this._initFormat(t), this.clear();
}
Yh.prototype = {
  all: function() {
    return this._all(this.data, []);
  },
  search: function(i) {
    var t = this.data, e = [], r = this.toBBox;
    if (!Wu(i, t)) return e;
    for (var n = [], s, o, a, l; t; ) {
      for (s = 0, o = t.children.length; s < o; s++)
        a = t.children[s], l = t.leaf ? r(a) : a, Wu(i, l) && (t.leaf ? e.push(a) : hp(i, l) ? this._all(a, e) : n.push(a));
      t = n.pop();
    }
    return e;
  },
  collides: function(i) {
    var t = this.data, e = this.toBBox;
    if (!Wu(i, t)) return !1;
    for (var r = [], n, s, o, a; t; ) {
      for (n = 0, s = t.children.length; n < s; n++)
        if (o = t.children[n], a = t.leaf ? e(o) : o, Wu(i, a)) {
          if (t.leaf || hp(i, a)) return !0;
          r.push(o);
        }
      t = r.pop();
    }
    return !1;
  },
  load: function(i) {
    if (!(i && i.length)) return this;
    if (i.length < this._minEntries) {
      for (var t = 0, e = i.length; t < e; t++)
        this.insert(i[t]);
      return this;
    }
    var r = this._build(i.slice(), 0, i.length - 1, 0);
    if (!this.data.children.length)
      this.data = r;
    else if (this.data.height === r.height)
      this._splitRoot(this.data, r);
    else {
      if (this.data.height < r.height) {
        var n = this.data;
        this.data = r, r = n;
      }
      this._insert(r, this.data.height - r.height - 1, !0);
    }
    return this;
  },
  insert: function(i) {
    return i && this._insert(i, this.data.height - 1), this;
  },
  clear: function() {
    return this.data = Ha([]), this;
  },
  remove: function(i, t) {
    if (!i) return this;
    for (var e = this.data, r = this.toBBox(i), n = [], s = [], o, a, l, h; e || n.length; ) {
      if (e || (e = n.pop(), a = n[n.length - 1], o = s.pop(), h = !0), e.leaf && (l = i3(i, e.children, t), l !== -1))
        return e.children.splice(l, 1), n.push(e), this._condense(n), this;
      !h && !e.leaf && hp(e, r) ? (n.push(e), s.push(o), o = 0, a = e, e = e.children[0]) : a ? (o++, e = a.children[o], h = !1) : e = null;
    }
    return this;
  },
  toBBox: function(i) {
    return i;
  },
  compareMinX: Wy,
  compareMinY: Zy,
  toJSON: function() {
    return this.data;
  },
  fromJSON: function(i) {
    return this.data = i, this;
  },
  _all: function(i, t) {
    for (var e = []; i; )
      i.leaf ? t.push.apply(t, i.children) : e.push.apply(e, i.children), i = e.pop();
    return t;
  },
  _build: function(i, t, e, r) {
    var n = e - t + 1, s = this._maxEntries, o;
    if (n <= s)
      return o = Ha(i.slice(t, e + 1)), na(o, this.toBBox), o;
    r || (r = Math.ceil(Math.log(n) / Math.log(s)), s = Math.ceil(n / Math.pow(s, r - 1))), o = Ha([]), o.leaf = !1, o.height = r;
    var a = Math.ceil(n / s), l = a * Math.ceil(Math.sqrt(s)), h, u, c, f;
    for (Xy(i, t, e, l, this.compareMinX), h = t; h <= e; h += l)
      for (c = Math.min(h + l - 1, e), Xy(i, h, c, a, this.compareMinY), u = h; u <= c; u += a)
        f = Math.min(u + a - 1, c), o.children.push(this._build(i, u, f, r - 1));
    return na(o, this.toBBox), o;
  },
  _chooseSubtree: function(i, t, e, r) {
    for (var n, s, o, a, l, h, u, c; r.push(t), !(t.leaf || r.length - 1 === e); ) {
      for (u = c = 1 / 0, n = 0, s = t.children.length; n < s; n++)
        o = t.children[n], l = lp(o), h = s3(i, o) - l, h < c ? (c = h, u = l < u ? l : u, a = o) : h === c && l < u && (u = l, a = o);
      t = a || t.children[0];
    }
    return t;
  },
  _insert: function(i, t, e) {
    var r = this.toBBox, n = e ? i : r(i), s = [], o = this._chooseSubtree(n, this.data, t, s);
    for (o.children.push(i), yh(o, n); t >= 0 && s[t].children.length > this._maxEntries; )
      this._split(s, t), t--;
    this._adjustParentBBoxes(n, s, t);
  },
  // split overflowed node into two
  _split: function(i, t) {
    var e = i[t], r = e.children.length, n = this._minEntries;
    this._chooseSplitAxis(e, n, r);
    var s = this._chooseSplitIndex(e, n, r), o = Ha(e.children.splice(s, e.children.length - s));
    o.height = e.height, o.leaf = e.leaf, na(e, this.toBBox), na(o, this.toBBox), t ? i[t - 1].children.push(o) : this._splitRoot(e, o);
  },
  _splitRoot: function(i, t) {
    this.data = Ha([i, t]), this.data.height = i.height + 1, this.data.leaf = !1, na(this.data, this.toBBox);
  },
  _chooseSplitIndex: function(i, t, e) {
    var r, n, s, o, a, l, h, u;
    for (l = h = 1 / 0, r = t; r <= e - t; r++)
      n = vh(i, 0, r, this.toBBox), s = vh(i, r, e, this.toBBox), o = o3(n, s), a = lp(n) + lp(s), o < l ? (l = o, u = r, h = a < h ? a : h) : o === l && a < h && (h = a, u = r);
    return u;
  },
  // sorts node children by the best axis for split
  _chooseSplitAxis: function(i, t, e) {
    var r = i.leaf ? this.compareMinX : Wy, n = i.leaf ? this.compareMinY : Zy, s = this._allDistMargin(i, t, e, r), o = this._allDistMargin(i, t, e, n);
    s < o && i.children.sort(r);
  },
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin: function(i, t, e, r) {
    i.children.sort(r);
    var n = this.toBBox, s = vh(i, 0, t, n), o = vh(i, e - t, e, n), a = $u(s) + $u(o), l, h;
    for (l = t; l < e - t; l++)
      h = i.children[l], yh(s, i.leaf ? n(h) : h), a += $u(s);
    for (l = e - t - 1; l >= t; l--)
      h = i.children[l], yh(o, i.leaf ? n(h) : h), a += $u(o);
    return a;
  },
  _adjustParentBBoxes: function(i, t, e) {
    for (var r = e; r >= 0; r--)
      yh(t[r], i);
  },
  _condense: function(i) {
    for (var t = i.length - 1, e; t >= 0; t--)
      i[t].children.length === 0 ? t > 0 ? (e = i[t - 1].children, e.splice(e.indexOf(i[t]), 1)) : this.clear() : na(i[t], this.toBBox);
  },
  _initFormat: function(i) {
    var t = ["return a", " - b", ";"];
    this.compareMinX = new Function("a", "b", t.join(i[0])), this.compareMinY = new Function("a", "b", t.join(i[1])), this.toBBox = new Function(
      "a",
      "return {minX: a" + i[0] + ", minY: a" + i[1] + ", maxX: a" + i[2] + ", maxY: a" + i[3] + "};"
    );
  }
};
function i3(i, t, e) {
  if (!e) return t.indexOf(i);
  for (var r = 0; r < t.length; r++)
    if (e(i, t[r])) return r;
  return -1;
}
function na(i, t) {
  vh(i, 0, i.children.length, t, i);
}
function vh(i, t, e, r, n) {
  n || (n = Ha(null)), n.minX = 1 / 0, n.minY = 1 / 0, n.maxX = -1 / 0, n.maxY = -1 / 0;
  for (var s = t, o; s < e; s++)
    o = i.children[s], yh(n, i.leaf ? r(o) : o);
  return n;
}
function yh(i, t) {
  return i.minX = Math.min(i.minX, t.minX), i.minY = Math.min(i.minY, t.minY), i.maxX = Math.max(i.maxX, t.maxX), i.maxY = Math.max(i.maxY, t.maxY), i;
}
function Wy(i, t) {
  return i.minX - t.minX;
}
function Zy(i, t) {
  return i.minY - t.minY;
}
function lp(i) {
  return (i.maxX - i.minX) * (i.maxY - i.minY);
}
function $u(i) {
  return i.maxX - i.minX + (i.maxY - i.minY);
}
function s3(i, t) {
  return (Math.max(t.maxX, i.maxX) - Math.min(t.minX, i.minX)) * (Math.max(t.maxY, i.maxY) - Math.min(t.minY, i.minY));
}
function o3(i, t) {
  var e = Math.max(i.minX, t.minX), r = Math.max(i.minY, t.minY), n = Math.min(i.maxX, t.maxX), s = Math.min(i.maxY, t.maxY);
  return Math.max(0, n - e) * Math.max(0, s - r);
}
function hp(i, t) {
  return i.minX <= t.minX && i.minY <= t.minY && t.maxX <= i.maxX && t.maxY <= i.maxY;
}
function Wu(i, t) {
  return t.minX <= i.maxX && t.minY <= i.maxY && t.maxX >= i.minX && t.maxY >= i.minY;
}
function Ha(i) {
  return {
    children: i,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function Xy(i, t, e, r, n) {
  for (var s = [t, e], o; s.length; )
    e = s.pop(), t = s.pop(), !(e - t <= r) && (o = t + Math.ceil((e - t) / r / 2) * r, r3(i, o, t, e, n), s.push(t, o, o, e));
}
var a3 = ov.exports;
const l3 = /* @__PURE__ */ Fs(a3);
var Cw = { exports: {} };
(function(i) {
  (function() {
    function t(a, l) {
      var h = a.x - l.x, u = a.y - l.y;
      return h * h + u * u;
    }
    function e(a, l, h) {
      var u = l.x, c = l.y, f = h.x - u, d = h.y - c;
      if (f !== 0 || d !== 0) {
        var p = ((a.x - u) * f + (a.y - c) * d) / (f * f + d * d);
        p > 1 ? (u = h.x, c = h.y) : p > 0 && (u += f * p, c += d * p);
      }
      return f = a.x - u, d = a.y - c, f * f + d * d;
    }
    function r(a, l) {
      for (var h = a[0], u = [h], c, f = 1, d = a.length; f < d; f++)
        c = a[f], t(c, h) > l && (u.push(c), h = c);
      return h !== c && u.push(c), u;
    }
    function n(a, l, h, u, c) {
      for (var f = u, d, p = l + 1; p < h; p++) {
        var g = e(a[p], a[l], a[h]);
        g > f && (d = p, f = g);
      }
      f > u && (d - l > 1 && n(a, l, d, u, c), c.push(a[d]), h - d > 1 && n(a, d, h, u, c));
    }
    function s(a, l) {
      var h = a.length - 1, u = [a[0]];
      return n(a, 0, h, l, u), u.push(a[h]), u;
    }
    function o(a, l, h) {
      if (a.length <= 2) return a;
      var u = l !== void 0 ? l * l : 1;
      return a = h ? a : r(a, u), a = s(a, u), a;
    }
    i.exports = o, i.exports.default = o;
  })();
})(Cw);
var h3 = Cw.exports;
const u3 = /* @__PURE__ */ Fs(h3);
/*!
* Contains code from THREE.js
* MIT License
* https://github.com/mrdoob/three.js
*/
var Ks = [];
for (var up = 0; up < 6; up++)
  Ks[up] = [];
var Zu = [];
function cp(i, t, e) {
  c3(i);
  for (var r = 0; r < 6; r++) {
    var n = Ks[r];
    if (Zu[0] = n[0] > 0 ? t[1][0] : t[0][0], Zu[1] = n[1] > 0 ? t[1][1] : t[0][1], Zu[2] = n[2] > 0 ? t[1][2] : t[0][2], f3(n, Zu) < 0)
      return !1;
  }
  return !0;
}
function c3(i) {
  var t = i, e = t[0], r = t[1], n = t[2], s = t[3], o = t[4], a = t[5], l = t[6], h = t[7], u = t[8], c = t[9], f = t[10], d = t[11], p = t[12], g = t[13], m = t[14], v = t[15];
  ra(Ks[0], s - e, h - o, d - u, v - p), ra(Ks[1], s + e, h + o, d + u, v + p), ra(Ks[2], s + r, h + a, d + c, v + g), ra(Ks[3], s - r, h - a, d - c, v - g), ra(Ks[4], s - n, h - l, d - f, v - m), ra(Ks[5], s + n, h + l, d + f, v + m);
}
var Xu = 1 / 6;
function ra(i, t, e, r, n) {
  return i[0] = t * Xu, i[1] = e * Xu, i[2] = r * Xu, i[3] = n * Xu, i;
}
function f3(i, t) {
  return i[0] * t[0] + i[1] * t[1] + i[2] * t[2] + i[3];
}
/*!
 * maptalks v1.0.0-rc.33
 * LICENSE : BSD-3-Clause
 * (c) 2016-2024 maptalks.org
 */
var d3 = "1.0.0-rc.33", xs = {
  isTest: !1,
  idleLog: !1,
  idleTimeRemaining: 8,
  idleForceTimeThreshold: 100,
  idleTimeout: 1e3,
  workerCount: window.MAPTALKS_WORKER_COUNT || 0,
  taskCountPerWorkerMessage: 5
}, Eu = "_maptalks__internal_layer_", Pw = ["MultiPoint", "MultiLineString", "MultiPolygon", "GeometryCollection"], Ew = ["FeatureCollection", "Feature", "Point", "LineString", "Polygon"].concat(Pw), Ow = ["markerFile", "polygonPatternFile", "linePatternFile", "markerFillPatternFile", "markerLinePatternFile"], p3 = [["markerWidth", "markerHeight"], [], [null, "lineWidth"], [], [null, "markerLineWidth"]], g3 = {
  lineWidth: 1,
  lineOpacity: 1,
  lineDx: 1,
  lineDy: 1,
  polygonOpacity: 1,
  markerWidth: 1,
  markerHeight: 1,
  markerDx: 1,
  markerDy: 1,
  markerOpacity: 1,
  markerFillOpacity: 1,
  markerLineWidth: 1,
  markerLineOpacity: 1,
  textSize: 1,
  textOpacity: 1,
  textHaloRadius: 1,
  textWrapWidth: 1,
  textLineSpacing: 1,
  textDx: 1,
  textDy: 1
}, m3 = ["lineColor", "polygonFill", "markerFill", "markerLineColor", "textFill"], kw = 14;
function Je() {
  return Date.now();
}
function jt(i) {
  for (var t = 1; t < arguments.length; t++) {
    var e = arguments[t];
    for (var r in e)
      i[r] = e[r];
  }
  return i;
}
function W(i) {
  return i == null;
}
function Ut(i) {
  return typeof i == "number" && !isNaN(i);
}
function ko(i) {
  return (i | 0) === i;
}
function ji(i) {
  return typeof i == "object" && !!i;
}
function De(i) {
  return W(i) ? !1 : typeof i == "string" || i.constructor !== null && i.constructor === String;
}
function Be(i) {
  return W(i) ? !1 : typeof i == "function" || i.constructor !== null && i.constructor === Function;
}
var v3 = Object.prototype.hasOwnProperty;
function Fl(i, t) {
  return v3.call(i, t);
}
function y3(i, t) {
  return i.join ? i.join(t || ",") : Array.prototype.join.call(i, t || ",");
}
function _3(i) {
  var t;
  for (t in i)
    return !1;
  return !t;
}
var Rw = Math.PI / 180;
function Vn(i) {
  return i * Rw;
}
function av(i) {
  return i / Rw;
}
var tr = Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]" && !process.versions.electron && !process.versions.nw && !process.versions["node-webkit"], _h = {};
function qy() {
  return window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI;
}
if (!tr) {
  var Ii = navigator.userAgent.toLowerCase(), fp = document.documentElement || {
    style: {}
  }, ia = "ActiveXObject" in window, dp = Ii.indexOf("webkit") !== -1, pp = Ii.indexOf("phantom") !== -1, Yy = Ii.search("android [23]") !== -1, gp = Ii.indexOf("chrome") !== -1, Jy = Ii.indexOf("gecko") !== -1 && !dp && !window.opera && !ia, x3 = /iphone/i.test(Ii) && /micromessenger/i.test(Ii), Vl = typeof orientation < "u" || Ii.indexOf("mobile") !== -1, Ky = !window.PointerEvent && window.MSPointerEvent, Qy = window.PointerEvent && navigator.pointerEnabled || Ky, t1 = ia && "transition" in fp.style, mp = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !Yy, e1 = "MozPerspective" in fp.style, n1 = "OTransition" in fp.style, b3 = (t1 || mp || e1) && !n1 && !pp, w3 = typeof window < "u" && Be(window.createImageBitmap), T3 = typeof window < "u" && Be(window.ResizeObserver), A3 = typeof window < "u" && Be(window.btoa), M3 = typeof window < "u" && Be(window.Proxy), S3 = typeof window < "u" && Be(window.requestIdleCallback), r1 = 0;
  gp && (r1 = Ii.match(/chrome\/([\d.]+)/)[1]);
  var C3 = !pp && (Qy || "ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch), P3 = typeof window < "u" && "WebGLRenderingContext" in window, i1 = qy(), vp = !1;
  try {
    var E3 = new OffscreenCanvas(2, 2);
    E3.getContext("2d"), vp = !0;
  } catch {
    vp = !1;
  }
  var s1 = !1;
  try {
    window.addEventListener("testPassive", function() {
    }, {
      get passive() {
        s1 = !0;
      }
    });
  } catch {
  }
  _h = {
    isTest: !1,
    ie: ia,
    ielt9: ia && !document.addEventListener,
    edge: "msLaunchUri" in navigator && !("documentMode" in document),
    webkit: dp,
    gecko: Jy,
    android: Ii.indexOf("android") !== -1,
    android23: Yy,
    chrome: gp,
    chromeVersion: r1,
    safari: !gp && Ii.indexOf("safari") !== -1,
    phantomjs: pp,
    ie3d: t1,
    webkit3d: mp,
    gecko3d: e1,
    opera12: n1,
    any3d: b3,
    iosWeixin: x3,
    mobile: Vl,
    mobileWebkit: Vl && dp,
    mobileWebkit3d: Vl && mp,
    mobileOpera: Vl && window.opera,
    mobileGecko: Vl && Jy,
    touch: !!C3,
    msPointer: !!Ky,
    pointer: !!Qy,
    retina: i1 > 1,
    devicePixelRatio: i1,
    language: navigator.browserLanguage ? navigator.browserLanguage : navigator.language,
    ie9: ia && document.documentMode === 9,
    ie10: ia && document.documentMode === 10,
    webgl: P3,
    imageBitMap: w3,
    resizeObserver: T3,
    btoa: A3,
    decodeImageInWorker: vp,
    monitorDPRChange: !0,
    supportsPassive: s1,
    proxy: M3,
    requestIdleCallback: S3,
    checkDevicePixelRatio: function() {
      if (typeof window < "u" && _h.monitorDPRChange) {
        var t = qy(), e = t !== _h.devicePixelRatio;
        return e && (_h.devicePixelRatio = t), e;
      }
      return !1;
    }
  };
}
var Ce = _h;
function O3(i, t) {
  for (var e = 0; e < t.length; e++) {
    var r = t[e];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, F3(r.key), r);
  }
}
function k3(i, t, e) {
  return t && O3(i.prototype, t), Object.defineProperty(i, "prototype", {
    writable: !1
  }), i;
}
function Lm() {
  return Lm = Object.assign ? Object.assign.bind() : function(i) {
    for (var t = 1; t < arguments.length; t++) {
      var e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (i[r] = e[r]);
    }
    return i;
  }, Lm.apply(this, arguments);
}
function Ot(i, t) {
  i.prototype = Object.create(t.prototype), i.prototype.constructor = i, Jh(i, t);
}
function zm(i) {
  return zm = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, zm(i);
}
function Jh(i, t) {
  return Jh = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, n) {
    return r.__proto__ = n, r;
  }, Jh(i, t);
}
function R3() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function gf(i, t, e) {
  return R3() ? gf = Reflect.construct.bind() : gf = function(n, s, o) {
    var a = [null];
    a.push.apply(a, s);
    var l = Function.bind.apply(n, a), h = new l();
    return o && Jh(h, o.prototype), h;
  }, gf.apply(null, arguments);
}
function I3(i) {
  return Function.toString.call(i).indexOf("[native code]") !== -1;
}
function Nm(i) {
  var t = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return Nm = function(r) {
    if (r === null || !I3(r)) return r;
    if (typeof r != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof t < "u") {
      if (t.has(r)) return t.get(r);
      t.set(r, n);
    }
    function n() {
      return gf(r, arguments, zm(this).constructor);
    }
    return n.prototype = Object.create(r.prototype, {
      constructor: {
        value: n,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), Jh(n, r);
  }, Nm(i);
}
function kn(i) {
  if (i === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return i;
}
function D3(i, t) {
  if (typeof i != "object" || i === null) return i;
  var e = i[Symbol.toPrimitive];
  if (e !== void 0) {
    var r = e.call(i, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(i);
}
function F3(i) {
  var t = D3(i, "string");
  return typeof t == "symbol" ? t : String(t);
}
var Iw = function() {
  function i(e, r, n) {
    if (!W(e) && !W(r) ? (this.x = +e, this.y = +r, this.z = n) : !W(e.x) && !W(e.y) ? (this.x = +e.x, this.y = +e.y, this.z = e.z) : Array.isArray(e) && (this.x = +e[0], this.y = +e[1], this.z = e[2]), this._isNaN())
      throw new Error("Position is NaN");
  }
  var t = i.prototype;
  return t.set = function(r, n, s) {
    return this.x = r, this.y = n, this.z = s || 0, this;
  }, t.abs = function() {
    return new this.constructor(Math.abs(this.x), Math.abs(this.y));
  }, t._abs = function() {
    return this.x = Math.abs(this.x), this.y = Math.abs(this.y), this;
  }, t._round = function() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }, t.round = function() {
    return new this.constructor(Math.round(this.x), Math.round(this.y));
  }, t._ceil = function() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }, t.ceil = function() {
    return new this.constructor(Math.ceil(this.x), Math.ceil(this.y));
  }, t.distanceTo = function(r) {
    var n = r.x - this.x, s = r.y - this.y;
    return Math.sqrt(n * n + s * s);
  }, t.mag = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, t._floor = function() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }, t.floor = function() {
    return new this.constructor(Math.floor(this.x), Math.floor(this.y));
  }, t.copy = function() {
    return new this.constructor(this.x, this.y, this.z);
  }, t._add = function(r, n) {
    return W(r.x) ? W(r[0]) ? (this.x += r, this.y += n) : (this.x += r[0], this.y += r[1]) : (this.x += r.x, this.y += r.y), this;
  }, t.add = function(r, n) {
    var s, o;
    return W(r.x) ? W(r[0]) ? (s = this.x + r, o = this.y + n) : (s = this.x + r[0], o = this.y + r[1]) : (s = this.x + r.x, o = this.y + r.y), new this.constructor(s, o);
  }, t._sub = function(r, n) {
    return W(r.x) ? W(r[0]) ? (this.x -= r, this.y -= n) : (this.x -= r[0], this.y -= r[1]) : (this.x -= r.x, this.y -= r.y), this;
  }, t._substract = function() {
    return this._sub.apply(this, arguments);
  }, t.sub = function(r, n) {
    var s, o;
    return W(r.x) ? W(r[0]) ? (s = this.x - r, o = this.y - n) : (s = this.x - r[0], o = this.y - r[1]) : (s = this.x - r.x, o = this.y - r.y), new this.constructor(s, o);
  }, t.substract = function() {
    return this.sub.apply(this, arguments);
  }, t.multi = function(r) {
    return new this.constructor(this.x * r, this.y * r);
  }, t._multi = function(r) {
    return this.x *= r, this.y *= r, this;
  }, t.div = function(r) {
    return this.multi(1 / r);
  }, t._div = function(r) {
    return this._multi(1 / r);
  }, t.equals = function(r) {
    return r instanceof this.constructor ? this.x === r.x && this.y === r.y && this.z === r.z : !1;
  }, t._isNaN = function() {
    return isNaN(this.x) || isNaN(this.y) || Ut(this.z) && isNaN(this.z);
  }, t.isZero = function() {
    return this.x === 0 && this.y === 0;
  }, t.toArray = function() {
    return Ut(this.z) ? [this.x, this.y, this.z] : [this.x, this.y];
  }, t.toFixed = function(r) {
    return new this.constructor(this.x.toFixed(r), this.y.toFixed(r), Ut(this.z) ? this.z.toFixed : void 0);
  }, t.toJSON = function() {
    var r = {
      x: this.x,
      y: this.y
    };
    return Ut(this.z) && (r.z = this.z), r;
  }, i;
}(), Y = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.closeTo = function(n, s) {
    return s || (s = 0), this.x >= n.x - s && this.x <= n.x + s && this.y >= n.y - s && this.y <= n.y + s;
  }, e.mag = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, e.unit = function() {
    return this.copy()._unit();
  }, e._unit = function() {
    return this._div(this.mag()), this;
  }, e.perp = function() {
    return this.copy()._perp();
  }, e._perp = function() {
    var n = this.y;
    return this.y = this.x, this.x = -n, this;
  }, e.angleWith = function(n) {
    return this.angleWithSep(n.x, n.y);
  }, e.angleWithSep = function(n, s) {
    return Math.atan2(this.x * s - this.y * n, this.x * n + this.y * s);
  }, e._rotate = function(n) {
    var s = Math.cos(n), o = Math.sin(n), a = s * this.x - o * this.y, l = o * this.x + s * this.y;
    return this.x = a, this.y = l, this;
  }, e.rotate = function(n) {
    return this.copy()._rotate(n);
  }, t;
}(Iw), Cs, Kh;
(function() {
  if (tr) {
    Cs = function(o) {
      return setTimeout(o, 16);
    }, Kh = clearTimeout;
    return;
  }
  var i, t, e = 1e3 / 30;
  function r(s) {
    return setTimeout(s, e);
  }
  function n(s) {
    return window["webkit" + s] || window["moz" + s] || window["ms" + s];
  }
  typeof window < "u" ? (i = window.requestAnimationFrame || n("RequestAnimationFrame") || r, t = window.cancelAnimationFrame || n("CancelAnimationFrame") || n("CancelRequestAnimationFrame") || function(s) {
    window.clearTimeout(s);
  }) : (i = r, t = clearTimeout), Cs = function(o) {
    return i(o);
  }, Kh = function(o) {
    o && t(o);
  };
})();
function Io(i) {
  var t = "data:image/svg+xml";
  return i.length > 4 && i.slice(-4) === ".svg" ? 1 : i.slice(0, t.length) === t ? 2 : 0;
}
function Qh(i, t) {
  if (tr && Qh.node) {
    Qh.node(i, t);
    return;
  }
  i.src = t[0];
}
var L3 = 0;
function Ls() {
  return L3++;
}
var Dw = Ls;
function tu(i) {
  return !i || !De(i) ? i : JSON.parse(i);
}
function Ui(i) {
  for (var t = 1; t < arguments.length; t++) {
    var e = arguments[t];
    if (e && e.length)
      for (var r = 0, n = e.length; r < n; r++)
        i.push(e[r]);
  }
  return i.length;
}
function zf(i, t) {
  var e = t.indexOf(i);
  e > -1 && t.splice(e, 1);
}
function No(i, t, e) {
  if (!Array.isArray(i))
    return e ? t.call(e, i) : t(i);
  for (var r = [], n, s, o = 0, a = i.length; o < a; o++) {
    if (n = i[o], W(n)) {
      r.push(null);
      continue;
    }
    Array.isArray(n) ? r.push(No(n, t, e)) : (s = e ? t.call(e, n) : t(n), r.push(s));
  }
  return r;
}
function ae(i, t) {
  return i === void 0 ? t : i;
}
function Ar(i) {
  return Math.sign ? Math.sign(i) : (i = +i, i === 0 || isNaN(i) ? Number(i) : i > 0 ? 1 : -1);
}
function z3(i) {
  if (Math.log2)
    return Math.log2(i);
  var t = Math.log(i) * Math.LOG2E, e = Math.round(t);
  return Math.abs(e - t) < 1e-14 ? e : t;
}
function Nf(i, t, e) {
  return i * (1 - e) + t * e;
}
function Ps(i, t, e) {
  if (i === e || i === t)
    return i;
  var r = e - t, n = ((i - t) % r + r) % r + t;
  return n;
}
function Hf(i, t, e) {
  return Math.min(e, Math.max(t, i));
}
function sn(i) {
  return Array.isArray(i) && i.length > 0;
}
var N3 = /^([a-z][a-z\d+\-.]*:)?\/\//i;
function H3(i) {
  return N3.test(i);
}
var Fw = /^url\((['"])(.+)\1\)$/i, Lw = /^url\(([^'"].*[^'"])\)$/i;
function zw(i) {
  return De(i) ? Lw.test(i) ? 1 : Fw.test(i) ? 2 : 3 : 0;
}
function Ad(i) {
  var t = zw(i), e;
  return t === 3 ? i : t === 1 ? (e = Lw.exec(i), e[1]) : t === 2 ? (e = Fw.exec(i), e[2]) : i;
}
var B3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function Nw(i) {
  if (Ce.btoa)
    return window.btoa(i);
  for (var t = String(i), e = "", r, n, s = 0, o = B3; t.charAt(s | 0) || (o = "=", s % 1); e += o.charAt(63 & r >> 8 - s % 1 * 8)) {
    if (n = t.charCodeAt(s += 3 / 4), n > 255)
      throw new Error("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
    r = r << 8 | n;
  }
  return e;
}
function Hw(i, t) {
  for (var e = atob(i), r = new ArrayBuffer(e.length), n = new Uint8Array(r), s = 0; s < e.length; s++)
    n[s] = e.charCodeAt(s) & 255;
  var o = new Blob([r], {
    type: t
  });
  return o;
}
function Bf(i, t, e, r) {
  var n = e - i, s = r - t;
  return Math.atan2(s, n);
}
var lv = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
function jf(i, t) {
  if (!i && !t)
    return !0;
  if (!i || !t)
    return !1;
  for (var e in i)
    if (e === "center") {
      if (!t[e] || !o1(i[e][0], t[e][0]) || !o1(i[e][1], t[e][1]))
        return !1;
    } else if (i[e] !== t[e])
      return !1;
  return !0;
}
function o1(i, t, e) {
  return e == null && (e = 1e-6), i >= t - e && i <= t + e;
}
function hv(i, t, e, r) {
  i || (i = 100), t || (t = 4);
  var n = this, s = this.isVisible();
  t *= 2, this._flashTimeout && clearTimeout(this._flashTimeout);
  function o() {
    if (t === 0) {
      s ? n.show() : n.hide(), e && (r ? e.call(r) : e());
      return;
    }
    t % 2 === 0 ? n.hide() : n.show(), t--, n._flashTimeout = setTimeout(o, i);
  }
  return this._flashTimeout = setTimeout(o, i), this;
}
function j3(i, t) {
  for (var e = Object.getOwnPropertyNames(t), r = 0; r < e.length; r++) {
    var n = e[r], s = Object.getOwnPropertyDescriptor(t, n);
    s && s.configurable && i[n] === void 0 && Object.defineProperty(i, n, s);
  }
  return i;
}
function eu(i, t) {
  i === void 0 && (i = []), t === void 0 && (t = "_pt");
  for (var e = [], r = 0, n = i.length; r < n; r++) {
    var s = i[r];
    if (!s) {
      e.push(null);
      continue;
    }
    s[t] || (s[t] = new Y(0, 0));
    var o = s[t];
    o.x = 0, o.y = 0, e.push(o);
  }
  return e;
}
function uv(i, t) {
  t(i.data);
}
function Md(i) {
  if (i && i.indexOf("http://") === 0 || i.indexOf("https://") === 0)
    return i;
  var t = document.createElement("a");
  return t.href = i, i = t.href, t = null, i;
}
var Ul = {
  cssWidth: "1px",
  cssHeight: "1px",
  width: 1,
  height: 1
};
function cv(i, t) {
  t === void 0 && (t = 1);
  var e = i.width, r = i.height;
  return Ul.cssWidth = e + "px", Ul.cssHeight = r + "px", Ul.width = Math.round(e * t), Ul.height = Math.round(r * t), Ul;
}
var sa, Hm = {
  width: 100,
  height: 10
};
function G3() {
  if (!sa) {
    var i = Hm.width, t = Hm.height;
    OffscreenCanvas ? sa = new OffscreenCanvas(i, t) : (sa = document.createElement("canvas"), sa.width = i, sa.height = t);
  }
  return sa;
}
var a1 = function() {
  function i(e, r) {
    if (r === void 0 && (r = {}), !Array.isArray(e)) {
      console.error("colors is not array");
      return;
    }
    if (e.length < 2) {
      console.error("colors.length should >1");
      return;
    }
    this.colors = e;
    for (var n = 1 / 0, s = -1 / 0, o = 0, a = e.length; o < a; o++) {
      var l = e[o][0];
      n = Math.min(l, n), s = Math.max(l, s);
    }
    this.min = n, this.max = s, this.valueOffset = this.max - this.min, this.options = Object.assign({}, Hm, r), this._initImgData();
  }
  var t = i.prototype;
  return t.getImageData = function() {
    return this.imgData;
  }, t._initImgData = function() {
    var r = G3(), n = this.options, s = n.width, o = n.height;
    r.width = s, r.height = o;
    var a = r.getContext("2d");
    a.clearRect(0, 0, r.width, r.height);
    for (var l = a.createLinearGradient(0, 0, r.width, 0), h = this.colors, u = this.valueOffset, c = 0, f = h.length; c < f; c++) {
      var d = h[c], p = d[0], g = d[1], m = (p - this.min) / u;
      l.addColorStop(m, g);
    }
    a.fillStyle = l, a.fillRect(0, 0, r.width, r.height), this.imgData = a.getImageData(0, 0, r.width, r.height);
  }, t.getColor = function(r) {
    r = Math.max(this.min, r), r = Math.min(r, this.max);
    var n = (r - this.min) / this.valueOffset, s = Math.round(n * this.imgData.width);
    s = Math.min(s, this.imgData.width - 1);
    var o = s * 4, a = this.imgData.data[o], l = this.imgData.data[o + 1], h = this.imgData.data[o + 2], u = this.imgData.data[o + 3];
    return [a, l, h, u];
  }, i;
}(), V3 = typeof Map == "function", xh;
V3 && (xh = /* @__PURE__ */ new Map());
function Bw(i, t) {
  var e, r, n;
  if (!_n(i))
    e = function() {
      return i;
    }, r = !0, n = !0;
  else {
    var s = i.stops && typeof i.stops[0][0] == "object", o = s || i.property !== void 0, a = s || !o, l = i.type || t || "exponential", h;
    if (l === "exponential")
      h = l1;
    else if (l === "interval")
      h = W3;
    else if (l === "categorical")
      h = $3;
    else if (l === "identity")
      h = X3;
    else if (l === "color-interpolate")
      h = Z3;
    else
      throw new Error('Unknown function type "' + l + '"');
    if (s) {
      for (var u = {}, c = [], f = 0; f < i.stops.length; f++) {
        var d = i.stops[f];
        u[d[0].zoom] === void 0 && (u[d[0].zoom] = {
          zoom: d[0].zoom,
          type: i.type,
          property: i.property,
          default: i.default,
          stops: []
        }), u[d[0].zoom].stops.push([d[0].value, d[1]]);
      }
      for (var p in u)
        c.push([u[p].zoom, Bw(u[p])]);
      e = function(m, v) {
        var _ = l1({
          stops: c,
          base: i.base
        }, m)(m, v);
        return typeof _ == "function" ? _(m, v) : _;
      }, r = !1, n = !1;
    } else a ? (e = function(m) {
      var v = h(i, m);
      return typeof v == "function" ? v(m) : v;
    }, r = !0, n = !1) : (e = function(m, v) {
      var _ = h(i, v ? v[i.property] : null);
      return typeof _ == "function" ? _(m, v) : _;
    }, r = !1, n = !0);
  }
  return e.isZoomConstant = n, e.isFeatureConstant = r, e;
}
function U3(i, t, e) {
  return i !== void 0 ? i : t !== void 0 ? t : null;
}
function $3(i, t) {
  for (var e = 0; e < i.stops.length; e++)
    if (t === i.stops[e][0])
      return i.stops[e][1];
  return i.default;
}
function W3(i, t) {
  for (var e = 0; e < i.stops.length && !(t < i.stops[e][0]); e++)
    ;
  return i.stops[Math.max(e - 1, 0)][1];
}
function l1(i, t) {
  for (var e = i.base !== void 0 ? i.base : 1, r = 0; !(r >= i.stops.length); ) {
    if (t <= i.stops[r][0]) break;
    r++;
  }
  return r === 0 ? i.stops[r][1] : r === i.stops.length ? i.stops[r - 1][1] : jw(t, e, i.stops[r - 1][0], i.stops[r][0], i.stops[r - 1][1], i.stops[r][1]);
}
var h1 = {
  width: 100,
  height: 1
};
function Z3(i, t) {
  var e = i.stops;
  if (e && e.length > 1) {
    var r;
    if (xh) {
      var n = JSON.stringify(e);
      if (!xh.has(n)) {
        var s = new a1(e, h1);
        xh.set(n, s);
      }
      r = xh.get(n);
    } else
      r = new a1(e, h1);
    var o = r.getColor(t), a = o[0], l = o[1], h = o[2], u = o[3];
    return [a / 255, l / 255, h / 255, u / 255];
  } else if (e && e.length === 1)
    return e[0][1];
  return null;
}
function X3(i, t) {
  return U3(t, i.default);
}
function jw(i, t, e, r, n, s) {
  return typeof n == "function" ? function() {
    var o = n.apply(void 0, arguments), a = s.apply(void 0, arguments);
    return jw(i, t, e, r, o, a);
  } : n.length ? q3(i, t, e, r, n, s) : Gw(i, t, e, r, n, s);
}
function Gw(i, t, e, r, n, s) {
  var o = r - e, a = i - e, l;
  return t === 1 ? l = a / o : l = (Math.pow(t, a) - 1) / (Math.pow(t, o) - 1), n * (1 - l) + s * l;
}
function q3(i, t, e, r, n, s) {
  for (var o = [], a = 0; a < n.length; a++)
    o[a] = Gw(i, t, e, r, n[a], s[a]);
  return o;
}
function _n(i) {
  return i && typeof i == "object" && (i.stops || i.property && i.type === "identity");
}
function Vw(i) {
  for (var t in i)
    if (_n(i[t]))
      return !0;
  return !1;
}
function Gf(i) {
  return Uw(i, "exponential");
}
function fv(i, t) {
  if (!i)
    return null;
  var e = !1;
  if (Array.isArray(i)) {
    for (var r = [], n, s = 0; s < i.length; s++)
      n = fv(i[s], t), n ? (r.push(n), e = !0) : r.push(i[s]);
    return e ? r : i;
  }
  var o = {
    __fn_types_loaded: !0
  }, a = [], l;
  for (l in i)
    i.hasOwnProperty(l) && a.push(l);
  for (var h = function(d) {
    Object.defineProperty(o, d, {
      get: function() {
        return this["__fn_" + d] || (this["__fn_" + d] = Gf(this["_" + d])), this["__fn_" + d].apply(this, t());
      },
      set: function(g) {
        this["_" + d] = g;
      },
      configurable: !0,
      enumerable: !0
    });
  }, u = 0, c = a.length; u < c; u++)
    l = a[u], _n(i[l]) ? (e = !0, o["_" + l] = i[l], h(l)) : o[l] = i[l];
  return e ? o : i;
}
function u1(i) {
  if (!i || !i.stops)
    return [];
  for (var t = [], e = 0, r = i.stops.length; e < r; e++)
    t.push(i.stops[e][1]);
  return t;
}
function Uw(i, t) {
  if (!_n(i))
    return function() {
      return i;
    };
  i = JSON.parse(JSON.stringify(i));
  var e = !0, r = !0, n = i.stops;
  if (n) {
    for (var s = 0; s < n.length; s++)
      if (_n(n[s][1])) {
        var o = Uw(n[s][1], t);
        e = e && o.isZoomConstant, r = r && o.isFeatureConstant, n[s] = [n[s][0], o];
      }
  }
  var a = Bw(i, t);
  return a.isZoomConstant = e && a.isZoomConstant, a.isFeatureConstant = r && a.isFeatureConstant, a;
}
var dv = ["Unknown", "Point", "LineString", "Polygon", "MultiPoint", "MultiLineString", "MultiPolygon", "GeometryCollection"];
function Y3(i) {
  return typeof i == "object" && !!i;
}
function pv(i) {
  return new Function("f", "var p = (f && f.properties || {}); return " + $w(i));
}
function $w(i) {
  if (!i) return "true";
  var t = i[0];
  if (i.length <= 1) return t === "any" ? "false" : "true";
  var e = t === "==" ? yp(i[1], i[2], "===", !1) : t === "!=" ? yp(i[1], i[2], "!==", !1) : t === "<" || t === ">" || t === "<=" || t === ">=" ? yp(i[1], i[2], t, !0) : t === "any" ? _p(i.slice(1), "||") : t === "all" ? _p(i.slice(1), "&&") : t === "none" ? xp(_p(i.slice(1), "||")) : t === "in" ? c1(i[1], i.slice(2)) : t === "!in" ? xp(c1(i[1], i.slice(2))) : t === "has" ? f1(i[1]) : t === "!has" ? xp(f1(i[1])) : t === "contains" ? K3(i[1], i[2], i[3]) : "true";
  return "(" + e + ")";
}
function J3(i, t, e, r) {
  var n = i.property, s = i.op, o = Sd(n);
  if (s === "length")
    o = "((" + o + "+='').length)";
  else
    return console.error("not support " + s + " op"), "false";
  return Ww(o, n, t, e, r);
}
function K3(i, t, e) {
  var r = Sd(i);
  return e !== void 0 ? "(" + r + ` + '').indexOf("` + t + '") === ' + e : "(" + r + ` + '').indexOf("` + t + '") >= 0';
}
function Sd(i) {
  return i[0] === "$" ? "f." + i.substring(1) : "p[" + JSON.stringify(i) + "]";
}
function yp(i, t, e, r) {
  if (Y3(i) && i.op)
    return J3(i, t, e, r);
  var n = Sd(i);
  return Ww(n, i, t, e, r);
}
function Ww(i, t, e, r, n) {
  var s = t === "$type" ? dv.indexOf(e) : JSON.stringify(e);
  return (n ? "typeof " + i + "=== typeof " + s + "&&" : "") + i + r + s;
}
function _p(i, t) {
  return i.map($w).join(t);
}
function c1(i, t) {
  i === "$type" && (t = t.map(function(n) {
    return dv.indexOf(n);
  }));
  var e = JSON.stringify(t.sort(Q3)), r = Sd(i);
  return t.length <= 200 ? e + ".indexOf(" + r + ") !== -1" : `function(v, a, i, j) {
        while (i <= j) { var m = (i + j) >> 1;
            if (a[m] === v) return true; if (a[m] > v) j = m - 1; else i = m + 1;
        }
    return false; }(` + r + ", " + e + ",0," + (t.length - 1) + ")";
}
function f1(i) {
  return i === "$id" ? '"id" in f' : JSON.stringify(i) + " in p";
}
function xp(i) {
  return "!(" + i + ")";
}
function Q3(i, t) {
  return i < t ? -1 : i > t ? 1 : 0;
}
function Bm(i) {
  var t = i._toJSON(), e = t.feature;
  return e.type = dv.indexOf(e.geometry.type), e.subType = t.subType, e;
}
function Zw(i) {
  if (!Array.isArray(i))
    return Zw([i]);
  for (var t = [], e = 0; e < i.length; e++) {
    var r = void 0;
    i[e].filter === !0 ? r = function() {
      return !0;
    } : r = pv(i[e].filter), t.push(tE({}, i[e], {
      filter: r
    }));
  }
  return t;
}
function tE(i) {
  for (var t = 1; t < arguments.length; t++) {
    var e = arguments[t];
    for (var r in e)
      i[r] = e[r];
  }
  return i;
}
var eE = [], nE = {};
function Vf(i, t) {
  return fv(i, function() {
    var e = t.getMap();
    return rE(eE, e ? e.getZoom() : 12, jt({}, t.getProperties(), iE(nE, e && e.getBearing() || 0, e && e.getPitch() || 0, e ? e.getZoom() : 10)));
  });
}
function rE(i, t, e) {
  return i[0] = t, i[1] = e, i;
}
function iE(i, t, e, r) {
  return i["{bearing}"] = t, i["{pitch}"] = e, i["{zoom}"] = r, i;
}
function Xw(i) {
  var t = {
    stroke: {
      stroke: i.markerLineColor,
      "stroke-width": i.markerLineWidth,
      "stroke-opacity": i.markerLineOpacity,
      "stroke-dasharray": null,
      "stroke-linecap": "butt",
      "stroke-linejoin": "round"
    },
    fill: {
      fill: i.markerFill,
      "fill-opacity": i.markerFillOpacity
    }
  };
  return t.stroke["stroke-width"] === 0 && (t.stroke["stroke-opacity"] = 0), t;
}
function nu(i, t, e) {
  if (!i.markerPath)
    return null;
  var r = 1, n = Xw(i);
  Ut(i.markerOpacity) && (r = i.markerOpacity), Ut(i.opacity) && (r *= i.opacity);
  var s = {};
  if (n) {
    for (var o in n.stroke)
      n.stroke.hasOwnProperty(o) && (W(n.stroke[o]) || (s[o] = n.stroke[o]));
    for (var a in n.fill)
      n.fill.hasOwnProperty(a) && (W(n.fill[a]) || (s[a] = n.fill[a]));
  }
  for (var l = Array.isArray(i.markerPath) ? i.markerPath : [i.markerPath], h, u = [], c = 0; c < l.length; c++)
    h = De(l[c]) ? {
      path: l[c]
    } : l[c], h = jt({}, h, s), h.d = h.path, delete h.path, u.push(h);
  var f = ['<svg version="1.1"', 'xmlns="http://www.w3.org/2000/svg"'];
  r < 1 && f.push('opacity="' + r + '"'), i.markerPathWidth && i.markerPathHeight && f.push('viewBox="0 0 ' + i.markerPathWidth + " " + i.markerPathHeight + '"'), f.push('preserveAspectRatio="none"'), t && f.push('width="' + t + '"'), e && f.push('height="' + e + '"'), f.push("><defs></defs>");
  for (var d = 0; d < u.length; d++) {
    var p = "<path ";
    for (var g in u[d])
      u[d].hasOwnProperty(g) && (p += " " + g + '="' + u[d][g] + '"');
    p += "></path>", f.push(p);
  }
  f.push("</svg>");
  var m = "data:image/svg+xml;base64," + Nw(f.join(" "));
  return m;
}
function Ou(i, t) {
  if (!i)
    return [];
  var e = i;
  Array.isArray(i) || (e = [i]);
  for (var r = [], n = Ow, s, o, a, l, h = e.length - 1; h >= 0; h--)
    if (i = e[h], !!i) {
      t && (i = Uf(i));
      for (var u = 0; u < n.length; u++)
        if (s = i[n[u]], _n(s) && (s = u1(s)), !!s) {
          Array.isArray(s) || (s = [s]);
          for (var c = 0; c < s.length; c++)
            s[c].slice(0, 4) === "url(" && (s[c] = Ad(s[c])), o = p3[u], r.push([s[c], i[o[0]], i[o[1]]]);
        }
      if (i.markerType === "path" && i.markerPath)
        if (a = _n(i.markerWidth) ? 200 : i.markerWidth, l = _n(i.markerHeight) ? 200 : i.markerHeight, _n(i.markerPath)) {
          s = u1(i.markerPath);
          for (var f = i.markerPath, d = 0; d < s.length; d++)
            i.markerPath = s[d], r.push([nu(i), a, l]);
          i.markerPath = f;
        } else
          r.push([nu(i), a, l]);
    }
  return r;
}
function Uf(i) {
  if (!i)
    return null;
  var t = i;
  if (tr)
    return t;
  for (var e = Ow, r, n = 0, s = e.length; n < s; n++)
    r = t[e[n]], r && (t[e[n]] = qw(r));
  return t;
}
function qw(i) {
  if (_n(i) && i.stops) {
    for (var t = i.stops, e = 0; e < t.length; e++)
      t[e][1] = qw(t[e][1]);
    return i;
  }
  return i.slice(0, 4) === "url(" && (i = Ad(i)), i;
}
var zn = function() {
  function i(e, r) {
    Ut(e) && Ut(r) ? (this.width = e, this.height = r) : Ut(e.width) ? (this.width = e.width, this.height = e.height) : Array.isArray(e) && (this.width = e[0], this.height = e[1]);
  }
  var t = i.prototype;
  return t.copy = function() {
    return new i(this.width, this.height);
  }, t.add = function(r, n) {
    var s, o;
    return r instanceof i ? (s = this.width + r.width, o = this.height + r.height) : (s = this.width + r, o = this.height + n), new i(s, o);
  }, t.equals = function(r) {
    return this.width === r.width && this.height === r.height;
  }, t.multi = function(r) {
    return new i(this.width * r, this.height * r);
  }, t._multi = function(r) {
    return this.width *= r, this.height *= r, this;
  }, t._round = function() {
    return this.width = Math.round(this.width), this.height = Math.round(this.height), this;
  }, t.toPoint = function() {
    return new Y(this.width, this.height);
  }, t.toArray = function() {
    return [this.width, this.height];
  }, t.toJSON = function() {
    return {
      width: this.width,
      height: this.height
    };
  }, i;
}();
function gv(i) {
  return i.trim ? i.trim() : i.replace(/^\s+|\s+$/g, "");
}
var sE = /[\b\t\r\v\f]/igm;
function Cd(i) {
  return De(i) ? i.replace(sE, "") : i;
}
function Yw(i) {
  return gv(i).split(/\s+/);
}
var d1 = typeof document < "u" ? document.createElement("canvas").getContext("2d") : null;
function lo(i, t) {
  return lo.node ? lo.node(i, t) : (d1.font = t, d1.measureText(i).width);
}
function mv(i, t, e) {
  var r = lo(i, t);
  return new zn(r, e || kw);
}
function jm(i, t, e, r) {
  if (!i || i.length === 0)
    return [{
      text: "",
      width: 0
    }];
  var n = W(r) ? lo(i, t) : r, s = n / i.length, o = Math.floor(e / s / 2);
  if (s >= e || o <= 0)
    return [{
      text: "",
      width: e
    }];
  if (n <= e) return [{
    text: i,
    width: n
  }];
  for (var a = [], l = i.substring(0, o), h = s * o, u = o, c = i.length; u < c; u++) {
    var f = i[u], d = lo(l + f);
    d >= e ? (a.push({
      text: l,
      width: h
    }), l = i.substring(u, o + u), u += o - 1, h = s * o) : (l += f, h = d), u >= c - 1 && (h = lo(l), a.push({
      text: l,
      width: h
    }));
  }
  return a;
}
var Jw = /\{([\w_]+)\}/g;
function $f(i, t) {
  return De(i) ? i.replace(Jw, function(e, r) {
    if (!t)
      return "";
    var n = t[r];
    return W(n) ? "" : Array.isArray(n) ? n.join() : n;
  }) : i;
}
function Wf(i, t) {
  Ut(i) && (i += ""), i = i || "";
  var e = t.textMaxHeight || 0, r = yv(i, t);
  return e && e < r.size.height && (r.size.height = e), r;
}
function Es(i, t, e) {
  var r = i.width, n = i.height, s, o;
  return t === "left" ? s = -r : t === "right" ? s = 0 : s = -r / 2, e === "top" ? o = -n : e === "bottom" ? o = 0 : o = -n / 2, new Y(s, o);
}
var Kw = "sans-serif", Qw = 14;
function vv(i) {
  if (i.textFont)
    return i.textFont;
  var t = i.textSize;
  return W(t) && (t = Qw), (i.textStyle && i.textStyle !== "normal" ? i.textStyle + " " : "") + (i.textWeight && i.textWeight !== "normal" ? i.textWeight + " " : "") + t + "px " + (i.textFaceName && oE(i.textFaceName) || Kw);
}
function oE(i) {
  for (var t = i.split(","), e = 0; e < t.length; e++)
    t[e].trim && (t[e] = t[e].trim()), t[e].indexOf(" ") > 0 && t[e][0] !== '"' && t[e][0] !== "'" && (t[e] = '"' + t[e] + '"');
  return t.join(",");
}
function yv(i, t) {
  var e = vv(t), r = t.textLineSpacing || 0, n = mv(i, e, t.textSize), s = n.width, o = n.height, a = t.textWrapCharacter || `
`, l = [], h = t.textWrapWidth;
  (!h || h > s) && (h = s), De(i) || (i += "");
  var u = 0;
  if (a && i.indexOf(a) >= 0)
    for (var c = i.split(a), f = 0, d = c.length; f < d; f++) {
      var p = c[f], g = lo(p, e);
      if (g > h)
        for (var m = jm(p, e, h, g), v = 0, _ = m.length; v < _; v++) {
          var y = m[v].width;
          y > u && (u = y), l.push({
            text: m[v].text,
            size: new zn(y, o)
          });
        }
      else
        g > u && (u = g), l.push({
          text: p,
          size: new zn(g, o)
        });
    }
  else if (s > h)
    for (var x = jm(i, e, h, s), w = 0; w < x.length; w++) {
      var b = x[w].width;
      b > u && (u = b), l.push({
        text: x[w].text,
        size: new zn(b, o)
      });
    }
  else
    s > u && (u = s), l.push({
      text: i,
      size: n
    });
  var T = l.length, A = new zn(u, o * T + r * (T - 1));
  return {
    total: T,
    size: A,
    rows: l,
    rawSize: n
  };
}
function _v(i) {
  var t = 0, e = i && i.length || 0;
  if (!e)
    return t;
  for (var r, n = 0; n < e; n++)
    r = i.charCodeAt(n), t = (t << 5) - t + r, t = t & t;
  return t;
}
function Os(i) {
  return i && i.colorStops;
}
function Gm(i) {
  var t = [i.type];
  if (i.places && t.push(i.places.join()), i.colorStops) {
    for (var e = [], r = i.colorStops.length - 1; r >= 0; r--)
      e.push(i.colorStops[r].join());
    t.push(e.join(","));
  }
  return t.join("_");
}
function aE(i, t) {
  return ku(i, t);
}
function ku(i, t) {
  if (!i)
    return 1;
  var e = [];
  if (Array.isArray(i)) {
    for (var r = 0; r < i.length; r++)
      e.push(ku(i[r], t));
    return e.sort().join(",");
  }
  var n = Object.keys(i).sort(), s = n.reduce(function(a, l) {
    return (!t || l.indexOf(t) === 0) && (a[l] = i[l]), a;
  }, {}), o = _v(JSON.stringify(s));
  return o;
}
function Zf(i, t) {
  function e(o, a) {
    var l = o.opacity;
    W(l) ? o.opacity = a : o.opacity *= a;
  }
  var r;
  if (Array.isArray(i)) {
    r = [];
    for (var n = 0; n < i.length; n++) {
      var s = jt({}, i[n]);
      e(s, t), r.push(s);
    }
  } else
    r = jt({}, i), e(r, t);
  return r;
}
function Ni(i) {
  var t = Array.prototype.slice.call(arguments, 1);
  if ((!t || !t.length) && (t = [{}]), Array.isArray(i)) {
    for (var e, r, n = [], s = 0, o = i.length; s < o; s++) {
      e = i[s], r = {};
      for (var a = 0, l = t.length; a < l; a++)
        Array.isArray(t[a]) ? W(t[a][s]) ? jt(r, e || {}) : jt(r, e, t[a][s]) : jt(r, e, t[a] ? t[a] : {});
      n.push(r);
    }
    return n;
  } else {
    var h = [{}, i];
    return h.push.apply(h, t), jt.apply(this, h);
  }
}
function tT(i) {
  if (i.symbol && (i = [i]), Array.isArray(i))
    return i;
  var t = i.$root, e = i.$iconset;
  if (i = i.style, t || e) {
    t && t[t.length - 1] === "/" && (t = t.substring(0, t.length - 1)), e && e[e.length - 1] === "/" && (e = e.substring(0, e.length - 1));
    var r = function(s) {
      return s === "{$root}" ? t : s === "{$iconset}" ? e : null;
    };
    eT(i, r);
  }
  return i;
}
function eT(i, t) {
  for (var e = 0; e < i.length; e++) {
    var r = i[e].symbol;
    r && xv(r, t);
  }
}
var Vm = /(\{\$root\}|\{\$iconset\})/g;
function xv(i, t) {
  for (var e in i)
    i.hasOwnProperty(e) && e !== "textName" && (De(i[e]) && i[e].length > 2 ? i[e] = i[e].replace(Vm, t) : _n(i[e]) ? i[e] = nT(i[e], t) : ji(i[e]) && xv(i[e], t));
}
function nT(i, t) {
  var e = i.default;
  De(e) && (i.default = e.replace(Vm, t));
  var r = i.stops;
  if (!r)
    return i;
  for (var n = 0; n < r.length; n++)
    Array.isArray(r[n]) && (De(r[n][1]) ? r[n][1] = r[n][1].replace(Vm, t) : _n(r[n][1]) && (r[n][1] = nT(r[n][1], t)));
  return i;
}
function rT(i) {
  i === void 0 && (i = []), Array.isArray(i) || (i = [i]);
  for (var t = i.length, e = 0; e < t; e++) {
    var r = i[e];
    if (r.style) {
      var n = r.style, s = n.lineDasharray, o = n.lineWidth;
      if (o && Ut(o) && o > 0 && s && Array.isArray(s) && s.length)
        return !0;
    }
  }
  return !1;
}
var Yr = /* @__PURE__ */ Object.freeze({
  now: Je,
  extend: jt,
  isNil: W,
  isNumber: Ut,
  isInteger: ko,
  isObject: ji,
  isString: De,
  isFunction: Be,
  hasOwn: Fl,
  join: y3,
  isEmpty: _3,
  toRadian: Vn,
  toDegree: av,
  IS_NODE: tr,
  get requestAnimFrame() {
    return Cs;
  },
  get cancelAnimFrame() {
    return Kh;
  },
  isSVG: Io,
  loadImage: Qh,
  UID: Ls,
  GUID: Dw,
  parseJSON: tu,
  pushIn: Ui,
  removeFromArray: zf,
  forEachCoord: No,
  getValueOrDefault: ae,
  sign: Ar,
  log2: z3,
  interpolate: Nf,
  wrap: Ps,
  clamp: Hf,
  isArrayHasData: sn,
  isURL: H3,
  isCssUrl: zw,
  extractCssUrl: Ad,
  btoa: Nw,
  b64toBlob: Hw,
  computeDegree: Bf,
  emptyImageUrl: lv,
  equalMapView: jf,
  flash: hv,
  _defaults: j3,
  getPointsResultPts: eu,
  getImageBitMap: uv,
  getAbsoluteURL: Md,
  calCanvasSize: cv,
  translateToSVGStyles: Xw,
  getMarkerPathBase64: nu,
  getExternalResources: Ou,
  convertResourceUrl: Uf,
  isGradient: Os,
  getGradientStamp: Gm,
  getSymbolStamp: aE,
  getSymbolHash: ku,
  lowerSymbolOpacity: Zf,
  extendSymbol: Ni,
  parseStyleRootPath: tT,
  convertStylePath: eT,
  parseSymbolPath: xv,
  isDashLine: rT,
  trim: gv,
  escapeSpecialChars: Cd,
  splitWords: Yw,
  stringWidth: lo,
  stringLength: mv,
  splitContent: jm,
  CONTENT_EXPRE: Jw,
  replaceVariable: $f,
  describeText: Wf,
  getAlignPoint: Es,
  DEFAULT_FONT: Kw,
  DEFAULT_TEXTSIZE: Qw,
  getFont: vv,
  splitTextToRow: yv,
  hashCode: _v
}), lE = function(t) {
  return t[0];
}, Pd = tr ? lE : function(i) {
  for (var t = document.documentElement && document.documentElement.style || {}, e = 0; e < i.length; e++)
    if (i[e] in t)
      return i[e];
  return !1;
}, Ba = Pd(["transform", "WebkitTransform", "OTransform", "MozTransform", "msTransform"]), hE = Pd(["transformOrigin", "WebkitTransformOrigin", "OTransformOrigin", "MozTransformOrigin", "msTransformOrigin"]), qu = Pd(["transition", "WebkitTransition", "OTransition", "MozTransition", "msTransition"]);
Pd(["filter", "WebkitFilter", "OFilter", "MozFilter", "msFilter"]);
function ve(i, t) {
  var e = document.createElement(i);
  return t && bv(e, t), e;
}
function p1(i, t, e) {
  var r = ve(i);
  return t && Od(r, t), e && e.appendChild(r), r;
}
function Ml(i) {
  if (!i)
    return this;
  if (Ce.ielt9 || Ce.ie9) {
    var t = ve("div");
    t.appendChild(i), t.innerHTML = "", t = null;
  } else i.parentNode && i.parentNode.removeChild(i);
  return this;
}
function Gi(i, t, e, r) {
  if (!i || !i.addEventListener || !t || !e)
    return this;
  for (var n = function(u) {
    u || (u = window.event), e.call(r || i, u);
  }, s = t.split(" "), o = s.length - 1; o >= 0; o--) {
    var a = s[o];
    if (a) {
      i["Z__" + a] || (i["Z__" + a] = []);
      var l = iT(i, a, e);
      l >= 0 && (console.warn(i, "find '" + a + "' handler:", e, " The old listener function will be removed"), Ho(i, a, e)), i["Z__" + a].push({
        callback: n,
        src: e
      }), i.addEventListener(a, n, Ce.supportsPassive ? {
        capture: !1,
        passive: !1
      } : !1);
    }
  }
  return this;
}
function Ho(i, t, e) {
  function r(f, d) {
    f === "mousewheel" && Ce.gecko && (f = "DOMMouseScroll"), i.removeEventListener(f, d, !1);
  }
  if (!i || !i.removeEventListener || !t)
    return this;
  for (var n = t.split(" "), s = n.length - 1; s >= 0; s--) {
    var o = n[s];
    if (o) {
      if (!e && i["Z__" + o]) {
        for (var a = i["Z__" + o], l = 0, h = a.length; l < h; l++)
          r(a[l].callback);
        return delete i["Z__" + o], this;
      }
      var u = iT(i, o, e);
      if (u < 0)
        return this;
      var c = i["Z__" + o][u];
      r(o, c.callback), i["Z__" + o].splice(u, 1);
    }
  }
  return this;
}
function iT(i, t, e) {
  if (!i || !i["Z__" + t] || !e)
    return -1;
  for (var r = i["Z__" + t], n = 0, s = r.length; n < s; n++)
    if (r[n].src === e)
      return n;
  return -1;
}
function ks(i) {
  return i.preventDefault ? i.preventDefault() : i.returnValue = !1, this;
}
function Jr(i) {
  return i._cancelBubble = !0, i.stopPropagation ? i.stopPropagation() : i.cancelBubble = !0, this;
}
function uE(i) {
  return i.onselectstart = function() {
    return !1;
  }, i.ondragstart = function() {
    return !1;
  }, i.setAttribute("unselectable", "on"), this;
}
function Yu(i, t) {
  return i ? (Ce.any3d ? fE(i, t) : (i.style.left = t.x + "px", i.style.top = t.y + "px"), t) : null;
}
function Ed(i) {
  var t = window.getComputedStyle(i), e = [parseInt(t["padding-left"]), parseInt(t["padding-top"])], r = i.getBoundingClientRect(), n = i.offsetWidth, s = i.offsetHeight, o = n ? r.width / n : 1, a = s ? r.height / s : 1;
  return i.__position = [r.left + e[0], r.top + e[1], o, a], i.__position;
}
function ai(i, t) {
  i || (i = window.event);
  var e = t.__position;
  return e || (e = Ed(t)), new Y((i.clientX - e[0] - t.clientLeft) / e[2], (i.clientY - e[1] - t.clientTop) / e[3]);
}
function cE(i, t) {
  var e = i.length - t.length;
  return e >= 0 && i.indexOf(t, e) === e;
}
function Od(i, t) {
  var e = i.style.cssText;
  return cE(e, ";") || (e += ";"), i.style.cssText = e + t, this;
}
function sT(i, t) {
  if (i.classList !== void 0)
    return i.classList.contains(t);
  var e = oT(i);
  return e.length > 0 && new RegExp("(^|\\s)" + t + "(\\s|$)").test(e);
}
function rl(i, t) {
  if (i.classList !== void 0 && !sT(i, t))
    for (var e = Yw(t), r = 0, n = e.length; r < n; r++)
      i.classList.add(e[r]);
  else {
    var s = oT(i);
    bv(i, (s ? s + " " : "") + t);
  }
  return this;
}
function bv(i, t) {
  return W(i.className.baseVal) ? i.className = t : i.className.baseVal = t, this;
}
function oT(i) {
  return W(i.className.baseVal) ? i.className : i.className.baseVal;
}
function fE(i, t) {
  var e = t || new Y(0, 0);
  return i.style[Ba] = Ce.any3d ? "translate3d(" + e.x + "px," + e.y + "px,0px)" : "translate(" + e.x + "px," + e.y + "px)", this;
}
function dE(i) {
  return /<[a-z\][\s\S]*>/i.test(i);
}
function pE(i, t) {
  var e = gE(i);
  De(t) ? e.innerHTML = t : e.appendChild(t);
  var r = new zn(e.clientWidth, e.clientHeight);
  return Ml(e), r;
}
function gE(i) {
  var t = document.createElement(i);
  return t.style.cssText = "position:absolute;left:-10000px;top:-10000px;", document.body.appendChild(t), t;
}
var Cn = Gi, Un = Ho;
function Xf(i) {
  return i && (i === "mousemove" || i === "touchmove");
}
var aT = 48;
function lT(i, t) {
  var e = Je(), r = t || aT;
  return i._mousemoveTime && e - i._mousemoveTime < r ? !0 : (i._mousemoveTime = e, !1);
}
var Um;
typeof Promise < "u" ? Um = Promise : Um = e3;
var ru = Um, wv = "core-fetch-image", hT;
function mE(i) {
  hT = i;
}
function vE() {
  return hT;
}
var uT = !1;
function yE() {
  uT = !0;
}
function _E() {
  return uT;
}
var cT = [];
function fT(i) {
  return cT.indexOf(i) > -1;
}
function dT(i) {
  fT(i) || cT.push(i);
}
var Do = {};
function il(i, t) {
  Do[i] = t;
}
var xE = `
    var adapters = {};
    // Dynamic Create Adapter
    function createAdapter(key,code){
        if(adapters[key]||!code){
            return;
        }
        var func=new Function('exports',code+'(exports)');
        var workerExports={};
        func(workerExports,self);
        adapters[key]=workerExports;
        workerExports.initialize && workerExports.initialize(self);
        
    }
    onmessage = function (msg) {
        msg = msg.data;
        //createAdapter
        if (msg.messageType === 'createAdapter') {
           var key=msg.key;
           var code=msg.code;
           createAdapter(key,code);
           postMessage({adapterName:key});
           return;
        }
        // postMessage when main thread idle
        if(msg.messageType==='idle'){
            var messageCount = msg.messageCount||5;
            handleMessageQueue(messageCount);
            return;
        }
        if (msg.messageType === 'batch') {
            const messages = msg.messages;
            if (messages) {
                for (let i = 0; i < messages.length; i++) {
                    dispatch(messages[i]);
                }
            }
        } else {
            dispatch(msg);
        }
    };

    function dispatch(msg) {
        var workerKey = msg.workerKey;
        var adapter = adapters[workerKey];
        if (!adapter) {
            post(msg.callback, 'Unregistered worker adapters for ' + workerKey);
            return;
        }
        try {
            adapter.onmessage(msg, wrap(msg.callback));
        } catch (err) {
            post(msg.callback, workerKey + ':' + err.message);
            console.error(err);
            throw err;
        }
    }

    var messageResultQueue = [];
    
    function handleMessageQueue(messageCount){
       if(messageResultQueue.length===0){
          return;
       }
       var queues = messageResultQueue.slice(0,messageCount);
       queues.forEach(function(queue){
          post(queue.callback,queue.err,queue.data,queue.buffers);
       });
       messageResultQueue=messageResultQueue.slice(messageCount,Infinity);
    }

    function post(callback, err, data, buffers) {
        var msg = {
            callback : callback
        };
        if (err) {
            msg.error = err;
        } else {
            msg.data = data;
        }
        if (buffers && buffers.length > 0) {
            postMessage(msg, buffers);
        } else {
            postMessage(msg);
        }
    }

    function joinQueue(callback,err,data,buffers){
        messageResultQueue.push({
            callback:callback,
            err:err,
            data:data,
            buffers:buffers
        });
    }

    function wrap(callback) {
        return function (err, data, buffers) {
            joinQueue(callback, err, data, buffers);
        };
    }
    var workerExports;
`, bE = `
    workerExports = null;
`;
function wE() {
  var i = xE;
  for (var t in Do) {
    var e = Do[t];
    dT(t), Be(e) && e.length === 0 && (e = e()), i += `
    workerExports = {};
    (` + e + `)(workerExports, self);
    adapters['` + t + "'] = workerExports", i += `
    workerExports.initialize && workerExports.initialize(self);
        `;
  }
  return i += bE, i;
}
var bp;
function TE() {
  if (typeof window > "u")
    return null;
  if (!bp) {
    var i = wE();
    bp = window.URL.createObjectURL(new Blob([i], {
      type: "text/javascript"
    })), Do = {};
  }
  return bp;
}
function AE(i, t) {
  if (!Do[i]) {
    console.error("not find " + i + " adapter");
    return;
  }
  var e = Do[i];
  Be(e) && e.length === 0 && (e = e()), e = "(" + e + ")";
  var r = vE();
  if (r) {
    var n = r.workers || [];
    n.length === 0 && console.error("workerpool workers count is 0");
    var s = 0, o = function a(l) {
      l = l.data || {}, l.adapterName === i && (s++, s === n.length && (n.forEach(function(h) {
        h.removeEventListener("message", a);
      }), delete Do[i], t()));
    };
    n.forEach(function(a) {
      a.addEventListener("message", o), a.postMessage({
        key: i,
        code: e,
        messageType: "createAdapter"
      });
    });
  }
}
var ME = typeof window < "u" ? window.navigator.hardwareConcurrency || 4 : 0, SE = Math.max(Math.floor(ME / 2), 1), g1 = function() {
  function i(e) {
    e === void 0 && (e = 50), this._limit = e, this._messages = [], this.buffers = [];
  }
  var t = i.prototype;
  return t.addMessage = function(r, n) {
    if (this._messages.push(r), !!Array.isArray(n))
      for (var s = 0; s < n.length; s++)
        this.buffers.indexOf(n[s]) < 0 && this.buffers.push(n[s]);
  }, t.isFull = function() {
    return this._messages.length >= this._limit;
  }, t.getMessage = function() {
    return {
      messageType: "batch",
      messages: this._messages
    };
  }, i;
}(), CE = function() {
  function i() {
    this.active = {}, this.workerCount = typeof window < "u" ? xs.workerCount || SE : 0, this._messages = [], this._messageBuffers = [];
  }
  var t = i.prototype;
  return t.acquire = function(r) {
    if (!this.workers) {
      this.workers = [];
      for (var n = TE(), s = 0; s < this.workerCount; s++) {
        var o = new Worker(n);
        o.id = s, this.workers.push(o);
      }
      URL.revokeObjectURL(n), yE();
    }
    return this.active[r] = !0, this.workers.slice();
  }, t.release = function(r) {
    delete this.active[r], Object.keys(this.active).length === 0 && (this.workers.forEach(function(n) {
      n.terminate();
    }), this.workers = null);
  }, t.addMessage = function(r, n, s) {
    var o = this._messages[r];
    (!o || !o.length) && (o = this._messages[r] = [new g1()]);
    var a = o[o.length - 1];
    a.isFull() && (a = new g1(), this._messages[r].push(a)), a.addMessage(n, s);
  }, t.commit = function() {
    if (this.workers && this._messages.length) {
      for (var r = 0; r < this._messages.length; r++)
        if (!(!this._messages[r] || !this._messages[r].length)) {
          var n = this._messages[r].shift();
          this.workers[r].postMessage(n.getMessage(), n.buffers);
        }
    }
  }, t.getWorkers = function() {
    return this.workers || [];
  }, t.broadcastIdleMessage = function() {
    var r = this.getWorkers();
    return r.forEach(function(n) {
      n.postMessage({
        messageType: "idle",
        messageCount: xs.taskCountPerWorkerMessage
      });
    }), this;
  }, i;
}(), Ju;
function $m() {
  return Ju || (Ju = new CE(), mE(Ju)), Ju;
}
var bh = [];
function PE(i) {
  pT();
  var t = new ru(function(e, r) {
    if (!i) {
      r(new Error("task is null"));
      return;
    }
    if (Be(i) && (i = {
      count: 1,
      run: i
    }), !i.run) {
      r(new Error("task.run is null"));
      return;
    }
    if (W(i.count) && (i.count = 1), i.count = Math.ceil(i.count), !Ut(i.count)) {
      r(new Error("task.count is not number"));
      return;
    }
    i.results = [], bh.push(i), i.resolve = e;
  });
  return t;
}
function EE() {
  if (bh.length !== 0) {
    for (var i = [], t = [], e = bh.length, r = 0; r < e; r++) {
      var n = bh[r];
      if (n.count--, n.count === -1)
        t.push(n);
      else {
        i.push(n);
        var s = n.run();
        n.results.push(s);
      }
    }
    bh = i, e = t.length;
    for (var o = 0; o < e; o++) {
      var a = t[o];
      a.resolve && a.resolve(a.results);
    }
  }
}
var wp = !0;
function Tp() {
  wp ? $m().broadcastIdleMessage() : $m().commit(), EE(), wp = !wp;
}
var Ap = Je();
function qf(i) {
  var t = xs.idleTimeRemaining, e = xs.idleLog, r = xs.idleTimeout, n = xs.idleForceTimeThreshold;
  if (Ce.requestIdleCallback) {
    if (i && i.timeRemaining) {
      var s = i.timeRemaining();
      if (s > t || i.didTimeout)
        i.didTimeout && e && console.error("idle timeout in", r), Tp(), Ap = Je();
      else {
        var o = Je();
        o - Ap > n && (Tp(), Ap = Je()), s <= t && e && console.warn("currrent page is busy,the timeRemaining is", s);
      }
    }
    requestIdleCallback(qf, {
      timeout: r
    });
  } else
    Tp(), Cs(qf);
}
var m1 = !1;
function pT() {
  if (!m1) {
    m1 = !0;
    var i = xs.idleTimeout;
    Ce.requestIdleCallback ? requestIdleCallback(qf, {
      timeout: i
    }) : Cs(qf);
  }
}
var gT = typeof Map == "function", mT = function() {
}, OE = function() {
  function i(e, r) {
    this.max = e, this.onRemove = r || mT, this.reset();
  }
  var t = i.prototype;
  return t.reset = function() {
    for (var r in this.data)
      this.onRemove(this.data[r]);
    return this.data = {}, this.order = [], this;
  }, t.clear = function() {
    this.reset(), delete this.onRemove;
  }, t.add = function(r, n) {
    if (this.has(r))
      this.order.splice(this.order.indexOf(r), 1), this.data[r] = n, this.order.push(r);
    else if (this.data[r] = n, this.order.push(r), this.order.length > this.max) {
      var s = this.getAndRemove(this.order[0]);
      s && this.onRemove(s);
    }
    return this;
  }, t.has = function(r) {
    return r in this.data;
  }, t.keys = function() {
    return this.order;
  }, t.getAndRemove = function(r) {
    if (!this.has(r))
      return null;
    var n = this.data[r];
    return delete this.data[r], this.order.splice(this.order.indexOf(r), 1), n;
  }, t.get = function(r) {
    if (!this.has(r))
      return null;
    var n = this.data[r];
    return n;
  }, t.remove = function(r) {
    if (!this.has(r))
      return this;
    var n = this.data[r];
    return delete this.data[r], this.onRemove(n), this.order.splice(this.order.indexOf(r), 1), this;
  }, t.setMaxSize = function(r) {
    for (this.max = r; this.order.length > this.max; ) {
      var n = this.getAndRemove(this.order[0]);
      n && this.onRemove(n);
    }
    return this;
  }, i;
}(), vT;
gT && (vT = function() {
  function i(e, r) {
    this.max = e, this.onRemove = r || mT, this.reset();
  }
  var t = i.prototype;
  return t.reset = function() {
    if (this.data)
      for (var r = this.data.values(), o = r, n = Array.isArray(o), s = 0, o = n ? o : o[Symbol.iterator](); ; ) {
        var a;
        if (n) {
          if (s >= o.length) break;
          a = o[s++];
        } else {
          if (s = o.next(), s.done) break;
          a = s.value;
        }
        var l = a;
        this.onRemove(l);
      }
    return this.data = /* @__PURE__ */ new Map(), this;
  }, t.clear = function() {
    this.reset(), delete this.onRemove;
  }, t.add = function(r, n) {
    return n ? (this.has(r) ? (this.data.delete(r), this.data.set(r, n)) : this.data.set(r, n), this) : this;
  }, t.keys = function() {
    for (var r = new Array(this.data.size), n = 0, s = this.data.keys(), l = s, o = Array.isArray(l), a = 0, l = o ? l : l[Symbol.iterator](); ; ) {
      var h;
      if (o) {
        if (a >= l.length) break;
        h = l[a++];
      } else {
        if (a = l.next(), a.done) break;
        h = a.value;
      }
      var u = h;
      r[n++] = u;
    }
    return r;
  }, t.shrink = function() {
    for (var r = this.data.keys(), n = r.next(); this.data.size > this.max; ) {
      var s = this.getAndRemove(n.value);
      s && this.onRemove(s), n = r.next();
    }
  }, t.has = function(r) {
    return this.data.has(r);
  }, t.getAndRemove = function(r) {
    if (!this.has(r))
      return null;
    var n = this.data.get(r);
    return this.data.delete(r), n;
  }, t.get = function(r) {
    if (!this.has(r))
      return null;
    var n = this.data.get(r);
    return n;
  }, t.remove = function(r) {
    if (!this.has(r))
      return this;
    var n = this.data.get(r);
    return this.data.delete(r), this.onRemove(n), this;
  }, t.setMaxSize = function(r) {
    return this.max = r, this.data.size > this.max && this.shrink(), this;
  }, i;
}());
var Tv = gT ? vT : OE, Wr = {
  jsonp: function(t, e) {
    var r = "_maptalks_jsonp_" + Ls();
    t.match(/\?/) ? t += "&callback=" + r : t += "?callback=" + r;
    var n = document.createElement("script");
    return n.type = "text/javascript", n.src = t, window[r] = function(s) {
      e(null, s), document.getElementsByTagName("head")[0].removeChild(n), n = null, delete window[r];
    }, document.getElementsByTagName("head")[0].appendChild(n), this;
  },
  get: function(t, e, r) {
    if (Be(e)) {
      var n = r;
      r = e, e = n;
    }
    if (tr && Wr.get.node)
      return Wr.get.node(t, r, e);
    var s = Wr._getClient(r);
    if (s.open("GET", t, !0), e) {
      for (var o in e.headers)
        s.setRequestHeader(o, e.headers[o]);
      s.withCredentials = e.credentials === "include", e.responseType && (s.responseType = e.responseType);
    }
    return s.send(null), s;
  },
  post: function(t, e, r) {
    var n;
    if (De(t)) {
      if (Be(e)) {
        var o = r;
        r = e, e = o;
      }
      e = e || {}, n = e.postData;
    } else {
      var s = r;
      n = e, e = t, t = e.url, r = s;
    }
    if (tr && Wr.post.node)
      return e.url = t, Wr.post.node(e, n, r);
    var a = Wr._getClient(r);
    if (a.open("POST", e.url, !0), e.headers || (e.headers = {}), e.headers["Content-Type"] || (e.headers["Content-Type"] = "application/x-www-form-urlencoded"), "setRequestHeader" in a)
      for (var l in e.headers)
        e.headers.hasOwnProperty(l) && a.setRequestHeader(l, e.headers[l]);
    return De(n) || (n = JSON.stringify(n)), a.send(n), a;
  },
  _wrapCallback: function(t, e) {
    return function() {
      if (t.readyState === 4)
        if (t.status === 200)
          if (t.responseType === "arraybuffer") {
            var r = t.response;
            r.byteLength === 0 ? e(new Error("http status 200 returned without content.")) : e(null, {
              data: t.response,
              cacheControl: t.getResponseHeader("Cache-Control"),
              expires: t.getResponseHeader("Expires"),
              contentType: t.getResponseHeader("Content-Type")
            });
          } else
            e(null, t.responseText);
        else
          e(new Error(t.statusText + "," + t.status));
    };
  },
  _getClient: function(t) {
    var e;
    try {
      e = new XMLHttpRequest();
    } catch {
      try {
        e = new ActiveXObject("Msxml2.XMLHTTP");
      } catch {
        try {
          e = new ActiveXObject("Microsoft.XMLHTTP");
        } catch {
        }
      }
    }
    return e.onreadystatechange = Wr._wrapCallback(e, t), e;
  },
  getArrayBuffer: function(t, e, r) {
    if (Be(e)) {
      var n = r;
      r = e, e = n;
    }
    return e || (e = {}), e.responseType = "arraybuffer", Wr.get(t, e, r);
  },
  getImage: function(t, e, r) {
    return Wr.getArrayBuffer(e, r, function(n, s) {
      if (n)
        t.onerror && t.onerror(n);
      else if (s) {
        var o = window.URL || window.webkitURL, a = t.onload;
        t.onload = function() {
          a && a(), o.revokeObjectURL(t.src);
        };
        var l = new Blob([new Uint8Array(s.data)], {
          type: s.contentType
        });
        t.cacheControl = s.cacheControl, t.expires = s.expires, t.src = s.data.byteLength ? o.createObjectURL(l) : lv;
      }
    });
  }
};
Wr.getJSON = function(i, t, e) {
  if (Be(t)) {
    var r = e;
    e = t, t = r;
  }
  var n = function(o, a) {
    var l = a ? tu(a) : null;
    e(o, l);
  };
  return t && t.jsonp ? Wr.jsonp(i, n) : Wr.get(i, t, n);
};
var yT = 1 / 0, _T = 1 / 0, xT = -1 / 0, bT = -1 / 0;
function Jo() {
  return [yT, _T, xT, bT];
}
var sl = Jo();
function iu(i) {
  i[0] = yT, i[1] = _T, i[2] = xT, i[3] = bT;
}
function kd(i, t) {
  if (i)
    if (Array.isArray(i[0]))
      for (var e = 0, r = i.length; e < r; e++)
        kd(i[e], t);
    else if (Array.isArray(i))
      for (var n = 0, s = i.length; n < s; n++) {
        var o = i[n], a = o.x, l = o.y;
        t[0] = Math.min(a, t[0]), t[1] = Math.min(l, t[1]), t[2] = Math.max(a, t[2]), t[3] = Math.max(l, t[3]);
      }
    else {
      var a = i.x, l = i.y;
      t[0] = Math.min(a, t[0]), t[1] = Math.min(l, t[1]), t[2] = Math.max(a, t[2]), t[3] = Math.max(l, t[3]);
    }
}
function Rd(i, t, e, r, n) {
  t !== 0 && !t || (Array.isArray(t) && (e = t[1], r = t[2], n = t[3], t = t[0]), i[0] = Math.min(t, i[0]), i[1] = Math.min(e, i[1]), i[2] = Math.max(r, i[2]), i[3] = Math.max(n, i[3]));
}
function Yf(i) {
  return i && i[0] !== 1 / 0 && i[0] !== void 0;
}
function wT(i, t) {
  t === void 0 && (t = 0), i[0] -= t, i[1] -= t, i[2] += t, i[3] += t;
}
var v1 = "#000", kE = "rgba(255,255,255,0)", RE = "#000", Ku = !1, oa = null, aa = Math.PI / 180, y1 = 1, _1 = "top", Ct = {
  getCanvas2DContext: function(t) {
    return t.getContext("2d", {
      willReadFrequently: !0
    });
  },
  setHitTesting: function(t) {
    Ku = t;
  },
  createCanvas: function(t, e, r) {
    var n;
    return tr ? n = new r(t, e) : (n = ve("canvas"), n.width = t, n.height = e), n;
  },
  prepareCanvasFont: function(t, e) {
    t.textBaseline !== _1 && (t.textBaseline = _1);
    var r = vv(e);
    t.font !== r && (t.font = r);
    var n = e.textFill;
    n || (n = RE);
    var s = Ct.getRgba(n, e.textOpacity);
    t.fillStyle !== s && (t.fillStyle = s);
  },
  prepareCanvas: function(t, e, r, n) {
    if (e) {
      var s = e.lineWidth;
      !W(s) && t.lineWidth !== s && (t.lineWidth = s);
      var o = e.linePatternFile, a = e.lineColor || v1;
      if (n)
        t.strokeStyle = "#000";
      else if (o && r) {
        var l;
        (e.linePatternDx || e.linePatternDy) && (l = [e.linePatternDx, e.linePatternDy]), Ct._setStrokePattern(t, o, s, l, r), e.lineDasharray = [];
      } else Os(a) ? e.lineGradientExtent ? t.strokeStyle = Ct._createGradient(t, a, e.lineGradientExtent) : t.strokeStyle = v1 : (Array.isArray(a) && (a = Ct.normalizeColorToRGBA(a)), t.strokeStyle = a);
      e.lineJoin && (t.lineJoin = e.lineJoin), e.lineCap && (t.lineCap = e.lineCap), t.setLineDash && sn(e.lineDasharray) && t.setLineDash(e.lineDasharray);
      var h = e.polygonPatternFile, u = e.polygonFill || kE;
      if (n)
        t.fillStyle = "#000";
      else if (h && r) {
        var c = b1(h), f = r.getImage([c, null, null]);
        if (f || (f = r.getImage([c + "-texture", null, s])), Io(c) && f instanceof Image && (Ce.edge || Ce.ie)) {
          var d = f.width || 20, p = f.height || 20, g = Ct.createCanvas(d, p);
          Ct.image(g.getContext("2d"), f, 0, 0, d, p), f = g;
        }
        f ? (t.fillStyle = t.createPattern(f, "repeat"), (e.polygonPatternDx || e.polygonPatternDy) && (t.fillStyle.polygonPatternOffset = [e.polygonPatternDx, e.polygonPatternDy])) : typeof console < "u" && console.warn("img not found for", c);
      } else Os(u) ? e.polygonGradientExtent ? t.fillStyle = Ct._createGradient(t, u, e.polygonGradientExtent) : t.fillStyle = "rgba(255,255,255,0)" : (Array.isArray(u) && (u = Ct.normalizeColorToRGBA(u)), t.fillStyle = u);
    }
  },
  _createGradient: function(t, e, r) {
    var n = null, s = e.places, o = r.getMin(), a = r.getMax(), l = r.getWidth(), h = r.getHeight();
    if (!e.type || e.type === "linear") {
      if (!s)
        s = [o.x, o.y, a.x, o.y];
      else {
        if (s.length !== 4)
          throw new Error("A linear gradient's places should have 4 numbers.");
        s = [o.x + s[0] * l, o.y + s[1] * h, o.x + s[2] * l, o.y + s[3] * h];
      }
      n = t.createLinearGradient.apply(t, s);
    } else if (e.type === "radial") {
      if (s) {
        if (s.length !== 6)
          throw new Error("A radial gradient's places should have 6 numbers.");
        s = [o.x + s[0] * l, o.y + s[1] * h, l * s[2], o.x + s[3] * l, o.y + s[4] * h, l * s[5]];
      } else {
        var u = r.getCenter()._round();
        s = [u.x, u.y, Math.abs(u.x - o.x), u.x, u.y, 0];
      }
      n = t.createRadialGradient.apply(t, s);
    }
    return e.colorStops.forEach(function(c) {
      n.addColorStop.apply(n, c);
    }), n;
  },
  _setStrokePattern: function(t, e, r, n, s) {
    var o = b1(e), a;
    if (tr)
      a = s.getImage([o, null, r]);
    else {
      var l = o + "-texture-" + r;
      if (a = s.getImage(l), !a) {
        var h = s.getImage([o, null, null]);
        if (h) {
          var u;
          !h.width || !h.height ? u = r : u = Math.round(h.width * r / h.height);
          var c = Ct.createCanvas(u, r, t.canvas.constructor);
          Ct.image(c.getContext("2d"), h, 0, 0, u, r), s.addResource([l, null, r], c), a = c;
        }
      }
    }
    a ? (t.strokeStyle = t.createPattern(a, "repeat"), t.strokeStyle.linePatternOffset = n) : typeof console < "u" && console.warn("img not found for", o);
  },
  clearRect: function(t, e, r, n, s) {
    t.canvas._drawn = !1, t.clearRect(e, r, n, s);
  },
  fillCanvas: function(t, e, r, n) {
    if (Ku && (e = 1), t.canvas._drawn = !0, e !== 0) {
      var s = Ct._isPattern(t.fillStyle), o = t.fillStyle && t.fillStyle.polygonPatternOffset, a = o ? o[0] : 0, l = o ? o[1] : 0;
      W(e) && (e = 1);
      var h;
      e < 1 && (h = t.globalAlpha, t.globalAlpha *= e), s && (r = r || 0, n = n || 0, t.translate(r + a, n + l)), t.fill(), s && t.translate(-r - a, -n - l), e < 1 && (t.globalAlpha = h);
    }
  },
  getRgba: function(t, e) {
    if (W(e) && (e = 1), t[0] !== "#")
      return Array.isArray(t) && (t = Ct.normalizeColorToRGBA(t, e)), t;
    var r, n, s;
    return t.length === 7 ? (r = parseInt(t.substring(1, 3), 16), n = parseInt(t.substring(3, 5), 16), s = parseInt(t.substring(5, 7), 16)) : (r = parseInt(t.substring(1, 2), 16) * 17, n = parseInt(t.substring(2, 3), 16) * 17, s = parseInt(t.substring(3, 4), 16) * 17), "rgba(" + r + "," + n + "," + s + "," + e + ")";
  },
  normalizeColorToRGBA: function(t, e) {
    return e === void 0 && (e = 1), "rgba(" + t[0] * 255 + "," + t[1] * 255 + "," + t[2] * 255 + "," + (t.length === 4 ? t[3] : 1) * e + ")";
  },
  image: function(t, e, r, n, s, o) {
    t.canvas._drawn = !0;
    try {
      Ut(s) && Ut(o) ? t.drawImage(e, r, n, s, o) : t.drawImage(e, r, n);
    } catch (a) {
      console && (console.warn("error when drawing image on canvas:", a), console.warn(e));
    }
  },
  text: function(t, e, r, n, s) {
    return Ct._textOnMultiRow(t, s.rows, n, r, s.size, s.rawSize);
  },
  _textOnMultiRow: function(t, e, r, n, s, o) {
    var a = Es(s, r.textHorizontalAlignment, r.textVerticalAlignment), l = o.height + r.textLineSpacing, h = n.add(0, a.y), u = r.textMaxHeight, c, f, d = 0;
    iu(sl);
    for (var p = 0, g = e.length; p < g; p++) {
      c = e[p].text, f = Es(e[p].size, r.textHorizontalAlignment, r.textVerticalAlignment);
      var m = h.add(f.x, p * l);
      Ct._textOnLine(t, c, m, r.textHaloRadius, r.textHaloFill, r.textHaloOpacity);
      var v = e[p].size, _ = m.x, y = m.y, x = _ + v.width, w = y + v.height;
      if (Rd(sl, _, y, x, w), u > 0 && (d += l, d + v.height >= u))
        break;
    }
    return sl;
  },
  _textOnLine: function(t, e, r, n, s, o) {
    Ku && (o = 1);
    var a = o !== 0 && n !== 0;
    t.textBaseline = "top";
    var l, h, u = t.shadowBlur, c = t.shadowOffsetX, f = t.shadowOffsetY;
    if (a) {
      var d = t.globalAlpha;
      t.globalAlpha *= o, t.miterLimit = 2, t.lineJoin = "round", t.lineCap = "round", t.lineWidth = n * 2, Array.isArray(s) && (s = Ct.normalizeColorToRGBA(s)), t.strokeStyle = s, t.strokeText(e, r.x, r.y + y1), t.miterLimit = 10, t.globalAlpha = d, l = t.globalCompositeOperation, t.globalCompositeOperation = "destination-out", h = t.fillStyle, t.fillStyle = "#000";
    }
    u && a && (t.shadowBlur = t.shadowOffsetX = t.shadowOffsetY = 0), Ct.fillText(t, e, r), l && (t.globalCompositeOperation = l, Ct.fillText(t, e, r, h), u && (t.shadowBlur = u, t.shadowOffsetX = c, t.shadowOffsetY = f));
  },
  fillText: function(t, e, r, n) {
    t.canvas._drawn = !0, n && (t.fillStyle = n), t.fillText(e, r.x, r.y + y1);
  },
  _stroke: function(t, e, r, n) {
    if (Ku && (e = 1), t.canvas._drawn = !0, e !== 0) {
      var s = t.strokeStyle && t.strokeStyle.linePatternOffset, o = s ? s[0] : 0, a = s ? s[1] : 0, l = Ct._isPattern(t.strokeStyle) && (!W(r) && !W(n) || !W(o) && !W(a));
      W(e) && (e = 1);
      var h;
      e < 1 && (h = t.globalAlpha, t.globalAlpha *= e), l && (r = r || 0, n = n || 0, t.translate(r + o, n + a)), t.stroke(), l && t.translate(-r - o, -n - a), e < 1 && (t.globalAlpha = h);
    }
  },
  _path: function(t, e, r, n, s) {
    if (!sn(e))
      return;
    function o(p, g) {
      var m = Bf(p.x, p.y, g.x, g.y);
      t.save();
      var v = Math.cos(m);
      Math.abs(v) < 1e-7 ? t.translate(p.x - t.lineWidth / 2, p.y) : t.translate(p.x, p.y - t.lineWidth / 2 / v), t.rotate(m), Ct._stroke(t, n), t.restore();
    }
    for (var a = sn(r), l = s === !0 ? !1 : Ct._isPattern(t.strokeStyle), h, u, c, f = 0, d = e.length; f < d; f++)
      if (h = e[f], !a || t.setLineDash)
        t.lineTo(h.x, h.y), l && f > 0 && (u = e[f - 1], o(u, h), t.beginPath(), t.moveTo(h.x, h.y));
      else if (a) {
        if (f === d - 1)
          break;
        c = e[f + 1], IE(t, h, c, r);
      }
  },
  path: function(t, e, r, n, s) {
    sn(e) && (t.beginPath(), t.moveTo(e[0].x, e[0].y), Ct._path(t, e, s, r), Ct._stroke(t, r));
  },
  _multiClip: function(t, e) {
    if (!(!e || e.length === 0)) {
      e = e[0];
      for (var r = 0, n = e.length; r < n; r++) {
        var s = e[r], o = s.x, a = s.y;
        r === 0 ? t.moveTo(o, a) : t.lineTo(o, a), r === n - 1 && (o = e[0].x, a = e[0].y, t.lineTo(o, a));
      }
    }
  },
  polygon: function(t, e, r, n, s, o) {
    if (t.isMultiClip) {
      Ct._multiClip(t, e);
      return;
    }
    if (t.isClip) {
      Ct._multiClip(t, Array.isArray(e[0]) ? e : [e]);
      return;
    }
    if (sn(e)) {
      var a = Ct._isPattern(t.strokeStyle), l = sn(s) && !t.setLineDash || a && !o;
      sn(e[0]) || (e = [e]);
      var h = t;
      e.length > 1 && !tr && (oa || (oa = Ct.createCanvas(1, 1)), t.canvas._drawn = !1, oa.width = t.canvas.width, oa.height = t.canvas.height, t = oa.getContext("2d"), T1(t, []), T1(t, s), w1(t, h));
      var u, c, f;
      if (l) {
        for (t.save(), c = 0, f = e.length; c < f; c++)
          sn(e[c]) && (Ct._ring(t, e[c], null, 0, !0), u = n, c > 0 && (t.globalCompositeOperation = "destination-out", u = 1), Ct.fillCanvas(t, u, e[c][0].x, e[c][0].y), c > 0 ? t.globalCompositeOperation = "source-over" : f > 1 && (t.fillStyle = "#fff"), Ct._stroke(t, 0));
        t.restore();
      }
      var d = t.fillStyle;
      for (c = 0, f = e.length; c < f; c++)
        sn(e[c]) && (o ? (Ct.paintSmoothLine(t, e[c], r, o, !0), t.closePath()) : Ct._ring(t, e[c], s, r), l || (u = n, c > 0 && (t.globalCompositeOperation = "destination-out", u = 1), Ct.fillCanvas(t, u, e[c][0].x, e[c][0].y), c > 0 ? t.globalCompositeOperation = "source-over" : f > 1 && (t.fillStyle = "#fff")), Ct._stroke(t, r));
      t.fillStyle !== d && (t.fillStyle = d), e.length > 1 && !tr && (h.drawImage(oa, 0, 0), h.canvas._drawn = t.canvas._drawn, w1(h, t));
    }
  },
  _ring: function(t, e, r, n, s) {
    var o = Ct._isPattern(t.strokeStyle);
    !s && o && !e[0].equals(e[e.length - 1]) && (e = e.concat([e[0]])), t.beginPath(), t.moveTo(e[0].x, e[0].y), Ct._path(t, e, r, n, s), o || t.closePath();
  },
  paintSmoothLine: function(t, e, r, n, s, o, a) {
    if (!e)
      return;
    if (e.length <= 2 || !n) {
      Ct.path(t, e, r);
      return;
    }
    function l(A, M, S, P, C, k, O, R, I, D) {
      var z = 1 - A, H = 1 - M, G = S * z * z + C * 2 * A * z + O * A * A, $ = S * H * H + C * 2 * M * H + O * M * M, K = C * z * z + O * 2 * A * z + I * A * A, dt = C * H * H + O * 2 * M * H + I * M * M, it = P * z * z + k * 2 * A * z + R * A * A, st = P * H * H + k * 2 * M * H + R * M * M, pt = k * z * z + R * 2 * A * z + D * A * A, Ht = k * H * H + R * 2 * M * H + D * M * M, Rt = G * H + K * M, Tt = $ * z + dt * A, $t = $ * H + dt * M, Wt = it * H + pt * M, re = st * z + Ht * A, ie = st * H + Ht * M;
      return [Rt, Wt, Tt, re, $t, ie];
    }
    function h(A, M, S, P, C, k, O, R, I, D) {
      var z = (A + S) / 2, H = (M + P) / 2, G = (S + C) / 2, $ = (P + k) / 2, K = (C + O) / 2, dt = (k + R) / 2, it = Math.sqrt((S - A) * (S - A) + (P - M) * (P - M)), st = Math.sqrt((C - S) * (C - S) + (k - P) * (k - P)), pt = Math.sqrt((O - C) * (O - C) + (R - k) * (R - k)), Ht = it / (it + st), Rt = st / (st + pt), Tt = z + (G - z) * Ht, $t = H + ($ - H) * Ht, Wt = G + (K - G) * Rt, re = $ + (dt - $) * Rt, ie = Tt + (G - Tt) * I + S - Tt, Kt = $t + ($ - $t) * I + P - $t, fe = Wt + (G - Wt) * I + C - Wt, Xt = re + ($ - re) * I + k - re, Re = [ie, Kt, fe, Xt];
      return D < 1 ? l(0, D, S, P, ie, Kt, fe, Xt, C, k) : Re;
    }
    var u = e.length, c = s ? u : u - 1;
    t.beginPath(), t.moveTo(e[0].x, e[0].y), a !== void 0 && (c -= Math.max(c - o - 1, 0));
    for (var f, d = 0; d < c; d++) {
      var p = e[d].x, g = e[d].y, m = void 0, v = void 0, _ = void 0, y = void 0, x = void 0, w = void 0;
      d - 1 < 0 ? s ? (m = e[c - 1].x, v = e[c - 1].y) : (m = e[d + 1].x, v = e[d + 1].y) : (m = e[d - 1].x, v = e[d - 1].y), d + 1 < u ? (_ = e[d + 1].x, y = e[d + 1].y) : (_ = e[d + 1 - u].x, y = e[d + 1 - u].y), d + 2 < u ? (x = e[d + 2].x, w = e[d + 2].y) : s ? (x = e[d + 2 - u].x, w = e[d + 2 - u].y) : (x = e[d].x, w = e[d].y);
      var b = h(m, v, p, g, _, y, x, w, n, d === c - 1 ? a : 1);
      if (d === c - 1 && a >= 0 && a < 1) {
        t.bezierCurveTo(b[0], b[1], b[2], b[3], b[4], b[5]), e.splice(c - 1, u - (c - 1) - 1);
        var T = new Y(b[4], b[5]);
        T.prevCtrlPoint = new Y(b[2], b[3]), e.push(T), u = e.length;
      } else
        t.bezierCurveTo(b[0], b[1], b[2], b[3], _, y);
      e[d].nextCtrlPoint = b.slice(0, 2), e[d].prevCtrlPoint = f ? f.slice(2) : null, f = b;
    }
    !s && e[1].prevCtrlPoint && (e[0].nextCtrlPoint = e[1].prevCtrlPoint, delete e[0].prevCtrlPoint), e[u - 1].prevCtrlPoint || (e[u - 1].prevCtrlPoint = e[u - 2].nextCtrlPoint), Ct._stroke(t, r);
  },
  _arcBetween: function(t, e, r, n) {
    var s = n, o = e.distanceTo(r), a = o / 2 / Math.sin(s / 2), l = Math.asin((r.y - e.y) / o);
    e.x > r.x && (l = Math.PI - l);
    var h = 90 * aa - s / 2, u = l - h, c = Math.cos(u) * a, f = Math.sin(u) * a, d = e.x + c, p = e.y + f, g = Math.asin((r.y - p) / a);
    d > r.x && (g = Math.PI - g);
    var m = g + s;
    return t.beginPath(), t.arc(d, p, a, g, m), [d, p];
  },
  _lineTo: function(t, e) {
    t.lineTo(e.x, e.y);
  },
  bezierCurveAndFill: function(t, e, r, n) {
    t.beginPath();
    var s = e[0];
    t.moveTo(s.x, s.y);
    var o = [t];
    o.push.apply(o, e.splice(1)), Ct._bezierCurveTo.apply(Ct, o), Ct.fillCanvas(t, n), Ct._stroke(t, r);
  },
  _bezierCurveTo: function(t, e, r, n) {
    t.bezierCurveTo(e.x, e.y, r.x, r.y, n.x, n.y);
  },
  ellipse: function(t, e, r, n, s, o, a) {
    function l(h, u, c, f, d) {
      var p = 0.5522848, g = c * p, m = f * p, v = d * p;
      t.moveTo(h - c, u), t.bezierCurveTo(h - c, u - m, h - g, u - f, h, u - f), t.bezierCurveTo(h + g, u - f, h + c, u - m, h + c, u), t.bezierCurveTo(h + c, u + v, h + g, u + d, h, u + d), t.bezierCurveTo(h - g, u + d, h - c, u + v, h - c, u), t.closePath();
    }
    t.beginPath(), r === n && r === s ? t.arc(e.x, e.y, r, 0, 2 * Math.PI) : t.ellipse ? n !== s ? (t.ellipse(e.x, e.y, r, n, 0, aa * 180, aa * 360, !1), t.ellipse(e.x, e.y, r, s, 0, 0, aa * 180, !1)) : t.ellipse(e.x, e.y, r, n, 0, 0, aa * 360, !1) : l(e.x, e.y, r, n, s), Ct.fillCanvas(t, a, e.x - r, e.y - n), Ct._stroke(t, o, e.x - r, e.y - n);
  },
  rectangle: function(t, e, r, n, s) {
    var o = e.x, a = e.y;
    t.beginPath(), t.rect(o, a, r.width, r.height), Ct.fillCanvas(t, s, o, a), Ct._stroke(t, n, o, a);
  },
  sector: function(t, e, r, n, s, o) {
    var a = aa, l = n[0], h = n[1];
    function u(c, f, d, p, g, m) {
      var v = a * -m, _ = a * -g;
      c.beginPath(), c.moveTo(f, d), c.arc(f, d, p, v, _), c.lineTo(f, d), Ct.fillCanvas(c, o, f - p, d - p), Ct._stroke(c, s, f - p, d - p);
    }
    u(t, e.x, e.y, r, l, h);
  },
  _isPattern: function(t) {
    return !De(t) && !("addColorStop" in t);
  },
  drawCross: function(t, e, r, n, s) {
    t.canvas._drawn = !0, t.strokeStyle = s, t.lineWidth = n, t.beginPath(), t.moveTo(e - 5, r), t.lineTo(e + 5, r), t.moveTo(e, r - 5), t.lineTo(e, r + 5), t.stroke();
  },
  copy: function(t, e) {
    var r = e || ve("canvas");
    return r.width = t.width, r.height = t.height, r.getContext("2d").drawImage(t, 0, 0), r;
  },
  pixelRect: function(t, e, r, n) {
    var s = t.lineWidth, o = t.globalAlpha, a = !1;
    if (s > 0 && r > 0)
      a = !0, r < 1 && (t.globalAlpha *= r);
    else if (n > 0)
      n < 1 && (t.globalAlpha *= n);
    else
      return;
    t.canvas._drawn = !0, a ? t.strokeRect(e[0], e[1], 1, 1) : t.fillRect(e[0], e[1], 1, 1), t.globalAlpha !== o && (t.globalAlpha = o);
  }
};
function IE(i, t, e, r) {
  var n = t.x, s = t.y, o = e.x, a = e.y, l = r, h = function(b, T) {
    return b <= T;
  }, u = function(b, T) {
    return b >= T;
  }, c = function(b, T) {
    return Math.min(b, T);
  }, f = function(b, T) {
    return Math.max(b, T);
  }, d = {
    thereYet: u,
    cap: c
  }, p = {
    thereYet: u,
    cap: c
  };
  s - a > 0 && (p.thereYet = h, p.cap = f), n - o > 0 && (d.thereYet = h, d.cap = f), i.moveTo(n, s);
  for (var g = n, m = s, v = 0, _ = !0, y, x; !(d.thereYet(g, o) && p.thereYet(m, a)); )
    y = Math.atan2(a - s, o - n), x = l[v], g = d.cap(o, g + Math.cos(y) * x), m = p.cap(a, m + Math.sin(y) * x), _ ? i.lineTo(g, m) : i.moveTo(g, m), v = (v + 1) % l.length, _ = !_;
}
var x1 = "data:image/";
function b1(i) {
  return i.substring(0, x1.length) === x1 ? i : Ad(i);
}
function w1(i, t) {
  i.filter = t.filter, i.fillStyle = t.fillStyle, i.globalAlpha = t.globalAlpha, i.lineCap = t.lineCap, i.lineDashOffset = t.lineDashOffset, i.lineJoin = t.lineJoin, i.lineWidth = t.lineWidth, i.shadowBlur = t.shadowBlur, i.shadowColor = t.shadowColor, i.shadowOffsetX = t.shadowOffsetX, i.shadowOffsetY = t.shadowOffsetY, i.strokeStyle = t.strokeStyle;
}
function T1(i, t) {
  !t || !i.setLineDash || !Array.isArray(t) || i.setLineDash(t);
}
function Mp(i) {
  return "Z__" + i;
}
var ls = function(t) {
  return function(e) {
    Ot(r, e);
    function r() {
      return e.apply(this, arguments) || this;
    }
    var n = r.prototype;
    return n.on = function(o, a, l) {
      if (!o)
        return this;
      if (!De(o))
        return this._switch("on", o, a);
      if (!a)
        return this;
      this._eventMap || (this._eventMap = {});
      var h = o.toLowerCase().split(" "), u;
      l || (l = this);
      var c = Ut(a._id);
      a._id = Ls();
      for (var f, d = 0, p = h.length; d < p; d++) {
        u = h[d];
        var g = Mp(u);
        if (a[g] && (a[g]._id = a._id), f = this._eventMap[u], f || (f = [], this._eventMap[u] = f), !c) {
          f.push({
            handler: a,
            context: l
          });
          continue;
        }
        var m = f.length;
        if (m > 0) {
          for (var v = 0; v < m; v++)
            if (a === f[v].handler && f[v].context === l)
              return console.warn(this, "find '" + o + "' handler:", a, " The old listener function will be removed"), this;
        }
        f.push({
          handler: a,
          context: l
        });
      }
      return this;
    }, n.addEventListener = function() {
      return this.on.apply(this, arguments);
    }, n.once = function(o, a, l) {
      if (!De(o)) {
        var h = {};
        for (var u in o)
          o.hasOwnProperty(u) && (h[u] = this._wrapOnceHandler(u, o[u], l));
        return this._switch("on", h);
      }
      for (var c = o.split(" "), f = 0, d = c.length; f < d; f++)
        this.on(c[f], this._wrapOnceHandler(c[f], a, l));
      return this;
    }, n.off = function(o, a, l) {
      if (!this._eventMap || !o)
        return this;
      if (!De(o))
        return this._switch("off", o, a);
      if (!a)
        return this;
      if (!Ut(a._id))
        return this;
      var h = o.split(" "), u, c, f;
      l || (l = this);
      for (var d = 0, p = h.length; d < p; d++)
        if (u = h[d].toLowerCase(), f = Mp(u), c = this._eventMap[u], !!c) {
          for (var g = c.length - 1; g >= 0; g--) {
            var m = c[g];
            (a === m.handler || a === m.handler[f]) && m.context === l && (delete m.handler[f], c.splice(g, 1));
          }
          c.length || delete this._eventMap[u];
        }
      return this;
    }, n.removeEventListener = function() {
      return this.off.apply(this, arguments);
    }, n.listens = function(o, a, l) {
      if (!this._eventMap || !De(o))
        return 0;
      var h = this._eventMap[o.toLowerCase()];
      if (!h || !h.length)
        return 0;
      if (!a)
        return h.length;
      for (var u = 0, c = h.length; u < c; u++)
        if (a === h[u].handler && (W(l) || h[u].context === l))
          return 1;
      return 0;
    }, n.getListeningEvents = function() {
      return this._eventMap ? Object.keys(this._eventMap) : [];
    }, n.copyEventListeners = function(o) {
      var a = o._eventMap;
      if (!a)
        return this;
      var l;
      for (var h in a) {
        l = a[h];
        for (var u = 0, c = l.length; u < c; u++)
          this.on(h, l[u].handler, l[u].context);
      }
      return this;
    }, n.fire = function() {
      return this._eventParent ? this._eventParent.fire.apply(this._eventParent, arguments) : this._fire.apply(this, arguments);
    }, n._wrapOnceHandler = function(o, a, l) {
      var h = Mp(o), u = !1, c = function f() {
        u || (delete c[h], u = !0, l ? a.apply(l, arguments) : a.apply(this, arguments), f._called = !0);
      };
      return c[h] = a, c;
    }, n._switch = function(o, a, l) {
      for (var h in a)
        a.hasOwnProperty(h) && this[o](h, a[h], l);
      return this;
    }, n._clearListeners = function(o) {
      if (!(!this._eventMap || !De(o))) {
        var a = this._eventMap[o.toLowerCase()];
        a && (this._eventMap[o] = null);
      }
    }, n._clearAllListeners = function() {
      this._eventMap = null;
    }, n._setEventParent = function(o) {
      return this._eventParent = o, this;
    }, n._setEventTarget = function(o) {
      return this._eventTarget = o, this;
    }, n._fire = function(o, a) {
      if (!this._eventMap)
        return this;
      o = o.toLowerCase();
      var l = this._eventMap[o];
      if (!l)
        return this;
      a || (a = {}), a.type = o, a.target = this._eventTarget || this;
      for (var h = l.slice(0), u, c, f, d = 0, p = h.length; d < p; d++)
        if (h[d]) {
          var g = h[d].handler;
          g._called || (u = h[d].context, c = !0, f = jt({}, a), u ? c = h[d].handler.call(u, f) : c = h[d].handler(f), c === !1 && a.domEvent && Jr(a.domEvent));
        }
      var m = this._eventMap[o];
      if (m) {
        for (var v = [], _ = 0, y = m.length; _ < y; _++) {
          var x = m[_].handler;
          x._called || v.push(m[_]);
        }
        this._eventMap[o] = v;
      }
      return this;
    }, r;
  }(t);
}, DE = function() {
  function i(e) {
    this.target = e;
  }
  var t = i.prototype;
  return t.enable = function() {
    return this._enabled ? this : (this._enabled = !0, this.addHooks(), this);
  }, t.disable = function() {
    return this._enabled ? (this._enabled = !1, this.removeHooks(), this) : this;
  }, t.enabled = function() {
    return !!this._enabled;
  }, t.remove = function() {
    this.disable(), delete this.target, delete this.dom;
  }, i;
}(), Xi = ls(DE), pi = function() {
  function i(e) {
    if (!this || !this.setOptions)
      throw new Error('Class instance is being created without "new" operator.');
    this.setOptions(e), this.callInitHooks(), this._isUpdatingOptions = !1;
  }
  var t = i.prototype;
  return t.proxyOptions = function() {
    var r = this;
    return Ce.proxy ? this.options.isExtensible ? this : (this.options = new Proxy(this.options, {
      set: function(s, o, a) {
        if (s[o] === a || (s[o] = a, r._isUpdatingOptions))
          return !0;
        var l = {};
        return l[o] = a, r.config(l), !0;
      }
    }), this) : this;
  }, t.callInitHooks = function() {
    var r = Object.getPrototypeOf(this);
    return this._visitInitHooks(r), this;
  }, t.setOptions = function(r) {
    if (this.hasOwnProperty("options") || (this.options = this.options ? Object.create(this.options) : {}), !r)
      return this;
    for (var n in r)
      this.options[n] = r[n];
    return this;
  }, t.config = function(r) {
    if (this._isUpdatingOptions = !0, r) {
      if (arguments.length === 2) {
        var o = {};
        o[r] = arguments[1], r = o;
      }
      for (var a in r)
        this.options[a] = r[a], this[a] && this[a] instanceof Xi && (r[a] ? this[a].enable() : this[a].disable());
      this.onConfig(r), this._isUpdatingOptions = !1;
    } else {
      var n = {};
      for (var s in this.options)
        this.options.hasOwnProperty(s) && (n[s] = this.options[s]);
      return this._isUpdatingOptions = !1, n;
    }
    return this;
  }, t.onConfig = function() {
  }, t._visitInitHooks = function(r) {
    if (!this._initHooksCalled) {
      var n = Object.getPrototypeOf(r);
      n._visitInitHooks && n._visitInitHooks.call(this, n), this._initHooksCalled = !0;
      var s = r._initHooks;
      if (s && s !== n._initHooks)
        for (var o = 0; o < s.length; o++)
          s[o].call(this);
    }
  }, i.addInitHook = function(r) {
    for (var n = arguments.length, s = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)
      s[o - 1] = arguments[o];
    var a = typeof r == "function" ? r : function() {
      this[r].apply(this, s);
    }, l = this.prototype, h = Object.getPrototypeOf(l);
    return (!l._initHooks || l._initHooks === h._initHooks) && (l._initHooks = []), l._initHooks.push(a), this;
  }, i.include = function() {
    for (var r = 0; r < arguments.length; r++)
      jt(this.prototype, r < 0 || arguments.length <= r ? void 0 : arguments[r]);
    return this;
  }, i.mergeOptions = function(r) {
    var n = this.prototype, s = Object.getPrototypeOf(n);
    return (!n.options || n.options === s.options) && (n.options = n.options ? Object.create(n.options) : {}), jt(n.options, r), this;
  }, i;
}(), FE = function() {
}, LE = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  return t;
}(ls(FE)), bi = new LE(), Wm = "dprchange", Zm = "docvisibilitychange", Xm = "dragstart", qm = "dragend";
if (typeof window < "u" && window.matchMedia)
  for (var Sp = 1; Sp < 500; Sp++) {
    var zE = (Sp * 0.01).toFixed(2), $l = window.matchMedia("screen and (resolution: " + zE + "dppx)");
    $l && ($l.addEventListener ? $l.addEventListener("change", Ce.checkDevicePixelRatio) : $l.addListener && $l.addListener(Ce.checkDevicePixelRatio));
  }
if (Ce.devicePixelRatio) {
  var Cp = Ce.devicePixelRatio;
  Object.defineProperty(Ce, "devicePixelRatio", {
    get: function() {
      return Cp;
    },
    set: function(t) {
      t !== Cp && (Cp = t, Ce.monitorDPRChange && bi.fire(Wm, {
        devicePixelRatio: t
      }));
    }
  });
}
Ce.webgl && typeof document < "u" && (Gi(document, "visibilitychange", function() {
  bi.fire(Zm, {
    visibilityState: document.visibilityState
  });
}), Gi(document, "dragstart", function() {
  bi.fire(Xm);
}), Gi(document, "dragend", function() {
  bi.fire(qm);
}));
var Wl = {}, TT = function(i) {
  return function(t) {
    Ot(e, t);
    function e() {
      return t.apply(this, arguments) || this;
    }
    e.registerJSONType = function(s) {
      return s ? Wl[s] ? (console.error(s + " has register. please use Different name for:", this), this) : (Wl[s] = this, this) : this;
    }, e.getJSONClass = function(s) {
      return s ? Wl[s] : null;
    };
    var r = e.prototype;
    return r.getJSONType = function() {
      if (this._jsonType === void 0) {
        var s = Object.getPrototypeOf(this).constructor;
        for (var o in Wl)
          if (Wl[o] === s) {
            this._jsonType = o;
            break;
          }
      }
      if (!this._jsonType)
        throw new Error("Found an unregistered Layer/Geometry class!");
      return this._jsonType;
    }, e;
  }(i);
}, Zl = {}, Ru = function() {
  function i() {
    this._tree = l3(9, ["[0]", "[1]", "[2]", "[3]"]);
  }
  var t = i.prototype;
  return t.collides = function(r) {
    return Zl.minX = r[0], Zl.minY = r[1], Zl.maxX = r[2], Zl.maxY = r[3], this._tree.collides(Zl);
  }, t.insertBox = function(r) {
    var n = this._tree;
    return n.insert(r), this;
  }, t.bulkInsertBox = function(r) {
    return this._tree.load(r), this;
  }, t.clear = function() {
    return this._tree.clear(), this;
  }, i;
}();
function Av(i) {
  return function(t) {
    Ot(e, t);
    function e() {
      return t.apply(this, arguments) || this;
    }
    var r = e.prototype;
    return r.addHandler = function(s, o) {
      if (!o)
        return this;
      if (this._handlers || (this._handlers = []), this[s])
        return this[s].enable(), this;
      var a = this[s] = new o(this);
      return this._handlers.push(a), this.options[s] && a.enable(), this;
    }, r.removeHandler = function(s) {
      if (!s)
        return this;
      var o = this[s];
      if (o) {
        var a = this._handlers.indexOf(o);
        a >= 0 && this._handlers.splice(a, 1), this[s].remove(), delete this[s];
      }
      return this;
    }, r._clearHandlers = function() {
      for (var s = 0, o = this._handlers.length; s < o; s++)
        this._handlers[s].remove();
      this._handlers = [];
    }, e;
  }(i);
}
var A1 = "touchstart mousedown", Qu = {
  mousedown: "mousemove",
  touchstart: "touchmove",
  pointerdown: "touchmove",
  MSPointerDown: "touchmove"
}, Pp = {
  mousedown: "mouseup",
  touchstart: "touchend",
  pointerdown: "touchend",
  MSPointerDown: "touchend"
}, Iu = function(i) {
  Ot(t, i);
  function t(r, n) {
    var s;
    return n === void 0 && (n = {}), s = i.call(this, null) || this, s.dom = r, s.options = n, s;
  }
  var e = t.prototype;
  return e.enable = function() {
    return this.dom ? (this._onMouseDown = function(n) {
      return this.onMouseDown(n);
    }, Cn(this.dom, A1, this._onMouseDown, this), this) : this;
  }, e.disable = function() {
    return this.dom ? (this._offEvents(), Un(this.dom, A1, this._onMouseDown), delete this._onMouseDown, this) : this;
  }, e.onMouseDown = function(n) {
    if (!(!this.options.rightclick && n.button === 2) && !(n.touches && n.touches.length > 1) && !(this.options.cancelOn && this.options.cancelOn(n) === !0)) {
      var s = this.dom;
      s.setCapture ? s.setCapture() : window.captureEvents && window.captureEvents(window.Event.MOUSEMOVE | window.Event.MOUSEUP), s.ondragstart = function() {
        return !1;
      }, delete this.moved;
      var o = n.touches ? n.touches[0] : n;
      this.startPos = new Y(o.clientX, o.clientY), Un(document, Qu[n.type], this.onMouseMove), Un(document, Pp[n.type], this.onMouseUp), Cn(document, Qu[n.type], this.onMouseMove, this), Cn(document, Pp[n.type], this.onMouseUp, this), this.options.ignoreMouseleave || (Un(this.dom, "mouseleave", this.onMouseUp), Cn(this.dom, "mouseleave", this.onMouseUp, this)), this.fire("mousedown", {
        domEvent: n,
        mousePos: new Y(o.clientX, o.clientY)
      });
    }
  }, e.onMouseMove = function(n) {
    if (n.touches && n.touches.length > 1) {
      this.moved && (this.interupted = !0, this.onMouseUp(n));
      return;
    }
    var s = n.touches ? n.touches[0] : n, o = new Y(s.clientX, s.clientY), a = o.sub(this.startPos);
    !a.x && !a.y || (this.moved ? this.fire("dragging", {
      domEvent: n,
      mousePos: new Y(s.clientX, s.clientY)
    }) : (this.fire("dragstart", {
      domEvent: n,
      mousePos: this.startPos.copy()
    }), this.moved = !0));
  }, e.onMouseUp = function(n) {
    var s = n.changedTouches ? n.changedTouches[0] : n;
    this._offEvents();
    var o = {
      domEvent: n
    };
    Ut(s.clientX) && (o.mousePos = new Y(parseInt(s.clientX, 0), parseInt(s.clientY, 0))), this.moved && (o.interupted = this.interupted, this.fire("dragend", o), delete this.interupted, delete this.moved), this.fire("mouseup", o);
  }, e._offEvents = function() {
    var n = this.dom;
    if (Un(n, "mouseleave", this.onMouseUp), !(typeof document > "u" || typeof window > "u")) {
      for (var s in Qu)
        Un(document, Qu[s], this.onMouseMove), Un(document, Pp[s], this.onMouseUp);
      n.releaseCapture ? n.releaseCapture() : window.captureEvents && window.captureEvents(window.Event.MOUSEMOVE | window.Event.MOUSEUP);
    }
  }, t;
}(Xi), lt = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  return t.toNumberArrays = function(r) {
    return Array.isArray(r) ? No(r, function(n) {
      return [n.x, n.y];
    }) : [r.x, r.y];
  }, t.toCoordinates = function(r) {
    if (Ut(r[0]) && Ut(r[1]))
      return new t(r);
    if (r instanceof t)
      return r;
    for (var n = [], s = 0, o = r.length; s < o; s++) {
      var a = r[s];
      Array.isArray(a) ? Ut(a[0]) ? n.push(new t(a)) : n.push(t.toCoordinates(a)) : a instanceof t ? n.push(a) : n.push(new t(a));
    }
    return n;
  }, t;
}(Iw), Or = function() {
  function i(t, e) {
    this.type = t, this.properties = e;
  }
  return i.createProj4 = function(e) {
    return new i("proj4", {
      proj: e
    });
  }, i.fromProjectionCode = function(e) {
    return e ? (e = e.toUpperCase().replace(":", ""), i[e] || null) : null;
  }, i;
}();
Or.WGS84 = Or.createProj4("+proj=longlat +datum=WGS84 +no_defs");
Or.EPSG4326 = Or.WGS84;
Or.EPSG3857 = Or.createProj4("+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs");
Or.IDENTITY = Or.createProj4("+proj=identity +no_defs");
Or.CGCS2000 = Or.createProj4("+proj=longlat +datum=CGCS2000");
Or.EPSG4490 = Or.CGCS2000;
Or.BD09LL = Or.createProj4("+proj=longlat +datum=BD09");
Or.GCJ02 = Or.createProj4("+proj=longlat +datum=GCJ02");
var NE = new Y(0, 0), HE = new lt(0, 0), Ep = new lt(0, 0), Op = new lt(0, 0), kp = new lt(0, 0), Rp = new lt(0, 0), BE = new lt(0, 0), M1 = new lt(0, 0), S1 = new lt(0, 0), Ip = [], ja, Xl = [], dn = function() {
  function i(e, r, n, s) {
    this._clazz = lt;
    var o = arguments.length, a = o > 0 ? arguments[o - 1] : null;
    a && a.unproject && (this.projection = arguments[o - 1]), this._dirty = !0, this._initialize(e, r, n, s);
  }
  var t = i.prototype;
  return t._initialize = function(r, n, s, o) {
    if (this.xmin = null, this.xmax = null, this.ymin = null, this.ymax = null, !W(r)) {
      var a = this.projection;
      if (Ut(r) && Ut(n) && Ut(s) && Ut(o)) {
        a ? this.set(r, n, s, o) : this.set(Math.min(r, s), Math.min(n, o), Math.max(r, s), Math.max(n, o));
        return;
      } else Array.isArray(r) ? a ? this.set(r[0], r[1], r[2], r[3]) : this.set(Math.min(r[0], r[2]), Math.min(r[1], r[3]), Math.max(r[0], r[2]), Math.max(r[1], r[3])) : Ut(r.x) && Ut(n.x) && Ut(r.y) && Ut(n.y) ? a ? this.set(r.x, r.y, n.x, n.y) : (r.x > n.x ? (this.xmin = n.x, this.xmax = r.x) : (this.xmin = r.x, this.xmax = n.x), r.y > n.y ? (this.ymin = n.y, this.ymax = r.y) : (this.ymin = r.y, this.ymax = n.y)) : Ut(r.xmin) && Ut(r.xmax) && Ut(r.ymin) && Ut(r.ymax) && this.set(r.xmin, r.ymin, r.xmax, r.ymax);
    }
  }, t._add = function(r) {
    return this._dirty = !0, W(r.x) ? W(r.xmin) ? W(r[0]) || (this.xmin += r[0], this.ymin += r[1], this.xmax += r[0], this.ymax += r[1]) : (this.xmin += r.xmin, this.ymin += r.ymin, this.xmax += r.xmax, this.ymax += r.ymax) : (this.xmin += r.x, this.ymin += r.y, this.xmax += r.x, this.ymax += r.y), this;
  }, t.add = function() {
    var r = new this.constructor(this.xmin, this.ymin, this.xmax, this.ymax, this.projection);
    return r._add.apply(r, arguments);
  }, t._scale = function(r) {
    return this._dirty = !0, this.xmin *= r, this.ymin *= r, this.xmax *= r, this.ymax *= r, this;
  }, t._sub = function(r) {
    return this._dirty = !0, W(r.x) ? W(r.xmin) ? W(r[0]) || (this.xmin -= r[0], this.ymin -= r[1], this.xmax -= r[0], this.ymax -= r[1]) : (this.xmin -= r.xmin, this.ymin -= r.ymin, this.xmax -= r.xmax, this.ymax -= r.ymax) : (this.xmin -= r.x, this.ymin -= r.y, this.xmax -= r.x, this.ymax -= r.y), this;
  }, t._substract = function() {
    return this._sub.apply(this, arguments);
  }, t.sub = function() {
    var r = new this.constructor(this.xmin, this.ymin, this.xmax, this.ymax, this.projection);
    return r._sub.apply(r, arguments);
  }, t.substract = function() {
    return this.sub.apply(this, arguments);
  }, t.round = function() {
    return new this.constructor(Math.round(this.xmin), Math.round(this.ymin), Math.round(this.xmax), Math.round(this.ymax), this.projection);
  }, t._round = function() {
    return this._dirty = !0, this.xmin = Math.round(this.xmin), this.ymin = Math.round(this.ymin), this.xmax = Math.round(this.xmax), this.ymax = Math.round(this.ymax), this;
  }, t.getMin = function(r) {
    return r ? (r.set(this.xmin, this.ymin), r) : new this._clazz(this.xmin, this.ymin);
  }, t.getMax = function(r) {
    return r ? (r.set(this.xmax, this.ymax), r) : new this._clazz(this.xmax, this.ymax);
  }, t.getCenter = function(r) {
    var n = (this.xmin + this.xmax) / 2, s = (this.ymin + this.ymax) / 2;
    return r ? (r.set(n, s), r) : new this._clazz(n, s);
  }, t.isValid = function() {
    return !W(this.xmin) && !W(this.ymin) && !W(this.xmax) && !W(this.ymax);
  }, t.equals = function(r) {
    return this.xmin === r.xmin && this.xmax === r.xmax && this.ymin === r.ymin && this.ymax === r.ymax;
  }, t.intersects = function(r) {
    this._project(this), this._project(r);
    var n = Math.max(this.pxmin, r.pxmin), s = Math.max(this.pymin, r.pymin), o = Math.min(this.pxmax, r.pxmax), a = Math.min(this.pymax, r.pymax), l = !(n > o || s > a);
    return l;
  }, t.within = function(r) {
    return this._project(this), this._project(r), this.pxmin >= r.pxmin && this.pxmax <= r.pxmax && this.pymin >= r.pymin && this.pymax <= r.pymax;
  }, t.contains = function(r) {
    if (!r)
      return !1;
    this._project(this);
    var n = this.projection;
    if (n)
      if (r.x !== void 0) {
        var s = HE;
        Array.isArray(r) ? (s.x = r[0], s.y = r[1]) : (s.x = r.x, s.y = r.y), r = n.project(s, s);
      } else r.xmin !== void 0 && this._project(r);
    return (r.x || r.pxmin || 0) >= this.pxmin && (r.x || r.pxmax || 0) <= this.pxmax && (r.y || r.pymin || 0) >= this.pymin && (r.y || r.pymax || 0) <= this.pymax;
  }, t.getWidth = function() {
    return Math.abs(this.xmax - this.xmin);
  }, t.getHeight = function() {
    return Math.abs(this.ymax - this.ymin);
  }, t.getSize = function() {
    return new zn(this.getWidth(), this.getHeight());
  }, t.set = function(r, n, s, o) {
    return this.xmin = r, this.ymin = n, this.xmax = s, this.ymax = o, this._dirty = !0, this;
  }, t.__combine = function(r) {
    r.x !== void 0 && (ja.xmin = ja.xmax = r.x, ja.ymin = ja.ymax = r.y, r = ja), this._project(r), this._project(this);
    var n = Ut(this.pxmin), s, o, a, l;
    n ? (s = Math.min(this.pxmin, r.pxmin), o = Math.min(this.pymin, r.pymin), a = Math.max(this.pxmax, r.pxmax), l = Math.max(this.pymax, r.pymax)) : (s = r.pxmin, o = r.pymin, a = r.pxmax, l = r.pymax);
    var h = this.projection;
    if (h) {
      Ep.set(s, o), Op.set(a, l);
      var u = h.unproject(Ep, Ep), c = h.unproject(Op, Op);
      s = u.x, o = u.y, a = c.x, l = c.y;
    }
    return Xl[0] = s, Xl[1] = o, Xl[2] = a, Xl[3] = l, Xl;
  }, t._combine = function(r) {
    if (!r || r.isValid && !r.isValid())
      return this;
    var n = this.__combine(r);
    return this.set(n[0], n[1], n[2], n[3]), this._dirty = !0, this;
  }, t.combine = function(r) {
    if (!r || r.isValid && !r.isValid())
      return this;
    var n = this.__combine(r);
    return new this.constructor(n[0], n[1], n[2], n[3], this.projection);
  }, t.intersection = function(r) {
    if (!this.intersects(r))
      return null;
    kp.x = Math.max(this.pxmin, r.pxmin), kp.y = Math.max(this.pymin, r.pymin), Rp.x = Math.min(this.pxmax, r.pxmax), Rp.y = Math.min(this.pymax, r.pymax);
    var n = kp, s = Rp, o = this.projection;
    return o && (n = o.unproject(n, n), s = o.unproject(s, s)), new this.constructor(n, s, o);
  }, t.expand = function(r) {
    var n, s;
    return Ut(r) ? n = s = r : (n = r.width || r.x || r[0] || 0, s = r.height || r.y || r[1] || 0), new this.constructor(this.xmin - n, this.ymin - s, this.xmax + n, this.ymax + s, this.projection);
  }, t._expand = function(r) {
    var n, s;
    return Ut(r) ? n = s = r : (n = r.width || r.x || r[0] || 0, s = r.height || r.y || r[1] || 0), this.xmin -= n, this.ymin -= s, this.xmax += n, this.ymax += s, this._dirty = !0, this;
  }, t.toJSON = function() {
    return {
      xmin: this.xmin,
      ymin: this.ymin,
      xmax: this.xmax,
      ymax: this.ymax
    };
  }, t.toArray = function(r) {
    var n = this.xmin, s = this.ymin, o = this.xmax, a = this.ymax;
    return r ? (r[0].x = n, r[0].y = a, r[1].x = o, r[1].y = a, r[2].x = o, r[2].y = s, r[3].x = n, r[3].y = s, r[4].x = n, r[4].y = a, r) : [new this._clazz([n, a]), new this._clazz([o, a]), new this._clazz([o, s]), new this._clazz([n, s]), new this._clazz([n, a])];
  }, t.toString = function() {
    return this.xmin + "," + this.ymin + "," + this.xmax + "," + this.ymax;
  }, t.copy = function() {
    return new this.constructor(this.xmin, this.ymin, this.xmax, this.ymax, this.projection);
  }, t.convertTo = function(r, n) {
    if (!this.isValid())
      return null;
    var s = n || new this.constructor();
    n && s.set(null, null, null, null);
    var o;
    return this._clazz === lt ? o = BE : this._clazz === Y && (o = NE), o.x = this.xmin, o.y = this.ymax, s._combine(r(o)), o.x = this.xmax, s._combine(r(o)), o.y = this.ymin, s._combine(r(o)), o.x = this.xmin, s._combine(r(o)), s;
  }, t._project = function(r) {
    if (!r || !r.isValid()) {
      r && (r.pxmin = r.pxmax = r.pymin = r.pymax = null);
      return;
    }
    var n = this.projection;
    if (n) {
      if (r._dirty) {
        M1.set(r.xmax, r.ymin), S1.set(r.xmin, r.ymax), Ip[0] = M1, Ip[1] = S1;
        var s = n.projectCoords(Ip), o = s[0], a = s[1];
        r.pxmin = Math.min(o.x, a.x), r.pymin = Math.min(o.y, a.y), r.pxmax = Math.max(o.x, a.x), r.pymax = Math.max(o.y, a.y);
      }
      delete r._dirty;
    } else
      r.pxmin = r.xmin, r.pxmax = r.xmax, r.pymin = r.ymin, r.pymax = r.ymax;
  }, i;
}();
ja = new dn(0, 0, 0, 0);
var Se = function(i) {
  Ot(t, i);
  function t(e, r, n, s) {
    var o;
    return o = i.call(this, e, r, n, s) || this, o._clazz = Y, o;
  }
  return t;
}(dn), AT = function() {
  function i(e) {
    this.matrix = e;
  }
  var t = i.prototype;
  return t.transform = function(r, n, s) {
    var o = this.matrix[0] * (r.x - this.matrix[2]) / n, a = -this.matrix[1] * (r.y - this.matrix[3]) / n;
    return s ? (s.x = o, s.y = a, s) : new Y(o, a);
  }, t.untransform = function(r, n, s) {
    var o = r.x * n / this.matrix[0] + this.matrix[2], a = r.y * n / -this.matrix[1] + this.matrix[3];
    return s ? (s.x = o, s.y = a, s) : new lt(o, a);
  }, i;
}(), po = {
  is: function(t) {
    if (this.code === t)
      return !0;
    if (!this.aliases)
      return !1;
    for (var e = 0; e < this.aliases.length; e++)
      if (this.aliases[e] === t)
        return !0;
    return !1;
  },
  project: function() {
  },
  unproject: function() {
  },
  projectCoords: function(t, e) {
    var r = this;
    if (!t)
      return [];
    if (!Array.isArray(t))
      return this.project(t);
    if (t.length === 0)
      return [];
    if (!this.isSphere())
      return No(t, this.project, this);
    if (Array.isArray(t[0]))
      return t.map(function(y) {
        return r.projectCoords(y, e);
      });
    for (var n = e !== !1, s = this.getCircum(), o = this.getSphereExtent(), a = o.sx, l = o.sy, h, u, c = t[0], f, d, p, g, m = [this.project(c)], v = 1, _ = t.length; v < _; v++)
      f = t[v], d = f.x - c.x, p = f.y - c.y, g = this.project(f), Math.abs(d) > 180 && n && (h === void 0 && (h = f.x > c.x), h && (g._add(-s.x * Ar(d) * a, 0), f._add(-360 * Ar(d), 0))), Math.abs(p) > 90 && n && (u === void 0 && (u = f.y < c.y), u && (g._add(0, -s.y * Ar(p) * l), f._add(0, -180 * Ar(p)))), c = f, m.push(g);
    return m;
  },
  unprojectCoords: function(t) {
    return t ? Array.isArray(t) ? No(t, this.unproject, this) : this.unproject(t) : [];
  },
  isSphere: function() {
    return !!this.sphere;
  },
  isOutSphere: function(t) {
    if (!this.isSphere())
      return !1;
    var e = this.getSphereExtent();
    return !e.contains(t);
  },
  wrapCoord: function(t) {
    if (!this.isSphere())
      return t;
    var e = this.getSphereExtent(), r = new lt(t);
    return e.contains(r) || (r.x = Ps(t.x, e.xmin, e.xmax), r.y = Ps(t.y, e.ymin, e.ymax)), r;
  },
  getCircum: function() {
    if (!this.circum && this.isSphere()) {
      var t = this.getSphereExtent();
      this.circum = {
        x: t.getWidth(),
        y: t.getHeight()
      };
    }
    return this.circum;
  },
  getSphereExtent: function() {
    if (!this.extent && this.isSphere()) {
      var t = this.project(new lt(180, 90)), e = this.project(new lt(-180, -90));
      this.extent = new dn(e, t, this), this.extent.sx = t.x > e.x ? 1 : -1, this.extent.sy = t.y > e.y ? 1 : -1;
    }
    return this.extent;
  }
}, Mv = {
  measureLength: function(t, e) {
    if (!Array.isArray(t))
      return this.measureLenBetween(t, e);
    for (var r = 0, n = 0, s = t.length; n < s - 1; n++)
      r += this.measureLenBetween(t[n], t[n + 1]);
    return r;
  }
}, MT = jt({
  measure: "IDENTITY",
  measureLenBetween: function(t, e) {
    if (!t || !e)
      return 0;
    try {
      return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
    } catch {
      return 0;
    }
  },
  measureArea: function(t) {
    if (!Array.isArray(t))
      return 0;
    for (var e = 0, r = 0, n = t.length; r < n; r++) {
      var s = t[r], o = null;
      r === n - 1 ? o = t[0] : o = t[r + 1], e += s.x * o.y - s.y * o.x;
    }
    return Math.abs(e / 2);
  },
  locate: function(t, e, r, n) {
    return n = n || new lt(0, 0), n.set(t.x, t.y), this._locate(n, e, r);
  },
  _locate: function(t, e, r) {
    return t ? (e || (e = 0), r || (r = 0), !e && !r || (t.x = t.x + e, t.y = t.y + r), t) : null;
  },
  rotate: function(t, e, r) {
    return t = new lt(t.x, t.y), this._rotate(t, e, r);
  },
  _rotate: function() {
    var i = new Y(0, 0);
    return function(t, e, r) {
      return i.x = t.x - e.x, i.y = t.y - e.y, i._rotate(r * Math.PI / 180), t.x = e.x + i.x, t.y = e.y + i.y, t;
    };
  }()
}, Mv), ST = function() {
  function i(e) {
    this.radius = e;
  }
  var t = i.prototype;
  return t.measureLenBetween = function(r, n) {
    if (!r || !n)
      return 0;
    var s = Vn(r.y), o = Vn(n.y), a = s - o, l = Vn(r.x) - Vn(n.x);
    return s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2) + Math.cos(s) * Math.cos(o) * Math.pow(Math.sin(l / 2), 2))), s *= this.radius, s;
  }, t.measureArea = function(r) {
    var n = Vn(this.radius), s = 0, o = r, a = o.length;
    if (a < 3)
      return 0;
    var l;
    for (l = 0; l < a - 1; l++) {
      var h = o[l], u = o[l + 1];
      s += h.x * n * Math.cos(Vn(h.y)) * u.y * n - u.x * n * Math.cos(Vn(u.y)) * h.y * n;
    }
    return a = o[l], o = o[0], s += a.x * n * Math.cos(Vn(a.y)) * o.y * n - o.x * n * Math.cos(Vn(o.y)) * a.y * n, 0.5 * Math.abs(s);
  }, t.locate = function(r, n, s, o) {
    return o = o || new lt(0, 0), o.set(r.x, r.y), this._locate(o, n, s);
  }, t._locate = function(r, n, s) {
    if (!r)
      return null;
    if (n || (n = 0), s || (s = 0), !n && !s)
      return r;
    var o, a, l = Vn(r.y);
    if (s !== 0) {
      var h = Math.abs(s), u = Math.sin(h / (2 * this.radius)) * 2;
      l = l + u * (s > 0 ? 1 : -1), a = Ps(l * 180 / Math.PI, -90, 90);
    } else
      a = r.y;
    if (n !== 0) {
      var c = Math.abs(n), f = Vn(r.x), d = 2 * Math.sqrt(Math.pow(Math.sin(c / (2 * this.radius)), 2) / Math.pow(Math.cos(l), 2));
      f = f + d * (n > 0 ? 1 : -1), o = Ps(f * 180 / Math.PI, -180, 180);
    } else
      o = r.x;
    return r.x = o, r.y = a, r;
  }, t.rotate = function(r, n, s) {
    return r = new lt(r), this._rotate(r, n, s);
  }, t._rotate = function(r, n, s) {
    var o = jE(n, r), a = o - s, l = this.measureLenBetween(n, r);
    return r.x = n.x, r.y = n.y, GE(r, l, a, this.radius);
  }, i;
}();
function jE(i, t, e) {
  e === void 0 && (e = {});
  var r;
  e.final ? r = C1(t, i) : r = C1(i, t);
  var n = r > 180 ? -(360 - r) : r;
  return n;
}
function C1(i, t) {
  var e = Vn(i.y), r = Vn(t.y), n = Vn(t.x - i.x);
  n > Math.PI && (n -= 2 * Math.PI), n < -Math.PI && (n += 2 * Math.PI);
  var s = Math.log(Math.tan(r / 2 + Math.PI / 4) / Math.tan(e / 2 + Math.PI / 4)), o = Math.atan2(n, s);
  return (av(o) + 360) % 360;
}
function GE(i, t, e, r) {
  var n = t / r, s = i.x * Math.PI / 180, o = Vn(i.y), a = Vn(e), l = n * Math.cos(a), h = o + l;
  Math.abs(h) > Math.PI / 2 && (h = h > 0 ? Math.PI - h : -Math.PI - h);
  var u = Math.log(Math.tan(h / 2 + Math.PI / 4) / Math.tan(o / 2 + Math.PI / 4)), c = Math.abs(u) > 1e-11 ? l / u : Math.cos(o), f = n * Math.sin(a) / c, d = s + f;
  return i.x = (d * 180 / Math.PI + 540) % 360 - 180, i.y = h * 180 / Math.PI, i;
}
var Du = jt({
  measure: "EPSG:4326",
  sphere: new ST(6378137),
  measureLenBetween: function() {
    return this.sphere.measureLenBetween.apply(this.sphere, arguments);
  },
  measureArea: function() {
    return this.sphere.measureArea.apply(this.sphere, arguments);
  },
  _locate: function() {
    return this.sphere._locate.apply(this.sphere, arguments);
  },
  locate: function() {
    return this.sphere.locate.apply(this.sphere, arguments);
  },
  _rotate: function() {
    return this.sphere._rotate.apply(this.sphere, arguments);
  },
  rotate: function() {
    return this.sphere.rotate.apply(this.sphere, arguments);
  }
}, Mv), CT = jt({
  measure: "BAIDU",
  sphere: new ST(637099681e-2),
  measureLenBetween: function() {
    return this.sphere.measureLenBetween.apply(this.sphere, arguments);
  },
  measureArea: function() {
    return this.sphere.measureArea.apply(this.sphere, arguments);
  },
  _locate: function() {
    return this.sphere._locate.apply(this.sphere, arguments);
  },
  locate: function() {
    return this.sphere.locate.apply(this.sphere, arguments);
  },
  _rotate: function() {
    return this.sphere._rotate.apply(this.sphere, arguments);
  },
  rotate: function() {
    return this.sphere.rotate.apply(this.sphere, arguments);
  }
}, Mv), VE = Du, wh = {};
function Sv(i) {
  wh[i.measure] = i;
}
Sv(MT);
Sv(Du);
Sv(CT);
var Dp = {
  getInstance: function(t) {
    if (!t)
      return VE;
    for (var e in wh)
      if (Fl(wh, e)) {
        var r = wh[e].measure;
        if (!r)
          continue;
        if (t.toLowerCase() === r.toLowerCase())
          return wh[e];
      }
    return null;
  }
}, P1 = 1e-7, PT = jt({}, po, {
  code: "EPSG:3857",
  rad: Math.PI / 180,
  metersPerDegree: 6378137 * Math.PI / 180,
  maxLatitude: 85.0511287798,
  project: function(t, e) {
    var r = this.rad, n = this.metersPerDegree, s = this.maxLatitude, o = t.x, a = Math.max(Math.min(s, t.y), -s), l;
    a === 0 ? l = 0 : l = Math.log(Math.tan((90 + a) * r / 2)) / r;
    var h = o * n, u = l * n;
    return e ? (e.x = h, e.y = u, e) : new lt(h, u);
  },
  unproject: function(t, e) {
    var r = this.rad, n = this.metersPerDegree, s = t.x / n, o = t.y, a;
    o === 0 ? a = 0 : (a = o / n, a = (2 * Math.atan(Math.exp(a * r)) - Math.PI / 2) / r), Math.abs(Math.abs(s) - 180) < P1 && (s = Ar(s) * 180), Math.abs(Math.abs(a) - this.maxLatitude) < P1 && (a = Ar(a) * this.maxLatitude);
    var l = Ps(s, -180, 180), h = Ps(a, -this.maxLatitude, this.maxLatitude);
    return e ? (e.x = l, e.y = h, e) : new lt(l, h);
  }
}, Du), UE = jt({}, po, {
  code: "EPSG:4326",
  aliases: ["EPSG:4490"],
  project: function(t, e) {
    return e ? (e.x = t.x, e.y = t.y, e) : new lt(t);
  },
  unproject: function(t, e) {
    return e ? (e.x = t.x, e.y = t.y, e) : new lt(t);
  }
}, Du), Fp = Math.abs, bo = Math.sin, wo = Math.cos, $E = Math.tan, WE = Math.atan, tc = Math.atan2, ZE = Math.sqrt, XE = Math.log, Lp = Math.hypot, E1 = Math.sinh, qE = Math.cosh, O1 = 1 / 0;
function YE(i) {
  var t = [], e = [], r = [], n = [], s, o, a, l, h, u;
  i.es <= 0, a = i.es / (1 + ZE(1 - i.es)), h = l = a / (2 - a), t[0] = l * (2 + l * (-2 / 3 + l * (-2 + l * (116 / 45 + l * (26 / 45 + l * (-2854 / 675)))))), e[0] = l * (-2 + l * (2 / 3 + l * (4 / 3 + l * (-82 / 45 + l * (32 / 45 + l * (4642 / 4725)))))), h *= l, t[1] = h * (7 / 3 + l * (-8 / 5 + l * (-227 / 45 + l * (2704 / 315 + l * (2323 / 945))))), e[1] = h * (5 / 3 + l * (-16 / 15 + l * (-13 / 9 + l * (904 / 315 + l * (-1522 / 945))))), h *= l, t[2] = h * (56 / 15 + l * (-136 / 35 + l * (-1262 / 105 + l * (73814 / 2835)))), e[2] = h * (-26 / 15 + l * (34 / 21 + l * (8 / 5 + l * (-12686 / 2835)))), h *= l, t[3] = h * (4279 / 630 + l * (-332 / 35 + l * (-399572 / 14175))), e[3] = h * (1237 / 630 + l * (-12 / 5 + l * (-24832 / 14175))), h *= l, t[4] = h * (4174 / 315 + l * (-144838 / 6237)), e[4] = h * (-734 / 315 + l * (109598 / 31185)), h *= l, t[5] = h * (601676 / 22275), e[5] = h * (444337 / 155925), h = l * l, s = i.k0 / (1 + l) * (1 + h * (1 / 4 + h * (1 / 64 + h / 256))), r[0] = l * (-0.5 + l * (2 / 3 + l * (-37 / 96 + l * (1 / 360 + l * (81 / 512 + l * (-96199 / 604800)))))), n[0] = l * (0.5 + l * (-2 / 3 + l * (5 / 16 + l * (41 / 180 + l * (-127 / 288 + l * (7891 / 37800)))))), r[1] = h * (-1 / 48 + l * (-1 / 15 + l * (437 / 1440 + l * (-46 / 105 + l * (1118711 / 3870720))))), n[1] = h * (13 / 48 + l * (-3 / 5 + l * (557 / 1440 + l * (281 / 630 + l * (-1983433 / 1935360))))), h *= l, r[2] = h * (-17 / 480 + l * (37 / 840 + l * (209 / 4480 + l * (-5569 / 90720)))), n[2] = h * (61 / 240 + l * (-103 / 140 + l * (15061 / 26880 + l * (167603 / 181440)))), h *= l, r[3] = h * (-4397 / 161280 + l * (11 / 504 + l * (830251 / 7257600))), n[3] = h * (49561 / 161280 + l * (-179 / 168 + l * (6601661 / 7257600))), h *= l, r[4] = h * (-4583 / 161280 + l * (108847 / 3991680)), n[4] = h * (34729 / 80640 + l * (-3418889 / 1995840)), h *= l, r[5] = h * (-20648693 / 638668800), n[5] = h * (212378941 / 319334400), u = g(e, i.phi0), o = -s * (u + m(n, 2 * u)), i.fwd = c, i.inv = f;
  function c(_, y) {
    var x, w, b, T, A, M = _.phi, S = _.lam;
    M = g(e, M), x = bo(M), w = wo(M), T = bo(S), b = wo(S), M = tc(x, b * w), S = tc(T * w, Lp(x, w * b)), S = p($E(S)), A = v(n, 2 * M, 2 * S), M += A[0], S += A[1], Fp(S) <= 2.623395162778 ? (y.y = s * M + o, y.x = s * S) : y.x = y.y = O1;
  }
  function f(_, y) {
    var x, w, b, T, A, M = _.y, S = _.x;
    M = (M - o) / s, S = S / s, Fp(S) <= 2.623395162778 ? (A = v(r, 2 * M, 2 * S), M += A[0], S += A[1], S = WE(E1(S)), x = bo(M), w = wo(M), T = bo(S), b = wo(S), S = tc(T, b * w), M = tc(x * b, Lp(T, b * w)), y.phi = g(t, M), y.lam = S) : y.phi = y.lam = O1;
  }
  function d(_) {
    var y = 1 + _, x = y - 1;
    return x === 0 ? _ : _ * XE(y) / x;
  }
  function p(_) {
    var y = Fp(_);
    return y = d(y * (1 + y / (Lp(1, y) + 1))), _ < 0 ? -y : y;
  }
  function g(_, y) {
    for (var x = 2 * wo(2 * y), w = _.length - 1, b = _[w], T = 0, A; --w >= 0; )
      A = -T + x * b + _[w], T = b, b = A;
    return y + A * bo(2 * y);
  }
  function m(_, y) {
    for (var x = 2 * wo(y), w = _.length - 1, b = _[w], T = 0, A; --w >= 0; )
      A = -T + x * b + _[w], T = b, b = A;
    return bo(y) * A;
  }
  function v(_, y, x) {
    for (var w = bo(y), b = wo(y), T = E1(x), A = qE(x), M = 2 * b * A, S = -2 * w * T, P = _.length - 1, C = _[P], k = 0, O = 0, R = 0, I, D; --P >= 0; )
      I = O, D = k, O = C, k = R, C = -I + M * O - S * k + _[P], R = -D + S * O + M * k;
    return M = w * A, S = b * T, [M * C - S * R, M * R + S * C];
  }
}
var k1 = 57.29577951308232, la = 0.017453292519943295, JE = 6378137, KE = 0.0066943799901413165, R1 = ["Traverse_Mercator"], Jf = jt({}, po, {
  code: "EPSG:9807",
  aliases: R1,
  create: function(t) {
    var e = {
      a: JE,
      es: KE,
      x0: W(t.falseEasting) ? 5e5 : t.falseEasting,
      y0: W(t.falseNorthing) ? 0 : t.falseNorthing,
      k0: t.scaleFactor || 0.9996,
      lam0: (t.centralMeridian || 0) * la,
      phi0: (t.latitudeOfOrigin || 0) * la,
      originLam0: t.startLongtitude || 0,
      originPhi0: t.startLatitude || 0
    };
    YE(e);
    var r = {
      lam: 0,
      phi: 0
    }, n = {}, s = 0, o = 0;
    return (e.originLam0 || e.originPhi0) && (r.lam = e.originLam0 * la - e.lam0, r.phi = e.originPhi0 * la, e.fwd(r, n), s = e.a * n.x + e.x0, o = e.a * n.y + e.y0), jt({}, po, {
      code: "EPSG:9807",
      aliases: R1,
      centralMeridian: t.centralMeridian,
      project: function(l, h) {
        r.lam = l.x * la - e.lam0, r.phi = l.y * la, e.fwd(r, n);
        var u = e.a * n.x + e.x0 - s, c = e.a * n.y + e.y0 - o;
        return h ? (h.x = u, h.y = c, h) : new lt(u, c);
      },
      unproject: function(l, h) {
        n.x = (l.x - e.x0 + s) / e.a, n.y = (l.y - e.y0 + o) / e.a, e.inv(n, r);
        var u = (r.lam + e.lam0) * k1, c = r.phi * k1;
        return h ? (h.x = u, h.y = c, h) : new lt(u, c);
      }
    }, Du);
  }
}), QE = jt({}, Jf, {
  code: "utm",
  aliases: [],
  create: function(t) {
    var e = {}, r = parseInt(t.zone);
    if (e.falseNorthing = t.south ? 1e7 : 0, e.falseEasting = 5e5, r > 0 && r <= 60)
      r--;
    else
      throw new Error("zone must be > 0 and <= 60.");
    return e.centralMeridian = (r + 0.5) * 6 - 180, e.scaleFactor = 0.9996, Jf.create(e);
  }
}), t5 = jt({}, po, {
  code: "BAIDU",
  project: function(t, e) {
    return this.convertLL2MC(t, e);
  },
  unproject: function(t, e) {
    return this.convertMC2LL(t, e);
  }
}, CT, {
  EARTHRADIUS: 637099681e-2,
  MCBAND: [1289059486e-2, 836237787e-2, 5591021, 348198983e-2, 167804312e-2, 0],
  LLBAND: [75, 60, 45, 30, 15, 0],
  MC2LL: [[1410526172116255e-23, 898305509648872e-20, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -0.03801003308653, 173379812e-1], [-7435856389565537e-24, 8983055097726239e-21, -0.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 1026014486e-2], [-3030883460898826e-23, 898305509983578e-20, 0.30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908, -3.29883767235584, 0.32710905363475, 685681737e-2], [-1981981304930552e-23, 8983055099779535e-21, 0.03278182852591, 40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263, 0.12923347998204, -0.04625736007561, 448277706e-2], [309191371068437e-23, 8983055096812155e-21, 6995724062e-14, 23.10934304144901, -23663490511e-14, -0.6321817810242, -0.00663494467273, 0.03430082397953, -0.00466043876332, 25551644e-1], [2890871144776878e-24, 8983055095805407e-21, -3068298e-14, 7.47137025468032, -353937994e-14, -0.02145144861037, -1234426596e-14, 10322952773e-14, -323890364e-14, 826088.5]],
  LL2MC: [[-0.0015702102444, 111320.7020616939, 1704480524535203, -10338987376042340, 26112667856603880, -35149669176653700, 26595700718403920, -10725012454188240, 1800819912950474, 82.5], [8277824516172526e-19, 111320.7020463578, 6477955746671607e-7, -4082003173641316e-6, 1077490566351142e-5, -1517187553151559e-5, 1205306533862167e-5, -5124939663577472e-6, 9133119359512032e-7, 67.5], [0.00337398766765, 111320.7020202162, 4481351045890365e-9, -2339375119931662e-8, 7968221547186455e-8, -1159649932797253e-7, 9723671115602145e-8, -4366194633752821e-8, 8477230501135234e-9, 52.5], [0.00220636496208, 111320.7020209128, 51751.86112841131, 3796837749470245e-9, 992013.7397791013, -122195221711287e-8, 1340652697009075e-9, -620943.6990984312, 144416.9293806241, 37.5], [-3441963504368392e-19, 111320.7020576856, 278.2353980772752, 2485758690035394e-9, 6070.750963243378, 54821.18345352118, 9540.606633304236, -2710.55326746645, 1405.483844121726, 22.5], [-3218135878613132e-19, 111320.7020701615, 0.00369383431289, 823725.6402795718, 0.46104986909093, 2351.343141331292, 1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45]],
  convertMC2LL: function(t, e) {
    for (var r, n = 0, s = this.MCBAND.length; n < s; n++)
      if (Math.abs(t.y) >= this.MCBAND[n]) {
        r = this.MC2LL[n];
        break;
      }
    var o = this.convertor(t, r, e);
    return o;
  },
  convertLL2MC: function(t, e) {
    var r, n, s;
    t.x = this.getLoop(t.x, -180, 180), t.y = this.getRange(t.y, -74, 74);
    var o = new lt(t.x, t.y);
    for (n = 0, s = this.LLBAND.length; n < s; n++)
      if (o.y >= this.LLBAND[n]) {
        r = this.LL2MC[n];
        break;
      }
    if (!r) {
      for (n = this.LLBAND.length - 1; n >= 0; n--)
        if (o.y <= -this.LLBAND[n]) {
          r = this.LL2MC[n];
          break;
        }
    }
    var a = this.convertor(t, r, e);
    return a;
  },
  convertor: function(t, e, r) {
    if (!t || !e)
      return null;
    var n = e[0] + e[1] * Math.abs(t.x), s = Math.abs(t.y) / e[9], o = e[2] + e[3] * s + e[4] * s * s + e[5] * s * s * s + e[6] * s * s * s * s + e[7] * s * s * s * s * s + e[8] * s * s * s * s * s * s;
    return n *= t.x < 0 ? -1 : 1, o *= t.y < 0 ? -1 : 1, r ? (r.x = n, r.y = o, r) : new lt(n, o);
  },
  toRadians: function(t) {
    return Math.PI * t / 180;
  },
  toDegrees: function(t) {
    return 180 * t / Math.PI;
  },
  getRange: function(t, e, r) {
    return e != null && (t = Math.max(t, e)), r != null && (t = Math.min(t, r)), t;
  },
  getLoop: function(t, e, r) {
    if (t === 1 / 0)
      return r;
    if (t === -1 / 0)
      return e;
    for (; t > r; )
      t -= r - e;
    for (; t < e; )
      t += r - e;
    return t;
  }
}), e5 = jt({}, po, {
  code: "IDENTITY",
  project: function(t, e) {
    return e ? (e.x = t.x, e.y = t.y, e) : t.copy();
  },
  unproject: function(t, e) {
    return e ? (e.x = t.x, e.y = t.y, e) : t.copy();
  }
}, MT), ET = PT, us = /* @__PURE__ */ Object.freeze({
  EPSG3857: PT,
  DEFAULT: ET,
  EPSG4326: UE,
  EPSG9807: Jf,
  UTM: QE,
  BAIDU: t5,
  IDENTITY: e5,
  Common: po
}), Cv = function(i) {
  return function(t) {
    Ot(e, t);
    function e() {
      return t.apply(this, arguments) || this;
    }
    return e.registerRenderer = function(n, s) {
      var o = this.prototype, a = Object.getPrototypeOf(o);
      return (!o._rendererClasses || o._rendererClasses === a._rendererClasses) && (o._rendererClasses = o._rendererClasses ? Object.create(o._rendererClasses) : {}), o._rendererClasses[n.toLowerCase()] = s, this;
    }, e.getRendererClass = function(n) {
      var s = this.prototype;
      return s._rendererClasses ? s._rendererClasses[n.toLowerCase()] : null;
    }, e;
  }(i);
}, zp = 0, I1 = [], Id = function() {
  function i(e) {
    var r = this;
    pT(), this._delayMessages = [], this.initializing = !1;
    var n = fT(e);
    _E() && !n && (this.initializing = !0, console.log("Injecting codes in worker with worker key: :" + e), AE(e, function() {
      r.initializing = !1, r.created();
    })), this.workerKey = e, this.workerPool = $m(), this.currentActor = 0, this.actorId = Ls(), this.workers = this.workerPool.acquire(this.actorId), this.callbacks = {}, this.callbackID = 0, this.receiveFn = this.receive.bind(this), this.workers.forEach(function(s) {
      s.addEventListener("message", r.receiveFn, !1);
    }), dT(e);
  }
  var t = i.prototype;
  return t.created = function() {
    var r = this;
    this._delayMessages.forEach(function(n) {
      var s = n.command, o = n.data, a = n.buffers, l = n.cb, h = n.workerId;
      r[s](o, a, l, h);
    }), this._delayMessages = [];
  }, t.isActive = function() {
    return !!this.workers;
  }, t.broadcast = function(r, n, s) {
    var o = this;
    return this.initializing ? (this._delayMessages.push({
      command: "broadcast",
      data: r,
      buffers: n,
      cb: s
    }), this) : (s = s || function() {
    }, n5(this.workers, function(a, l) {
      o.send(r, n, l, a.id);
    }, s), this);
  }, t.send = function(r, n, s, o) {
    if (this.initializing)
      return this._delayMessages.push({
        command: "send",
        data: r,
        buffers: n,
        cb: s,
        workerId: o
      }), this;
    var a = s ? this.actorId + ":" + this.callbackID++ : null;
    return s && (this.callbacks[a] = s), this.post({
      data: r,
      callback: String(a)
    }, n, o), this;
  }, t.receive = function(r) {
    var n = this, s = r.data, o = s.callback, a = this.callbacks[o];
    delete this.callbacks[o], s.type === "<request>" ? this.actorId === s.actorId && this[s.command](s.params, function(l, h, u) {
      var c = {
        type: "<response>",
        callback: s.callback
      };
      l ? c.error = l.message : c.data = h, n.post(c, u || I1, s.workerId);
    }) : a && s.error ? a(s.error) : a && a(null, s.data);
  }, t.remove = function() {
    var r = this;
    this.workers.forEach(function(n) {
      n.removeEventListener("message", r.receiveFn, !1);
    }), delete this.receiveFn, delete this.workers, delete this.callbacks, delete this.workerPool;
  }, t.post = function(r, n, s) {
    return (typeof s != "number" || isNaN(s)) && (s = this.currentActor = (this.currentActor + 1) % this.workerPool.workerCount), r.workerId = s, r.workerKey = this.workerKey, r.actorId = this.actorId, this.workerPool.addMessage(s, r, n || I1), s;
  }, t.getDedicatedWorker = function() {
    return zp = (zp + 1) % this.workerPool.workerCount, zp;
  }, i;
}();
function n5(i, t, e) {
  i.length || e(null, []);
  var r = i.length, n = new Array(i.length), s = null;
  i.forEach(function(o, a) {
    t(o, function(l, h) {
      l && (s = l), n[a] = h, --r === 0 && e(s, n);
    });
  });
}
var r5 = [], i5 = function(i) {
  Ot(t, i);
  function t() {
    return i.call(this, wv) || this;
  }
  var e = t.prototype;
  return e.fetchImage = function(n, s) {
    var o = {
      url: n
    };
    this.send(o, r5, s);
  }, t;
}(Id), Ll = function(i) {
  Ot(t, i);
  function t(r) {
    var n;
    return n = i.call(this) || this, n.layer = r, n._painted = !1, n._drawTime = 0, Ce.decodeImageInWorker && !Ce.safari && !Ce.iosWeixin && (n._resWorkerConn = new i5()), n.setToRedraw(), n;
  }
  var e = t.prototype;
  return e.render = function(n) {
    this.prepareRender(), !(!this.getMap() || !this.layer.isVisible()) && (this.resources || (this.resources = new Bo()), this.checkAndDraw(this._tryToDraw, n), this._frameTime = n);
  }, e.getFrameTimestamp = function() {
    return this._frameTime || 0;
  }, e.checkAndDraw = function(n) {
    var s = this;
    this._toRedraw = !1;
    for (var o = arguments.length, a = new Array(o > 1 ? o - 1 : 0), l = 1; l < o; l++)
      a[l - 1] = arguments[l];
    if (this.checkResources) {
      var h = this.checkResources();
      h.length > 0 ? (this._loadingResource = !0, this.loadResources(h).then(function() {
        if (s._loadingResource = !1, s.layer) {
          s.layer.fire("resourceload");
          var u = s.layer.getMap();
          s.setToRedraw(), u.getRenderer().callInNextFrame(function() {
            s.setToRedraw();
          });
        }
      })) : n.call.apply(n, [this].concat(a));
    } else
      n.call.apply(n, [this].concat(a));
  }, e.testIfNeedRedraw = function() {
    var n = this.getMap();
    return this._loadingResource ? !1 : this._toRedraw ? !0 : n.isInteracting() && !this.drawOnInteracting ? !1 : !!this.needToRedraw();
  }, e.needToRedraw = function() {
    var n = this.getMap();
    return n.isInteracting() || n.getRenderer().isViewChanged() ? !(!n.getPitch() && n.isMoving() && !n.isZooming() && !n.isRotating() && !this.layer.options.forceRenderOnMoving) : !1;
  }, e.onSkipDrawOnInteracting = function() {
  }, e.isLoadingResource = function() {
    return this._loadingResource;
  }, e.isRenderComplete = function() {
    return !!this._renderComplete;
  }, e.mustRenderOnInteracting = function() {
    return !this._painted;
  }, e.setToRedraw = function() {
    return this._toRedraw = !0, this;
  }, e.setCanvasUpdated = function() {
    return this._canvasUpdated = !0, this;
  }, e.isCanvasUpdated = function() {
    return !!this._canvasUpdated;
  }, e.remove = function() {
    this.onRemove(), delete this._loadingResource, delete this.middleWest, delete this.canvas, delete this.context, delete this.canvasExtent2D, delete this._extent2D, this.resources && this.resources.remove(), delete this.resources, this._resWorkerConn && (this._resWorkerConn.remove(), delete this._resWorkerConn), delete this.layer;
  }, e.onRemove = function() {
  }, e.onAdd = function() {
  }, e.getMap = function() {
    return this.layer ? this.layer.getMap() : null;
  }, e.getCanvasImage = function() {
    var n = this.getMap();
    if (this._canvasUpdated = !1, this._renderZoom !== n.getZoom() || !this.canvas || !this._extent2D || this.isBlank() || this.layer.isEmpty && this.layer.isEmpty())
      return null;
    var s = n._pointToContainerPoint(this.middleWest)._add(0, -n.height / 2);
    return {
      image: this.canvas,
      layer: this.layer,
      point: s
    };
  }, e.clear = function() {
    this.clearCanvas();
  }, e.isBlank = function() {
    return !this._painted;
  }, e.show = function() {
    this.setToRedraw();
  }, e.hide = function() {
    this.clear(), this.setToRedraw();
  }, e.setZIndex = function() {
    this.setToRedraw();
  }, e.hitDetect = function(n) {
    if (!this.context || this.layer.isEmpty && this.layer.isEmpty() || this.isBlank() || this._errorThrown || this.layer.isVisible && !this.layer.isVisible())
      return !1;
    var s = this.getMap(), o = s.getDevicePixelRatio(), a = s.getSize();
    if (n.x < 0 || n.x > a.width * o || n.y < 0 || n.y > a.height * o)
      return !1;
    var l = this.getImageData && this.getImageData();
    if (l) {
      var h = Math.round(o * n.x), u = Math.round(o * n.y), c = u * l.width * 4 + h * 4;
      return l.data[c + 3] > 0;
    }
    try {
      var f = this.context.getImageData(o * n.x, o * n.y, 1, 1).data;
      if (f[3] > 0)
        return !0;
    } catch (d) {
      return this._errorThrown || (console && console.warn(`hit detect failed with tainted canvas, some geometries have external resources in another domain:
`, d), this._errorThrown = !0), !1;
    }
    return !1;
  }, e.loadResources = function(n) {
    this.resources || (this.resources = new Bo());
    var s = this.resources, o = [];
    if (sn(n))
      for (var a = {}, l = n.length - 1; l >= 0; l--) {
        var h = n[l];
        !h || !h.length || a[h.join("-")] || (a[h.join("-")] = 1, s.isResourceLoaded(h, !0) || o.push(new ru(this._promiseResource(h))));
      }
    return ru.all(o);
  }, e.prepareRender = function() {
    delete this._renderComplete;
    var n = this.getMap();
    this._renderZoom = n.getZoom(), this.canvasExtent2D = this._extent2D = n._get2DExtent(), this.middleWest = n._containerPointToPoint(new Y(0, n.height / 2));
  }, e.createCanvas = function() {
    if (!this.canvas) {
      var n = this.getMap(), s = n.getSize(), o = n.getDevicePixelRatio(), a = Math.round(o * s.width), l = Math.round(o * s.height);
      if (this.layer._canvas) {
        var h = this.layer._canvas;
        h.width = a, h.height = l, h.style && (h.style.width = s.width + "px", h.style.height = s.height + "px"), this.canvas = this.layer._canvas;
      } else
        this.canvas = Ct.createCanvas(a, l, n.CanvasClass);
      this.onCanvasCreate();
    }
  }, e.onCanvasCreate = function() {
  }, e.createContext = function() {
    if (!(this.gl && this.gl.canvas === this.canvas || this.context) && (this.context = Ct.getCanvas2DContext(this.canvas), !!this.context)) {
      this.layer.options.globalCompositeOperation && (this.context.globalCompositeOperation = this.layer.options.globalCompositeOperation);
      var n = this.getMap().getDevicePixelRatio();
      n !== 1 && this.context.scale(n, n);
    }
  }, e.resetCanvasTransform = function() {
    if (this.context) {
      var n = this.getMap().getDevicePixelRatio();
      this.context.setTransform(n, 0, 0, n, 0, 0);
    }
  }, e.resizeCanvas = function(n) {
    var s = this.canvas;
    if (s) {
      var o = n || this.getMap().getSize(), a = this.getMap().getDevicePixelRatio(), l = cv(o, a), h = l.width, u = l.height, c = l.cssWidth, f = l.cssHeight;
      this.layer._canvas && (s.style.width !== c || s.style.height !== f) && (s.style.width = c, s.style.height = f), !(s.width === h && s.height === u) && (s.height = u, s.width = h, a !== 1 && this.context && this.context.scale(a, a));
    }
  }, e.clearCanvas = function() {
    if (!(!this.context || !this.getMap())) {
      var n = this.getMap().getDevicePixelRatio(), s = 1 / n, o = this.canvas.width * s, a = this.canvas.height * s;
      Ct.clearRect(this.context, 0, 0, Math.max(o, this.canvas.width), Math.max(a, this.canvas.height));
    }
  }, e.prepareCanvas = function() {
    this.canvas ? (this.resetCanvasTransform(), this.clearCanvas(), this.resizeCanvas()) : (this.createCanvas(), this.createContext(), this.layer.onCanvasCreate(), this.layer.fire("canvascreate", {
      context: this.context,
      gl: this.gl
    })), delete this._maskExtent;
    var n = this.layer.getMask();
    if (!n)
      return this.layer.fire("renderstart", {
        context: this.context,
        gl: this.gl
      }), null;
    var s = this._maskExtent = n._getMaskPainter().get2DExtent();
    return s.intersects(this._extent2D) ? (this.layer.fire("renderstart", {
      context: this.context,
      gl: this.gl
    }), s) : (this.layer.fire("renderstart", {
      context: this.context,
      gl: this.gl
    }), s);
  }, e.clipCanvas = function(n) {
    var s = this.layer.getMask();
    if (!s)
      return !1;
    var o = this.middleWest, a = this.getMap();
    this.middleWest = a._containerPointToPoint(new Y(0, a.height / 2)), n.save();
    var l = a.getDevicePixelRatio();
    if (l !== 1 && (n.save(), n.scale(l, l)), s.getGeometries) {
      n.isMultiClip = !0;
      var h = s.getGeometries() || [];
      n.beginPath(), h.forEach(function(c) {
        var f = c._getMaskPainter();
        f.paint(null, n);
      }), n.stroke(), n.isMultiClip = !1;
    } else {
      n.isClip = !0, n.beginPath();
      var u = s._getMaskPainter();
      u.paint(null, n), n.isClip = !1;
    }
    return l !== 1 && n.restore(), n.clip(), this.middleWest = o, !0;
  }, e.getViewExtent = function() {
    return {
      extent: this._extent2D,
      maskExtent: this._maskExtent,
      zoom: this._renderZoom,
      middleWest: this.middleWest
    };
  }, e.completeRender = function() {
    this.getMap() && (this._renderComplete = !0, this.layer.fire("renderend", {
      context: this.context,
      gl: this.gl
    }), this.setCanvasUpdated());
  }, e.getEvents = function() {
    return {
      _zoomstart: this.onZoomStart,
      _zooming: this.onZooming,
      _zoomend: this.onZoomEnd,
      _resize: this.onResize,
      _movestart: this.onMoveStart,
      _moving: this.onMoving,
      _moveend: this.onMoveEnd,
      _dragrotatestart: this.onDragRotateStart,
      _dragrotating: this.onDragRotating,
      _dragrotateend: this.onDragRotateEnd,
      _spatialreferencechange: this.onSpatialReferenceChange
    };
  }, e.onZoomStart = function() {
  }, e.onZoomEnd = function() {
    this.setToRedraw();
  }, e.onZooming = function() {
  }, e.onMoveStart = function() {
  }, e.onMoving = function() {
  }, e.onMoveEnd = function() {
    this.setToRedraw();
  }, e.onResize = function() {
    delete this._extent2D, this.resizeCanvas(), this.setToRedraw();
  }, e.onDragRotateStart = function() {
  }, e.onDragRotating = function() {
  }, e.onDragRotateEnd = function() {
    this.setToRedraw();
  }, e.onSpatialReferenceChange = function() {
  }, e.getDrawTime = function() {
    return this._drawTime;
  }, e._tryToDraw = function(n) {
    if (this._toRedraw = !1, !this.canvas && this.layer.isEmpty && this.layer.isEmpty()) {
      this._renderComplete = !0;
      return;
    }
    this._drawAndRecord(n);
  }, e._drawAndRecord = function(n) {
    if (this.getMap()) {
      var s = this._painted;
      this._painted = !0;
      var o = Je();
      this.draw(n), o = Je() - o, this._drawTime = s ? o : o / 2, s && this.layer && this.layer.options.logDrawTime && console.log(this.layer.getId(), "frameTimeStamp:", n, "drawTime:", this._drawTime);
    }
  }, e._promiseResource = function(n) {
    var s = this.layer, o = this, a = this.resources, l = s.options.crossOrigin, h = s.options.renderer || "";
    return function(u) {
      if (a.isResourceLoaded(n, !0)) {
        u(n);
        return;
      }
      var c = !Io(n[0]) && o._resWorkerConn && (s.options.renderer !== "canvas" || s.options.decodeImageInWorker);
      if (c) {
        var f = Md(n[0]);
        o._resWorkerConn.fetchImage(f, function(p, g) {
          if (p) {
            p && typeof console < "u" && console.warn(p), u(n);
            return;
          }
          uv(g, function(m) {
            o._cacheResource(n, m), u(n);
          });
        });
      } else {
        var d = new Image();
        W(l) ? h !== "canvas" && (d.crossOrigin = "") : d.crossOrigin = l, Io(n[0]) && !tr && (n[1] && (n[1] *= 2), n[2] && (n[2] *= 2)), d.onload = function() {
          o._cacheResource(n, d), u(n);
        }, d.onabort = function(p) {
          console && console.warn("image loading aborted: " + n[0]), p && console && console.warn(p), u(n);
        }, d.onerror = function(p) {
          p && typeof console < "u" && console.warn(p), a.markErrorResource(n), u(n);
        }, Qh(d, n);
      }
    };
  }, e._cacheResource = function(n, s) {
    if (!(!this.layer || !this.resources)) {
      var o = n[1], a = n[2];
      if (this.layer.options.cacheSvgOnCanvas && Io(n[0]) === 1 && (Ce.edge || Ce.ie)) {
        W(o) && (o = s.width || this.layer.options.defaultIconSize[0]), W(a) && (a = s.height || this.layer.options.defaultIconSize[1]);
        var l = Ct.createCanvas(o, a);
        Ct.image(l.getContext("2d"), s, 0, 0, o, a), s = l;
      }
      this.resources.addResource(n, s);
    }
  }, t;
}(pi), Bo = function() {
  function i() {
    this.resources = {}, this._errors = {};
  }
  var t = i.prototype;
  return t.addResource = function(r, n) {
    var s = this;
    if (this.resources[r[0]] = {
      image: n,
      width: +r[1],
      height: +r[2],
      refCnt: 0
    }, n && n.width && n.height && !n.close && Ce.imageBitMap && !Ce.safari && !Ce.iosWeixin) {
      if (n.src && Io(n.src))
        return;
      createImageBitmap(n).then(function(o) {
        s.resources[r[0]] && (s.resources[r[0]].image = o);
      });
    }
  }, t.isResourceLoaded = function(r, n) {
    if (!r)
      return !1;
    var s = this._getImgUrl(r);
    if (this._errors[s])
      return !0;
    var o = this.resources[s];
    return !(!o || n && Io(r[0]) && (+r[1] > o.width || +r[2] > o.height));
  }, t.login = function(r) {
    var n = this.resources[r];
    n && n.refCnt++;
  }, t.logout = function(r) {
    var n = this.resources[r];
    n && n.refCnt-- <= 0 && (n.image && n.image.close && n.image.close(), delete this.resources[r]);
  }, t.getImage = function(r) {
    var n = this._getImgUrl(r);
    return !this.isResourceLoaded(r) || this._errors[n] ? null : this.resources[n].image;
  }, t.markErrorResource = function(r) {
    this._errors[this._getImgUrl(r)] = 1;
  }, t.merge = function(r) {
    if (!r)
      return this;
    for (var n in r.resources) {
      var s = r.resources[n];
      this.addResource([n, s.width, s.height], s.image);
    }
    return this;
  }, t.forEach = function(r) {
    if (!this.resources)
      return this;
    for (var n in this.resources)
      Fl(this.resources, n) && r(n, this.resources[n]);
    return this;
  }, t._getImgUrl = function(r) {
    return Array.isArray(r) ? r[0] : r;
  }, t.remove = function() {
    for (var r in this.resources) {
      var n = this.resources[r];
      n && n.image && n.image.close && n.image.close();
    }
    this.resources = {};
  }, i;
}(), s5 = `
function (exports) {
    exports.onmessage = function (msg, postResponse) {
        var url = msg.data.url;
        var fetchOptions = msg.data.fetchOptions;
        requestImageOffscreen(url, function (err, data) {
            var buffers = [];
            if (data && data.data) {
                buffers.push(data.data);
            }
            postResponse(err, data, buffers);
        }, fetchOptions);
    };

    function requestImageOffscreen(url, cb, fetchOptions) {
        fetch(url, fetchOptions ? fetchOptions : {})
            .then(response => response.arrayBuffer())
            .then(arrayBuffer => {
                const blob=new Blob([arrayBuffer]);
                return createImageBitmap(blob);
            })
            .then(bitmap => {
                cb(null, {data:bitmap});
            }).catch(err => {
                console.warn('error when loading tile:', url);
                console.warn(err);
                cb(err);
            });
    }
}`;
function o5() {
  Ce.decodeImageInWorker && il(wv, function() {
    return s5;
  });
}
o5();
var ol = {
  markerWidth: 10,
  markerHeight: 10,
  markerLineWidth: 1
}, Np = new Y(0, 0);
function a5(i) {
  if (!i)
    return 0;
  var t = i.x, e = i.y;
  if (t === 0 && e === 0)
    return 0;
  if (t === 0 || !t) {
    if (e < 0)
      return -Math.PI / 2;
    if (e > 0)
      return Math.PI / 2;
  }
  var r = e / t;
  return e < 0 && t < 0 ? Math.atan(r) - Math.PI : e > 0 && t < 0 ? Math.atan(r) + Math.PI : Math.atan(r);
}
function l5(i, t, e) {
  var r = Math.PI / 2 + e, n = Math.PI / 4 + e, s = e, o = t, a = Math.sqrt(i * i + t * t), l = i, h = 0, u = 0, c = Math.cos(r) * o, f = Math.sin(r) * o, d = Math.cos(n) * a, p = Math.sin(n) * a, g = Math.cos(s) * l, m = Math.sin(s) * l, v = Math.min(c, d, g, h), _ = Math.min(f, p, m, u), y = Math.max(c, d, g, h), x = Math.max(f, p, m, u);
  return [v, _, y - v, x - _];
}
function su(i, t, e, r, n, s) {
  var o = n.x + s.x, a = n.y + s.y;
  Np.x = o, Np.y = a;
  var l = a5(Np), h = Math.sqrt(o * o + a * a), u = Math.cos(t + l) * h, c = Math.sin(t + l) * h, f = 0, d = 0;
  f += u, d += c;
  var p = l5(e, r, t), g = p[0], m = p[1], v = p[2], _ = p[3];
  f += g, d += m;
  var y = f + Math.max(e, v), x = d + Math.max(r, _);
  return i.set(f, d, y, x), i;
}
function OT() {
  return 0.5;
}
var h5 = new Y(0, 0);
function Pv(i, t, e, r, n, s, o) {
  var a = h5.set(t, e);
  if (r)
    return su(i, r, s, o, a, n);
  var l = i.set(a.x, a.y, a.x + s, a.y + o);
  return l._add(n), r && c5(l, r), l;
}
var u5 = [];
function kT(i, t, e) {
  if (e = e || Ym(u5, t), e && (e[0] === 0 || e[1] === 0))
    return kv(i), i;
  var r = DT(t, e[0], e[1]);
  return Pv(i, t.markerDx || 0, t.markerDy || 0, Dd(t), r, e[0], e[1]);
}
function RT(i) {
  return i === "rectangle" ? "right" : "middle";
}
function IT(i) {
  return i === "bar" || i === "pie" || i === "pin" ? "top" : i === "rectangle" ? "bottom" : "middle";
}
var al = new zn(0, 0);
function DT(i, t, e) {
  var r = OT(), n = 2 * (i.shadowBlur || 0), s = n + r;
  al.width = t, al.height = e;
  var o = i.markerType, a = Es(al, i.markerHorizontalAlignment || RT(o), i.markerVerticalAlignment || IT(o));
  return a.x !== -t / 2 && (a.x -= Ar(a.x + t / 2) * s), a.y !== -e / 2 && (a.y -= Ar(a.y + e / 2) * s), a;
}
function Ym(i, t) {
  var e = OT(), r = ae(t.markerWidth, ol.markerWidth), n = ae(t.markerHeight, ol.markerHeight);
  if (r === 0 || n === 0)
    return i[0] = 0, i[1] = 0, i;
  var s = ae(t.markerLineWidth, ol.markerLineWidth), o = 2 * ((t.shadowBlur || 0) + Math.max(Math.abs(t.shadowOffsetX || 0) + Math.abs(t.shadowOffsetY || 0))), a = Math.round(r + s + o + e * 2), l = Math.round(n + s + o + e * 2);
  return i[0] = a, i[1] = l, i;
}
var D1 = new Se();
function c5(i, t) {
  var e = i.xmin, r = i.ymin, n = i.xmax, s = i.ymax;
  return D1.set(e, r, n, s), D1.convertTo(function(o) {
    return o._rotate(t);
  }, i);
}
function Dd(i, t) {
  t === void 0 && (t = "markerRotation");
  var e = i[t];
  return Ut(e) ? -e * Math.PI / 180 : 0;
}
function Jm(i, t, e) {
  var r = t.markerFile, n = e ? e.getImage(r) : null, s = t.markerWidth || (n ? n.width : 0), o = t.markerHeight || (n ? n.height : 0);
  if (al.width = s, al.height = o, t.markerWidth === 0 || t.markerHeight === 0)
    return kv(i), i;
  var a = Es(al, t.markerHorizontalAlignment || "middle", t.markerVerticalAlignment || "top");
  return Pv(i, t.markerDx || 0, t.markerDy || 0, Dd(t), a, s, o);
}
function FT(i, t, e) {
  var r = e.size;
  if (r && (r.width === 0 || r.height === 0))
    return kv(i), i;
  var n = Es(r, t.textHorizontalAlignment, t.textVerticalAlignment), s = t.textHaloRadius || 0, o = Pv(i, t.textDx || 0, t.textDy || 0, Dd(t, "textRotation"), n, r.width, r.height);
  return o.xmin -= s, o.xmax += s, o.ymin -= s, o.ymax += s, o;
}
var ec = new Se();
function Km(i, t, e, r) {
  var n = i || new Se();
  if (Array.isArray(t)) {
    for (var s = t, o = 0; o < s.length; o++)
      Km(n, s[o], e, r[o]);
    return n;
  }
  return Kf(t) && n._combine(FT(ec, t, r)), Ev(t) && n._combine(Jm(ec, t, e)), Qf(t) && n._combine(kT(ec, t)), Ov(t) && n._combine(Jm(ec, t)), n;
}
function Kf(i) {
  return i ? !W(i.textName) : !1;
}
function Ev(i) {
  return i ? !W(i.markerFile) : !1;
}
function Qf(i) {
  return i ? !!(W(i.markerFile) && !W(i.markerType) && i.markerType !== "path") : !1;
}
function Ov(i) {
  return i ? !!(W(i.markerFile) && i.markerType === "path") : !1;
}
var Hp = ["markerWidth", "markerHeight", "markerHorizontalAlignment", "markerVerticalAlignment", "markerDx", "markerDy", "markerRotation", "textName", "textSize", "textDx", "textDy", "textVerticalAlignment", "textHorizontalAlignment", "textRotation", "textWrapWidth"], Bp = ["textName", "markerType", "markerFile", "textHaloRadius", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textWrapWidth"];
function kv(i) {
  i && (i.xmin = 1 / 0, i.ymin = 1 / 0, i.xmax = -1 / 0, i.ymax = -1 / 0);
}
function mf(i, t, e, r) {
  for (var n = [], s = 0, o, a = 0, l = i.length; a < l - 1; a++)
    o = f5(i[a], i[a + 1], t, a, e, r), o && (n[s] = n[s] || [], n[s].push({
      point: o[0],
      index: a
    }), (o[1] !== i[a + 1] || a === l - 2) && (n[s].push({
      point: o[1],
      index: a + 1
    }), s++));
  return n;
}
var F1;
function f5(i, t, e, r, n, s) {
  var o = r ? F1 : ll(i, e), a = ll(t, e), l, h, u;
  for (F1 = a; ; ) {
    if (!(o | a))
      return [i, t];
    if (o & a)
      return !1;
    if (s)
      return [i, t];
    l = o || a, h = Qm(i, t, l, e, n), u = ll(h, e), l === o ? (i = h, o = u) : (t = h, a = u);
  }
}
function vf(i, t, e) {
  var r = [1, 4, 2, 8], n, s, o, a, l, h, u, c, f;
  for (s = 0, u = i.length; s < u; s++)
    i[s]._code = ll(i[s], t);
  for (a = 0; a < 4; a++) {
    for (c = r[a], n = [], s = 0, u = i.length, o = u - 1; s < u; o = s++)
      l = i[s], h = i[o], l._code & c ? h._code & c || (f = Qm(h, l, c, t, e), f._code = ll(f, t), n.push(f)) : (h._code & c && (f = Qm(h, l, c, t, e), f._code = ll(f, t), n.push(f)), n.push(l));
    i = n;
  }
  return i;
}
function Qm(i, t, e, r, n) {
  var s = t.x - i.x, o = t.y - i.y, a = r.getMin(), l = r.getMax(), h, u;
  e & 8 ? (h = i.x + s * (l.y - i.y) / o, u = l.y) : e & 4 ? (h = i.x + s * (a.y - i.y) / o, u = a.y) : e & 2 ? (h = l.x, u = i.y + o * (l.x - i.x) / s) : e & 1 && (h = a.x, u = i.y + o * (a.x - i.x) / s);
  var c = new Y(h, u);
  return n && c._round(), c;
}
function ll(i, t) {
  var e = 0;
  return i.x < t.getMin().x ? e |= 1 : i.x > t.getMax().x && (e |= 2), i.y < t.getMin().y ? e |= 4 : i.y > t.getMax().y && (e |= 8), e;
}
function LT(i, t, e, r) {
  i = new Y(i);
  var n = Math.abs(e.x - t.x), s = Math.abs(e.y - t.y), o = Math.sqrt(Math.abs(n * n - s * s)), a = n >= s, l, h, u;
  return a ? (l = new Y(t.x - o, t.y), h = new Y(t.x + o, t.y), u = n * 2) : (l = new Y(t.x, t.y - o), h = new Y(t.x, t.y + o), u = s * 2), i.distanceTo(l) + i.distanceTo(h) <= u + 2 * r;
}
var d5 = function() {
  function i() {
    this.bbox = Jo();
  }
  var t = i.prototype;
  return t._setBBOX = function(r, n, s, o, a) {
    return r.isHitTesting || Rd(this.bbox, n, s, o, a), this;
  }, t._bufferBBOX = function(r, n) {
    return n === void 0 && (n = 0), r.isHitTesting || wT(this.bbox, n), this;
  }, t.getMap = function() {
    return this.geometry.getMap();
  }, t.getPainter = function() {
    return this.painter;
  }, t.isDynamicSize = function() {
    return !1;
  }, i.testColor = function(r) {
    return !r || !De(r) ? !1 : m3.indexOf(r) >= 0;
  }, i;
}(), zT = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e._prepareContext = function(n) {
    if (_n(this.symbol.opacity) ? this._opacityFn || (this._opacityFn = Gf(this.symbol.opacity)) : delete this._opacityFn, Ut(this.symbol.opacity))
      n.globalAlpha !== this.symbol.opacity && (n.globalAlpha = this.symbol.opacity);
    else if (this._opacityFn) {
      var s = this.getMap();
      n.globalAlpha = this._opacityFn(s.getZoom());
    } else n.globalAlpha !== 1 && (n.globalAlpha = 1);
  }, e.prepareCanvas = function(n, s, o) {
    n.setLineDash && sn(s.lineDasharray) && n.setLineDash(s.lineDasharray);
    var a = this.getPainter().isHitTesting();
    Ct.prepareCanvas(n, s, o, a);
  }, e.remove = function() {
  }, e.setZIndex = function() {
  }, e.show = function() {
  }, e.hide = function() {
  }, e._defineStyle = function(n) {
    return Vf(n, this.geometry);
  }, t;
}(d5);
function p5(i, t) {
  var e = i && i.getImage(t);
  return e || null;
}
function NT(i, t, e, r) {
  var n = HT(e), s = e, o = s.markerType.toLowerCase(), a = BT(o, s.markerWidth, s.markerHeight), l = n.lineOpacity, h = n.polygonOpacity, u = Os(n.polygonFill);
  if (u) {
    var c;
    Os(n.polygonFill) && (c || (c = g5(t, s.markerWidth, s.markerHeight)), n.polygonGradientExtent = c);
  }
  Ct.prepareCanvas(i, n, r);
  var f = s.markerWidth, d = s.markerHeight, p = s.markerLineWidth / 2;
  if (o === "ellipse")
    Ct.ellipse(i, t, f / 2, d / 2, d / 2, l, h);
  else if (o === "cross" || o === "x") {
    for (var g = a.length - 1; g >= 0; g--)
      a[g]._add(t);
    Ct.path(i, a.slice(0, 2), l), Ct.path(i, a.slice(2, 4), l);
  } else if (o === "diamond" || o === "bar" || o === "square" || o === "rectangle" || o === "triangle") {
    o === "bar" ? t = t.add(0, -p) : o === "rectangle" && (t = t.add(p, p));
    for (var m = a.length - 1; m >= 0; m--)
      a[m]._add(t);
    Ct.polygon(i, a, l, h);
  } else if (o === "pin") {
    t = t.add(0, -p);
    for (var v = a.length - 1; v >= 0; v--)
      a[v]._add(t);
    var _ = i.lineCap;
    i.lineCap = "round", Ct.bezierCurveAndFill(i, a, l, h), i.lineCap = _;
  } else if (o === "pie") {
    t = t.add(0, -p);
    var y = Math.atan(f / 2 / d) * 180 / Math.PI, x = i.lineCap;
    i.lineCap = "round", Ct.sector(i, t, d, [90 - y, 90 + y], l, h), i.lineCap = x;
  } else
    throw new Error("unsupported markerType: " + o);
  return i.canvas;
}
function g5(i, t, e) {
  var r = new Se();
  return r._combine(i), r.xmin += -t / 2, r.ymin += -e / 2, r.xmax += t / 2, r.ymax += e / 2, r;
}
function HT(i) {
  var t = {
    lineColor: i.markerLineColor,
    linePatternFile: i.markerLinePatternFile,
    lineWidth: i.markerLineWidth,
    lineOpacity: i.markerLineOpacity,
    lineDasharray: i.markerLineDasharray,
    lineCap: "butt",
    lineJoin: "round",
    polygonFill: i.markerFill,
    polygonPatternFile: i.markerFillPatternFile,
    polygonOpacity: i.markerFillOpacity
  };
  return t.lineWidth === 0 && (t.lineOpacity = 0), t;
}
function BT(i, t, e) {
  var r = e / 2, n = t / 2, s = 0, o = 0, a, l, h, u;
  if (i === "triangle")
    return a = new Y(s, o - r), l = new Y(s - n, o + r), h = new Y(s + n, o + r), [a, l, h];
  if (i === "cross")
    return a = new Y(s - n, o), l = new Y(s + n, o), h = new Y(s, o - r), u = new Y(s, o + r), [a, l, h, u];
  if (i === "diamond")
    return a = new Y(s - n, o), l = new Y(s, o - r), h = new Y(s + n, o), u = new Y(s, o + r), [a, l, h, u];
  if (i === "square")
    return a = new Y(s - n, o + r), l = new Y(s + n, o + r), h = new Y(s + n, o - r), u = new Y(s - n, o - r), [a, l, h, u];
  if (i === "rectangle")
    return a = new Y(s, o), l = a.add(t, 0), h = a.add(t, e), u = a.add(0, e), [a, l, h, u];
  if (i === "x")
    return a = new Y(s - n, o + r), l = new Y(s + n, o - r), h = new Y(s + n, o + r), u = new Y(s - n, o - r), [a, l, h, u];
  if (i === "bar")
    return a = new Y(s - n, o - e), l = new Y(s + n, o - e), h = new Y(s + n, o), u = new Y(s - n, o), [a, l, h, u];
  if (i === "pin" || i === "pie") {
    var c = e * Math.atan(n / r);
    return a = new Y(s, o), l = new Y(s - c, o - e), h = new Y(s + c, o - e), u = new Y(s, o), [a, l, h, u];
  }
  return [];
}
var m5 = new Y(0, 0), v5 = new Y(0, 0), y5 = new Y(0, 0), _5 = new Y(0, 0), zl = function(i) {
  Ot(t, i);
  function t(r, n, s) {
    var o;
    return o = i.call(this) || this, o.symbol = r, o.geometry = n, o.painter = s, o;
  }
  var e = t.prototype;
  return e.get2DExtent = function() {
    for (var n = this.getMap(), s = n.getGLRes(), o = new Se(), a = this._getRenderPoints()[0], l = a.length - 1; l >= 0; l--)
      a[l] && o._combine(n._pointAtResToPoint(a[l], s));
    return o;
  }, e.isDynamicSize = function() {
    var n = this.symbol;
    return _n(n.markerWidth) || _n(n.markerHeight) || _n(n.textSize);
  }, e._rotateExtent = function(n, s) {
    return n.convertTo(function(o) {
      return o._rotate(s);
    });
  }, e._getRenderPoints = function() {
    var n = this.getPainter(), s = n.isSpriting() ? "center" : this.getPlacement();
    return this.getPainter().getRenderPoints(s);
  }, e._getRenderContainerPoints = function(n) {
    var s = this.getPainter();
    if (s.isSpriting())
      return this._getRenderPoints()[0];
    var o = this.geometry, a = this.getDxDy(), l;
    if (o._cPoint && !n) {
      var h = n ? y5 : _5;
      h.set(o._cPoint.x, o._cPoint.y);
      var u = s.containerOffset;
      h._sub(u);
      var c = a.x, f = a.y;
      (c || f) && h._add(c || 0, f || 0), l = [h];
    } else {
      var d = this._getRenderPoints()[0];
      l = this.painter._pointContainerPoints(d, a.x, a.y, n, !0, this.getPlacement());
    }
    if (!l || !Array.isArray(l[0]))
      return l;
    for (var p = [], g = 0, m = l.length; g < m; g++)
      for (var v = 0, _ = l[g].length; v < _; v++)
        p.push(l[g][v]);
    return p;
  }, e.getPlacement = function() {
    return this.symbol.markerPlacement;
  }, e.getRotation = function() {
    return Dd(this.style);
  }, e.getDxDy = function() {
    var n = this.style, s = n.markerDx, o = n.markerDy;
    return new Y(s, o);
  }, e._getRotationAt = function(n) {
    var s = this.getRotation();
    s || (s = 0);
    var o = this._getRenderPoints()[1];
    if (!o || !o[n])
      return s;
    var a = this.getMap(), l = o[n][0], h = o[n][1];
    if (a.isTransforming()) {
      var u = a.getGLRes();
      return l = a._pointAtResToContainerPoint(o[n][0], u, 0, m5), h = a._pointAtResToContainerPoint(o[n][1], u, 0, v5), s + Bf(l.x, l.y, h.x, h.y);
    } else
      return s + -Bf(l.x, l.y, h.x, h.y);
  }, e._rotate = function(n, s, o) {
    if (o) {
      var a = this.getDxDy(), l = s.sub(a);
      return n.save(), n.translate(l.x, l.y), n.rotate(o), a;
    }
    return null;
  }, t;
}(zT), x5 = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.getPlacement = function() {
    return "point";
  }, e.getDxDy = function() {
    return new Y(0, 0);
  }, e.symbolize = function(n) {
    var s = this.geometry, o = s.getLayer();
    if (!(!s.options.debug && o && !o.options.debug)) {
      var a = this.getMap();
      if (!(!a || a.isZooming())) {
        var l = o.options.debugOutline, h = 1;
        n.strokeStyle = l, n.fillStyle = l, n.lineWidth = 1, n.font = "18px  serif";
        var u = s.getContainerExtent().toArray();
        Ct.polygon(n, [u], h, 0);
        for (var c = this._getRenderContainerPoints(), f = this.geometry.getId(), d = BT("cross", 10, 10), p = 0; p < c.length; p++) {
          var g = c[p];
          W(f) || Ct.fillText(n, f, g.add(8, -4), l);
          for (var m = [], v = 0; v < d.length; v++)
            m.push(d[v].add(g));
          Ct.path(n, m.slice(0, 2), h), Ct.path(n, m.slice(2, 4), h);
        }
      }
    }
  }, t;
}(zl), jp = new zn(1, 1), b5 = new Se(), Rv = function(i) {
  Ot(t, i), t.test = function(n) {
    return Ev(n);
  };
  function t(r, n, s) {
    var o;
    return o = i.call(this, r, n, s) || this, o.style = o._defineStyle(o.translate()), o;
  }
  var e = t.prototype;
  return e.symbolize = function(n, s) {
    var o = this.style;
    if (!(!this.painter.isHitTesting() && (o.markerWidth === 0 || o.markerHeight === 0 || o.markerOpacity === 0))) {
      var a = this._getRenderContainerPoints();
      if (sn(a)) {
        var l = this._getImage(s);
        if (!l) {
          typeof console < "u" && console.warn("no img found for " + (this.style.markerFile || this._url[0]));
          return;
        }
        this._prepareContext(n);
        var h = o.markerWidth, u = o.markerHeight;
        if (!Ut(h) || !Ut(u)) {
          h = l.width, u = l.height, o.markerWidth = h, o.markerHeight = u;
          var c = o.markerFile;
          s.isResourceLoaded(c) || s.addResource(c, l);
          var f = this.getPainter();
          f.isSpriting() || f.removeCache();
        }
        var d;
        this.symbol.markerType !== "path" && Ut(o.markerOpacity) && o.markerOpacity < 1 && (d = n.globalAlpha, n.globalAlpha *= o.markerOpacity), jp.width = h, jp.height = u;
        for (var p = Es(jp, o.markerHorizontalAlignment, o.markerVerticalAlignment), g = 0, m = a.length; g < m; g++) {
          var v = a[g], _ = this.getRotation() ? this._rotate(n, v, this._getRotationAt(g)) : null, y = void 0;
          if (_) {
            var x = v.sub(_);
            v = _;
            var w = this._getRotationAt(g);
            y = su(b5, w, h, u, v, p), y._add(x);
          }
          var b = v.x + p.x, T = v.y + p.y;
          Ct.image(n, l, b, T, h, u), _ && n.restore(), _ ? this._setBBOX(n, y.xmin, y.ymin, y.xmax, y.ymax) : this._setBBOX(n, b, T, b + h, T + u);
        }
        d !== void 0 && (n.globalAlpha = d);
      }
    }
  }, e._getImage = function(n) {
    return p5(n, this.style.markerFile);
  }, e.getFixedExtent = function(n) {
    return this._fixedExtent = this._fixedExtent || new Se(), Jm(this._fixedExtent, this.style, n);
  }, e.translate = function() {
    var n = this.symbol;
    return {
      markerFile: n.markerFile,
      markerOpacity: ae(n.markerOpacity, 1),
      markerWidth: ae(n.markerWidth, null),
      markerHeight: ae(n.markerHeight, null),
      markerRotation: ae(n.markerRotation, 0),
      markerDx: ae(n.markerDx, 0),
      markerDy: ae(n.markerDy, 0),
      markerHorizontalAlignment: ae(n.markerHorizontalAlignment, "middle"),
      markerVerticalAlignment: ae(n.markerVerticalAlignment, "top")
    };
  }, t;
}(zl), w5 = new lt(0, 0), T5 = new lt(0, 0), jT = function(i) {
  Ot(t, i), t.test = function(n, s) {
    if (!n || s && s.isPoint)
      return !1;
    for (var o in n) {
      var a = o.slice(0, 4);
      if (a === "line" || a === "poly")
        return !0;
    }
    return !1;
  };
  function t(r, n, s) {
    var o;
    return o = i.call(this) || this, o.symbol = r, o.geometry = n, o.painter = s, n.isPoint ? kn(o) : (o.style = o._defineStyle(o.translate()), o);
  }
  var e = t.prototype;
  return e.symbolize = function(n, s) {
    var o = this.style;
    if (!(o.polygonOpacity === 0 && o.lineOpacity === 0 && !this.painter.isHitTesting())) {
      var a = this._getPaintParams();
      if (a) {
        this._prepareContext(n);
        var l = Os(o.lineColor), h = this.geometry.getJSONType() === "Polygon" || this.geometry.type === "LineString";
        l && (o.lineColor.places || !h) && (o.lineGradientExtent = this.geometry.getContainerExtent()._expand(o.lineWidth)), Os(o.polygonFill) && (o.polygonGradientExtent = this.geometry.getContainerExtent());
        var u = this.geometry.getLayer().options.geometryEventTolerance || 0, c = this.geometry._hitTestTolerance() + u, f = a[0], d = this.geometry.getJSONType() === "Polygon" && f.length > 0 && Array.isArray(f[0][0]) || this.geometry.type === "LineString" && f.length > 0 && Array.isArray(f[0]);
        if (d)
          for (var p = 0; p < f.length; p++) {
            this.prepareCanvas(n, o, s), l && h && !o.lineColor.places && this._createGradient(n, f[p], o.lineColor);
            var g = [n, f[p]];
            a.length > 1 && g.push.apply(g, a.slice(1)), g.push(o.lineOpacity, o.polygonOpacity, o.lineDasharray);
            var m = this.geometry._paintOn.apply(this.geometry, g);
            this._setBBOX(n, m), this._bufferBBOX(n, c);
          }
        else {
          this.prepareCanvas(n, o, s), l && h && !o.lineColor.places && this._createGradient(n, f, o.lineColor);
          var v = [n];
          v.push.apply(v, a), v.push(o.lineOpacity, o.polygonOpacity, o.lineDasharray);
          var _ = this.geometry._paintOn.apply(this.geometry, v);
          this._setBBOX(n, _), this._bufferBBOX(n, c);
        }
        n.setLineDash && Array.isArray(o.lineDasharray) && n.setLineDash([]);
      }
    }
  }, e.get2DExtent = function() {
    var n = this.getMap(), s = this.geometry._getPrjExtent();
    if (!s)
      return null;
    (!this._extMin || !this._extMax) && (this._extMin = new lt(0, 0), this._extMax = new lt(0, 0)), this._extMin.x = s.xmin, this._extMin.y = s.ymin, this._extMax.x = s.xmax, this._extMax.y = s.ymax;
    var o = n._prjToPoint(this._extMin, void 0, w5), a = n._prjToPoint(this._extMax, void 0, T5);
    return this._pxExtent ? this._pxExtent.set(Math.min(o.x, a.x), Math.min(o.y, a.y), Math.max(o.x, a.x), Math.max(o.y, a.y)) : this._pxExtent = new Se(o, a), this._pxExtent;
  }, e.getFixedExtent = function() {
    var n = this.style.lineWidth / 2;
    return new Se(-n, -n, n, n);
  }, e._getPaintParams = function() {
    return this.getPainter().getPaintParams(this.style.lineDx, this.style.lineDy);
  }, e.translate = function() {
    var n = this.symbol, s = {
      lineColor: ae(n.lineColor, "#000"),
      lineWidth: ae(n.lineWidth, 2),
      lineOpacity: ae(n.lineOpacity, 1),
      lineDasharray: ae(n.lineDasharray, []),
      lineCap: ae(n.lineCap, "butt"),
      lineJoin: ae(n.lineJoin, "miter"),
      linePatternFile: ae(n.linePatternFile, null),
      lineDx: ae(n.lineDx, 0),
      lineDy: ae(n.lineDy, 0),
      polygonFill: ae(n.polygonFill, null),
      polygonOpacity: ae(n.polygonOpacity, 1),
      polygonPatternFile: ae(n.polygonPatternFile, null),
      polygonPatternDx: ae(n.polygonPatternDx, 0),
      polygonPatternDy: ae(n.polygonPatternDy, 0),
      linePatternDx: ae(n.linePatternDx, 0),
      linePatternDy: ae(n.linePatternDy, 0)
    };
    return s.lineWidth === 0 && (s.lineOpacity = 0), this.geometry.type === "LineString" && !s.polygonFill && (s.polygonFill = s.lineColor), s;
  }, e._createGradient = function(n, s, o) {
    if (!(!Array.isArray(s) || !s.length)) {
      var a = A5(s), l = a[0], h = a[1];
      if (!l || !h) {
        console.error("unable create canvas LinearGradient,error data:", s);
        return;
      }
      var u = n.createLinearGradient(l.x, l.y, h.x, h.y);
      o.colorStops.forEach(function(c) {
        u.addColorStop.apply(u, c);
      }), n.strokeStyle = u;
    }
  }, t;
}(zT);
function A5(i) {
  var t, e = !0;
  Array.isArray(i[0]) ? (t = i[0], e = !1) : t = i;
  var r = t.length;
  if (e)
    return [t[0], t[r - 1]];
  for (var n = t[0], s = 0, o, a = 1; a < r; a++) {
    var l = t[a], h = n.distanceTo(l);
    h > s && (s = h, o = l);
  }
  return [n, o];
}
var M5 = new Se(), S5 = function(i) {
  Ot(t, i), t.test = function(n) {
    return Kf(n);
  };
  function t(r, n, s) {
    var o;
    o = i.call(this, r, n, s) || this;
    var a = o.translate();
    return o._dynamic = Vw(a), o.style = o._defineStyle(a), o.style.textWrapWidth === 0 ? kn(o) : (o.strokeAndFill = o._defineStyle(o.translateLineAndFill(o.style)), o);
  }
  var e = t.prototype;
  return e.symbolize = function(n, s) {
    if (!(!this.painter.isHitTesting() && (this.style.textSize === 0 || !this.style.textOpacity && (!this.style.textHaloRadius || !this.style.textHaloOpacity) || this.style.textWrapWidth === 0))) {
      var o = this._getRenderContainerPoints();
      if (sn(o)) {
        var a = this.style, l = this.strokeAndFill, h = $f(this.style.textName, this.geometry.getProperties());
        this._dynamic && delete this._textDesc;
        var u = this._textDesc = this._textDesc || Wf(h, this.style);
        this._prepareContext(n), this.prepareCanvas(n, l, s), Ct.prepareCanvasFont(n, a);
        for (var c = a.textHaloRadius || 0, f = 0, d = o.length; f < d; f++) {
          var p = o[f], g = this.getRotation() ? this._rotate(n, p, this._getRotationAt(f)) : null, m = void 0;
          if (g) {
            var v = p.sub(g);
            p = g;
            var _ = this._getRotationAt(f), y = u.size || {
              width: 0,
              height: 0
            }, x = y.width, w = y.height, b = Es(u.size, a.textHorizontalAlignment, a.textVerticalAlignment);
            m = su(M5, _, x, w, p, b), m._add(v);
          }
          var T = Ct.text(n, h, p, a, u);
          g ? (this._setBBOX(n, m.xmin, m.ymin, m.xmax, m.ymax), n.restore()) : this._setBBOX(n, T), this._bufferBBOX(n, c);
        }
      }
    }
  }, e.getPlacement = function() {
    return this.symbol.textPlacement;
  }, e.getRotation = function() {
    var n = this.style.textRotation;
    return Ut(n) ? -n * Math.PI / 180 : null;
  }, e.getDxDy = function() {
    var n = this.style;
    return new Y(n.textDx, n.textDy);
  }, e.getFixedExtent = function() {
    var n = this.geometry.getTextDesc();
    return Array.isArray(n) && (n = n[this._index]), this._fixedExtent = this._fixedExtent || new Se(), n ? FT(this._fixedExtent, this.style, n) : this._fixedExtent;
  }, e.translate = function() {
    var n = this.symbol, s = {
      textName: n.textName,
      textFaceName: ae(n.textFaceName, "monospace"),
      textWeight: ae(n.textWeight, "normal"),
      textStyle: ae(n.textStyle, "normal"),
      textSize: ae(n.textSize, kw),
      textFont: ae(n.textFont, null),
      textFill: ae(n.textFill, "#000"),
      textOpacity: ae(n.textOpacity, 1),
      textHaloFill: ae(n.textHaloFill, "#ffffff"),
      textHaloRadius: ae(n.textHaloRadius, 0),
      textHaloOpacity: ae(n.textHaloOpacity, 1),
      textWrapWidth: ae(n.textWrapWidth, null),
      textWrapCharacter: ae(n.textWrapCharacter, `
`),
      textLineSpacing: ae(n.textLineSpacing, 0),
      textDx: ae(n.textDx, 0),
      textDy: ae(n.textDy, 0),
      textHorizontalAlignment: ae(n.textHorizontalAlignment, "middle"),
      textVerticalAlignment: ae(n.textVerticalAlignment, "middle"),
      textAlign: ae(n.textAlign, "center"),
      textRotation: ae(n.textRotation, 0),
      textMaxWidth: ae(n.textMaxWidth, 0),
      textMaxHeight: ae(n.textMaxHeight, 0)
    };
    return s.textMaxWidth > 0 && (!s.textWrapWidth || s.textWrapWidth > s.textMaxWidth) && (s.textWrapWidth || (s.textMaxHeight = 1), s.textWrapWidth = s.textMaxWidth), s;
  }, e.translateLineAndFill = function(n) {
    return {
      lineColor: n.textHaloRadius ? n.textHaloFill : n.textFill,
      lineWidth: n.textHaloRadius,
      lineOpacity: n.textOpacity,
      lineDasharray: null,
      lineCap: "butt",
      lineJoin: "round",
      polygonFill: n.textFill,
      polygonOpacity: n.textOpacity
    };
  }, t;
}(zl), L1 = [], z1 = new Se(), C5 = new Y(0, 0), GT = function(i) {
  Ot(t, i), t.test = function(n) {
    return Qf(n);
  };
  function t(r, n, s) {
    var o;
    o = i.call(this, r, n, s) || this;
    var a = o.translate();
    return o._dynamic = Vw(a), o.style = o._defineStyle(a), o.strokeAndFill = o._defineStyle(HT(o.style)), o.padding = 0, o;
  }
  var e = t.prototype;
  return e.symbolize = function(n, s) {
    var o = this.style;
    if (!(!this.painter.isHitTesting() && (o.markerWidth === 0 || o.markerHeight === 0 || o.polygonOpacity === 0 && o.lineOpacity === 0))) {
      var a = this._getRenderContainerPoints();
      sn(a) && (this._prepareContext(n), this.getPainter().isSpriting() || this.geometry.getLayer().getMask() === this.geometry || this._dynamic || this.geometry.getLayer().options.cacheVectorOnCanvas === !1 ? this._drawMarkers(n, a, s) : this._drawMarkersWithCache(n, a, s));
    }
  }, e._drawMarkers = function(n, s, o) {
    for (var a = s.length - 1; a >= 0; a--) {
      var l = s[a], h = Ym(L1, this.style), u = h[0], c = h[1], f = void 0, d = this.getRotation() ? this._rotate(n, l, this._getRotationAt(a)) : null;
      if (d) {
        var p = l.sub(d);
        l = d;
        var g = this._getRotationAt(a);
        f = su(z1, g, u, c, l, C5), f._add(p);
      }
      if (this._drawVectorMarker(n, l, o), d)
        n.restore(), this._setBBOX(n, f.xmin, f.ymin, f.xmax, f.ymax);
      else {
        var m = l, v = m.x, _ = m.y;
        this._setBBOX(n, v, _, v + u, _ + c);
      }
    }
  }, e._drawMarkersWithCache = function(n, s, o) {
    var a = this._stampSymbol(), l = o.getImage(a);
    l || (l = this._createMarkerImage(n, o), o.addResource([a, l.width, l.height], l));
    for (var h = DT(this.style, l.width, l.height), u = s.length - 1; u >= 0; u--) {
      var c = s[u], f = this.getRotation() ? this._rotate(n, c, this._getRotationAt(u)) : null, d = void 0;
      if (f) {
        var p = c.sub(f);
        c = f;
        var g = this._getRotationAt(u);
        d = su(z1, g, l.width, l.height, c, h), d._add(p);
      }
      var m = c.x + h.x, v = c.y + h.y;
      Ct.image(n, l, m, v), f ? (n.restore(), this._setBBOX(n, d.xmin, d.ymin, d.xmax, d.ymax)) : this._setBBOX(n, m, v, m + l.width, v + l.height);
    }
  }, e._createMarkerImage = function(n, s) {
    var o = n.canvas.constructor, a = Ym(L1, this.style), l = Ct.createCanvas(a[0], a[1], o), h = this._getCacheImageAnchor(a[0], a[1]), u = l.getContext("2d");
    return this._drawVectorMarker(u, h, s), l;
  }, e._stampSymbol = function() {
    return this._stamp || (this._stamp = _v([this.style.markerType, Os(this.style.markerFill) ? Gm(this.style.markerFill) : this.style.markerFill, this.style.markerFillOpacity, this.style.markerFillPatternFile, Os(this.style.markerLineColor) ? Gm(this.style.markerLineColor) : this.style.markerLineColor, this.style.markerLineWidth, this.style.markerLineOpacity, this.style.markerLineDasharray ? this.style.markerLineDasharray.join(",") : "", this.style.markerLinePatternFile, this.style.markerWidth, this.style.markerHeight, this.style.markerHorizontalAlignment, this.style.markerVerticalAlignment].join("_"))), this._stamp;
  }, e._getCacheImageAnchor = function(n, s) {
    var o = 2 * (this.symbol.shadowBlur || 0), a = o + this.padding, l = this.style.markerType;
    return l === "bar" || l === "pie" || l === "pin" ? new Y(n / 2, s - a) : l === "rectangle" ? new Y(a, a) : new Y(n / 2, s / 2);
  }, e._getGraidentExtent = function(n) {
    var s = new Se(), o = this.getDxDy(), a = this.getFixedExtent();
    if (Array.isArray(n))
      for (var l = n.length - 1; l >= 0; l--)
        s._combine(n[l]);
    else
      s._combine(n);
    return s.xmin += a.xmin - o.x, s.ymin += a.ymin - o.y, s.xmax += a.xmax - o.x, s.ymax += a.ymax - o.y, s;
  }, e._drawVectorMarker = function(n, s, o) {
    NT(n, s, this.style, o);
  }, e.getFixedExtent = function() {
    var n = this.isDynamicSize(), s = this.style.markerWidth, o = this.style.markerHeight;
    return this._fixedExtent = this._fixedExtent || new Se(), kT(this._fixedExtent, this.style, n ? [128, 128 * (s === 0 ? 1 : o / s)] : null);
  }, e.translate = function() {
    var n = this.symbol, s = {
      markerType: ae(n.markerType, "ellipse"),
      markerFill: ae(n.markerFill, "#00f"),
      markerFillOpacity: ae(n.markerFillOpacity, 1),
      markerFillPatternFile: ae(n.markerFillPatternFile, null),
      markerLineColor: ae(n.markerLineColor, "#000"),
      markerLineWidth: ae(n.markerLineWidth, ol.markerLineWidth),
      markerLineOpacity: ae(n.markerLineOpacity, 1),
      markerLineDasharray: ae(n.markerLineDasharray, []),
      markerLinePatternFile: ae(n.markerLinePatternFile, null),
      markerDx: ae(n.markerDx, 0),
      markerDy: ae(n.markerDy, 0),
      markerWidth: ae(n.markerWidth, ol.markerWidth),
      markerHeight: ae(n.markerHeight, ol.markerHeight),
      markerRotation: ae(n.markerRotation, 0),
      shadowBlur: ae(n.shadowBlur, 0),
      shadowOffsetX: ae(n.shadowOffsetX, 0),
      shadowOffsetY: ae(n.shadowOffsetY, 0)
    }, o = s.markerType, a = RT(o), l = IT(o);
    return s.markerHorizontalAlignment = ae(n.markerHorizontalAlignment, a), s.markerVerticalAlignment = ae(n.markerVerticalAlignment, l), Ut(n.markerOpacity) && (Ut(n.markerFillOpacity) && (s.markerFillOpacity *= n.markerOpacity), Ut(n.markerLineOpacity) && (s.markerLineOpacity *= n.markerOpacity)), s;
  }, t;
}(zl), VT = function(i) {
  Ot(t, i), t.test = function(n) {
    return Ov(n);
  };
  function t(r, n, s) {
    var o;
    W(r.markerWidth) && (r.markerWidth = 80), W(r.markerHeight) && (r.markerHeight = 80), o = i.call(this, r, n, s) || this, r = jt(r, o.translate());
    var a = o.style = o._defineStyle(r);
    return Ce.gecko ? o._url = [nu(a, a.markerWidth, a.markerHeight), a.markerWidth, a.markerHeight] : o._url = [nu(a), a.markerWidth, a.markerHeight], o;
  }
  var e = t.prototype;
  return e._prepareContext = function() {
  }, e._getImage = function(n) {
    var s = this;
    if (n && n.isResourceLoaded(this._url))
      return n.getImage(this._url);
    var o = this.painter, a = new Image();
    return a.onload = function() {
      var l = o.getLayer() && o.getLayer().getRenderer();
      l && l.setToRedraw();
    }, a.onerror = function(l) {
      l && typeof console < "u" && console.warn(l), n.markErrorResource(s._url);
    }, a.src = this._url[0], n && n.addResource(this._url, a), a;
  }, t;
}(Rv), P5 = {
  lineWidth: 1,
  polygonFill: "#fff",
  polygonOpacity: 0.5
}, E5 = function(i) {
  Ot(t, i), t.test = function(n, s) {
    var o = s.getLayer();
    if (!o)
      return !1;
    var a = s.getJSONType();
    return a === "Marker" || a === "LineString";
  };
  function t(r, n, s) {
    var o;
    return o = i.call(this, r, n, s) || this, o.style = n.getLayer().options.drawAltitude, (!o.style || !ji(o.style)) && (o.style = {
      lineWidth: 2
    }), o.style.lineWidth || (o.style.lineWidth = 0), o.dxdy = o._defineStyle({
      dx: r.textDx || r.markerDx,
      dy: r.textDy || r.markerDy
    }), o;
  }
  var e = t.prototype;
  return e.symbolize = function(n) {
    var s = this.geometry.getLayer();
    if (s.options.drawAltitude && this.geometry.hasAltitude()) {
      var o = this._getStyle();
      if (this._prepareContext(n), this.geometry.type === "LineString") {
        var a = this._getPaintParams(o.lineDx, o.lineDy, !1, !0);
        if (!a)
          return;
        var l = this.getPainter().getPaintParams(o.lineDx, o.lineDy, !0, !0, "_groundpt")[0];
        this._drawLineAltitude(n, a[0], l);
      } else {
        var h = this._getRenderContainerPoints(), u = this._getRenderContainerPoints(!0);
        if (!h || h.length === 0)
          return;
        this._drawMarkerAltitude(n, h[0], u[0]);
      }
    }
  }, e.getDxDy = function() {
    var n = this.dxdy;
    return new Y(n.dx || 0, n.dy || 0);
  }, e.get2DExtent = function() {
    return this.geometry.type === "LineString" ? jT.prototype.get2DExtent.apply(this) : i.prototype.get2DExtent.call(this);
  }, e.getPlacement = function() {
    return "point";
  }, e._getPaintParams = function(n, s) {
    return this.getPainter().getPaintParams(n || 0, s || 0, null, !0, "_altpt");
  }, e._drawMarkerAltitude = function(n, s, o) {
    var a = this._getStyle();
    this.prepareCanvas(n, a), Ct.path(n, [s, o], a.lineOpacity, null, a.lineDasharray);
  }, e._drawLineAltitude = function(n, s, o) {
    var a = this._getStyle(), l = s.length > 0 && Array.isArray(s[0]);
    if (l)
      for (var h = 0; h < s.length; h++)
        this._drawLine(n, s[h], o[h]);
    else
      this._drawLine(n, s, o);
    n.setLineDash && Array.isArray(a.lineDasharray) && n.setLineDash([]);
  }, e._drawLine = function(n, s, o) {
    var a = this._getStyle();
    this.prepareCanvas(n, a);
    for (var l = 0, h = s.length - 1; l < h; l++)
      Ct.polygon(n, [s[l], s[l + 1], o[l + 1], o[l]], a.lineOpacity, a.polygonOpacity, a.lineDasharray);
  }, e._getStyle = function() {
    var n = this.geometry.getLayer().options.drawAltitude;
    return ji(n) || (n = P5), n.lineWidth || (n.lineWidth = 0, n.lineOpacity = 0), n;
  }, t;
}(zl), O5 = [E5, jT, Rv, VT, GT, S5], To, N1 = new Y(0, 0), k5 = new Se(), nc = new Se(), vi = new Se(), R5 = new Se(), Bs = new Se(), I5 = {}, ql = {
  minx: 1 / 0,
  miny: 1 / 0,
  maxx: -1 / 0,
  maxy: -1 / 0
}, Iv = function(i) {
  Ot(t, i);
  function t(r) {
    var n;
    return n = i.call(this) || this, n.geometry = r, n.symbolizers = n._createSymbolizers(), n._altAtGL = n._getGeometryAltitude(), n.bbox = Jo(), n._drawTime = 0, n;
  }
  var e = t.prototype;
  return e._setDrawTime = function(n) {
    return this._drawTime = n, this;
  }, e.getRenderBBOX = function() {
    var n = this.getLayer();
    if (n && n._drawTime !== this._drawTime)
      return null;
    iu(this.bbox);
    for (var s = this.symbolizers.length - 1; s >= 0; s--) {
      var o = this.symbolizers[s], a = o.bbox;
      Yf(a) && Rd(this.bbox, a);
    }
    return Yf(this.bbox) ? this.bbox : null;
  }, e.getMap = function() {
    return this.geometry.getMap();
  }, e.getLayer = function() {
    return this.geometry && this.geometry.getLayer();
  }, e._createSymbolizers = function() {
    var n = this.getSymbol(), s = [], o = O5, a = n;
    Array.isArray(n) || (a = [n]);
    for (var l = a.length - 1; l >= 0; l--)
      for (var h = a[l], u = o.length - 1; u >= 0; u--)
        if (o[u].test(h, this.geometry)) {
          var c = new o[u](h, this.geometry, this);
          c._index = l, s.push(c), c instanceof zl && (this._hasPoint = !0);
        }
    if (!s.length && console) {
      var f = this.geometry.getId();
      console.warn("invalid symbol for geometry(" + (this.geometry ? this.geometry.getType() + (f ? ":" + f : "") : "") + ") to draw : " + JSON.stringify(n));
    }
    return this._debugSymbolizer = new x5(n, this.geometry, this), s;
  }, e.hasPoint = function() {
    return !!this._hasPoint;
  }, e.getRenderPoints = function(n) {
    return this._verifyProjection(), this._renderPoints || (this._renderPoints = {}), n || (n = "center"), this._renderPoints[n] || (this._renderPoints[n] = this.geometry._getRenderPoints(n)), this._renderPoints[n];
  }, e.getPaintParams = function(n, s, o, a, l) {
    l === void 0 && (l = "_pt");
    var h = this.getLayer()._getRenderer(), u = h.mapStateCache, c, f, d, p, g, m = this.getMap();
    u && !this._hitPoint ? (c = u.resolution, f = u.pitch, d = u.bearing, p = u.glScale, g = u.containerExtent) : (c = m.getResolution(), f = m.getPitch(), d = m.getBearing(), p = m.getGLScale(), g = m.getContainerExtent());
    var v = this.geometry, _ = c, y = f !== 0, x = d !== 0, w = this._cachedParams, b = v._paintAsPath && v._paintAsPath();
    if (b && this._unsimpledParams && _ <= this._unsimpledParams._res)
      w = this._unsimpledParams;
    else if (!w || w._res !== c || this._pitched !== y && v._redrawWhenPitch() || this._rotated !== x && v._redrawWhenRotate()) {
      if (w = v._getPaintParams(), !w)
        return null;
      w._res = _, !v._simplified && b && (this._unsimpledParams || (this._unsimpledParams = w), _ > this._unsimpledParams._res && (this._unsimpledParams._res = _)), this._cachedParams = w;
    }
    if (!w)
      return null;
    this._pitched = y, this._rotated = x;
    var T = p, A = [], M = w[0], S = g, P = this._pointContainerPoints(M, n, s, o, a || this._hitPoint && !S.contains(this._hitPoint), null, l);
    if (!P)
      return null;
    A.push(P);
    for (var C = 1, k = w.length; C < k; C++)
      Ut(w[C]) || w[C] instanceof zn ? Ut(w[C]) ? A.push(w[C] / T) : A.push(w[C].multi(1 / T)) : A.push(w[C]);
    return A;
  }, e._pointContainerPoints = function(n, s, o, a, l, h, u) {
    if (u === void 0 && (u = "_pt"), this._aboveCamera())
      return null;
    var c = this.getLayer()._getRenderer(), f = c.mapStateCache, d = this.getMap(), p = this.geometry, g = this.containerOffset, m, v;
    f ? (m = f.glRes, v = f.containerExtent) : (m = d.getGLRes(), v = d.getContainerExtent());
    var _, y = this.getLayer().options.roundPoint, x = 1 / 0, w = 1 / 0, b = -1 / 0, T = -1 / 0, A = !l, M = c.layer.options.clipBBoxBufferSize || 3, S = this.symbolizers;
    function P(Ht, Rt) {
      Ht === void 0 && (Ht = []), Rt === void 0 && (Rt = []);
      var Tt = eu(Ht, u);
      Tt = d._pointsAtResToContainerPoints(Ht, m, Rt, Tt);
      for (var $t = 0, Wt = Tt.length; $t < Wt; $t++) {
        var re = Tt[$t];
        re._sub(g), (s || o) && re._add(s || 0, o || 0), y && (re.x = Math.ceil(re.x), re.y = Math.ceil(re.y)), x = Math.min(re.x, x), w = Math.min(re.y, w), b = Math.max(re.x, b), T = Math.max(re.y, T);
      }
      if (A && rT(S)) {
        if (Bs.ymin = v.ymin, Bs.ymin < M && (Bs.ymin = v.ymin - M), Bs.xmin = v.xmin - M, Bs.xmax = v.xmax + M, Bs.ymax = v.ymax + M, p.getShell && p.getHoles)
          return vf(Tt, Bs);
        var ie = mf(Tt, Bs, !1);
        if (ie.length) {
          var Kt = [];
          return ie.forEach(function(fe) {
            for (var Xt = 0, Re = fe.length; Xt < Re; Xt++)
              Kt.push(fe[Xt].point);
          }), Kt;
        }
      }
      return Tt;
    }
    var C = this.getAltitude();
    if (Array.isArray(n)) {
      var k = this.geometry, O;
      !l && k.options.enableClip ? (O = this._clip(n, C), O.inView && (A = !1)) : O = {
        points: n,
        altitude: C
      };
      var R = O.points;
      C = O.altitude, a && (C = 0);
      var I = C;
      _ = [];
      for (var D = [], z = Ut(C), H = 0, G = R.length; H < G; H++) {
        var $ = R[H];
        if (Array.isArray($)) {
          if (z) {
            var K = P($, C);
            _.push(K);
            continue;
          }
          for (var dt = [], it = 0, st = $.length; it < st; it++)
            Array.isArray(C) && (C[H] ? I = C[H][it] : I = 0), dt.push(I);
          var pt = P($, dt);
          _.push(pt);
        } else
          Array.isArray(C) && (h === "vertex-last" ? I = C[C.length - 1 - H] : h === "line" ? I = (C[H] + C[H + 1]) / 2 : I = C[H]), D.push(I);
      }
      D.length && (_ = P(R, D));
    } else n instanceof Y && (a && (C = 0), _ = d._pointAtResToContainerPoint(n, m, C)._sub(g), (s || o) && _._add(s, o));
    return ql.minx = x, ql.miny = w, ql.maxx = b, ql.maxy = T, this._containerBbox = ql, _;
  }, e._clip = function(n, s) {
    if (Ut(s) && s !== 0)
      return {
        points: n,
        altitude: s
      };
    if (Array.isArray(s)) {
      for (var o = !1, a = 0, l = s.length; a < l; a++)
        if (s[a] !== 0) {
          o = !0;
          break;
        }
      if (o)
        return {
          points: n,
          altitude: s
        };
    }
    var h = this.getMap(), u = this.geometry, c = this.getSymbol().lineWidth;
    Ut(c) || (c = 4);
    var f = this.getLayer()._getRenderer(), d = f.mapStateCache, p, g, m;
    d ? (p = d._2DExtent, g = d.glExtent, m = d.pitch) : (p = h._get2DExtent(), g = h._get2DExtentAtRes(h.getGLRes()), m = h.getPitch());
    var v = p._expand(c);
    if (m > 0 && s) {
      var _ = h.cameraLookAt, y = h.cameraPosition;
      N1.set(y.x, y.y), v = v._combine(N1._add(Ar(_[0] - y[0]), Ar(_[1] - y[1])));
    }
    var x = this.get2DExtent(null, R5), w = n;
    if (x.within(v))
      return {
        points: w,
        altitude: s,
        inView: !0
      };
    var b = g._expand(c * h._glScale);
    vi.xmin = b.xmin, vi.xmax = b.xmax, vi.ymin = b.ymin, vi.ymax = b.ymax;
    var T = u.options.smoothness;
    if (u.getShell && this.geometry.getHoles && !T) {
      var A = b.xmin, M = b.ymin, S = b.xmax, P = b.ymax, C = Math.abs(S - A), k = Math.abs(P - M), O = Math.sqrt(C * C + k * k), R = (O - C) / 2, I = (O - k) / 2;
      if (vi.xmin = b.xmin - R, vi.xmax = b.xmax + R, vi.ymin = b.ymin - I, vi.ymax = b.ymax + I, !Array.isArray(n[0]))
        w = vf(n, vi);
      else {
        w = [];
        for (var D = 0; D < n.length; D++) {
          var z = vf(n[D], vi);
          z.length && w.push(z);
        }
      }
    } else if (u.getJSONType() === "LineString" && !T) {
      if (!Array.isArray(n[0]))
        w = mf(n, vi, !1, !!T);
      else {
        w = [];
        for (var H = 0; H < n.length; H++)
          Ui(w, mf(n[H], vi, !1, !!T));
      }
      return this._interpolateSegAlt(w, n, s);
    }
    return {
      points: w,
      altitude: s
    };
  }, e._interpolateSegAlt = function(n, s, o) {
    if (!Array.isArray(o)) {
      var a = function(c) {
        return c.point;
      };
      return {
        points: n.map(function(u) {
          return Array.isArray(u) ? u.map(a) : u.point;
        }),
        altitude: o
      };
    }
    var l = UT(n, s, o);
    o = [];
    var h = l.map(function(u) {
      if (Array.isArray(u)) {
        var c = [], f = u.map(function(d) {
          return c.push(d.altitude), d.point;
        });
        return o.push(c), f;
      }
      return o.push(u.altitude), u.point;
    });
    return {
      points: h,
      altitude: o
    };
  }, e.getSymbol = function() {
    return this.geometry._getInternalSymbol();
  }, e._resetSymbolizersBBOX = function() {
    for (var n = this.symbolizers.length - 1; n >= 0; n--) {
      var s = this.symbolizers[n], o = s.bbox;
      iu(o);
    }
    return this;
  }, e.paint = function(n, s, o) {
    if (this.symbolizers) {
      var a = this.getLayer(), l = a._getRenderer();
      if (!(!l || !l.context && !s)) {
        var h = l.mapStateCache || {};
        if (!(!this.geometry._isCheck && n && !n.intersects(this.get2DExtent(l.resources, k5)))) {
          var u = this.getMap();
          if (!this._aboveCamera()) {
            this.containerOffset = o || h.offset || u._pointToContainerPoint(l.middleWest)._add(0, -u.height / 2), this._beforePaint();
            var c = s || l.context;
            c.isHitTesting || this._resetSymbolizersBBOX();
            for (var f = [c, l.resources], d = this.symbolizers.length - 1; d >= 0; d--)
              (c.shadowBlur || this.symbolizers[d].symbol.shadowBlur) && this._prepareShadow(c, this.symbolizers[d].symbol), this.symbolizers[d].symbolize.apply(this.symbolizers[d], f);
            this._afterPaint(), this._painted = !0, (this.geometry.options.debug || a.options.debug) && this._debugSymbolizer.symbolize.apply(this._debugSymbolizer, f);
          }
        }
      }
    }
  }, e.getSprite = function(n, s) {
    if (!this.geometry.isPoint)
      return null;
    if (this._spriting = !0, !this._sprite && this.symbolizers.length > 0) {
      var o = new Se();
      this.symbolizers.forEach(function(g) {
        var m = g.getFixedExtent(n);
        o._combine(m);
      });
      var a = o.getMin().multi(-1), l = s || (this.getMap() ? this.getMap().CanvasClass : null), h = Ct.createCanvas(o.getWidth(), o.getHeight(), l), u;
      this._renderPoints && (u = this._renderPoints);
      for (var c = h.getContext("2d"), f = [c, n], d = this.symbolizers.length - 1; d >= 0; d--) {
        var p = this.symbolizers[d].getDxDy();
        this._renderPoints = {
          center: [[a.add(p)]]
        }, this._prepareShadow(c, this.symbolizers[d].symbol), this.symbolizers[d].symbolize.apply(this.symbolizers[d], f);
      }
      u && (this._renderPoints = u), this._sprite = {
        canvas: h,
        offset: o.getCenter()
      };
    }
    return this._spriting = !1, this._sprite;
  }, e.isSpriting = function() {
    return !!this._spriting;
  }, e.hitTest = function(n, s) {
    if ((!s || s < 0.5) && (s = 0.5), this._hitPoint = n.sub(s, s), !To) {
      var o = this.getMap() ? this.getMap().CanvasClass : null;
      To = Ct.createCanvas(1, 1, o);
    }
    Ct.setHitTesting(!0), To.width = To.height = 2 * s;
    var a = Ct.getCanvas2DContext(To);
    a.isHitTesting = !0;
    try {
      this.paint(null, a, this._hitPoint);
    } catch (c) {
      throw c;
    } finally {
      Ct.setHitTesting(!1);
    }
    delete this._hitPoint;
    for (var l = a.getImageData(0, 0, To.width, To.height).data, h = 3, u = l.length; h < u; h += 4)
      if (l[h] > 0)
        return !0;
    return !1;
  }, e.isHitTesting = function() {
    return !!this._hitPoint;
  }, e._prepareShadow = function(n, s) {
    s.shadowBlur ? (n.shadowBlur = this.isHitTesting() ? 0 : s.shadowBlur, n.shadowColor = s.shadowColor || "#000", n.shadowOffsetX = s.shadowOffsetX || 0, n.shadowOffsetY = s.shadowOffsetY || 0) : n.shadowBlur && (n.shadowBlur = null, n.shadowColor = null, n.shadowOffsetX = null, n.shadowOffsetY = null);
  }, e._eachSymbolizer = function(n, s) {
    if (this.symbolizers) {
      s || (s = this);
      for (var o = this.symbolizers.length - 1; o >= 0; o--)
        n.apply(s, [this.symbolizers[o]]);
    }
  }, e.get2DExtent = function(n, s) {
    this._verifyProjection();
    var o = this.getMap();
    n = n || this.getLayer()._getRenderer().resources;
    var a = o.getZoom(), l = this._isDynamicSize();
    if ((!this._extent2D || this._extent2D._zoom !== a || !this._fixedExtent) && (this._extent2D && this._extent2D._zoom !== a && delete this._extent2D, this.symbolizers && (this._extent2D || (this._extent2D = this._computeExtent2D(new Se()), this._extent2D._zoom = a), this._fixedExtent || (this._fixedExtent = this._computeFixedExtent(n, new Se())))), !this._extent2D)
      return l && delete this._fixedExtent, null;
    var h = this._fixedExtent, u = h.xmin, c = h.ymin, f = h.xmax, d = h.ymax;
    return l && delete this._fixedExtent, nc.set(u, -d, f, -c), s ? (s.set(this._extent2D.xmin, this._extent2D.ymin, this._extent2D.xmax, this._extent2D.ymax), s._add(nc), s) : this._extent2D.add(nc);
  }, e._computeExtent2D = function(n) {
    for (var s = this.symbolizers.length - 1; s >= 0; s--) {
      var o = this.symbolizers[s];
      n._combine(o.get2DExtent());
    }
    return n;
  }, e._computeFixedExtent = function(n, s) {
    for (var o = this.symbolizers.length - 1; o >= 0; o--) {
      var a = this.symbolizers[o];
      a.getFixedExtent && s._combine(a.getFixedExtent(n));
    }
    return s;
  }, e._isDynamicSize = function() {
    for (var n = this.symbolizers.length - 1; n >= 0; n--) {
      var s = this.symbolizers[n];
      if (s.isDynamicSize())
        return !0;
    }
    return !1;
  }, e._aboveCamera = function() {
    var n = this.getMinAltitude(), s = this.getMap(), o = s.getGLRes();
    n = s.altitudeToPoint(n, o) * Ar(n);
    var a = s.getFrustumAltitude();
    return n && a && a < n;
  }, e.getFixedExtent = function() {
    var n = this.getMap(), s = n.getZoom();
    return this._isDynamicSize() ? this._computeFixedExtent(null, new Se()) : ((!this._extent2D || this._extent2D._zoom !== s) && this.get2DExtent(null, nc), this._fixedExtent);
  }, e.setZIndex = function(n) {
    this._eachSymbolizer(function(s) {
      s.setZIndex(n);
    });
  }, e.show = function() {
    if (this._painted)
      this.removeCache(), this._eachSymbolizer(function(s) {
        s.show();
      });
    else {
      var n = this.getLayer();
      n.isCanvasRender() || this.paint();
    }
  }, e.hide = function() {
    this._eachSymbolizer(function(n) {
      n.hide();
    });
  }, e.repaint = function() {
    this._altAtGL = this._getGeometryAltitude(), this.removeCache();
    var n = this.getLayer();
    if (n) {
      var s = n.getRenderer();
      !s || !s.setToRedraw() || s.setToRedraw();
    }
  }, e.refreshSymbol = function() {
    this.removeCache(), this._removeSymbolizers(), this.symbolizers = this._createSymbolizers();
  }, e.remove = function() {
    this.removeCache(), this._removeSymbolizers();
  }, e._removeSymbolizers = function() {
    this._eachSymbolizer(function(n) {
      delete n.painter, n.remove();
    }), delete this.symbolizers;
  }, e.removeCache = function() {
    delete this._renderPoints, delete this._paintParams, delete this._sprite, delete this._extent2D, delete this._fixedExtent, delete this._cachedParams, delete this._unsimpledParams;
  }, e.getAltitude = function() {
    var n = this.geometry._getAltitude();
    return n !== this._propAlt && (this._altAtGL = this._getGeometryAltitude()), this._altAtGL ? this._altAtGL : 0;
  }, e.getMinAltitude = function() {
    return this.minAltitude ? this.minAltitude : 0;
  }, e.getMaxAltitude = function() {
    return this.maxAltitude ? this.maxAltitude : 0;
  }, e._getGeometryAltitude = function() {
    var n = this, s = this.getMap();
    if (!s)
      return 0;
    var o = this.geometry._getAltitude();
    if (this._propAlt = o, !o)
      return this.minAltitude = this.maxAltitude = 0, 0;
    var a = this.geometry.getCenter();
    return a ? Array.isArray(o) ? (this.minAltitude = Number.MAX_VALUE, this.maxAltitude = Number.MIN_VALUE, o.map(function(l) {
      var h = Array.isArray(l);
      h || (l = [l]);
      var u = l.map(function(c) {
        var f = c;
        return f < n.minAltitude && (n.minAltitude = f), f > n.maxAltitude && (n.maxAltitude = f), f;
      });
      return h ? u : u[0];
    })) : (this.minAltitude = this.maxAltitude = o, this.minAltitude) : 0;
  }, e._verifyProjection = function() {
    var n = this.geometry._getProjection() || I5;
    this._projCode && this._projCode !== n.code && this.removeCache(), this._projCode = n.code;
  }, e._beforePaint = function() {
  }, e._afterPaint = function() {
  }, t;
}(pi);
function UT(i, t, e) {
  if (!Array.isArray(e))
    return i;
  for (var r = [], n = 0, s = i.length; n < s; n++)
    if (Array.isArray(i[n]))
      r.push(UT(i[n], t, e));
    else {
      var o = i[n];
      if (o.point.equals(t[o.index]))
        o.altitude = e[o.index], r.push(o);
      else {
        var a = void 0, l = void 0;
        o.index === 0 ? (a = o.index, l = o.index + 1) : (a = o.index - 1, l = o.index);
        var h = o.point.distanceTo(t[l]), u = h / (h + t[a].distanceTo(o.point)), c = Nf(e[a], e[l], 1 - u);
        o.altitude = c, r.push(o);
      }
    }
  return r;
}
var D5 = new Se(), $T = function(i) {
  Ot(t, i);
  function t(r, n) {
    var s;
    return s = i.call(this) || this, s.geometry = r, s.isMask = n, s.bbox = Jo(), s._drawTime = 0, s;
  }
  var e = t.prototype;
  return e._setDrawTime = function(n) {
    return this._drawTime = n, this._eachPainter(function(s) {
      s._setDrawTime(n);
    }), this;
  }, e.getRenderBBOX = function() {
    var n = this, s = this.getLayer();
    return s && s._drawTime !== this._drawTime ? null : (iu(this.bbox), this._eachPainter(function(o) {
      var a = o.getRenderBBOX();
      Yf(a) && Rd(n.bbox, a);
    }), Yf(this.bbox) ? this.bbox : null);
  }, e._eachPainter = function(n) {
    for (var s = this.geometry.getGeometries(), o, a = 0, l = s.length; a < l && (o = this.isMask ? s[a]._getMaskPainter() : s[a]._getPainter(), !(!!o && o && n.call(this, o) === !1)); a++)
      ;
  }, e.getLayer = function() {
    return this.geometry && this.geometry.getLayer();
  }, e.paint = function(n) {
    this.geometry && this._eachPainter(function(s) {
      s.paint(n);
    });
  }, e.get2DExtent = function(n, s) {
    s && s.set(null, null, null, null);
    var o = s || new Se();
    return this._eachPainter(function(a) {
      o = o._combine(a.get2DExtent(n, D5));
    }), o;
  }, e.remove = function() {
    var n = arguments;
    this._eachPainter(function(s) {
      s.remove.apply(s, n);
    });
  }, e.setZIndex = function() {
    var n = arguments;
    this._eachPainter(function(s) {
      s.setZIndex.apply(s, n);
    });
  }, e.show = function() {
    var n = arguments;
    this._eachPainter(function(s) {
      s.show.apply(s, n);
    });
  }, e.hide = function() {
    var n = arguments;
    this._eachPainter(function(s) {
      s.hide.apply(s, n);
    });
  }, e.repaint = function() {
    var n = arguments;
    this._eachPainter(function(s) {
      s.repaint.apply(s, n);
    });
  }, e.refreshSymbol = function() {
    var n = arguments;
    this._eachPainter(function(s) {
      s.refreshSymbol.apply(s, n);
    });
  }, e.hasPoint = function() {
    var n = !1;
    return this._eachPainter(function(s) {
      return s.hasPoint() ? (n = !0, !1) : !0;
    }), n;
  }, e.getMinAltitude = function() {
    var n = !0, s = 0;
    return this._eachPainter(function(o) {
      var a = o.getMinAltitude();
      (n || a < s) && (n = !1, s = a);
    }), s;
  }, e.getMaxAltitude = function() {
    var n = 0;
    return this._eachPainter(function(s) {
      var o = s.getMaxAltitude();
      o > n && (n = o);
    }), n;
  }, t;
}(pi), ha = 23, Mi = {
  "EPSG:3857": {
    projection: "EPSG:3857",
    resolutions: function() {
      for (var i = [], t = 12756274 * Math.PI, e = 0; e < ha; e++)
        i[e] = t / (256 * Math.pow(2, e));
      return i;
    }(),
    fullExtent: {
      top: 6378137 * Math.PI,
      left: -6378137 * Math.PI,
      bottom: -6378137 * Math.PI,
      right: 6378137 * Math.PI
    }
  },
  "EPSG:4326": {
    projection: "EPSG:4326",
    fullExtent: {
      top: 90,
      left: -180,
      bottom: -90,
      right: 180
    },
    resolutions: function() {
      for (var i = [], t = 0; t < ha; t++)
        i[t] = 180 / (Math.pow(2, t) * 128);
      return i;
    }()
  },
  BAIDU: {
    projection: "baidu",
    resolutions: function() {
      for (var i = Math.pow(2, 18), t = [], e = 0; e < ha; e++)
        t[e] = i, i *= 0.5;
      return t;
    }(),
    fullExtent: {
      top: 33554432,
      left: -33554432,
      bottom: -33554432,
      right: 33554432
    }
  },
  IDENTITY: {
    projection: "identity",
    resolutions: function() {
      for (var i = Math.pow(2, 8), t = [], e = 0; e < ha; e++)
        t[e] = i, i *= 0.5;
      return t;
    }(),
    fullExtent: {
      top: 2e5,
      left: -2e5,
      bottom: -2e5,
      right: 2e5
    }
  },
  "PRESET-VT-3857": {
    projection: "EPSG:3857",
    resolutions: function() {
      for (var i = [], t = 6378137 * Math.PI, e = 0; e < ha; e++)
        i[e] = t / (256 * Math.pow(2, e));
      return i;
    }(),
    fullExtent: {
      top: 6378137 * Math.PI,
      left: -6378137 * Math.PI,
      bottom: -6378137 * Math.PI,
      right: 6378137 * Math.PI
    }
  },
  "PRESET-VT-4326": {
    projection: "EPSG:4326",
    fullExtent: {
      top: 90,
      left: -180,
      bottom: -90,
      right: 180
    },
    resolutions: function() {
      for (var i = [], t = 0; t < ha; t++)
        i[t] = 180 / 4 / (Math.pow(2, t) * 128);
      return i;
    }()
  }
};
Mi["EPSG:4490"] = Mi["EPSG:4326"];
Mi["PRESET-3857-512"] = Mi["PRESET-VT-3857"];
Mi["PRESET-4326-512"] = Mi["PRESET-VT-4326"];
var Ci = function() {
  function i(e) {
    e === void 0 && (e = {}), this.options = e, this._initSpatialRef();
  }
  i.registerPreset = function(r, n) {
    r = r && r.toUpperCase(), Mi[r] && console.warn("Spatial reference " + r + " already registered."), Mi[r] = n;
  }, i.getPreset = function(r) {
    return Mi[r.toUpperCase()];
  }, i.getAllPresets = function() {
    return Object.keys(Mi);
  }, i.getProjectionInstance = function(r) {
    if (!r)
      return null;
    if (De(r) && (r = {
      code: r
    }), r.project)
      return r.locate || (r = jt({}, r), r.measure === "identity" ? jt(r, Dp.getInstance("IDENTITY")) : jt(r, Dp.getInstance("EPSG:4326"))), r;
    var n = (r.code + "").toLowerCase();
    for (var s in us)
      if (Fl(us, s)) {
        var o = us[s].aliases || [], a = us[s].code;
        o.push(a);
        for (var l = 0; l < o.length; l++)
          if (o[l].toLowerCase() === n)
            if (us[s].create) {
              var h = us[s].create(r);
              return h.code = o[l], h;
            } else {
              if (us[s].code === o[l])
                return us[s];
              var u = jt({}, us[s]);
              return u.code = o[l], u;
            }
      }
    return null;
  }, i.equals = function(r, n) {
    if (De(r) || De(n))
      return r === n;
    if (!r && !n)
      return !0;
    if (!r || !n || r.projection !== n.projection)
      return !1;
    var s = r.fullExtent, o = n.fullExtent;
    if (s && !o || !s && o || s && o && (s.top !== o.top || s.bottom !== o.bottom || s.left !== o.left || s.right !== o.right))
      return !1;
    var a = r.resolutions, l = n.resolutions;
    if (a && l) {
      if (a.length !== l.length)
        return !1;
      for (var h = 0; h < a.length; h++)
        if (a[h] !== l[h])
          return !1;
    } else if (a || l)
      return !1;
    return !0;
  };
  var t = i.prototype;
  return t._initSpatialRef = function() {
    var r = this.options.projection;
    if (r ? r = i.getProjectionInstance(r) : r = ET, !r)
      throw new Error("must provide a valid projection in map's spatial reference.");
    r = jt({}, po, r), r.measureLength || jt(r, Dp.DEFAULT), this._projection = r;
    var n, s = this.options.resolutions;
    if (!s && (r.code && (n = Mi[r.code.toUpperCase()], n && (s = n.resolutions, this.isEPSG = r.code !== "IDENTITY")), !s))
      throw new Error("must provide valid resolutions in map's spatial reference.");
    if (this._resolutions = s, this._pyramid = !0, this._pyramid) {
      for (var o = 0; o < s.length; o++)
        if (s[o] && s[o - 1] && s[o - 1] / s[o] !== 2) {
          this._pyramid = !1;
          break;
        }
    }
    var a = this.options.fullExtent;
    if (!a && (r.code && (n = Mi[r.code.toUpperCase()], n && (a = n.fullExtent)), !a))
      throw new Error("must provide a valid fullExtent in map's spatial reference.");
    if (W(a.left) ? (this._fullExtent = new dn(a), a.left = a.xmin, a.right = a.xmax, a.top = a.ymax, a.bottom = a.ymin) : this._fullExtent = new dn(new lt(a.left, a.top), new lt(a.right, a.bottom)), W(a.top) || W(a.bottom) || W(a.left) || W(a.right))
      throw new Error("must provide valid top/bottom/left/right in fullExtent.");
    jt(this._fullExtent, a), this._projection.fullExtent = a;
    var l = a.right >= a.left ? 1 : -1, h = a.top >= a.bottom ? -1 : 1;
    this._transformation = new AT([l, h, 0, 0]);
  }, t.getResolutions = function() {
    return this._resolutions || [];
  }, t.getResolution = function(r) {
    var n = r | 0;
    n < 0 ? n = 0 : n > this._resolutions.length - 1 && (n = this._resolutions.length - 1);
    var s = this._resolutions[n];
    if (n !== r && r > 0 && n < this._resolutions.length - 1) {
      var o = this._resolutions[n + 1];
      return s + (o - s) * (r - n);
    }
    return s;
  }, t.getProjection = function() {
    return this._projection;
  }, t.getFullExtent = function() {
    return this._fullExtent;
  }, t.getTransformation = function() {
    return this._transformation;
  }, t.getMinZoom = function() {
    for (var r = 0; r < this._resolutions.length; r++)
      if (!W(this._resolutions[r]))
        return r;
    return 0;
  }, t.getMaxZoom = function() {
    for (var r = this._resolutions.length - 1; r >= 0; r--)
      if (!W(this._resolutions[r]))
        return r;
    return this._resolutions.length - 1;
  }, t.getZoomDirection = function() {
    return Ar(this._resolutions[this.getMinZoom()] - this._resolutions[this.getMaxZoom()]);
  }, t.toJSON = function() {
    return this.json || (this.json = {
      resolutions: this._resolutions,
      fullExtent: {
        top: this._fullExtent.top,
        left: this._fullExtent.left,
        bottom: this._fullExtent.bottom,
        right: this._fullExtent.right
      },
      projection: this._projection.code
    }), this.json;
  }, t.isPyramid = function() {
    return this._pyramid;
  }, i;
}(), Gp = new Y(0, 0), H1 = new Se(), Vp = {};
function F5(i) {
  if (!i)
    return !1;
  var t = i.xmin, e = i.ymin, r = i.xmax, n = i.ymax;
  return r - t > 0 && n - e > 0;
}
var L5 = {
  id: null,
  visible: !0,
  interactive: !0,
  editable: !0,
  cursor: null,
  antiMeridian: !1,
  defaultProjection: "EPSG:4326"
}, nn = function(i) {
  Ot(t, i);
  function t(r) {
    var n, s = jt({}, r), o = s.symbol, a = s.properties, l = s.id;
    return delete s.symbol, delete s.id, delete s.properties, n = i.call(this, s) || this, o ? n.setSymbol(o) : n._genSizeSymbol(), a && n.setProperties(a), W(l) || n.setId(l), n;
  }
  var e = t.prototype;
  return e.getFirstCoordinate = function() {
    if (this.type === "GeometryCollection") {
      var n = this.getGeometries();
      return n.length ? n[0].getFirstCoordinate() : null;
    }
    var s = this.getCoordinates();
    if (!Array.isArray(s))
      return s;
    do
      s = s[0];
    while (Array.isArray(s) && s.length > 0);
    return s;
  }, e.getLastCoordinate = function() {
    if (this.type === "GeometryCollection") {
      var n = this.getGeometries();
      return n.length ? n[n.length - 1].getLastCoordinate() : null;
    }
    var s = this.getCoordinates();
    if (!Array.isArray(s))
      return s;
    do
      s = s[s.length - 1];
    while (Array.isArray(s) && s.length > 0);
    return s;
  }, e.addTo = function(n, s) {
    return n.addGeometry(this, s), this;
  }, e.getLayer = function() {
    return this._layer ? this._layer : null;
  }, e.getMap = function() {
    return this._layer ? this._layer.getMap() : null;
  }, e.getId = function() {
    return this._id;
  }, e.setId = function(n) {
    var s = this.getId();
    return this._id = n, this._fireEvent("idchange", {
      old: s,
      new: n
    }), this;
  }, e.getProperties = function() {
    return this.properties ? this.properties : this._getParent() ? this._getParent().getProperties() : null;
  }, e.setProperties = function(n) {
    var s = this.properties;
    return this.properties = ji(n) ? jt({}, n) : n, this._clearAltitudeCache(), this._repaint(), this._fireEvent("propertieschange", {
      old: s,
      new: n
    }), this;
  }, e.getType = function() {
    return this.type;
  }, e.getSymbol = function() {
    var n = this._symbol;
    return n ? Array.isArray(n) ? Ni(n) : jt({}, n) : null;
  }, e.setSymbol = function(n) {
    return this._symbolUpdated = n, this._symbol = this._prepareSymbol(n), this.onSymbolChanged(), delete this._compiledSymbol, delete this._symbolHash, this;
  }, e.getSymbolHash = function() {
    return this._symbolHash || (this._symbolHash = ku(this._symbolUpdated)), this._symbolHash;
  }, e.updateSymbol = function(n) {
    if (!n)
      return this;
    var s = this._getSymbol();
    if (Array.isArray(s)) {
      if (!Array.isArray(n))
        throw new Error("Parameter of updateSymbol is not an array.");
      for (var o = 0; o < n.length; o++)
        Kf(n[o]) && delete this._textDesc, s[o] && n[o] && (s[o] = Ni(s[o], n[o]));
    } else {
      if (Array.isArray(n))
        throw new Error("Geometry's symbol is not an array to update.");
      Kf(s) && delete this._textDesc, s ? s = Ni(s, n) : s = Ni(this._getInternalSymbol(), n);
    }
    return this._eventSymbolProperties = n, delete this._compiledSymbol, this.setSymbol(s);
  }, e.getTextContent = function() {
    var n = this._getInternalSymbol();
    if (Array.isArray(n)) {
      for (var s = [], o = !1, a = 0; a < n.length; a++)
        s[a] = $f(n[a] && n[a].textName, this.getProperties()), W(s[a]) || (o = !0);
      return o ? s : null;
    }
    return $f(n && n.textName, this.getProperties());
  }, e.getTextDesc = function() {
    if (!this._textDesc) {
      var n = this.getTextContent(), s = this._sizeSymbol, o = Array.isArray(n);
      Array.isArray(s) ? this._textDesc = s.map(function(a, l) {
        return Wf(o ? n[l] : "", a);
      }) : this._textDesc = Wf(n, s);
    }
    return this._textDesc;
  }, e.getCenter = function() {
    return this._computeCenter(this._getMeasurer());
  }, e.getExtent = function() {
    var n = this._getPrjExtent(), s = this._getProjection();
    if (n && s) {
      var o = s.unproject(new lt(n.xmin, n.ymin)), a = s.unproject(new lt(n.xmax, n.ymax));
      return new dn(o, a, s);
    } else
      return this._computeExtent(this._getMeasurer());
  }, e.getContainerExtent = function(n) {
    var s = this.get2DExtent();
    if (!s || !s.isValid())
      return null;
    var o = this.getMap(), a = o.getGLRes(), l = this.getMinAltitude(), h = s.convertTo(function(m) {
      return o._pointAtResToContainerPoint(m, a, l, Gp);
    }, n), u = this.getMaxAltitude();
    if (u !== l) {
      var c = s.convertTo(function(m) {
        return o._pointAtResToContainerPoint(m, a, u, Gp);
      }, H1);
      h._combine(c);
    }
    var f = this.getLayer();
    if (f && this.type === "LineString" && u && f.options.drawAltitude) {
      var d = s.convertTo(function(m) {
        return o._pointAtResToContainerPoint(m, a, 0, Gp);
      }, H1);
      h._combine(d);
    }
    if (h) {
      var p = this._getFixedExtent();
      F5(p) && h._add(p);
    }
    var g = this.options.smoothness;
    return g && h._expand(h.getWidth() * 0.15), h;
  }, e._getFixedExtent = function() {
    this._fixedExtent || (this._fixedExtent = new Se());
    var n = this._sizeSymbol, s = (n && n.lineWidth || 1) / 2;
    this._fixedExtent.set(-s, -s, s, s);
    var o = n && n.lineDx || 0;
    this._fixedExtent._add([o, 0]);
    var a = n && n.lineDy || 0;
    return this._fixedExtent._add([0, a]), this._fixedExtent;
  }, e.get2DExtent = function() {
    var n = this.getMap();
    if (!n)
      return null;
    if (this._extent2d)
      return this._extent2d;
    var s = this._getPrjExtent();
    if (!s || !s.isValid())
      return null;
    var o = s.getMin(), a = s.getMax(), l = n.getGLRes();
    return n._prjToPointAtRes(o, l, o), n._prjToPointAtRes(a, l, a), this._extent2d = new Se(o, a), this._extent2d.z = n.getZoom(), this._extent2d;
  }, e.getSize = function() {
    var n = this.getContainerExtent();
    return n ? n.getSize() : null;
  }, e.containsPoint = function(n, s) {
    if (!this.getMap())
      throw new Error('The geometry is required to be added on a map to perform "containsPoint".');
    return n instanceof lt && (n = this.getMap().coordToContainerPoint(n)), this._containsPoint(n, s);
  }, e._containsPoint = function(n, s) {
    var o = this._getPainter();
    return o ? (s = s || 0, this._hitTestTolerance && (s += this._hitTestTolerance()), o.hitTest(n, s)) : !1;
  }, e.show = function() {
    if (this.options.visible = !0, this.getMap()) {
      var n = this._getPainter();
      n && n.show(), this._fireEvent("show");
    }
    return this;
  }, e.hide = function() {
    if (this.options.visible = !1, this.getMap()) {
      this.onHide();
      var n = this._getPainter();
      n && n.hide(), this._fireEvent("hide");
    }
    return this;
  }, e.isVisible = function() {
    if (!this.options.visible)
      return !1;
    var n = this._getInternalSymbol();
    if (!n)
      return !0;
    if (Array.isArray(n)) {
      if (!n.length)
        return !0;
      for (var s = 0, o = n.length; s < o; s++)
        if (W(n[s].opacity) || n[s].opacity > 0)
          return !0;
      return !1;
    } else
      return W(n.opacity) || ji(n.opacity) || Ut(n.opacity) && n.opacity > 0;
  }, e.getZIndex = function() {
    return this.options.zIndex || 0;
  }, e.setZIndex = function(n) {
    var s = this.options.zIndex;
    return this.options.zIndex = n, this._fireEvent("zindexchange", {
      old: s,
      new: n
    }), this;
  }, e.setZIndexSilently = function(n) {
    return this.options.zIndex = n, this;
  }, e.bringToFront = function() {
    var n = this.getLayer();
    if (!n || !n.getGeoMaxZIndex)
      return this;
    var s = n.getGeoMaxZIndex();
    return this.setZIndex(s + 1), this;
  }, e.bringToBack = function() {
    var n = this.getLayer();
    if (!n || !n.getGeoMinZIndex)
      return this;
    var s = n.getGeoMinZIndex();
    return this.setZIndex(s - 1), this;
  }, e.translate = function(n, s) {
    if (W(n))
      return this;
    var o = new lt(n, s);
    if (o.x === 0 && o.y === 0)
      return this;
    var a = this.getCoordinates();
    if (this._silence = !0, a)
      if (Array.isArray(a)) {
        var l = No(a, function(h) {
          return h.add(o);
        });
        this.setCoordinates(l);
      } else
        this.setCoordinates(a.add(o));
    return this._silence = !1, this._fireEvent("positionchange"), this;
  }, e.flash = function(n, s, o, a) {
    return hv.call(this, n, s, o, a);
  }, e.copy = function() {
    var n = this.toJSON(), s = t.fromJSON(n);
    return s.options.visible = !0, s;
  }, e.remove = function() {
    var n = this.getLayer();
    return n ? (this._fireEvent("removestart"), this._unbind(), this._fireEvent("removeend"), this._fireEvent("remove"), this) : this;
  }, e.toGeoJSONGeometry = function() {
    var n = this._exportGeoJSONGeometry();
    return n;
  }, e.toGeoJSON = function(n) {
    n || (n = {});
    var s = {
      type: "Feature",
      geometry: null
    };
    if (W(n.geometry) || n.geometry) {
      var o = this._exportGeoJSONGeometry();
      s.geometry = o;
    }
    var a = this.getId();
    W(a) || (s.id = a);
    var l;
    return (W(n.properties) || n.properties) && (l = this._exportProperties()), s.properties = l, s;
  }, e.toJSON = function(n) {
    n || (n = {});
    var s = this._toJSON(n), o = this._exportGraphicOptions(n);
    return jt(s, o), s;
  }, e.getLength = function() {
    return this._computeGeodesicLength(this._getMeasurer());
  }, e.getArea = function() {
    return this._computeGeodesicArea(this._getMeasurer());
  }, e.rotate = function(n, s) {
    if (!Ut(n))
      return console.error("angle:" + n + " is not number"), this;
    if (this.type === "GeometryCollection") {
      var o = this.getGeometries();
      return o.forEach(function(u) {
        return u.rotate(n, s);
      }), this;
    }
    s ? s = new lt(s) : s = this.getCenter(), this._angle = n, this._pivot = s;
    var a = this._getMeasurer(), l = this.getCoordinates();
    if (!Array.isArray(l)) {
      if ((s.x !== l.x || s.y !== l.y) && !this.getShell) {
        var h = a._rotate(l, s, n);
        this.setCoordinates(h);
      } else
        this.onPositionChanged();
      return this;
    }
    return No(l, function(u) {
      return a._rotate(u, s, n);
    }), this.setCoordinates(l), this;
  }, e._rotatePrjCoordinates = function(n) {
    if (!n || this._angle === 0 || !this._pivot)
      return n;
    var s = this._getProjection();
    if (!s)
      return n;
    var o = 0, a = Array.isArray(n), l = a ? n : [n], h = [], u, c;
    if (this.getRotateOffsetAngle) {
      o = this.getRotateOffsetAngle();
      var f = l[l.length - 1];
      u = f.x, c = f.y;
    } else {
      var d = Jo();
      kd(l, d);
      var p = d[0], g = d[1], m = d[2], v = d[3];
      u = (p + m) / 2, c = (g + v) / 2;
    }
    for (var _ = 0, y = l.length; _ < y; _++) {
      var x = l[_], w = x.x, b = x.y, T = w - u, A = b - c, M = Math.sqrt(T * T + A * A), S = z5(u, c, w, b), P = (S - this._angle + o) / 180 * Math.PI, C = Math.cos(P) * M, k = Math.sin(P) * M, O = new lt(u + C, c + k);
      h.push(O);
    }
    for (var R = s.project(this._pivot), I = R.x, D = R.y, z = u - I, H = c - D, G = 0, $ = h.length; G < $; G++) {
      var K = h[G];
      K.x -= z, K.y -= H;
    }
    return a ? h : h[0];
  }, e.isRotated = function() {
    return Ut(this._angle) && this._pivot;
  }, e._getConnectPoints = function() {
    return [this.getCenter()];
  }, e._initOptions = function(n) {
    var s = jt({}, n), o = s.symbol, a = s.properties, l = s.id;
    delete s.symbol, delete s.id, delete s.properties, this.setOptions(s), o && this.setSymbol(o), a && this.setProperties(a), W(l) || this.setId(l);
  }, e._bindLayer = function(n) {
    if (n !== this.getLayer()) {
      if (this.getLayer())
        throw new Error("Geometry cannot be added to two or more layers at the same time.");
      this._layer = n, this._clearCache(), this._bindInfoWindow(), this._bindMenu();
    }
  }, e._prepareSymbol = function(n) {
    if (Array.isArray(n)) {
      for (var s = [], o = 0; o < n.length; o++)
        s.push(Uf(this._checkAndCopySymbol(n[o])));
      return s;
    } else if (n)
      return n = this._checkAndCopySymbol(n), Uf(n);
    return null;
  }, e._checkAndCopySymbol = function(n) {
    var s = {};
    for (var o in n)
      g3[o] && De(n[o]) ? s[o] = +n[o] : s[o] = n[o];
    return s;
  }, e._getSymbol = function() {
    return this._symbol;
  }, e._setExternSymbol = function(n) {
    return this._eventSymbolProperties = n, this._symbol || delete this._textDesc, this._externSymbol = this._prepareSymbol(n), this.onSymbolChanged(), this;
  }, e._getInternalSymbol = function() {
    return this._symbol ? this._symbol : this._externSymbol ? this._externSymbol : this.options.symbol ? this.options.symbol : null;
  }, e._getPrjExtent = function() {
    var n = this._getProjection();
    return this._verifyProjection(), !this._extent && n && (this._extent = this._computePrjExtent(n)), this._extent;
  }, e._unbind = function() {
    var n = this.getLayer();
    n && (this._animPlayer && this._animPlayer.finish(), this._unbindMenu(), this._unbindInfoWindow(), this.isEditing() && this.endEdit(), this._removePainter(), this.onRemove && this.onRemove(), n.onRemoveGeometry && n.onRemoveGeometry(this), delete this._layer, delete this._internalId, delete this._extent);
  }, e._getInternalId = function() {
    return this._internalId;
  }, e._setInternalId = function(n) {
    this._internalId = n;
  }, e._getMeasurer = function() {
    return this._getProjection() ? this._getProjection() : Ci.getProjectionInstance(this.options.defaultProjection);
  }, e._getProjection = function() {
    var n = this.getMap();
    return n ? n.getProjection() : null;
  }, e._verifyProjection = function() {
    var n = this._getProjection();
    this._projCode && n && this._projCode !== n.code && this._clearProjection(), this._projCode = n ? n.code : this._projCode;
  }, e._getExternalResources = function() {
    var n = this._getInternalSymbol();
    return Ou(n);
  }, e._getPainter = function() {
    if (this._painter)
      return this._painter;
    var n = this.getLayer();
    if (!this._painter && n) {
      if (Pw.indexOf(this.type) !== -1) {
        if (n.constructor.getCollectionPainterClass) {
          var s = n.constructor.getCollectionPainterClass();
          s && (this._painter = new s(this));
        }
      } else if (n.constructor.getPainterClass) {
        var o = n.constructor.getPainterClass();
        o && (this._painter = new o(this));
      }
    }
    return this._painter;
  }, e._getMaskPainter = function() {
    return this._maskPainter ? this._maskPainter : (this._maskPainter = this.getGeometries && this.getGeometries() ? new $T(this, !0) : new Iv(this), this._maskPainter);
  }, e._removePainter = function() {
    this._painter && this._painter.remove(), delete this._painter;
  }, e._paint = function(n) {
    if (this._painter) {
      if (this._dirtyCoords) {
        delete this._dirtyCoords;
        var s = this._getProjection();
        s && (this._pcenter = s.project(this._coordinates), this._clearCache());
      }
      this._painter.paint(n);
    }
  }, e._clearCache = function() {
    delete this._extent, delete this._extent2d, this._clearAltitudeCache();
  }, e._clearProjection = function() {
    delete this._extent, delete this._extent2d;
  }, e._repaint = function() {
    this._painter && this._painter.repaint();
  }, e.onHide = function() {
    this.closeMenu(), this.closeInfoWindow();
  }, e.onShapeChanged = function() {
    this._clearCache(), this._repaint(), this._fireEvent("shapechange");
  }, e.onPositionChanged = function() {
    this._clearCache(), this._repaint(), this._fireEvent("positionchange");
  }, e.onSymbolChanged = function() {
    this._painter && this._painter.refreshSymbol();
    var n = {};
    this._eventSymbolProperties ? (n.properties = JSON.parse(JSON.stringify(this._eventSymbolProperties)), delete this._eventSymbolProperties) : delete this._textDesc, this._genSizeSymbol(), this._fireEvent("symbolchange", n);
  }, e._genSizeSymbol = function() {
    var n = this._getInternalSymbol();
    if (!n) {
      delete this._sizeSymbol;
      return;
    }
    if (Array.isArray(n)) {
      this._sizeSymbol = [];
      for (var s = !1, o = 0; o < n.length; o++) {
        var a = this._sizeSymbol[o] = this._getSizeSymbol(n[o]);
        !s && a && a._dynamic && (s = !0);
      }
      this._sizeSymbol._dynamic = s;
    } else
      this._sizeSymbol = this._getSizeSymbol(n);
  }, e._getSizeSymbol = function(n) {
    var s = Vf({
      lineWidth: n.lineWidth,
      lineDx: n.lineDx,
      lineDy: n.lineDy
    }, this);
    return (_n(n.lineWidth) || _n(n.lineDx) || _n(n.lineDy)) && (s._dynamic = !0), s;
  }, e._getCompiledSymbol = function() {
    return this._compiledSymbol ? this._compiledSymbol : (this._compiledSymbol = Vf(this._getInternalSymbol(), this), this._compiledSymbol);
  }, e.onConfig = function(n) {
    var s;
    n.properties && (s = n.properties, delete n.properties);
    var o = !1;
    for (var a in n)
      if (n.hasOwnProperty(a)) {
        var l = a.slice(0, 5);
        if (l === "arrow" || l === "smoot") {
          o = !0;
          break;
        }
      }
    s ? (this.setProperties(s), this._repaint()) : o && this._repaint();
  }, e._setParent = function(n) {
    n && (this._parent = n);
  }, e._getParent = function() {
    return this._parent;
  }, e._fireEvent = function(n, s) {
    this._silence || (this.getLayer() && this.getLayer()._onGeometryEvent && (s || (s = {}), s.type = n, s.target = this, this.getLayer()._onGeometryEvent(s)), this.fire(n, s));
  }, e._toJSON = function(n) {
    return {
      feature: this.toGeoJSON(n)
    };
  }, e._exportGraphicOptions = function(n) {
    var s = {};
    return (W(n.options) || n.options) && (s.options = this.config()), (W(n.symbol) || n.symbol) && (s.symbol = this.getSymbol()), (W(n.infoWindow) || n.infoWindow) && this._infoWinOptions && (s.infoWindow = this._infoWinOptions), s;
  }, e._exportGeoJSONGeometry = function() {
    var n = this.getCoordinates(), s = lt.toNumberArrays(n);
    return {
      type: this.getType(),
      coordinates: s
    };
  }, e._exportProperties = function() {
    var n = null, s = this.getProperties();
    return W(s) || (ji(s) ? n = jt({}, s) : n = s), n;
  }, e._hitTestTolerance = function() {
    return 0;
  }, e._getAltitude = function() {
    var n = this.getLayer();
    if (!n)
      return 0;
    var s = n.options, o = n.getAltitude ? n.getAltitude() : 0, a = s.enableAltitude;
    if (!a)
      return o;
    var l = Up(n), h = this.properties || Vp, u = h[l];
    if (W(u)) {
      var c = B1(this, o, a);
      return W(c) ? o : c;
    }
    return Array.isArray(u) ? u.map(function(f) {
      return f + o;
    }) : u + o;
  }, e.getAltitude = function() {
    var n = this.getLayer(), s = Up(n), o = this.properties || Vp, a = o[s];
    if (!W(a))
      return a;
    var l = B1(this, 0, !1);
    return W(l) ? 0 : l;
  }, e.hasAltitude = function() {
    var n = this._getAltitude();
    return !!n;
  }, e.setAltitude = function(n) {
    if (!Ut(n))
      return this;
    var s = this.getLayer(), o = Up(s), a = this.properties || Vp, l = a[o];
    if (!W(l))
      if (Array.isArray(l))
        for (var h = 0, u = l.length; h < u; h++)
          l[h] = n;
      else
        a[o] = n;
    var c = this.getCoordinates ? this.getCoordinates() : null;
    if (!c)
      return this;
    if (WT(c, n), s) {
      var f = s.getRenderer();
      f && f.gl ? this.setCoordinates(c) : f && this._repaint();
    }
    return this._clearAltitudeCache(), this;
  }, e._genMinMaxAlt = function() {
    var n = this, s = this._getAltitude();
    Array.isArray(s) ? (this._minAlt = Number.MAX_VALUE, this._maxAlt = Number.MIN_VALUE, s.forEach(function(o) {
      var a = o;
      a < n._minAlt && (n._minAlt = a), a > n._maxAlt && (n._maxAlt = a);
    })) : this._minAlt = this._maxAlt = s;
  }, e.getMinAltitude = function() {
    return this._minAlt === void 0 && this._genMinMaxAlt(), this._minAlt ? this._minAlt : 0;
  }, e.getMaxAltitude = function() {
    return this._maxAlt === void 0 && this._genMinMaxAlt(), this._maxAlt ? this._maxAlt : 0;
  }, e._clearAltitudeCache = function() {
    return this._minAlt = void 0, this._maxAlt = void 0, this;
  }, t;
}(TT(ls(Av(pi))));
nn.mergeOptions(L5);
function Up(i) {
  var t = "altitude";
  if (i) {
    var e = i.options;
    t = e.altitudeProperty;
  }
  return t;
}
function B1(i, t, e) {
  var r = i.getCoordinates ? i.getCoordinates() : null;
  if (r) {
    var n = [];
    if (ZT(r, n), n.length) {
      var s = XT(r, t, e);
      return s;
    }
  }
  return null;
}
function WT(i, t) {
  if (Array.isArray(i))
    for (var e = 0, r = i.length; e < r; e++)
      WT(i[e], t);
  else
    i.z = t;
}
function ZT(i, t) {
  if (!t.length)
    if (Array.isArray(i))
      for (var e = 0, r = i.length; e < r; e++)
        ZT(i[e], t);
    else Ut(i.z) && t.push(i.z);
}
function XT(i, t, e) {
  if (Array.isArray(i)) {
    for (var r = [], n = 0, s = i.length; n < s; n++)
      r.push(XT(i[n], t, e));
    return r;
  }
  return Ut(i.z) ? e ? t + i.z : i.z : e ? t : 0;
}
function z5(i, t, e, r) {
  if (i === e)
    return r > t ? -90 : 90;
  e -= i, r -= t, r = -r;
  var n = Math.atan2(r, e);
  return n / Math.PI * 180;
}
var N5 = {
  attribution: null,
  minZoom: null,
  maxZoom: null,
  visible: !0,
  opacity: 1,
  globalCompositeOperation: null,
  renderer: "canvas",
  debugOutline: "#0f0",
  cssFilter: null,
  forceRenderOnMoving: !1,
  forceRenderOnZooming: !1,
  forceRenderOnRotating: !1,
  collision: !1,
  collisionScope: "layer",
  hitDetect: function() {
    return !Ce.mobile;
  }()
}, gr = function(i) {
  Ot(t, i);
  function t(r, n) {
    var s, o;
    return n && (o = n.canvas, delete n.canvas), s = i.call(this, n) || this, s._canvas = o, s.setId(r), n && (s.setZIndex(n.zIndex), n.mask && s.setMask(nn.fromJSON(n.mask))), s.proxyOptions(), s;
  }
  var e = t.prototype;
  return e.load = function() {
    if (!this.getMap())
      return this;
    if (this.onLoad()) {
      this._initRenderer();
      var n = this.getZIndex();
      W(n) || (this._renderer.setZIndex(n), this.isCanvasRender() || this._renderer.render()), this.onLoadEnd();
    }
    return this;
  }, e.getId = function() {
    return this._id;
  }, e.setId = function(n) {
    var s = this._id;
    return W(n) || (n = n + ""), this._id = n, this.fire("idchange", {
      old: s,
      new: n
    }), this;
  }, e.addTo = function(n) {
    return n.addLayer(this), this;
  }, e.setZIndex = function(n) {
    return this._zIndex = n, W(n) ? delete this.options.zIndex : this.options.zIndex = n, this.map && this.map._sortLayersByZIndex(), this._renderer && this._renderer.setZIndex(n), this.fire("setzindex", {
      zIndex: n
    }), this;
  }, e.getZIndex = function() {
    return this._zIndex || 0;
  }, e.getMinZoom = function() {
    var n = this.getMap(), s = this.options.minZoom;
    return n ? Math.max(n.getMinZoom(), s || 0) : s;
  }, e.getMaxZoom = function() {
    var n = this.getMap(), s = this.options.maxZoom;
    return n ? Math.min(n.getMaxZoom(), W(s) ? 1 / 0 : s) : s;
  }, e.getOpacity = function() {
    return this.options.opacity;
  }, e.setOpacity = function(n) {
    return this.config("opacity", n), this.fire("setopacity", {
      opacity: n
    }), this;
  }, e.isCanvasRender = function() {
    var n = this._getRenderer();
    return n && n instanceof Ll;
  }, e.getMap = function() {
    return this.map ? this.map : null;
  }, e.getProjection = function() {
    var n = this.getMap();
    return n ? n.getProjection() : null;
  }, e.bringToFront = function() {
    var n = this._getLayerList();
    if (!n.length)
      return this;
    var s = n[n.length - 1];
    if (n.length === 1 || s === this)
      return this;
    var o = s.getZIndex();
    return this.setZIndex(o + 1), this;
  }, e.bringToBack = function() {
    var n = this._getLayerList();
    if (!n.length)
      return this;
    var s = n[0];
    if (n.length === 1 || s === this)
      return this;
    var o = s.getZIndex();
    return this.setZIndex(o - 1), this;
  }, e.show = function() {
    var n = this;
    if (!this.options.visible) {
      this.options.visible = !0;
      var s = this.getRenderer();
      s && s.show();
      var o = this.getMap();
      s && o ? o.once("renderend", function() {
        n.fire("show");
      }) : this.fire("show");
    }
    return this;
  }, e.hide = function() {
    var n = this;
    if (this.options.visible) {
      this.options.visible = !1;
      var s = this.getRenderer();
      s && s.hide();
      var o = this.getMap();
      s && o ? o.once("renderend", function() {
        n.fire("hide");
      }) : this.fire("hide");
    }
    return this;
  }, e.isVisible = function() {
    if (Ut(this.options.opacity) && this.options.opacity <= 0)
      return !1;
    var n = this.getMap();
    if (n) {
      var s = n.getZoom();
      if (!W(this.options.maxZoom) && this.options.maxZoom < s || !W(this.options.minZoom) && this.options.minZoom > s)
        return !1;
    }
    return W(this.options.visible) && (this.options.visible = !0), this.options.visible;
  }, e.remove = function() {
    if (this.map) {
      var n = this.map.getRenderer();
      this.map.removeLayer(this), n && n.setToRedraw();
    } else
      this.fire("remove");
    return this;
  }, e.getMask = function() {
    return this._mask;
  }, e.setMask = function(n) {
    if (!(n.type === "Point" && n._isVectorMarker() || n.type === "Polygon" || n.type === "MultiPolygon"))
      throw new Error("Mask for a layer must be a marker with vector marker symbol or a Polygon(MultiPolygon).");
    if (n._bindLayer(this), n.type === "Point" ? n.updateSymbol({
      markerLineColor: "rgba(0, 0, 0, 0)",
      markerFillOpacity: 0
    }) : n.setSymbol({
      lineColor: "rgba(0, 0, 0, 0)",
      polygonOpacity: 0
    }), this._mask = n, this.options.mask = n.toJSON(), !this.getMap() || this.getMap().isZooming())
      return this;
    var s = this._getRenderer();
    return s && s.setToRedraw && this._getRenderer().setToRedraw(), this;
  }, e.removeMask = function() {
    if (delete this._mask, delete this.options.mask, !this.getMap() || this.getMap().isZooming())
      return this;
    var n = this._getRenderer();
    return n && n.setToRedraw && this._getRenderer().setToRedraw(), this;
  }, e.onLoad = function() {
    return !0;
  }, e.onLoadEnd = function() {
  }, e.isLoaded = function() {
    return !!this._loaded;
  }, e.getCollisionIndex = function() {
    if (this.options.collisionScope === "layer")
      return this._collisionIndex || (this._collisionIndex = new Ru()), this._collisionIndex;
    var n = this.getMap();
    return n ? n.getCollisionIndex() : null;
  }, e.clearCollisionIndex = function() {
    return this.options.collisionScope === "layer" && this._collisionIndex && this._collisionIndex.clear(), this;
  }, e.getRenderer = function() {
    return this._getRenderer();
  }, e.onConfig = function(n) {
    var s = n && Object.keys && Object.keys(n).length > 0;
    if (s && W(n.animation)) {
      if (this._optionsHook && Be(this._optionsHook) && this._optionsHook(n), this._silentConfig)
        return;
      var o = this.getRenderer();
      o && o.setToRedraw && o.setToRedraw();
    }
  }, e.onAdd = function() {
  }, e.onRendererCreate = function() {
  }, e.onCanvasCreate = function() {
  }, e.onRemove = function() {
  }, e._bindMap = function(n, s) {
    n && (this.map = n, W(s) || this.setZIndex(s), this._switchEvents("on", this), this.onAdd(), this.fire("add"));
  }, e._initRenderer = function() {
    var n = this.options.renderer;
    if (this.constructor.getRendererClass) {
      var s = this.constructor.getRendererClass(n);
      if (!s)
        throw new Error("Invalid renderer for Layer(" + this.getId() + "):" + n);
      this._renderer = new s(this), this._renderer.layer = this, this._renderer.setZIndex(this.getZIndex()), this._switchEvents("on", this._renderer), this._renderer.onAdd && this._renderer.onAdd(), this.onRendererCreate(), this.fire("renderercreate", {
        renderer: this._renderer
      });
    }
  }, e._doRemove = function() {
    this._loaded = !1, this._switchEvents("off", this), this.onRemove(), this._renderer && (this._switchEvents("off", this._renderer), this._renderer.remove(), delete this._renderer), delete this.map, delete this._collisionIndex;
  }, e._switchEvents = function(n, s) {
    s && s.getEvents && this.getMap() && this.getMap()[n](s.getEvents(), s);
  }, e._getRenderer = function() {
    return this._renderer;
  }, e._getLayerList = function() {
    return this.map ? this.map._layers : [];
  }, e._getMask2DExtent = function() {
    if (!this._mask || !this.getMap())
      return null;
    var n = this._mask._getMaskPainter();
    return n ? n.get2DExtent() : null;
  }, t;
}(TT(ls(Cv(pi))));
gr.mergeOptions(N5);
var H5 = gr.prototype.fire;
gr.prototype.fire = function(i, t) {
  return i === "layerload" && (this._loaded = !0), this.map && (t || (t = {}), t.type = i, t.target = this, this.map._onLayerEvent(t)), H5.apply(this, arguments), ["show", "hide"].indexOf(i) > -1 && this.fire("visiblechange", Object.assign({}, t, {
    visible: this.options.visible
  })), this;
};
var qT = new lt(0, 0), j1 = new Y(0, 0), G1 = ["centerCross", "fog", "fogColor", "debugSky"], B5 = {
  maxVisualPitch: 70,
  maxPitch: 80,
  centerCross: !1,
  zoomInCenter: !1,
  zoomOrigin: null,
  zoomAnimation: /* @__PURE__ */ function() {
    return !tr;
  }(),
  zoomAnimationDuration: 330,
  panAnimation: /* @__PURE__ */ function() {
    return !tr;
  }(),
  panAnimationDuration: 600,
  rotateAnimation: /* @__PURE__ */ function() {
    return !tr;
  }(),
  zoomable: !0,
  enableInfoWindow: !0,
  hitDetect: function() {
    return !Ce.mobile;
  }(),
  hitDetectLimit: 5,
  fpsOnInteracting: 25,
  layerCanvasLimitOnInteracting: -1,
  maxZoom: null,
  minZoom: null,
  maxExtent: null,
  fixCenterOnResize: !0,
  checkSize: !0,
  checkSizeInterval: 1e3,
  renderer: "canvas",
  cascadePitches: [10, 60],
  renderable: !0,
  clickTimeThreshold: 280,
  stopRenderOnOffscreen: !0,
  preventWheelScroll: !0,
  preventTouch: !0,
  supportPluginEvent: !0,
  switchDragButton: !1,
  mousemoveThrottleTime: aT
}, xe = function(i) {
  Ot(t, i);
  function t(r, n) {
    var s;
    if (!n)
      throw new Error("Invalid options when creating map.");
    if (!n.center)
      throw new Error("Invalid center when creating map.");
    var o = jt({}, n), a = o.zoom;
    delete o.zoom;
    var l = new lt(o.center);
    delete o.center;
    var h = o.baseLayer;
    delete o.baseLayer;
    var u = o.layers;
    return delete o.layers, s = i.call(this, o) || this, s.VERSION = t.VERSION, Object.defineProperty(kn(kn(s)), "id", {
      value: Ls(),
      writable: !1
    }), s._loaded = !1, s._initContainer(r), s._panels = {}, s._baseLayer = null, s._layers = [], s._zoomLevel = a, s._center = l, s._centerZ = l.z, s.setSpatialReference(o.spatialReference || o.view), s._mapViewPoint = new Y(0, 0), s._initRenderer(), s._updateMapSize(s._getContainerDomSize()), h && s.setBaseLayer(h), u && s.addLayer(u), s.setMaxExtent(o.maxExtent), s._Load(), s.proxyOptions(), s.isMap = !0, s;
  }
  t.addOnLoadHook = function(n) {
    var s = Array.prototype.slice.call(arguments, 1), o = typeof n == "function" ? n : function() {
      this[n].apply(this, s);
    };
    return this.prototype._onLoadHooks = this.prototype._onLoadHooks || [], this.prototype._onLoadHooks.push(o), this;
  };
  var e = t.prototype;
  return e.isLoaded = function() {
    return !!this._loaded;
  }, e.getContainer = function() {
    return this._containerDOM;
  }, e.getSpatialReference = function() {
    return this._spatialReference;
  }, e.setSpatialReference = function(n) {
    var s = this.options.spatialReference;
    return this._loaded && Ci.equals(s, n) ? this : (this._updateSpatialReference(n, s), this);
  }, e._updateSpatialReference = function(n, s) {
    De(n) && (n = Ci.getPreset(n)), n = jt({}, n), this._center = this.getCenter(), this.options.spatialReference = n, this._spatialReference = new Ci(n);
    var o = this._spatialReference.getProjection();
    return this.options.spatialReference && Be(this.options.spatialReference.projection) && (this.options.spatialReference.projection = o.code), this._resetMapStatus(), Jf.is(o.code) && (this._originLng = o.centralMeridian, this._altitudeOriginDirty = !0), this._fireEvent("spatialreferencechange", {
      old: s,
      new: jt({}, this.options.spatialReference)
    }), this;
  }, e.onConfig = function(n) {
    var s = n.spatialReference || n.view;
    W(s) || this._updateSpatialReference(s, null);
    for (var o = !1, a = 0, l = G1.length; a < l; a++) {
      var h = G1[a];
      if (!W(n[h])) {
        o = !0;
        break;
      }
    }
    if (!o)
      return this;
    var u = this.getRenderer();
    return u && u.setToRedraw(), this;
  }, e.getProjection = function() {
    return this._spatialReference ? this._spatialReference.getProjection() : null;
  }, e.getFullExtent = function() {
    return this._spatialReference ? this._spatialReference.getFullExtent() : null;
  }, e.setCursor = function(n) {
    return delete this._cursor, this._trySetCursor(n), this._cursor = n, this;
  }, e.resetCursor = function() {
    return this.setCursor(null);
  }, e.getCenter = function() {
    if (!this._loaded || !this._prjCenter)
      return this._center;
    var n = this.getProjection(), s = n.unproject(this._prjCenter);
    return s.x = Math.round(s.x * 1e8) / 1e8, s.y = Math.round(s.y * 1e8) / 1e8, s.z = this._centerZ, this.centerAltitude && (s.z = this.centerAltitude), s;
  }, e.setCenter = function(n, s) {
    if (!n)
      return this;
    n = new lt(n), s && (n = this._getCenterByPadding(n, this.getZoom(), s));
    var o = this.getProjection(), a = o.project(n);
    return this._verifyExtent(a) ? this._loaded ? (this._centerZ = n.z || 0, this.onMoveStart(), this._setPrjCenter(a), this.onMoveEnd(this._parseEventFromCoord(this.getCenter())), this) : (this._center = n, this) : this;
  }, e.getSize = function() {
    return W(this.width) || W(this.height) ? this._getContainerDomSize() : new zn(this.width, this.height);
  }, e.getContainerExtent = function() {
    var n = this.height, s = this.getPitch(), o = this.options.maxVisualPitch;
    return o && s > o && (n = this._getVisualHeight(o)), new Se(0, this.height - n, this.width, this.height);
  }, e._getVisualHeight = function(n) {
    n = n || 0.01;
    var s = (90 - this.getPitch()) * Math.PI / 180, o = this.getFov() * Math.PI / 180;
    n *= Math.PI / 180;
    var a = this.cameraCenterDistance / this.getGLScale(), l = Math.tan(o / 2), h = Math.tan(n), u = a * l / (1 / h - l) / Math.sin(n), c = a * (Math.sin(s) * u / (a + Math.cos(s) * u));
    return this.height / 2 + c;
  }, e.getExtent = function() {
    return this._pointToExtent(this._get2DExtent());
  }, e.getProjExtent = function() {
    var n = this._get2DExtent();
    return new dn(this._pointToPrj(n.getMin()), this._pointToPrj(n.getMax()));
  }, e.getPrjExtent = function() {
    return this.getProjExtent();
  }, e.getMaxExtent = function() {
    return this.options.maxExtent ? new dn(this.options.maxExtent, this.getProjection()) : null;
  }, e.setMaxExtent = function(n) {
    if (n) {
      var s = new dn(n, this.getProjection());
      this.options.maxExtent = s;
      var o = this.getProjection();
      this._prjMaxExtent = s.convertTo(function(a) {
        return o.project(a);
      }), this._verifyExtent(this._getPrjCenter()) || (this._loaded ? this._panTo(this._prjMaxExtent.getCenter()) : this._center = o.unproject(this._prjMaxExtent.getCenter()));
    } else
      delete this.options.maxExtent, delete this._prjMaxExtent;
    return this;
  }, e.getZoom = function() {
    return this._zoomLevel;
  }, e.getZoomForScale = function(n, s, o) {
    var a = this.getZoom();
    if (W(s) && (s = a), n === 1 && s === a)
      return a;
    var l = this._getResolution(s), h = l / n, u = this.getZoomFromRes(h);
    if (o)
      return u;
    var c = 1e-6;
    return this.getSpatialReference().getZoomDirection() < 0 ? Math.ceil(u - c) : Math.floor(u + c);
  }, e.getZoomFromRes = function(n) {
    var s = this._getResolutions(), o = this._getResolution(this.getMinZoom()), a = this._getResolution(this.getMaxZoom());
    if (o <= a) {
      if (n <= o)
        return this.getMinZoom();
      if (n >= a)
        return this.getMaxZoom();
    } else {
      if (n >= o)
        return this.getMinZoom();
      if (n <= a)
        return this.getMaxZoom();
    }
    for (var l = s.length, h = 0; h < l - 1; h++)
      if (s[h]) {
        var u = s[h + 1] - s[h], c = n - s[h];
        if (Ar(u) === Ar(c) && Math.abs(u) >= Math.abs(c))
          return h + c / u;
      }
    return l - 1;
  }, e.setZoom = function(n, s) {
    return s === void 0 && (s = {
      animation: !0
    }), isNaN(n) || W(n) ? this : (n = +n, this._loaded && this.options.zoomAnimation && s.animation ? this._zoomAnimation(n) : this._zoom(n), this);
  }, e.getMaxZoom = function() {
    return W(this.options.maxZoom) ? this.getMaxNativeZoom() : this.options.maxZoom;
  }, e.setMaxZoom = function(n) {
    var s = this.getMaxNativeZoom();
    return n > s && (n = s), n !== null && n < this._zoomLevel && (this.setZoom(n), n = +n), this.options.maxZoom = n, this;
  }, e.getMinZoom = function() {
    return W(this.options.minZoom) ? this._spatialReference.getMinZoom() : this.options.minZoom;
  }, e.setMinZoom = function(n) {
    if (n !== null) {
      n = +n;
      var s = this._spatialReference.getMinZoom();
      n < s && (n = s), n > this._zoomLevel && this.setZoom(n);
    }
    return this.options.minZoom = n, this;
  }, e.getMaxNativeZoom = function() {
    var n = this.getSpatialReference();
    return n ? n.getMaxZoom() : null;
  }, e.getGLRes = function() {
    if (this._glRes)
      return this._glRes;
    var n = this.getSpatialReference().getFullExtent();
    return this._glRes = (n.right - n.left) / Math.pow(2, 19), this._glRes;
  }, e.getGLScale = function(n) {
    return W(n) && (n = this.getZoom()), this._getResolution(n) / this.getGLRes();
  }, e.zoomIn = function() {
    return this.setZoom(this.getZoom() + 1);
  }, e.zoomOut = function() {
    return this.setZoom(this.getZoom() - 1);
  }, e.isZooming = function() {
    return !!this._zooming;
  }, e.isInteracting = function() {
    return this.isZooming() || this.isMoving() || this.isRotating();
  }, e.setCenterAndZoom = function(n, s) {
    return !W(s) && this._zoomLevel !== s ? (this.setCenter(n), this.setZoom(s, {
      animation: !1
    })) : this.setCenter(n), this;
  }, e._getPaddingSize = function(n) {
    return n === void 0 && (n = {}), n.paddingLeft || n.paddingTop || n.paddingRight || n.paddingBottom ? {
      width: (n.paddingLeft || 0) + (n.paddingRight || 0),
      height: (n.paddingTop || 0) + (n.paddingBottom || 0)
    } : null;
  }, e.getFitZoom = function(n, s, o) {
    var a = this;
    if (!n || !(n instanceof dn))
      return this._zoomLevel;
    if (n.xmin === n.xmax && n.ymin === n.ymax)
      return this.getMaxZoom();
    var l = this.getSize(), h = this._getPaddingSize(o);
    h && (l = {
      width: l.width - (h.width || 0),
      height: l.height - (h.height || 0)
    });
    var u = n.convertTo(function(v) {
      return a.coordToPoint(v);
    }), c = u.getWidth(), f = u.getHeight(), d = l.width / c, p = l.height / f, g = this.getSpatialReference().getZoomDirection() < 0 ? Math.max(d, p) : Math.min(d, p), m = this.getZoomForScale(g, null, s);
    return m;
  }, e.getView = function() {
    return {
      center: this.getCenter().toArray(),
      zoom: this.getZoom(),
      pitch: this.getPitch(),
      bearing: this.getBearing()
    };
  }, e.setView = function(n) {
    return n ? (n.center && this.setCenter(n.center), n.zoom !== null && !isNaN(+n.zoom) && this.setZoom(+n.zoom, {
      animation: !1
    }), n.pitch !== null && !isNaN(+n.pitch) && this.setPitch(+n.pitch), n.pitch !== null && !isNaN(+n.bearing) && this.setBearing(+n.bearing), this) : this;
  }, e.getResolution = function(n) {
    return this._getResolution(n);
  }, e.getScale = function(n) {
    var s = W(n) ? this.getZoom() : n, o = this._getResolution(this.getMaxNativeZoom()), a = this._getResolution(s);
    return a / o;
  }, e._getCenterByPadding = function(n, s, o) {
    o === void 0 && (o = {});
    var a = this.coordinateToPoint(n, s), l = o, h = l.paddingLeft, u = h === void 0 ? 0 : h, c = l.paddingRight, f = c === void 0 ? 0 : c, d = l.paddingTop, p = d === void 0 ? 0 : d, g = l.paddingBottom, m = g === void 0 ? 0 : g, v = 0, _ = 0;
    (u || f) && (v = (f - u) / 2), (p || m) && (_ = (p - m) / 2);
    var y = new Y({
      x: a.x + v,
      y: a.y + _
    });
    return this.pointToCoordinate(y, s);
  }, e.fitExtent = function(n, s, o, a) {
    if (o === void 0 && (o = {}), !n)
      return this;
    n = new dn(n, this.getProjection());
    var l = this.getFitZoom(n, o.isFraction || !1, o) + (s || 0), h = n.getCenter();
    return this._getPaddingSize(o) && (h = this._getCenterByPadding(h, l, o)), typeof o.animation > "u" || o.animation ? this._animateTo({
      center: h,
      zoom: l
    }, {
      duration: o.duration || this.options.zoomAnimationDuration,
      easing: o.easing || "out"
    }, a) : this.setCenterAndZoom(h, l);
  }, e.getBaseLayer = function() {
    return this._baseLayer;
  }, e.setBaseLayer = function(n) {
    var s = !1;
    if (this._baseLayer && (s = !0, this._fireEvent("baselayerchangestart"), this._baseLayer.remove()), !n)
      return delete this._baseLayer, this._fireEvent("baselayerchangeend"), this._fireEvent("setbaselayer"), this;
    this._baseLayer = n, n._bindMap(this, -1);
    function o() {
      this._fireEvent("baselayerload"), s && (s = !1, this._fireEvent("baselayerchangeend"));
    }
    return this._baseLayer.on("layerload", o, this), this._loaded && this._baseLayer.load(), this._fireEvent("setbaselayer"), this;
  }, e.removeBaseLayer = function() {
    return this._baseLayer && (this._baseLayer.remove(), delete this._baseLayer, this._fireEvent("baselayerremove")), this;
  }, e.getLayers = function(n) {
    return this._getLayers(function(s) {
      return s === this._baseLayer || s.getId().indexOf(Eu) >= 0 ? !1 : n ? n(s) : !0;
    });
  }, e.getLayer = function(n) {
    if (!n)
      return null;
    var s = this._layerCache ? this._layerCache[n] : null;
    if (s)
      return s;
    var o = this.getBaseLayer();
    return o && o.getId() === n ? o : null;
  }, e.addLayer = function(n) {
    if (!n)
      return this;
    if (!Array.isArray(n))
      return n = Array.prototype.slice.call(arguments, 0), this.addLayer(n);
    this._layerCache || (this._layerCache = {});
    for (var s = this._layers, o = 0, a = n.length; o < a; o++) {
      var l = n[o], h = l.getId();
      if (W(h))
        throw new Error("Invalid id for the layer: " + h);
      if (l.getMap() !== this) {
        if (this._layerCache[h])
          throw new Error("Duplicate layer id in the map: " + h);
        this._layerCache[h] = l, l._bindMap(this), s.push(l), this._loaded && l.load();
      }
    }
    return this._sortLayersByZIndex(), this._fireEvent("addlayer", {
      layers: n
    }), this;
  }, e.removeLayer = function(n) {
    if (!n)
      return this;
    if (!Array.isArray(n))
      return this.removeLayer([n]);
    for (var s = [], o = 0, a = n.length; o < a; o++) {
      var l = n[o];
      if (l instanceof gr || (l = this.getLayer(l)), !!l) {
        var h = l.getMap();
        if (!(!h || h !== this)) {
          s.push(l), this._removeLayer(l, this._layers), this._loaded && l._doRemove();
          var u = l.getId();
          this._layerCache && delete this._layerCache[u];
        }
      }
    }
    if (s.length > 0) {
      var c = this.getRenderer();
      c && c.setLayerCanvasUpdated(), this.once("frameend", function() {
        s.forEach(function(f) {
          f.fire("remove");
        });
      });
    }
    return this._fireEvent("removelayer", {
      layers: n
    }), this;
  }, e.sortLayers = function(n) {
    if (!n || !Array.isArray(n))
      return this;
    for (var s = [], o = Number.MAX_VALUE, a = 0, l = n.length; a < l; a++) {
      var h = n[a];
      if (De(n[a]) && (h = this.getLayer(h)), !(h instanceof gr) || !h.getMap() || h.getMap() !== this)
        throw new Error("It must be a layer added to this map to order.");
      h.getZIndex() < o && (o = h.getZIndex()), s.push(h);
    }
    for (var u = 0, c = s.length; u < c; u++)
      s[u].setZIndex(o + u);
    return this;
  }, e.toDataURL = function(n) {
    n || (n = {});
    var s = n.mimeType;
    s || (s = "image/png");
    var o = n.save, a = this._getRenderer();
    if (a && a.toDataURL) {
      var l = n.fileName;
      l || (l = "export");
      var h = a.toDataURL(s, n.quality || 0.92);
      if (o && h) {
        var u;
        if (typeof Blob < "u" && typeof atob < "u") {
          var c = Hw(h.replace(/^data:image\/(png|jpeg|jpg|webp);base64,/, ""), s);
          u = URL.createObjectURL(c);
        } else
          u = h;
        var f = document.createElement("a");
        f.download = l, f.href = u, document.body.appendChild(f), f.click(), document.body.removeChild(f);
      }
      return h;
    }
    return null;
  }, e.coordToPoint = function(n, s, o) {
    return this.coordinateToPoint(n, s, o);
  }, e.coordToPointAtRes = function(n, s, o) {
    return this.coordinateToPointAtRes(n, s, o);
  }, e.pointToCoord = function(n, s, o) {
    return this.pointToCoordinate(n, s, o);
  }, e.pointAtResToCoord = function(n, s, o) {
    return this.pointAtResToCoordinate(n, s, o);
  }, e.coordToViewPoint = function(n, s, o) {
    return this.coordinateToViewPoint(n, s, o);
  }, e.viewPointToCoord = function(n, s) {
    return this.viewPointToCoordinate(n, s);
  }, e.coordToContainerPoint = function(n, s, o) {
    return this.coordinateToContainerPoint(n, s, o);
  }, e.containerPointToCoord = function(n, s) {
    return this.containerPointToCoordinate(n, s);
  }, e.containerPointToViewPoint = function(n, s) {
    return s ? s.set(n.x, n.y) : s = n.copy(), s._sub(this.getViewPoint());
  }, e.viewPointToContainerPoint = function(n, s) {
    return s ? s.set(n.x, n.y) : s = n.copy(), s._add(this.getViewPoint());
  }, e.checkSize = function(n) {
    var s = Je() - this._initTime < 1500 && this.width === 0 || this.height === 0, o = this._getContainerDomSize(), a = this.height, l = this.width;
    if (!n && o.width === l && o.height === a)
      return this;
    Ed(this._containerDOM);
    var h = this.getCenter();
    if (this.options.fixCenterOnResize)
      this._updateMapSize(o);
    else {
      var u = this._getVisualHeight(this.getPitch()), c = new Y(0, this.height - u), f = this._containerPointToPrj(c);
      this._updateMapSize(o);
      var d = this._getVisualHeight(this.getPitch()), p = new Y(0, this.height - d);
      this._setPrjCoordAtContainerPoint(f, p), this._mapViewCoord = this._getPrjCenter();
    }
    var g = o.width === 0 || o.height === 0 || l === 0 || a === 0;
    return (s || g) && (this._eventSilence = !0, this.setCenter(h), delete this._eventSilence), this._fireEvent("resize"), this;
  }, e.locate = function(n, s, o) {
    return this.getProjection()._locate(new lt(n), s, o);
  }, e.getMainPanel = function() {
    return this._getRenderer().getMainPanel();
  }, e.getPanels = function() {
    return this._panels;
  }, e.remove = function() {
    var n = this;
    if (this.isRemoved())
      return this;
    this._fireEvent("removestart"), this._removeDomEvents(), this._clearHandlers(), this.removeBaseLayer();
    for (var s = this.getLayers(), o = 0; o < s.length; o++)
      s[o].remove();
    return this._getRenderer() && this._getRenderer().remove(), this._containerDOM.childNodes && this._containerDOM.childNodes.length > 0 && Array.prototype.slice.call(this._containerDOM.childNodes, 0).filter(function(a) {
      return a.className === "maptalks-wrapper";
    }).forEach(function(a) {
      return n._containerDOM.removeChild(a);
    }), delete this._panels, delete this._containerDOM, delete this.renderer, this._fireEvent("removeend"), this._clearAllListeners(), this;
  }, e.isRemoved = function() {
    return !this._containerDOM;
  }, e.isMoving = function() {
    return !!this._moving;
  }, e.onMoveStart = function(n) {
    this._mapAnimPlayer && this._stopAnim(this._mapAnimPlayer);
    var s = this._getPrjCenter();
    (!this._originCenter || this._verifyExtent(s)) && (this._originCenter = s), this._moving = !0, this._trySetCursor("move"), this._fireEvent("movestart", this._parseEvent(n ? n.domEvent : null, "movestart"));
  }, e.onMoving = function(n) {
    this._fireEvent("moving", this._parseEvent(n ? n.domEvent : null, "moving"));
  }, e.onMoveEnd = function(n) {
    if (this._moving = !1, this._suppressRecenter || this._recenterOnTerrain(), this._trySetCursor("default"), this._fireEvent("moveend", n && n.domEvent ? this._parseEvent(n.domEvent, "moveend") : n), !this._verifyExtent(this._getPrjCenter()) && this._originCenter) {
      var s = this._originCenter;
      this._panTo(s);
    }
  }, e.onDragRotateStart = function(n) {
    this._dragRotating = !0, this._fireEvent("dragrotatestart", this._parseEvent(n ? n.domEvent : null, "dragrotatestart"));
  }, e.onDragRotating = function(n) {
    this._fireEvent("dragrotating", this._parseEvent(n ? n.domEvent : null, "dragrotating"));
  }, e.onDragRotateEnd = function(n) {
    this._dragRotating = !1, this._fireEvent("dragrotateend", this._parseEvent(n ? n.domEvent : null, "dragrotateend"));
  }, e.isDragRotating = function() {
    return !!this._dragRotating;
  }, e.isOffscreen = function(n, s) {
    s === void 0 && (s = 0);
    var o = this.width, a = this.height, l = o + s, h = a + s, u = n.xmin, c = n.ymin, f = n.xmax, d = n.ymax;
    return Array.isArray(n) && (u = n[0], c = n[1], f = n[2], d = n[3]), f < s || u >= l || d < s || c > h;
  }, e.getRenderer = function() {
    return this._getRenderer();
  }, e.getDevicePixelRatio = function() {
    return this.options.devicePixelRatio || Ce.devicePixelRatio || 1;
  }, e.setDevicePixelRatio = function(n) {
    return Ut(n) && n > 0 && n !== this.options.devicePixelRatio && (this.options.devicePixelRatio = n, this.checkSize(!0)), this;
  }, e._initContainer = function(n) {
    if (De(n)) {
      if (this._containerDOM = document.getElementById(n), !this._containerDOM)
        throw new Error("Invalid container when creating map: '" + n + "'");
    } else
      this._containerDOM = n, tr && (this.CanvasClass = this._containerDOM.constructor);
    if (this._containerDOM.childNodes && this._containerDOM.childNodes.length > 0 && this._containerDOM.childNodes[0].className === "maptalks-wrapper")
      throw new Error("Container is already loaded with another map instance, use map.remove() to clear it.");
  }, e._trySetCursor = function(n) {
    return !this._cursor && !this._priorityCursor && (n || (n = "default"), this._setCursorToPanel(n)), this;
  }, e._setPriorityCursor = function(n) {
    if (n)
      this._priorityCursor = n, this._setCursorToPanel(n);
    else {
      var s = !1;
      this._priorityCursor && (s = !0), delete this._priorityCursor, s && this.setCursor(this._cursor);
    }
    return this;
  }, e._setCursorToPanel = function(n) {
    var s = this.getMainPanel();
    s && s.style && s.style.cursor !== n && (s.style.cursor = n);
  }, e._removeLayer = function(n, s) {
    if (!(!n || !s)) {
      var o = s.indexOf(n);
      o > -1 && s.splice(o, 1);
    }
  }, e._sortLayersByZIndex = function() {
    if (this._layers) {
      for (var n = 0, s = this._layers.length; n < s; n++)
        this._layers[n]._order = n, this._layers[n].sortLayersByZIndex && this._layers[n].sortLayersByZIndex();
      this._layers.sort(function(o, a) {
        var l = o.getZIndex() - a.getZIndex();
        return l === 0 ? o._order - a._order : l;
      });
    }
  }, e._fireEvent = function(n, s) {
    if (!this._eventSilence) {
      var o = "_";
      n[0] !== o && this.fire(o + n, s), this.fire(n, s);
    }
  }, e._Load = function() {
    this._resetMapStatus(), this.options.pitch && (this.setPitch(this.options.pitch), delete this.options.pitch), this.options.bearing && (this.setBearing(this.options.bearing), delete this.options.bearing), delete this._glRes, this._loadAllLayers(), this._getRenderer().onLoad(), this._loaded = !0, this._callOnLoadHooks(), this._initTime = Je();
  }, e._initRenderer = function() {
    var n = this.options.renderer, s = t.getRendererClass(n);
    this._renderer = new s(this), this._renderer.load();
  }, e._getRenderer = function() {
    return this._renderer;
  }, e._loadAllLayers = function() {
    function n(s) {
      s && s.load();
    }
    this._baseLayer && this._baseLayer.load(), this._eachLayer(n, this.getLayers());
  }, e._getLayers = function(n) {
    for (var s = this._baseLayer ? [this._baseLayer].concat(this._layers) : this._layers, o = [], a = 0; a < s.length; a++)
      (!n || n.call(this, s[a])) && o.push(s[a]);
    return o;
  }, e._eachLayer = function(n) {
    if (!(arguments.length < 2)) {
      var s = Array.prototype.slice.call(arguments, 1);
      s && !Array.isArray(s) && (s = [s]);
      for (var o = [], a = 0, l = s.length; a < l; a++)
        o = o.concat(s[a]);
      for (var h = 0, u = o.length; h < u; h++)
        n.call(n, o[h]);
    }
  }, e._onLayerEvent = function(n) {
    n && n.type === "idchange" && (delete this._layerCache[n.old], this._layerCache[n.new] = n.target);
  }, e._resetMapStatus = function() {
    var n = this.getMaxZoom(), s = this.getMinZoom(), o = this._spatialReference.getMaxZoom(), a = this._spatialReference.getMinZoom();
    (W(n) || n === -1 || n > o) && this.setMaxZoom(o), (W(s) || s === -1 || s < a) && this.setMinZoom(a), n = this.getMaxZoom(), s = this.getMinZoom(), n < s && this.setMaxZoom(s), (W(this._zoomLevel) || this._zoomLevel > n) && (this._zoomLevel = n), this._zoomLevel < s && (this._zoomLevel = s), delete this._prjCenter, delete this._glRes;
    var l = this.getProjection();
    this._prjCenter = l.project(this._center), this._prjCenter.z = this._center.z, this._calcMatrices();
    var h = this._getRenderer();
    h && h.resetContainer();
  }, e._getContainerDomSize = function() {
    if (!this._containerDOM)
      return null;
    var n = this._containerDOM, s, o;
    if (this._containerDomContentRect)
      return s = this._containerDomContentRect.width, o = this._containerDomContentRect.height, new zn(s, o);
    if (!W(n.width) && !W(n.height)) {
      s = n.width, o = n.height;
      var a = this.getDevicePixelRatio();
      a !== 1 && n.layer && (s /= a, o /= a);
    } else if (!W(n.clientWidth) && !W(n.clientHeight))
      s = parseInt(n.clientWidth, 0), o = parseInt(n.clientHeight, 0);
    else
      throw new Error("can not get size of container");
    return new zn(s, o);
  }, e._updateMapSize = function(n) {
    return this.width = n.width, this.height = n.height, this._getRenderer().updateMapSize(n), this._calcMatrices(), this;
  }, e._getPrjCenter = function() {
    return this._prjCenter;
  }, e._setPrjCenter = function(n) {
    this._prjCenter = n, this.isInteracting() && !this.isMoving() && (this._mapViewCoord = n), this._calcMatrices();
  }, e._setPrjCoordAtContainerPoint = function(n, s) {
    if (!this.centerAltitude && s.x === this.width / 2 && s.y === this.height / 2)
      return this;
    var o = this._containerPointToPoint(s)._sub(this._prjToPoint(this._getPrjCenter())), a = this._pointToPrj(this._prjToPoint(n).sub(o));
    return this._setPrjCenter(a), this;
  }, e._setPrjCoordAtOffsetToCenter = function(n, s) {
    var o = this._pointToPrj(this._prjToPoint(n).sub(s));
    return this._setPrjCenter(o), this;
  }, e._verifyExtent = function(n) {
    if (!n)
      return !1;
    var s = this._prjMaxExtent;
    return s ? s.contains(n) : !0;
  }, e._offsetCenterByPixel = function(n) {
    var s = j1.set(this.width / 2 - n.x, this.height / 2 - n.y), o = this._containerPointToPrj(s, qT), a = j1.set(this.width / 2, this.height / 2);
    this._setPrjCoordAtContainerPoint(o, a);
  }, e.offsetPlatform = function(n) {
    return n ? (this._getRenderer().offsetPlatform(n), this._mapViewCoord = this._getPrjCenter(), this._mapViewPoint = this._mapViewPoint.add(n), this) : this._mapViewPoint;
  }, e.getViewPoint = function() {
    var n = this._getViewPointFrameOffset(), s = this.offsetPlatform();
    return n && (s = s.add(n)), s;
  }, e._resetMapViewPoint = function() {
    this._mapViewPoint = new Y(0, 0), this._mapViewCoord = this._getPrjCenter();
  }, e._getResolution = function(n) {
    return (n === void 0 || n === this._zoomLevel) && this._mapRes !== void 0 ? this._mapRes : (W(n) && (n = this._zoomLevel), this._spatialReference.getResolution(n));
  }, e._getResolutions = function() {
    return this._spatialReference.getResolutions();
  }, e._prjToPoint = function(n, s, o) {
    s = W(s) ? this.getZoom() : s;
    var a = this._getResolution(s);
    return this._prjToPointAtRes(n, a, o);
  }, e._prjToPointAtRes = function(n, s, o) {
    return this._spatialReference.getTransformation().transform(n, s, o);
  }, e._prjsToPointsAtRes = function(n, s, o) {
    o === void 0 && (o = []);
    for (var a = this._spatialReference.getTransformation(), l = [], h = 0, u = n.length; h < u; h++) {
      var c = a.transform(n[h], s, o[h]);
      l.push(c);
    }
    return l;
  }, e._pointToPrj = function(n, s, o) {
    s = W(s) ? this.getZoom() : s;
    var a = this._getResolution(s);
    return this._pointToPrjAtRes(n, a, o);
  }, e._pointToPrjAtRes = function(n, s, o) {
    return this._spatialReference.getTransformation().untransform(n, s, o);
  }, e._pointToPoint = function(n, s, o) {
    return W(s) ? (o ? (o.x = n.x, o.y = n.y) : o = n.copy(), o) : this._pointAtResToPoint(n, this._getResolution(s), o);
  }, e._pointAtResToPoint = function(n, s, o) {
    return o ? (o.x = n.x, o.y = n.y) : o = n.copy(), o._multi(s / this._getResolution());
  }, e._pointToPointAtRes = function(n, s, o) {
    return o ? (o.x = n.x, o.y = n.y) : o = n.copy(), o._multi(this._getResolution() / s);
  }, e._containerPointToPrj = function(n, s) {
    return this._pointToPrj(this._containerPointToPoint(n, void 0, s), void 0, s);
  }, e._callOnLoadHooks = function() {
    var n = t.prototype;
    if (n._onLoadHooks)
      for (var s = 0, o = n._onLoadHooks.length; s < o; s++)
        n._onLoadHooks[s].call(this);
  }, e._fixPrjOnWorldWide = function(n) {
    var s = this.getProjection();
    if (s && s.fullExtent && n) {
      var o = s.fullExtent || {}, a = o.left, l = o.bottom, h = o.top, u = o.right;
      Ut(a) && (n.x = Math.max(a, n.x)), Ut(u) && (n.x = Math.min(u, n.x)), Ut(l) && (n.y = Math.max(l, n.y)), Ut(h) && (n.y = Math.min(h, n.y));
    }
    return this;
  }, t;
}(Av(ls(Cv(pi))));
xe.include({
  coordinateToPoint: function(t, e, r) {
    var n = this._getResolution(e);
    return this.coordinateToPointAtRes(t, n, r);
  },
  coordinateToPointAtRes: function() {
    var i = new lt(0, 0);
    return function(t, e, r) {
      var n = this.getProjection().project(t, i);
      return this._prjToPointAtRes(n, e, r);
    };
  }(),
  pointToCoordinate: function() {
    var i = new lt(0, 0);
    return function(t, e, r) {
      var n = this._pointToPrj(t, e, i);
      return this.getProjection().unproject(n, r);
    };
  }(),
  pointAtResToCoordinate: function() {
    var i = new lt(0, 0);
    return function(t, e, r) {
      var n = this._pointToPrjAtRes(t, e, i);
      return this.getProjection().unproject(n, r);
    };
  }(),
  coordinateToViewPoint: function() {
    var i = new lt(0, 0);
    return function(t, e, r) {
      return this._prjToViewPoint(this.getProjection().project(t, i), e, r);
    };
  }(),
  viewPointToCoordinate: function() {
    var i = new lt(0, 0);
    return function(t, e) {
      return this.getProjection().unproject(this._viewPointToPrj(t, i), e);
    };
  }(),
  coordinateToContainerPoint: function(t, e, r) {
    var n = this._getResolution(e);
    return this.coordinateToContainerPointAtRes(t, n, r);
  },
  coordinateToContainerPointAtRes: function() {
    var i = new lt(0, 0);
    return function(t, e, r) {
      var n = this.getProjection().project(t, i);
      return this._prjToContainerPointAtRes(n, e, r);
    };
  }(),
  coordinatesToContainerPoints: function(t, e) {
    var r = this._getResolution(e);
    return this.coordinatesToContainerPointsAtRes(t, r);
  },
  coordinatesToContainerPointsAtRes: /* @__PURE__ */ function() {
    return function(i, t) {
      for (var e = [], r = this._spatialReference.getTransformation(), n = t / this._getResolution(), s = this.getProjection(), o = new lt(0, 0), a = this.isTransforming(), l = this._prjToPoint(this._getPrjCenter(), void 0, qT), h = 0, u = i.length; h < u; h++) {
        var c = s.project(i[h], o), f = r.transform(c, t);
        f = f._multi(n), this._toContainerPoint(f, a, i[h].z, l), e.push(f);
      }
      return e;
    };
  }(),
  containerPointToCoordinate: function() {
    var i = new lt(0, 0);
    return function(t, e) {
      var r = this._containerPointToPrj(t, i);
      return this.getProjection().unproject(r, e);
    };
  }(),
  containerToExtent: function() {
    var i = new Y(0, 0), t = new Y(0, 0);
    return function(e) {
      var r = new Se(this._containerPointToPoint(e.getMin(i), void 0, i), this._containerPointToPoint(e.getMax(t), void 0, t));
      return this._pointToExtent(r);
    };
  }(),
  distanceToPixel: function() {
    var i = new Y(0, 0), t = new Y(0, 0);
    return function(e, r, n) {
      var s = this.getProjection();
      if (!s)
        return null;
      var o = this.getScale() / this.getScale(n), a = this.getCenter(), l = s.locate(a, e, r), h = this.coordToContainerPoint(a, void 0, i), u = this.coordToContainerPoint(l, void 0, t);
      return u._sub(h)._multi(o)._abs(), new zn(u.x, u.y);
    };
  }(),
  distanceToPoint: function(t, e, r, n) {
    var s = this._getResolution(r);
    return this.distanceToPointAtRes(t, e, s, n);
  },
  distanceToPointAtRes: function() {
    var i = new Y(0, 0), t = new lt(0, 0);
    return function(e, r, n, s, o) {
      var a = this.getProjection();
      if (!a)
        return null;
      var l = s || this.getCenter(), h = a.locate(l, e, r, t), u = this.coordToPointAtRes(l, n, i), c = this.coordToPointAtRes(h, n, o);
      return c._sub(u)._abs(), c;
    };
  }(),
  altitudeToPoint: function() {
    var i = new lt(0, 40), t = new Y(0, 0);
    return function(e, r, n) {
      e === void 0 && (e = 0), this._altitudeOriginDirty && (i.x = this._originLng, this._altitudeOriginDirty = !1);
      var s = this.distanceToPointAtRes(e, e, r, n || i, t);
      e < 0 && s.x > 0 && (s.x = -s.x);
      var o = this.options.heightFactor;
      return o && o !== 1 && (s.x *= o, s.y *= o), s.x;
    };
  }(),
  pointAtResToAltitude: function() {
    var i = new lt(0, 40);
    return function(t, e, r) {
      t === void 0 && (t = 0);
      var n = this.pointAtResToDistance(t, 0, e, r || i);
      return n;
    };
  }(),
  pixelToDistance: function() {
    var i = new lt(0, 0), t = new lt(0, 0), e = new lt(0, 0), r = new lt(0, 0);
    return function(n, s) {
      var o = this.getProjection();
      if (!o)
        return null;
      var a = this.getFullExtent(), l = a.top > a.bottom ? -1 : 1, h = i.set(this.width / 2, this.height / 2), u = t.set(this.width / 2 + n, this.height / 2 + l * s), c = this.containerPointToCoord(h, e), f = this.containerPointToCoord(u, r);
      return o.measureLength(c, f);
    };
  }(),
  pointToDistance: function(t, e, r) {
    var n = this.getResolution(r);
    return this.pointAtResToDistance(t, e, n);
  },
  pointAtResToDistance: function() {
    var i = new Y(0, 0), t = new lt(0, 0), e = new lt(0, 0), r = new lt(0, 0);
    return function(n, s, o, a) {
      var l = this.getProjection();
      if (!l)
        return null;
      var h = a ? l.project(a, t) : this._getPrjCenter(), u = this._prjToPointAtRes(h, o, i);
      u._add(n, s);
      var c = this.pointAtResToCoord(u, o, e), f = a || l.unproject(h, r);
      return l.measureLength(f, c);
    };
  }(),
  locateByPoint: function() {
    var i = new Y(0, 0);
    return function(t, e, r) {
      var n = this.coordToContainerPoint(t, void 0, i);
      return this.containerPointToCoord(n._add(e, r));
    };
  }(),
  _get2DExtent: function(t, e) {
    var r;
    if ((t === void 0 || t === this._zoomLevel) && this._mapExtent2D && (r = this._mapExtent2D), r)
      return e ? (e.set(r.xmin, r.ymin, r.xmax, r.ymax), e) : r.copy();
    var n = this._getResolution(t);
    return this._get2DExtentAtRes(n, e);
  },
  _get2DExtentAtRes: function() {
    var i = new Y(0, 0);
    return function(t, e) {
      var r = this;
      if (t === this._mapGlRes && this._mapGlExtent2D)
        return this._mapGlExtent2D;
      var n = this.getContainerExtent();
      return n.convertTo(function(s) {
        return r._containerPointToPointAtRes(s, t, i);
      }, e);
    };
  }(),
  _pointToExtent: function() {
    var i = new lt(0, 0), t = new lt(0, 0);
    return function(e) {
      var r = e.getMin(), n = e.getMax(), s = this.getFullExtent(), o = !s || s.left <= s.right ? [r.x, n.x] : [n.x, r.x], a = o[0], l = o[1], h = !s || s.top > s.bottom ? [n.y, r.y] : [r.y, n.y], u = h[0], c = h[1], f = r.set(a, c), d = n.set(l, u);
      return new dn(this.pointToCoord(f, void 0, i), this.pointToCoord(d, void 0, t), this.getProjection());
    };
  }(),
  _getViewPointFrameOffset: function() {
    var i = new Y(0, 0);
    return function() {
      if (this.isZooming())
        return null;
      var t = this._getPrjCenter();
      return this._mapViewCoord && !this._mapViewCoord.equals(t) ? this._prjToContainerPoint(this._mapViewCoord)._sub(this._prjToContainerPoint(t, void 0, i)) : null;
    };
  }(),
  _viewPointToPrj: function() {
    var i = new Y(0, 0);
    return function(t, e) {
      return this._containerPointToPrj(this.viewPointToContainerPoint(t, i), e);
    };
  }(),
  _prjToContainerPoint: function(t, e, r, n) {
    var s = this._getResolution(e);
    return this._prjToContainerPointAtRes(t, s, r, n);
  },
  _prjToContainerPointAtRes: function() {
    var i = new Y(0, 0);
    return function(t, e, r, n) {
      return this._pointAtResToContainerPoint(this._prjToPointAtRes(t, e, i), e, n || 0, r);
    };
  }(),
  _prjToViewPoint: function() {
    var i = new Y(0, 0);
    return function(t, e, r) {
      var n = this._prjToContainerPoint(t, void 0, i, r);
      return this.containerPointToViewPoint(n, e);
    };
  }(),
  _viewPointToPoint: function() {
    var i = new Y(0, 0);
    return function(t, e, r) {
      return this._containerPointToPoint(this.viewPointToContainerPoint(t, i), e, r);
    };
  }(),
  _pointToViewPoint: function() {
    var i = new lt(0, 0);
    return function(t, e, r) {
      return this._prjToViewPoint(this._pointToPrj(t, e, i), r);
    };
  }()
});
xe.mergeOptions(B5);
var j5 = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.addHooks = function() {
    this.target && this.target.on("_dblclick", this._onDoubleClick, this);
  }, e.removeHooks = function() {
    this.target && this.target.off("_dblclick", this._onDoubleClick, this);
  }, e._onDoubleClick = function(n) {
    var s = this.target;
    if (s.options.doubleClickZoom) {
      var o = s.getZoom(), a = n.domEvent.shiftKey ? Math.ceil(o) - 1 : Math.floor(o) + 1;
      s._zoomAnimation(a, n.containerPoint);
    }
  }, t;
}(Xi);
xe.mergeOptions({
  doubleClickZoom: !0
});
xe.addOnLoadHook("addHandler", "doubleClickZoom", j5);
var G5 = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.addHooks = function() {
    var n = this.target;
    if (n) {
      var s = n._panels.mapWrapper || n._containerDOM;
      this._dragHandler = new Iu(s, {
        cancelOn: this._cancelOn.bind(this),
        rightclick: !0
      }), this._dragHandler.on("mousedown", this._onMouseDown, this).on("dragstart", this._onDragStart, this).on("dragging", this._onDragging, this).on("dragend", this._onDragEnd, this).enable();
    }
  }, e.removeHooks = function() {
    this._dragHandler.off("mousedown", this._onMouseDown, this).off("dragstart", this._onDragStart, this).off("dragging", this._onDragging, this).off("dragend", this._onDragEnd, this), this._dragHandler.remove(), delete this._dragHandler;
  }, e._cancelOn = function(n) {
    return !!(this.target.isZooming() || this._ignore(n));
  }, e._ignore = function(n) {
    return n ? (n.domEvent && (n = n.domEvent), this.target._ignoreEvent(n) || this.target._isEventOutMap(n)) : !1;
  }, e._onMouseDown = function(n) {
    delete this.startDragTime, delete this._mode;
    var s = this.target.options.switchDragButton, o = s ? 0 : 2, a = n.domEvent.type === "touchstart", l = s && a || n.domEvent.button === o || n.domEvent.ctrlKey;
    l ? (this.target.options.dragRotate || this.target.options.dragPitch) && (this._mode = "rotatePitch") : this.target.options.dragPan && (this._mode = "move"), this.target._stopAnim(this.target._mapAnimPlayer), ks(n.domEvent);
  }, e._onDragStart = function(n) {
    this.startDragTime = Je(), this._mode === "move" ? this._moveStart(n) : this._mode === "rotatePitch" && this._rotateStart(n);
  }, e._onDragging = function(n) {
    var s = this.target;
    s._isEventOutMap(n.domEvent) || (this._mode === "move" ? this._moving(n) : this._mode === "rotatePitch" && this._rotating(n));
  }, e._onDragEnd = function(n) {
    this._mode === "move" ? this._moveEnd(n) : this._mode === "rotatePitch" && this._rotateEnd(n), delete this.startDragTime, delete this.startBearing;
  }, e._start = function(n) {
    this.preX = n.mousePos.x, this.preY = n.mousePos.y, this.startX = this.preX, this.startY = this.preY, this._startPrjCenter = this.target._getPrjCenter().copy();
  }, e._moveStart = function(n) {
    this._start(n);
    var s = this.target;
    s.onMoveStart(n);
    var o = ai(s._getActualEvent(n.domEvent), s.getContainer());
    this.startPrjCoord = this._containerPointToPrj(o);
  }, e._moving = function(n) {
    if (this.startDragTime) {
      var s = this.target, o = ai(s._getActualEvent(n.domEvent), s.getContainer()), a = s._prjToPoint(this._containerPointToPrj(o)), l = a._sub(s._prjToPoint(s._getPrjCenter()));
      s._setPrjCoordAtOffsetToCenter(this.startPrjCoord, l), s.onMoving(n);
    }
  }, e._containerPointToPrj = function(n) {
    var s = this.target, o = s._queryTerrainInfo(n);
    if (o) {
      var a = s.getProjection().project(o.coordinate);
      return a.z = o.altitude, a;
    }
    return s._containerPointToPrj(n);
  }, e._moveEnd = function(n) {
    if (this.startDragTime) {
      var s = n.domEvent.type === "touchend", o = this.target, a = Je() - this.startDragTime, l = n.mousePos.x, h = n.mousePos.y, u = l - this.startX, c = h - this.startY, f = o._getPrjCenter(), d = f.sub(this._startPrjCenter);
      if (this._clear(), o.options.panAnimation && !n.interupted && o._verifyExtent(o._getPrjCenter()) && a < 280 && Math.abs(c) + Math.abs(u) > 5) {
        a = 5 * a;
        var p = s ? 5 : 2.8, g = f.add(d._multi(p));
        o._panTo(g, {
          duration: s ? a * 3 : a * 2,
          easing: "outExpo"
        });
      } else
        o.onMoveEnd(n);
    }
  }, e._rotateStart = function(n) {
    this._start(n), delete this._rotateMode, this.startBearing = this.target.getBearing(), this.target.onDragRotateStart(n), this._db = 0;
  }, e._rotating = function(n) {
    var s = this.target, o = n.mousePos.x, a = n.mousePos.y, l = s.getPitch(), h = s.getBearing(), u = Math.abs(o - this.preX), c = Math.abs(a - this.preY);
    if (this._rotateMode || (s.options.dragRotatePitch ? this._rotateMode = "rotate_pitch" : u > c ? this._rotateMode = "rotate" : u < c ? this._rotateMode = "pitch" : this._rotateMode = "rotate"), !(this._rotateMode === "pitch" && l === 0 && c < 10)) {
      if (this._rotateMode.indexOf("rotate") >= 0 && s.options.dragRotate) {
        var f = 0.15, d = 0;
        s.options.dragPitch || u > c ? d = -f * (this.preX - o) : o > s.width / 2 ? d = f * (this.preY - a) : d = -f * (this.preY - a);
        var p = s.getBearing() + d;
        this._db = this._db || 0, this._db += d, s._setBearing(p);
      }
      this._rotateMode.indexOf("pitch") >= 0 && s.options.dragPitch && s._setPitch(s.getPitch() + (this.preY - a) * 0.15), this.preX = o, this.preY = a, (s.getBearing() !== h || s.getPitch() !== l) && s.onDragRotating(n);
    }
  }, e._rotateEnd = function(n) {
    var s = this.target, o = s.getBearing();
    this._clear();
    var a = Je() - this.startDragTime;
    if (s.onDragRotateEnd(n), s.options.rotateAnimation && Math.abs(o - this.startBearing) > 20 && (this._rotateMode === "rotate" || this._rotateMode === "rotate_pitch") && !n.interupted && a < 400) {
      var l = s.getBearing();
      s._animateTo({
        bearing: l + this._db / 1.5
      }, {
        easing: "outQuint",
        duration: 1600
      });
    }
  }, e._clear = function() {
    delete this.startPrjCoord, delete this.preX, delete this.preY, delete this.startX, delete this.startY;
  }, t;
}(Xi);
xe.mergeOptions({
  draggable: !0,
  dragPan: !0,
  dragRotatePitch: !0,
  dragRotate: !0,
  dragPitch: !0
});
xe.addOnLoadHook("addHandler", "draggable", G5);
var V1 = "mousedown mouseup mousemove click dblclick contextmenu touchstart touchmove touchend mouseout", V5 = {
  mousemove: ["mousemove", "mouseover", "mouseout", "mouseenter"],
  touchend: ["touchend", "click"]
}, rc = function(t) {
  return t && t.getLayer && t.on && t.fire;
}, U1 = function(t) {
  return t._getInternalId ? t._getInternalId() : t.getId ? t.getId() : null;
}, ua = function(t, e, r) {
  if (t._onEvent)
    return t._onEvent(e, r);
  var n = t.getLayer();
  return n && n.fireGeoEvent ? n.fireGeoEvent(t, e, r) : null;
}, U5 = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.addHooks = function() {
    var n = this.target, s = n._panels.allLayers || n._containerDOM;
    Cn(s, V1, this._identifyGeometryEvents, this);
  }, e.removeHooks = function() {
    var n = this.target, s = n._panels.allLayers || n._containerDOM;
    Un(s, V1, this._identifyGeometryEvents);
  }, e._identifyGeometryEvents = function(n, s) {
    var o = this.target;
    if (o.isInteracting() || o._ignoreEvent(n))
      return;
    var a = null, l = s || n.type;
    if (Xf(l) && !xs.isTest && lT(this, o.options.mousemoveThrottleTime)) {
      Jr(n);
      return;
    }
    var h = l === "mousedown" || l === "touchstart" && n.touches && n.touches.length === 1;
    if (h)
      this._mouseDownTime = Je();
    else if ((l === "click" || l === "touchend") && this._mouseDownTime) {
      var u = this._mouseDownTime;
      delete this._mouseDownTime;
      var c = Je();
      if (c - u > 300) {
        if (l === "click")
          return;
      } else l === "touchend" && (a = "click");
    }
    var f = n.touches && n.touches.length > 0 ? n.touches[0] : n.changedTouches && n.changedTouches.length > 0 ? n.changedTouches[0] : n;
    if (!f)
      return;
    var d = ai(f, o._containerDOM);
    l === "touchstart" && o.options.preventTouch && ks(n);
    for (var p = null, g = this.target.getRenderer().getTopElements(), m = h && n.button !== 2, v = 0; v < g.length; v++)
      if (g[v].hitTest(d)) {
        var _ = g[v].options.cursor;
        if (_ && (p = _), m || g[v].events && g[v].events.indexOf(l) >= 0) {
          var y = {
            target: o,
            type: l,
            domEvent: n,
            containerPoint: d
          };
          if (m) {
            o._setPriorityCursor(p), g[v].mousedown(y);
            return;
          } else
            g[v].onEvent(y);
        }
      }
    var x = o._getLayers(function(M) {
      return !!(M.identify && M.options.geometryEvents);
    });
    if (!x.length)
      return;
    var w = V5[l] || [l], b = {
      includeInternals: !0,
      filter: function(S) {
        if (S instanceof nn) {
          var P = S._getEventTypeToFire(n);
          return l === "mousemove" ? (!p && S.options.cursor && (p = S.options.cursor), !0) : !(!S.listens(P) && !S.listens(a));
        } else if (rc(S))
          return !0;
        return !1;
      },
      count: 1,
      onlyVisible: o.options.onlyVisibleGeometryEvents,
      containerPoint: d,
      layers: x,
      eventTypes: w,
      domEvent: n
    }, T = A.bind(this);
    Xf(l) ? this._queryIdentifyTimeout = o.getRenderer().callInNextFrame(function() {
      o.isInteracting() || o.identifyAtPoint(b, T);
    }) : o.identifyAtPoint(b, T);
    function A(M) {
      var S = this, P = !0, C = function() {
        var K = S._prevOverGeos && S._prevOverGeos.geos;
        return K || [];
      }, k = function(K, dt) {
        if (K === void 0 && (K = []), dt === void 0 && (dt = {}), K && K.length > 0)
          for (var it = K.length - 1; it >= 0; it--) {
            var st = K[it];
            if (rc(st)) {
              var pt = U1(K[it]);
              dt[pt] || (P = ua(st, n, "mouseout"));
            }
          }
      };
      if (l === "mouseout") {
        var O = C();
        this._prevOverGeos = {
          geos: [],
          geomap: {}
        }, k(O, {});
      } else if (l === "mousemove") {
        var R = {};
        if (M.length > 0)
          for (var I = M.length - 1; I >= 0; I--) {
            var D = M[I];
            if (rc(D)) {
              var z = U1(D);
              R[z] = D, ua(D, n), (!this._prevOverGeos || !this._prevOverGeos.geomap[z]) && ua(D, n, "mouseenter"), P = ua(D, n, "mouseover");
            }
          }
        o._setPriorityCursor(p);
        var H = C();
        this._prevOverGeos = {
          geos: M,
          geomap: R
        }, k(H, R);
      } else {
        if (!M || !M.length)
          return;
        for (var G = M.length - 1; G >= 0; G--)
          if (rc(M[G])) {
            P = ua(M[G], n), a && ua(M[G], n, a);
            break;
          }
      }
      P === !1 && Jr(n);
    }
  }, t;
}(Xi);
xe.mergeOptions({
  geometryEvents: !0,
  onlyVisibleGeometryEvents: !0
});
xe.addOnLoadHook("addHandler", "geometryEvents", U5);
var $1 = 4.000244140625, $5 = 1 / 100, W5 = 1 / 450, Z5 = 2, X5 = function(i) {
  Ot(t, i);
  function t(r) {
    var n;
    return n = i.call(this, r) || this, n._thisScrollZoom = n._scrollZoom.bind(kn(kn(n))), n._wheelZoomRate = W5, n._defaultZoomRate = $5, n._delta = 0, n;
  }
  var e = t.prototype;
  return e.addHooks = function() {
    Gi(this.target._containerDOM, "wheel", this._onWheelScroll, this);
  }, e.removeHooks = function() {
    Ho(this.target._containerDOM, "wheel", this._onWheelScroll);
  }, e._onWheelScroll = function(n) {
    var s = this.target;
    if (s.options.preventWheelScroll && (ks(n), Jr(n)), s._ignoreEvent(n) || s._isEventOutMap(n) || !s.options.zoomable)
      return !1;
    var o = s._containerDOM, a = s._checkZoomOrigin(ai(n, o));
    return s.options.seamlessZoom ? (this._zooming || (this._trackPadSuspect = 0, this._ensureTrackpad = !1), this._seamless(n, a)) : this._interval(n, a);
  }, e._seamless = function(n, s) {
    var o = n.deltaMode === window.WheelEvent.DOM_DELTA_LINE ? n.deltaY * 60 : n.deltaY;
    if (o % $1 !== 0 && (this._ensureTrackpad || (Math.abs(o) < 60 ? this._trackPadSuspect++ : this._trackPadSuspect = 0, this._trackPadSuspect >= 2 && (this._ensureTrackpad = !0)), this._ensureTrackpad && (o *= 14)), n.shiftKey && o && (o = o / 4), this._lastWheelEvent = n, this._delta -= o, !this._zooming && this._delta) {
      var a = this.target;
      this._zoomOrigin = s, a.onZoomStart(null, s);
    }
    this._start();
  }, e._start = function() {
    if (this._delta) {
      this._zooming = !0;
      var n = this.target;
      this._active || (n.getRenderer().callInNextFrame(this._thisScrollZoom), this._active = !0);
    }
  }, e._scrollZoom = function() {
    var n = this;
    if (this._active = !1, !!this._delta) {
      var s = Math.abs(this._delta) > $1 ? this._wheelZoomRate : this._defaultZoomRate, o = Z5 / (1 + Math.exp(-Math.abs(this._delta * s)));
      this._delta < 0 && o !== 0 && (o = 1 / o);
      var a = this.target, l = a.getZoom(), h = a.getZoomForScale(o, l, !0);
      this._delta = 0, a.onZooming(h, this._zoomOrigin), this._timeout && clearTimeout(this._timeout), this._timeout = setTimeout(function() {
        n._zooming = !1, delete n._timeout, a.onZoomEnd(a.getZoom(), n._zoomOrigin);
      }, 210);
    }
  }, e._interval = function(n, s) {
    var o = this, a = this.target;
    if (this._zooming)
      return this._requesting++, !1;
    this._requesting = 0;
    var l = (n.deltaY ? n.deltaY * -1 : n.wheelDelta ? n.wheelDelta : n.detail) > 0 ? 1 : -1;
    n.detail && (l *= -1);
    var h = a.getZoom(), u = h + l;
    if (u = a._checkZoom(l > 0 ? Math.ceil(u) : Math.floor(u)), u === h)
      return !1;
    this._zooming = !0, this._delta || (a.onZoomStart(null, s), this._origin = s, this._delta = l, this._startZoom = a.getZoom());
    var c = 90;
    return a._animateTo({
      zoom: u - this._delta * 1 / 2,
      around: this._origin
    }, {
      continueOnViewChanged: !0,
      easing: "linear",
      duration: c,
      wheelZoom: !0
    }, function(f) {
      if (f.state.playState !== "finished") {
        f.state.playState !== "running" && (delete o._zooming, delete o._requesting);
        return;
      }
      o._requesting < 1 || Math.abs(u - o._startZoom) > 2 || u === a.getMaxZoom() || u === a.getMinZoom() ? (a._animateTo({
        zoom: u,
        around: o._origin
      }, {
        continueOnViewChanged: !0,
        duration: 100
      }, function(d) {
        d.state.playState !== "running" && (delete o._zooming, delete o._requesting);
      }), delete o._startZoom, delete o._origin, delete o._delta, o._requesting = 0) : W(o._requesting) || (delete o._zooming, o._onWheelScroll(n));
    }), !1;
  }, t;
}(Xi);
xe.mergeOptions({
  scrollWheelZoom: !0,
  seamlessZoom: !0
});
xe.addOnLoadHook("addHandler", "scrollWheelZoom", X5);
var q5 = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.addHooks = function() {
    Gi(this.target.getContainer(), "touchstart", this._onTouchStart, this);
  }, e.removeHooks = function() {
    Ho(this.target.getContainer(), "touchstart", this._onTouchStart);
  }, e._onTouchStart = function(n) {
    var s = this.target;
    if (!(!n.touches || n.touches.length < 2)) {
      var o = s.getContainer(), a = ai(n.touches[0], o), l = ai(n.touches[1], o);
      this.preY = a.y, this._startP1 = a, this._startP2 = l, this._startDist = a.distanceTo(l), this._startVector = a.sub(l), this._startZoom = s.getZoom(), this._startBearing = s.getBearing(), Un(document, "touchmove", this._onTouchMove), Un(document, "touchend", this._onTouchEnd), Gi(document, "touchmove", this._onTouchMove, this), Gi(document, "touchend", this._onTouchEnd, this), s.options.preventTouch && ks(n), s._fireEvent("touchactstart");
    }
  }, e._onTouchMove = function(n) {
    var s = this.target;
    if (!(!n.touches || n.touches.length < 2)) {
      var o = s.getContainer(), a = ai(n.touches[0], o), l = ai(n.touches[1], o), h = a.sub(this._startP1), u = l.sub(this._startP2), c = a.sub(l), f = a.distanceTo(l) / this._startDist, d = c.angleWith(this._startVector) * 180 / Math.PI, p = this.preY || a.y, g = (p - a.y) * 0.4;
      this.preY = a.y;
      var m = {
        domEvent: n,
        mousePos: [a, l]
      };
      if (this.mode || (s.options.touchRotate && Math.abs(d) > 8 ? this.mode = s.options.touchZoomRotate ? "rotate_zoom" : "rotate" : s.options.touchPitch && h.y * u.y > 0 && Math.abs(h.y) > 10 && Math.abs(u.y) > 10 ? this.mode = "pitch" : s.options.zoomable && s.options.touchZoom && Math.abs(1 - f) > 0.15 && (this.mode = s.options.touchZoomRotate && s.options.touchRotate ? "rotate_zoom" : "zoom"), this._startTouching(m)), this.mode === "zoom" || this.mode === "rotate_zoom") {
        this._scale = f;
        var v = s._getResolution(this._startZoom) / f, _ = s.getZoomFromRes(v);
        s.onZooming(_, this._Origin);
      }
      this.mode === "rotate" || this.mode === "rotate_zoom" ? (s._setBearing(this._startBearing + d), s.onDragRotating(m)) : this.mode === "pitch" && (s._setPitch(s.getPitch() + g), s.onDragRotating(m)), s._fireEvent("touchactinging");
    }
  }, e._startTouching = function(n) {
    var s = this.target;
    if (this.mode === "zoom" || this.mode === "rotate_zoom") {
      var o = s.getSize();
      this._Origin = new Y(o.width / 2, o.height / 2), s.onZoomStart(null, this._Origin);
    }
    (this.mode === "rotate" || this.mode === "pitch" || this.mode === "rotate_zoom") && s.onDragRotateStart(n);
  }, e._onTouchEnd = function(n) {
    delete this.preY;
    var s = this.target;
    if (Un(document, "touchmove", this._onTouchMove), Un(document, "touchend", this._onTouchEnd), this.mode === "zoom" || this.mode === "rotate_zoom") {
      var o = this._scale, a = s._getResolution(this._startZoom) / o, l = s.getZoomFromRes(a);
      s.onZoomEnd(l, this._Origin);
    }
    (this.mode === "pitch" || this.mode === "rotate" || this.mode === "rotate_zoom") && s.onDragRotateEnd({
      domEvent: n
    }), delete this.mode, s._fireEvent("touchactend");
  }, t;
}(Xi);
xe.mergeOptions({
  touchGesture: !0,
  touchZoom: !0,
  touchPitch: !0,
  touchRotate: !0,
  touchZoomRotate: !1
});
xe.addOnLoadHook("addHandler", "touchGesture", q5);
var ic = "__anim_player", hl = {
  outExpo: function(t) {
    return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
  },
  outQuint: function(t) {
    return 1 - Math.pow(1 - t, 5);
  },
  in: function(t) {
    return Math.pow(t, 2);
  },
  out: function(t) {
    return 1 - hl.in(1 - t);
  },
  inAndOut: function(t) {
    return 3 * t * t - 2 * t * t * t;
  },
  linear: function(t) {
    return t;
  },
  upAndDown: function(t) {
    return t < 0.5 ? hl.inAndOut(2 * t) : 1 - hl.inAndOut(2 * (t - 0.5));
  }
}, Y5 = function() {
  function i(t, e) {
    this.state = t, this.styles = e;
  }
  return k3(i, [{
    key: "playState",
    get: function() {
      return this.state.playState;
    }
  }, {
    key: "symbol",
    get: function() {
      return this.styles.symbol;
    }
  }]), i;
}(), YT = function(t, e, r, n) {
  this._animation = t, this.options = e, this._onFrame = r, this.playState = "idle", this.ready = !0, this.finished = !1, this.target = n;
}, dr = {
  speed: {
    slow: 2e3,
    normal: 1e3,
    fast: 500
  },
  _resolveStyles: function(t) {
    if (!t)
      return null;
    function e(c) {
      if (!Array.isArray(c))
        return dr._resolveStyles(c);
      for (var f = [], d = [], p = [], g = 0; g < c.length; g++) {
        var m = dr._resolveStyles(c[g]);
        m && (f.push(m[0]), d.push(m[1]), p.push(m[2]));
      }
      return f.length ? [f, d, p] : null;
    }
    function r(c) {
      var f = c, d;
      Array.isArray(c) || (Ut(c) ? f = [0, c] : c instanceof Y || c instanceof lt ? (d = c.constructor, f = [new d(0, 0), c]) : f = [c, c]);
      var p = f[0], g = f[1];
      return Ut(p) && Ut(g) ? p === g ? null : [p, g - p, g] : Array.isArray(p) && Ut(p[0]) || p instanceof lt || p instanceof Y ? (Array.isArray(p) ? (p = new lt(p), g = new lt(g)) : (d = p.constructor, p = new d(p), g = new d(g)), p.equals(g) ? null : [p, g.sub(p), g]) : [p, g, g];
    }
    function n(c) {
      return !Array.isArray(c) && c.constructor === Object ? !0 : !!(Array.isArray(c) && c[0].constructor === Object);
    }
    var s = {}, o = {}, a = {};
    for (var l in t)
      if (t.hasOwnProperty(l)) {
        var h = t[l];
        if (h) {
          if (Array.isArray(h) && (W(h[0]) || W(h[1])))
            continue;
        } else continue;
        var u = void 0;
        n(h) ? u = e(h) : u = r(h), u && (o[l] = u[0], s[l] = u[1], a[l] = u[2]);
      }
    return [o, s, a];
  },
  framing: function(t, e) {
    e || (e = {});
    var r = e.easing ? hl[e.easing] : hl.linear;
    r || (r = hl.linear);
    var n, s, o;
    t = dr._resolveStyles(t), t && (s = t[0], n = t[1], o = t[2]);
    var a = function l(h, u, c) {
      if (!u || !c)
        return null;
      var f = {};
      for (var d in c)
        if (c.hasOwnProperty(d)) {
          if (u[d] === o[d]) {
            f[d] = u[d];
            continue;
          }
          var p = u[d], g = c[d];
          if (Ut(g))
            f[d] = p + h * g;
          else if (Array.isArray(g)) {
            for (var m = [], v = 0; v < g.length; v++)
              m.push(l(h, p[v], g[v]));
            f[d] = m;
          } else {
            var _ = g.constructor;
            _ === Object ? f[d] = l(h, p, g) : p instanceof Y || p instanceof lt ? f[d] = p.add(g.multi(h)) : f[d] = g;
          }
        }
      return f;
    };
    return function(l, h) {
      var u, c;
      if (l < 0)
        u = {
          playState: "idle",
          delta: 0
        }, c = s;
      else if (l < h) {
        var f = r(l / h);
        u = {
          playState: "running",
          delta: f
        }, c = a(f, s, n);
      } else
        u = {
          playState: "finished",
          delta: 1
        }, c = o;
      return u.startStyles = s, u.destStyles = o, u.progress = l, u.remainingMs = h - l, new Y5(u, c);
    };
  },
  _requestAnimFrame: function(t) {
    this._frameQueue || (this._frameQueue = []), this._frameQueue.push(t), this._a();
  },
  _a: function() {
    this._animationFrameId || (this._animationFrameId = Cs(dr._frameFn));
  },
  _run: function() {
    if (this._frameQueue.length) {
      var t = this._frameQueue;
      this._frameQueue = [];
      for (var e = 0, r = t.length; e < r; e++)
        t[e]();
      this._frameQueue.length ? this._animationFrameId = Cs(dr._frameFn) : delete this._animationFrameId;
    }
  },
  animate: function(t, e, r, n) {
    e || (e = {});
    var s = dr.framing(t, e), o = new YT(s, e, r, n);
    return o;
  }
};
dr._frameFn = dr._run.bind(dr);
jt(YT.prototype, {
  _prepare: function() {
    var t = this.options, e = t.speed || t.duration;
    De(e) && (e = dr.speed[e], e || (e = +e)), e || (e = dr.speed.normal), this.duration = e, this._framer = t.framer || dr._requestAnimFrame.bind(dr);
  },
  play: function() {
    if (this.playState !== "idle" && this.playState !== "paused" || this.target && this.target[ic])
      return this;
    this.target && (this.target[ic] = 1), this.playState === "idle" && (this.currentTime = 0, this._prepare());
    var t = Je();
    if (!this.startTime) {
      var e = this.options;
      this.startTime = e.startTime ? e.startTime : t;
    }
    return this._playStartTime = Math.max(t, this.startTime), this.playState === "paused" && (this._playStartTime -= this.currentTime), this.playState = "running", this._run(), this;
  },
  pause: function() {
    return this.playState === "paused" ? this : (this.playState = "paused", this._run(), this);
  },
  cancel: function() {
    return this.playState === "idle" ? this : (this.playState = "idle", this.finished = !1, this._run(), this);
  },
  finish: function() {
    return this.playState === "finished" ? this : (this.playState = "finished", this.finished = !0, this._run(), this);
  },
  reverse: function() {
  },
  _run: function() {
    var t = this, e = this._onFrame, r = Je(), n = r - this._playStartTime;
    if (this.options.repeat && n >= this.duration && (this._playStartTime = r, n = 0), this.playState !== "running") {
      if (this.target && delete this.target[ic], e) {
        this.playState === "finished" ? n = this.duration : this.playState === "idle" && (n = 0);
        var s = this._animation(n, this.duration);
        s.state.playState = this.playState, e(s);
      }
      return;
    }
    var o = this._animation(n, this.duration);
    this.playState = o.state.playState, this.playState !== "running" && this.target && delete this.target[ic], this.playState === "idle" ? this.startTime > r && setTimeout(this._run.bind(this), this.startTime - r) : this.playState === "running" ? this._framer(function() {
      t.playState === "running" && (t.currentTime = n, e && e(o), t._run());
    }) : this.playState === "finished" && (this.finished = !0, e && e(o));
  }
});
dr.animate;
var J5 = {
  smoothness: 0,
  enableClip: !0,
  enableSimplify: !0,
  simplifyTolerance: 2,
  symbol: {
    lineColor: "#000",
    lineWidth: 2,
    lineOpacity: 1,
    polygonFill: "#fff",
    polygonOpacity: 1,
    opacity: 1
  }
}, Fd = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.animateShow = function(n, s) {
    var o = this;
    n === void 0 && (n = {}), this._showPlayer && this._showPlayer.finish(), Be(n) && (n = {}, s = n);
    var a = this.getCoordinates();
    if (a.length === 0)
      return this;
    this._animIdx = 0, this._animLenSoFar = 0, this.show();
    var l = !!this.getShell, h = l ? this.getShell().concat(this.getShell()[0]) : a, u = this._getProjection(), c = u.projectCoords(h, this.options.antiMeridian);
    this._prjAniShowCenter = this._getPrjExtent().getCenter(), this._aniShowCenter = u.unproject(this._prjAniShowCenter);
    var f = n.duration || 1e3, d = n.easing || "out";
    this.setCoordinates([]);
    var p = 0;
    c.length && (c[0]._distance = 0);
    for (var g = 1; g < c.length; g++) {
      var m = c[g].distanceTo(c[g - 1]);
      c[g]._distance = m, p += m;
    }
    this._tempCoord = new lt(0, 0), this._tempPrjCoord = new Y(0, 0);
    var v = this._showPlayer = dr.animate({
      t: f
    }, {
      duration: f,
      easing: d
    }, function(_) {
      if (!o.getMap()) {
        if (v.playState !== "finished" && (v.finish(), s)) {
          var y = o.getCoordinates();
          s(_, y[y.length - 1]);
        }
        return;
      }
      var x = o._drawAnimShowFrame(_.styles.t, f, p, h, c);
      _.state.playState === "finished" && (delete o._showPlayer, delete o._aniShowCenter, delete o._prjAniShowCenter, delete o._animIdx, delete o._animLenSoFar, delete o._animTailRatio, delete o._tempCoord, delete o._tempPrjCoord, o.setCoordinates(a)), s && s(_, x);
    }, this);
    return v.play(), v;
  }, e._drawAnimShowFrame = function(n, s, o, a, l) {
    if (n === 0)
      return a[0];
    var h = n / s * o, u = 0, c, f;
    for (c = this._animIdx + 1, f = l.length; c < f && (u = l[c]._distance, !(this._animLenSoFar + u > h)); c++)
      this._animLenSoFar += u;
    if (this._animIdx = c - 1, this._animIdx >= f - 1)
      return this.setCoordinates(a), a[a.length - 1];
    var d = this._animIdx, p = l[d], g = l[d + 1], m = h - this._animLenSoFar, v = m / u;
    this._animTailRatio = v;
    var _ = p.x + (g.x - p.x) * v, y = p.y + (g.y - p.y) * v;
    this._tempPrjCoord.x = _, this._tempPrjCoord.y = y;
    var x = this._tempPrjCoord, w = a[d], b = a[d + 1], T = w.x + (b.x - w.x) * v, A = w.y + (b.y - w.y) * v;
    this._tempCoord.x = T, this._tempCoord.y = A;
    var M = this._tempCoord, S = !!this.getShell;
    if (!S && this.options.smoothness > 0) {
      for (var P = [], C = [], k = 0; k <= this._animIdx; k++)
        P.push(a[k]), C.push(l[k]);
      P.push(M, M), C.push(x, x), this.setCoordinates(P), this._setPrjCoordinates(C);
    } else {
      var O = a.slice(0, this._animIdx + 1);
      O.push(M);
      var R = l.slice(0, this._animIdx + 1);
      R.push(x), S ? (this.setCoordinates([this._aniShowCenter].concat(O)), this._setPrjCoordinates([this._prjAniShowCenter].concat(R))) : (this.setCoordinates(O), this._setPrjCoordinates(R));
    }
    return M;
  }, e._getCenterInExtent = function(n, s, o) {
    var a = this.getExtent();
    if (!n.intersects(a))
      return null;
    var l = o(s, n);
    if (l.length === 0)
      return null;
    var h = 0, u = 0, c = 0;
    l.forEach(function(d) {
      Array.isArray(d) ? d.forEach(function(p) {
        p.point && (p = p.point), h += p.x, u += p.y, c++;
      }) : (d.point && (d = d.point), h += d.x, u += d.y, c++);
    });
    var f = new lt(h, u)._multi(1 / c);
    return f.count = c, f;
  }, e._getPath2DPoints = function(n, s, o) {
    if (!sn(n))
      return [];
    var a = this.getMap(), l = !s && this._shouldSimplify(), h = this.options.simplifyTolerance * a._getResolution(), u = Array.isArray(n[0]);
    if (delete this._simplified, l && !u) {
      var c = n.length;
      n = u3(n, h, !1), this._simplified = n.length < c;
    }
    if (o || (o = a._getResolution()), Array.isArray(n)) {
      var f = [], d = "_glPt";
      if (!Array.isArray(n[0]))
        return f = eu(n, d), a._prjsToPointsAtRes(n, o, f);
      for (var p = [], g = 0, m = n.length; g < m; g++) {
        var v = n[g];
        f = eu(v, d);
        var _ = a._prjsToPointsAtRes(v, o, f);
        p.push(_);
      }
      return p;
    } else
      return a._prjToPointAtRes(n, o);
  }, e._shouldSimplify = function() {
    var n = this.getLayer(), s = n.options.enableAltitude;
    return n && n.options.enableSimplify && !s && this.options.enableSimplify && !this._showPlayer;
  }, e._setPrjCoordinates = function(n) {
    this._prjCoords = n, this.onShapeChanged();
  }, e._getPrjCoordinates = function() {
    return this._verifyProjection(), !this._prjCoords && this._getProjection() && (this._prjCoords = this._projectCoords(this._coordinates)), this._prjCoords;
  }, e._updateCache = function() {
    this._clearCache();
    var n = this._getProjection();
    n && this._prjCoords && (this._coordinates = this._unprojectCoords(this._getPrjCoordinates()));
  }, e._clearProjection = function() {
    this._prjCoords = null, i.prototype._clearProjection.call(this);
  }, e._projectCoords = function(n) {
    var s = this._getProjection();
    return s ? s.projectCoords(n, this.options.antiMeridian) : [];
  }, e._unprojectCoords = function(n) {
    var s = this._getProjection();
    return s ? s.unprojectCoords(n) : [];
  }, e._computeCenter = function() {
    var n = this._coordinates;
    if (!sn(n))
      return null;
    for (var s = 0, o = 0, a = 0, l = n.length, h = 0; h < l; h++)
      n[h] && Ut(n[h].x) && Ut(n[h].y) && (s += n[h].x, o += n[h].y, a++);
    return new lt(s / a, o / a);
  }, e._computeExtent = function() {
    var n = this._coordinates;
    if (!sn(n))
      return null;
    var s = [n];
    return this.hasHoles && this.hasHoles() && s.push.apply(s, this.getHoles()), this._coords2Extent(s, this._getProjection());
  }, e._computePrjExtent = function() {
    var n = [this._getPrjCoordinates()];
    return this.hasHoles && this.hasHoles() && n.push.apply(n, this._getPrjHoles()), this._coords2Extent(n);
  }, e._get2DLength = function() {
    for (var n = this._getPath2DPoints(this._getPrjCoordinates(), !0), s = 0, o = 1, a = n.length; o < a; o++)
      s += n[o].distanceTo(n[o - 1]);
    return s;
  }, e._hitTestTolerance = function() {
    var n = this._getInternalSymbol(), s;
    if (Array.isArray(n)) {
      s = 0;
      for (var o = 0; o < n.length; o++)
        Ut(n[o].lineWidth) && n[o].lineWidth > s && (s = n[o].lineWidth);
    } else
      s = n.lineWidth;
    return i.prototype._hitTestTolerance.call(this) + (Ut(s) ? s / 2 : 1.5);
  }, e._coords2Extent = function(n, s) {
    if (!n || n.length === 0 || Array.isArray(n[0]) && n[0].length === 0)
      return null;
    for (var o = new dn(s), a = 0, l = n.length; a < l; a++)
      for (var h = 0, u = n[a].length; h < u; h++)
        o._combine(n[a][h]);
    return o;
  }, t;
}(nn);
Fd.mergeOptions(J5);
var JT = "Polygon", vn = function(i) {
  Ot(t, i);
  function t(r, n) {
    var s;
    return s = i.call(this, n) || this, s.type = "Polygon", r && s.setCoordinates(r), s;
  }
  var e = t.prototype;
  return e.getOutline = function() {
    var n = this._getPainter();
    if (!n)
      return null;
    var s = this.getExtent();
    return new t(s.toArray(), {
      symbol: {
        lineWidth: 1,
        lineColor: "6b707b"
      }
    });
  }, e.setCoordinates = function(n) {
    if (!n)
      return this._coordinates = null, this._holes = null, this._projectRings(), this;
    var s = lt.toCoordinates(n), o = s.length;
    if (!Array.isArray(s[0]))
      this._coordinates = this._trimRing(s);
    else if (this._coordinates = this._trimRing(s[0]), o > 1) {
      for (var a = [], l = 1; l < o; l++)
        s[l] && a.push(this._trimRing(s[l]));
      this._holes = a;
    } else
      this._holes = null;
    return this._projectRings(), this;
  }, e.getCoordinates = function() {
    if (!this._coordinates)
      return [];
    for (var n = this.getHoles(), s = [this._copyAndCloseRing(this._coordinates)], o = 0, a = n.length; o < a; o++)
      s.push(this._copyAndCloseRing(n[o]));
    return s;
  }, e.getCenterInExtent = function(n) {
    return this._getCenterInExtent(n, this.getShell(), vf);
  }, e.getShell = function() {
    return this._coordinates || [];
  }, e.getHoles = function() {
    return this._holes || [];
  }, e.hasHoles = function() {
    return this.getHoles().length > 0;
  }, e._projectRings = function() {
    if (!this.getMap()) {
      this.onShapeChanged();
      return;
    }
    this._prjCoords = this._projectCoords(this._coordinates), this._prjHoles = this._projectCoords(this._holes), this.onShapeChanged();
  }, e._setPrjCoordinates = function(n) {
    this._prjCoords = n, this.onShapeChanged();
  }, e._cleanRing = function(n) {
    for (var s = n.length - 1; s >= 0; s--)
      n[s] || n.splice(s, 1);
  }, e._checkRing = function(n) {
    if (this._cleanRing(n), !n || !sn(n))
      return !1;
    var s = n[n.length - 1], o = !0;
    return (n[0].x !== s.x || n[0].y !== s.y) && (o = !1), o;
  }, e._trimRing = function(n) {
    var s = this._checkRing(n);
    return sn(n) && s && n.splice(n.length - 1, 1), n;
  }, e._copyAndCloseRing = function(n) {
    n = n.slice(0);
    var s = this._checkRing(n);
    return sn(n) && !s && n.push(n[0].copy()), n;
  }, e._getPrjShell = function() {
    return this.getJSONType() === JT ? this._getPrjCoordinates() : (this._verifyProjection(), this._getProjection() && !this._prjShell && (this._prjShell = this._projectCoords(this._getShell ? this._getShell() : this.getShell())), this._prjShell);
  }, e._getPrjHoles = function() {
    var n = this._getProjection();
    return this._verifyProjection(), n && !this._prjHoles && (this._prjHoles = this._projectCoords(this.getHoles())), this._prjHoles;
  }, e._computeGeodesicLength = function(n) {
    var s = this.getCoordinates();
    if (!sn(s))
      return 0;
    for (var o = 0, a = 0, l = s.length; a < l; a++)
      o += n.measureLength(s[a]);
    return o;
  }, e._computeGeodesicArea = function(n) {
    var s = this.getCoordinates();
    if (!sn(s))
      return 0;
    for (var o = n.measureArea(s[0]), a = 1, l = s.length; a < l; a++)
      o -= n.measureArea(s[a]);
    return o;
  }, e._updateCache = function() {
    i.prototype._updateCache.call(this), this._prjHoles && (this._holes = this._unprojectCoords(this._getPrjHoles()));
  }, e._clearCache = function() {
    return delete this._prjShell, i.prototype._clearCache.call(this);
  }, e._clearProjection = function() {
    this._prjHoles && (this._prjHoles = null), this._prjShell && (this._prjShell = null), i.prototype._clearProjection.call(this);
  }, t;
}(Fd);
vn.registerJSONType(JT);
function Dv(i) {
  return function(t) {
    Ot(e, t);
    function e() {
      return t.apply(this, arguments) || this;
    }
    var r = e.prototype;
    return r.getCoordinates = function() {
      return this._coordinates;
    }, r.setCoordinates = function(s) {
      var o = s instanceof lt ? s : new lt(s);
      if (this._coordinates = o, !this.getMap())
        return this._dirtyCoords = !0, this.onPositionChanged(), this;
      var a = this._getProjection();
      return this._setPrjCoordinates(a.project(this._coordinates)), this;
    }, r._getCenter2DPoint = function(s) {
      var o = this.getMap();
      if (!o)
        return null;
      var a = this._getPrjCoordinates();
      return a ? (s || (s = o._getResolution()), o._prjToPointAtRes(a, s)) : null;
    }, r._getPrjCoordinates = function() {
      var s = this._getProjection();
      return this._verifyProjection(), !this._pcenter && s && this._coordinates && (this._pcenter = s.project(this._coordinates)), this._pcenter;
    }, r._setPrjCoordinates = function(s) {
      this._pcenter = s, this.onPositionChanged();
    }, r._updateCache = function() {
      this._clearCache();
      var s = this._getProjection();
      this._pcenter && s && (this._coordinates = s.unproject(this._pcenter));
    }, r._clearProjection = function() {
      this._pcenter = null, t.prototype._clearProjection.call(this);
    }, r._computeCenter = function() {
      return this._coordinates ? this._coordinates.copy() : null;
    }, e;
  }(i);
}
var W1 = new Se(), K5 = {
  symbol: {
    markerType: "path",
    markerPath: [{
      path: "M8 23l0 0 0 0 0 0 0 0 0 0c-4,-5 -8,-10 -8,-14 0,-5 4,-9 8,-9l0 0 0 0c4,0 8,4 8,9 0,4 -4,9 -8,14z M3,9 a5,5 0,1,0,0,-0.9Z",
      fill: "#DE3333"
    }],
    markerPathWidth: 16,
    markerPathHeight: 23,
    markerWidth: 24,
    markerHeight: 34
  },
  hitTestForEvent: !1,
  collision: !0
}, xn = function(i) {
  Ot(t, i);
  function t(r, n) {
    var s;
    return s = i.call(this, n) || this, s.type = "Point", s.isPoint = !0, r && s.setCoordinates(r), s;
  }
  var e = t.prototype;
  return e.getOutline = function() {
    var n = this.getCoordinates(), s = this.getContainerExtent(), o = this.getMap().coordToContainerPoint(n);
    return new t(n, {
      symbol: {
        markerType: "square",
        markerWidth: s.getWidth(),
        markerHeight: s.getHeight(),
        markerLineWidth: 1,
        markerLineColor: "6b707b",
        markerFill: "rgba(0, 0, 0, 0)",
        markerDx: s.xmin - (o.x - s.getWidth() / 2),
        markerDy: s.ymin - (o.y - s.getHeight() / 2)
      }
    });
  }, e.setSymbol = function() {
    var n;
    delete this._fixedExtent;
    for (var s = arguments.length, o = new Array(s), a = 0; a < s; a++)
      o[a] = arguments[a];
    return (n = i.prototype.setSymbol).call.apply(n, [this].concat(o));
  }, e._getSizeSymbol = function(n) {
    for (var s = {}, o = !1, a = !1, l = 0; l < Hp.length; l++) {
      var h = n[Hp[l]];
      W(h) || (!o && _n(h) && (o = !0, a = !0), s[Hp[l]] = h);
    }
    for (var u = 0; u < Bp.length; u++) {
      var c = n[Bp[u]];
      W(c) || (!o && _n(c) && (o = !0), s[Bp[u]] = c);
    }
    var f;
    return o ? (f = Vf(s, this), a && (f._dynamic = !0)) : f = s, f;
  }, e._setExternSymbol = function(n) {
    return this._symbol || delete this._fixedExtent, i.prototype._setExternSymbol.call(this, n);
  }, e._isDynamicSize = function() {
    return this._sizeSymbol && this._sizeSymbol._dynamic;
  }, e._getFixedExtent = function() {
    if (this._fixedExtent && !this._isDynamicSize())
      return this._fixedExtent;
    this._fixedExtent = this._fixedExtent || new Se(), this._fixedExtent.set(null, null, null, null);
    var n = this._sizeSymbol;
    if (!n)
      return this._fixedExtent;
    var s = this.getLayer() && this.getLayer().getRenderer(), o = s && s.resources, a = this.getTextDesc();
    if (Array.isArray(n)) {
      W1.set(1 / 0, 1 / 0, -1 / 0, -1 / 0);
      for (var l = 0; l < n.length; l++)
        n[l] && this._fixedExtent._combine(Km(W1, n[l], o, a && a[l]));
    } else
      this._fixedExtent = Km(this._fixedExtent, n, o, a);
    return this._fixedExtent;
  }, e._isVectorMarker = function() {
    var n = this._getInternalSymbol();
    return Array.isArray(n) ? !1 : Qf(n);
  }, e._canEdit = function() {
    var n = this._getInternalSymbol();
    return Array.isArray(n) ? !1 : Qf(n) || Ov(n) || Ev(n);
  }, e._containsPoint = function(n, s) {
    var o = this.getContainerExtent();
    return s && (o = o.expand(s)), o.contains(n) ? this.options.hitTestForEvent ? i.prototype._containsPoint.call(this, n, s) : !0 : !1;
  }, e._computeExtent = function() {
    return Z1.call(this, "getCenter");
  }, e._computePrjExtent = function() {
    return Z1.call(this, "_getPrjCoordinates");
  }, e._computeGeodesicLength = function() {
    return 0;
  }, e._computeGeodesicArea = function() {
    return 0;
  }, e._getSprite = function(n, s) {
    return this._getPainter() ? this._getPainter().getSprite(n, s) : new Iv(this).getSprite(n, s);
  }, t;
}(Dv(nn));
xn.mergeOptions(K5);
xn.registerJSONType("Marker");
function Z1(i) {
  var t = this[i]();
  return t ? new dn(t, t, this._getProjection()) : null;
}
var Q5 = {
  arrowStyle: null,
  arrowPlacement: "vertex-last"
}, Tn = function(i) {
  Ot(t, i);
  function t(r, n) {
    var s;
    return s = i.call(this, n) || this, s.type = "LineString", r && s.setCoordinates(r), s;
  }
  var e = t.prototype;
  return e.getOutline = function() {
    return vn.prototype.getOutline.call(this);
  }, e.setCoordinates = function(n) {
    return n ? (this._coordinates = lt.toCoordinates(n), this.getMap() ? this._setPrjCoordinates(this._projectCoords(this._coordinates)) : this.onShapeChanged(), this) : (this._coordinates = null, this._setPrjCoordinates(null), this);
  }, e.getCoordinates = function() {
    return this._coordinates || [];
  }, e.getCenterInExtent = function(n) {
    return this._getCenterInExtent(n, this.getCoordinates(), mf);
  }, e._computeGeodesicLength = function(n) {
    return n.measureLength(this.getCoordinates());
  }, e._computeGeodesicArea = function() {
    return 0;
  }, t;
}(Fd);
Tn.mergeOptions(Q5);
Tn.registerJSONType("LineString");
var tO = new Se(), ou = function(i) {
  Ot(t, i);
  function t(r, n) {
    var s;
    return s = i.call(this, n) || this, s.type = "GeometryCollection", s.setGeometries(r), s;
  }
  var e = t.prototype;
  return e.getContainerExtent = function(n) {
    var s = n || new Se();
    return this.forEach(function(o) {
      s._combine(o.getContainerExtent(tO));
    }), s;
  }, e.setGeometries = function(n) {
    for (var s = this._checkGeometries(n || []), o = this._getSymbol(), a = this.config(), l = this.getProperties(), h = s.length - 1; h >= 0; h--)
      s[h]._initOptions(a), s[h]._setParent(this), s[h]._setEventParent(this), o && s[h].setSymbol(o), l && s[h].setProperties(l);
    return this._geometries = s, this.getLayer() && (this._bindGeometriesToLayer(), this.onShapeChanged()), this;
  }, e.getGeometries = function() {
    return this._geometries || [];
  }, e.forEach = function(n, s) {
    for (var o = this.getGeometries(), a = 0, l = o.length; a < l; a++)
      o[a] && (s ? n.call(s, o[a], a) : n(o[a], a));
    return this;
  }, e.filter = function(n, s) {
    if (!n)
      return new t();
    var o = [], a = Be(n), l = a ? n : pv(n);
    return this.forEach(function(h) {
      var u = a ? h : Bm(h);
      (s ? l.call(s, u) : l(u)) && o.push(h);
    }, this), new t(o);
  }, e.translate = function(n) {
    if (!n)
      return this;
    if (this.isEmpty())
      return this;
    var s = arguments;
    return this.forEach(function(o) {
      o && o.translate && o.translate.apply(o, s);
    }), this;
  }, e.isEmpty = function() {
    return !sn(this.getGeometries());
  }, e.remove = function() {
    return this.forEach(function(n) {
      n._unbind();
    }), nn.prototype.remove.apply(this, arguments);
  }, e.show = function() {
    return this.options.visible = !0, this.forEach(function(n) {
      n.show();
    }), this;
  }, e.hide = function() {
    return this.options.visible = !1, this.forEach(function(n) {
      n.hide();
    }), this;
  }, e.onConfig = function(n) {
    this.forEach(function(s) {
      s.config(n);
    });
  }, e.getSymbol = function() {
    var n = i.prototype.getSymbol.call(this);
    if (!n) {
      var s = [], o = !1;
      this.forEach(function(a) {
        var l = a.getSymbol();
        l && !o && (o = !0), s.push(a.getSymbol());
      }), o && (n = {
        children: s
      });
    }
    return n;
  }, e.setSymbol = function(n) {
    var s = this;
    if (n && n.children)
      this._symbol = null, this.forEach(function(a, l) {
        a._eventSymbolProperties = s._eventSymbolProperties, a.setSymbol(n.children[l]);
      });
    else {
      var o = this._prepareSymbol(n);
      this._symbol = o, this.forEach(function(a) {
        a._eventSymbolProperties = s._eventSymbolProperties, a.setSymbol(o);
      });
    }
    return this.onSymbolChanged(), this;
  }, e._setExternSymbol = function(n) {
    return n = this._prepareSymbol(n), this._externSymbol = n, this.forEach(function(s) {
      s._setExternSymbol(n);
    }), this.onSymbolChanged(), this;
  }, e._bindLayer = function() {
    i.prototype._bindLayer.apply(this, arguments), this._bindGeometriesToLayer();
  }, e._bindGeometriesToLayer = function() {
    var n = this.getLayer();
    this.forEach(function(s) {
      s._bindLayer(n);
    });
  }, e._checkGeometries = function(n) {
    var s = "The geometry added to collection is invalid.";
    n = Array.isArray(n) ? n : [n];
    for (var o = [], a = 0, l = n.length; a < l; a++) {
      var h = n[a];
      if (h) {
        if (!this._checkGeo(h)) {
          console.error(s + " Index: " + a);
          continue;
        }
        if (eO(h)) {
          console.error(h, " is GeometryCollection sub class,it Cannot be placed in GeometryCollection");
          continue;
        }
        o.push(h);
      }
    }
    return o;
  }, e._checkGeo = function(n) {
    return n instanceof nn;
  }, e._updateCache = function() {
    this._clearCache(), !this.isEmpty() && this.forEach(function(n) {
      n && n._updateCache && n._updateCache();
    });
  }, e._removePainter = function() {
    this._painter && this._painter.remove(), delete this._painter, this.forEach(function(n) {
      n._removePainter();
    });
  }, e._computeCenter = function(n) {
    if (!n || this.isEmpty())
      return null;
    for (var s = 0, o = 0, a = 0, l = this.getGeometries(), h = 0, u = l.length; h < u; h++)
      if (l[h]) {
        var c = l[h]._computeCenter(n);
        c && (s += c.x, o += c.y, a++);
      }
    return a === 0 ? null : new lt(s / a, o / a);
  }, e._containsPoint = function(n, s) {
    if (this.isEmpty())
      return !1;
    delete this._pickGeometryIndex;
    for (var o = this.getGeometries(), a = 0, l = o.length; a < l; a++)
      if (o[a]._containsPoint(n, s))
        return this._pickGeometryIndex = a, !0;
    return !1;
  }, e._hitTestTolerance = function() {
    for (var n = this.getGeometries(), s = 0, o = 0, a = n.length; o < a; o++) {
      var l = n[o]._hitTestTolerance();
      s = Math.max(s, l);
    }
    return s;
  }, e._computeExtent = function(n) {
    return X1.call(this, n, "_computeExtent");
  }, e._computePrjExtent = function(n) {
    return X1.call(this, n, "_computePrjExtent");
  }, e._computeGeodesicLength = function(n) {
    if (!n || this.isEmpty())
      return 0;
    for (var s = this.getGeometries(), o = 0, a = 0, l = s.length; a < l; a++)
      s[a] && (o += s[a]._computeGeodesicLength(n));
    return o;
  }, e._computeGeodesicArea = function(n) {
    if (!n || this.isEmpty())
      return 0;
    for (var s = this.getGeometries(), o = 0, a = 0, l = s.length; a < l; a++)
      s[a] && (o += s[a]._computeGeodesicArea(n));
    return o;
  }, e._exportGeoJSONGeometry = function() {
    var n = [];
    if (!this.isEmpty())
      for (var s = this.getGeometries(), o = 0, a = s.length; o < a; o++)
        s[o] && n.push(s[o]._exportGeoJSONGeometry());
    return {
      type: "GeometryCollection",
      geometries: n
    };
  }, e._toJSON = function(n) {
    n = jt({}, n);
    var s = {
      type: "Feature",
      geometry: {
        type: "GeometryCollection",
        geometries: this.getGeometries().filter(function(l) {
          return l && l._toJSON;
        }).map(function(l) {
          var h = l._toJSON();
          return h.subType ? h : l._exportGeoJSONGeometry();
        })
      }
    }, o = this.getId();
    W(o) || (s.id = o);
    var a;
    return (W(n.properties) || n.properties) && (a = this._exportProperties()), s.properties = a, n.feature = s, n;
  }, e._clearProjection = function() {
    if (!this.isEmpty())
      for (var n = this.getGeometries(), s = 0, o = n.length; s < o; s++)
        n[s] && n[s]._clearProjection();
  }, e._getConnectPoints = function() {
    var n = this.getExtent(), s = [new lt(n.xmin, n.ymax), new lt(n.xmax, n.ymin), new lt(n.xmin, n.ymin), new lt(n.xmax, n.ymax)];
    return s;
  }, e._getExternalResources = function() {
    if (this.isEmpty())
      return [];
    for (var n = this.getGeometries(), s = [], o = {}, a, l, h, u = 0, c = n.length; u < c; u++)
      if (n[u]) {
        a = n[u]._getInternalSymbol(), l = Ou(a);
        for (var f = 0, d = l.length; f < d; f++)
          h = l[f].join(), o[h] || (s.push(l[f]), o[h] = 1);
      }
    return s;
  }, e.startEdit = function(n) {
    var s = this;
    if (this.isEmpty())
      return this;
    n || (n = {}), n.symbol && (this._originalSymbol = this.getSymbol(), this.setSymbol(n.symbol)), this._draggbleBeforeEdit = this.options.draggable, this.config("draggable", !1);
    for (var o = this.getGeometries(), a = 0, l = o.length; a < l; a++)
      o[a].startEdit(n);
    this._editing = !0;
    var h = this.getLayer(), u = h && h.options.renderer === "canvas";
    return u && this.hide(), setTimeout(function() {
      s.fire("editstart");
    }, 1), this;
  }, e.endEdit = function() {
    if (this.isEmpty())
      return this;
    for (var n = this.getGeometries(), s = 0, o = n.length; s < o; s++)
      n[s].endEdit();
    return this._originalSymbol && (this.setSymbol(this._originalSymbol), delete this._originalSymbol), this._editing = !1, this.show(), this.config("draggable", this._draggbleBeforeEdit), this.fire("editend"), this;
  }, e.isEditing = function() {
    return !!this._editing;
  }, t;
}(nn);
ou.registerJSONType("GeometryCollection");
function X1(i, t) {
  if (this.isEmpty())
    return null;
  for (var e = new dn(), r = this.getGeometries(), n = 0, s = r.length; n < s; n++)
    if (r[n]) {
      var o = r[n][t](i);
      o && e._combine(o);
    }
  return e;
}
function eO(i) {
  return i instanceof ou;
}
var KT = function(i) {
  Ot(t, i);
  function t(r, n, s, o) {
    var a;
    return a = i.call(this, null, o) || this, a.GeometryType = r, a.type = n, a._initData(s), a;
  }
  var e = t.prototype;
  return e.getCoordinates = function() {
    for (var n = [], s = this.getGeometries(), o = 0, a = s.length; o < a; o++) {
      var l = s[o];
      n.push(l.getShell && l.getJSONType() !== "Polygon" ? [l.getShell()] : l.getCoordinates());
    }
    return n;
  }, e.setCoordinates = function(n) {
    n = n || [];
    for (var s = [], o = 0, a = n.length; o < a; o++) {
      var l = new this.GeometryType(n[o], this.config());
      s.push(l);
    }
    return this.setGeometries(s), this;
  }, e._initData = function(n) {
    n = n || [], n.length && (n[0] instanceof this.GeometryType ? this.setGeometries(n) : this.setCoordinates(n));
  }, e._checkGeo = function(n) {
    return n instanceof this.GeometryType;
  }, e._exportGeoJSONGeometry = function() {
    var n = this.getCoordinates(), s = lt.toNumberArrays(n);
    return {
      type: this.getType(),
      coordinates: s
    };
  }, e._toJSON = function(n) {
    return {
      feature: this.toGeoJSON(n)
    };
  }, t;
}(ou), jo = function(i) {
  Ot(t, i);
  function t(r, n) {
    return i.call(this, xn, "MultiPoint", r, n) || this;
  }
  var e = t.prototype;
  return e.findClosest = function(n) {
    if (!n)
      return null;
    var s = this.getCoordinates(), o = null, a = 1 / 0;
    return s.forEach(function(l) {
      var h = nO(l, n);
      h < a && (o = l, a = h);
    }), o;
  }, t;
}(KT);
jo.registerJSONType("MultiPoint");
function nO(i, t) {
  var e = t.x - i.x, r = t.y - i.y;
  return Math.sqrt(e * e + r * r);
}
var QT = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.getCenterInExtent = function(n) {
    var s = this.getGeometries(), o = 0, a = 0, l = 0;
    return s.forEach(function(h) {
      var u = h.getCenterInExtent(n);
      u && (o += u.x * u.count, a += u.y * u.count, l += u.count);
    }), l === 0 ? null : new lt(o, a)._multi(1 / l);
  }, t;
}(KT), Go = function(i) {
  Ot(t, i);
  function t(e, r) {
    return i.call(this, Tn, "MultiLineString", e, r) || this;
  }
  return t;
}(QT);
Go.registerJSONType("MultiLineString");
var Vo = function(i) {
  Ot(t, i);
  function t(e, r) {
    return i.call(this, vn, "MultiPolygon", e, r) || this;
  }
  return t;
}(QT);
Vo.registerJSONType("MultiPolygon");
var rO = {
  Marker: xn,
  LineString: Tn,
  Polygon: vn,
  MultiPoint: jo,
  MultiLineString: Go,
  MultiPolygon: Vo
}, tA = "geojson-fetch-worker-page-async", iO = `
function (exports) {
    const resultMap = {};

    function handleResult(msg, postResponse) {
        const data = msg.data || {};
        const { taskId } = data;
        const features = resultMap[taskId];
        if (!features) {
            postResponse('not find geojson dataset the taskId:' + taskId);
            return;
        }
        if (features.length === 0) {
            delete resultMap[taskId];
            postResponse(null, []);
            return;
        }
        const pageSize = data.pageSize || 2000;
        const pageFeatures = features.slice(0, pageSize);
        resultMap[taskId] = features.slice(pageSize, Infinity);
        postResponse(null, pageFeatures);
    }
    //worker init
    exports.initialize = function () {
        // console.log("geojson fetch init");
    };
    //recive message
    exports.onmessage = function (msg, postResponse) {
        const { taskId, type, url } = msg.data || {};
        if (!taskId) {
            postResponse('not find task id for get geojson dataset,taskId=' + taskId);
            return;
        }
        if (type === 'fetchdata') {
            if (!url) {
                postResponse('url is null,url=' + url);
                return;
            }
            fetch(url).then(res => res.json()).then(geojson => {
                let features;
                if (Array.isArray(geojson)) {
                    features = geojson;
                } else if (geojson.features) {
                    features = geojson.features;
                } else {
                    features = [geojson];
                }
                resultMap[taskId] = features;
                handleResult(msg, postResponse);
            }).catch(errror => {
                postResponse(errror.message);
            });
        } else if (type === 'pagefeatures') {
            handleResult(msg, postResponse);
        } else {
            postResponse('not support task type:' + type);
        }
    };
}`, sO = function(i) {
  Ot(t, i);
  function t() {
    return i.call(this, tA) || this;
  }
  var e = t.prototype;
  return e._sendMsg = function(n, s, o) {
    var a = this;
    this.send(n, [], function(l, h) {
      l ? o(l) : a._pageFeatures(n, h, s, o);
    }, n.workerId);
  }, e._fetchGeoJSON = function(n, s, o, a) {
    o === void 0 && (o = []);
    var l = jt({}, s);
    l.type = "fetchdata", l.url = n, this._sendMsg(l, o, a);
  }, e._pageFeatures = function(n, s, o, a) {
    if (o.push(s), s.length === 0) {
      a(null, o);
      return;
    }
    var l = jt({}, n);
    l.type = "pagefeatures", this._sendMsg(l, o, a);
  }, t;
}(Id);
il(tA, function() {
  return iO;
});
var sc, wi = {
  toGeometry: function(t, e) {
    if (De(t) && (t = tu(t)), Array.isArray(t)) {
      for (var r = [], n = 0, s = t.length; n < s; n++) {
        var o = wi._convert(t[n], e);
        Array.isArray(o) ? Ui(r, o) : r.push(o);
      }
      return r;
    } else {
      var a = wi._convert(t, e);
      return a;
    }
  },
  toGeometryAsync: function(t, e, r) {
    return r === void 0 && (r = 2e3), De(t) && (t = tu(t)), new ru(function(n) {
      var s = [];
      if (t && (Array.isArray(t) || Array.isArray(t.features))) {
        var o = Ut(r) ? Math.round(r) : 2e3, a = t.features || t, l = Math.ceil(a.length / o), h = 1, u = function() {
          var d = (h - 1) * o, p = h * o, g = a.slice(d, p), m = wi.toGeometry(g, e);
          return h++, m;
        };
        PE({
          count: l,
          run: u
        }).then(function(f) {
          for (var d = 0, p = f.length; d < p; d++) {
            var g = f[d];
            g && (Array.isArray(g) ? Ui(s, g) : s.push(g));
          }
          n(s);
        });
      } else {
        var c = wi.toGeometry(t, e);
        n(c);
      }
    });
  },
  _convert: function(t, e) {
    if (!t || W(t.type))
      return null;
    var r = t.type;
    if (r === "Feature") {
      var n = t.geometry, s = wi._convert(n);
      return s ? (s.setId(t.id), s.setProperties(t.properties), e && e(s), s) : null;
    } else if (r === "FeatureCollection") {
      var o = t.features;
      return o ? wi.toGeometry(o, e) : null;
    } else if (["Point", "LineString", "Polygon", "MultiPoint", "MultiLineString", "MultiPolygon"].indexOf(r) >= 0) {
      var a = r === "Point" ? "Marker" : r, l = new rO[a](t.coordinates);
      return e && e(l), l;
    } else if (r === "GeometryCollection") {
      var h = t.geometries;
      if (!sn(h)) {
        var u = new ou();
        return e && e(u), u;
      }
      for (var c = [], f = h.length, d = 0; d < f; d++)
        h[d].subType ? c.push(nn.getJSONClass(h[d].subType).fromJSON(h[d])) : c.push(wi._convert(h[d]));
      var p = new ou(c);
      return e && e(p), p;
    }
    return null;
  },
  _isGeoJSON: function(t) {
    if (!t)
      return !1;
    if (t = t || {}, Array.isArray(t) && t.length)
      return wi.isGeoJSON(t[0]);
    var e = t.type;
    if (!e || Ew.indexOf(e) === -1)
      return !1;
    var r = t, n = r.features, s = r.geometries, o = r.geometry, a = r.coordinates;
    if (a && Array.isArray(a) || Array.isArray(s) || Array.isArray(n))
      return !0;
    if (o) {
      var l = o.coordinates;
      if (l && Array.isArray(l))
        return !0;
    }
    return !1;
  },
  fetch: function(t, e) {
    return e === void 0 && (e = 2e3), new ru(function(r, n) {
      if (!t || !De(t)) {
        n("url is error,It should be string");
        return;
      }
      var s = jt({
        pageSize: 2e3
      }, {
        pageSize: e
      });
      t = Md(t), sc || (sc = new sO());
      var o = sc.workers.length, a = Math.floor(Math.random() * o);
      a = Math.min(o - 1, a), s.workerId = a, s.taskId = Dw(), sc._fetchGeoJSON(t, s, [], function(l, h) {
        if (l) {
          n(l);
          return;
        }
        var u = [];
        h.forEach(function(c) {
          for (var f = 0, d = c.length; f < d; f++)
            u.push(c[f]);
        }), r({
          type: "FeatureCollection",
          features: u
        });
      });
    });
  }
}, oO = {
  numberOfShellPoints: 60
}, Pi = function(i) {
  Ot(t, i), t.fromJSON = function(n) {
    var s = n.feature, o = new t(n.coordinates, n.radius, n.options);
    return o.setProperties(s.properties), o;
  };
  function t(r, n, s) {
    var o;
    return o = i.call(this, null, s) || this, r && o.setCoordinates(r), o._radius = n, o;
  }
  var e = t.prototype;
  return e.getRadius = function() {
    return this._radius;
  }, e.setRadius = function(n) {
    return this._radius = n, this.onShapeChanged(), this;
  }, e.getShell = function() {
    for (var n = this._getMeasurer(), s = this.getCoordinates(), o = this.options.numberOfShellPoints, a = this.getRadius(), l = [], h, u, c, f = 0, d = o - 1; f < d; f++) {
      h = 360 * f / d * Math.PI / 180, u = a * Math.cos(h), c = a * Math.sin(h);
      var p = n.locate(s, u, c);
      p.z = s.z, l.push(p);
    }
    return l.push(l[0]), l;
  }, e.getHoles = function() {
    return [];
  }, e.animateShow = function() {
    return this.show();
  }, e._containsPoint = function(n, s) {
    var o = this.getMap();
    if (o.getPitch())
      return i.prototype._containsPoint.call(this, n, s);
    var a = o._pointToContainerPoint(this._getCenter2DPoint()), l = this.getSize(), h = this._hitTestTolerance() + (s || 0), u = a.add(l.width / 2, l.height / 2);
    return LT(n, a, u, h);
  }, e._computePrjExtent = function(n) {
    var s = this._getMinMax(n);
    if (!s)
      return null;
    var o = this._getPrjCoordinates(), a = s.map(function(f) {
      return n.project(f);
    }), l = a[0].x - o.x, h = a[1].x - o.x, u = a[2].y - o.y, c = a[3].y - o.y;
    return new dn(o.add(l, u), o.add(h, c));
  }, e._computeExtent = function(n) {
    var s = this._getMinMax(n);
    return s ? new dn(s[0].x, s[2].y, s[1].x, s[3].y, this._getProjection()) : null;
  }, e._getMinMax = function(n) {
    if (!n || !this._coordinates || W(this._radius))
      return null;
    var s = this._radius, o = n.locate(this._coordinates, -s, 0), a = n.locate(this._coordinates, s, 0), l = n.locate(this._coordinates, 0, s), h = n.locate(this._coordinates, 0, -s);
    return [o, a, l, h];
  }, e._computeGeodesicLength = function() {
    return W(this._radius) ? 0 : Math.PI * 2 * this._radius;
  }, e._computeGeodesicArea = function() {
    return W(this._radius) ? 0 : Math.PI * Math.pow(this._radius, 2);
  }, e._exportGeoJSONGeometry = function() {
    var n = lt.toNumberArrays([this.getShell()]);
    return {
      type: "Polygon",
      coordinates: n
    };
  }, e._toJSON = function(n) {
    var s = this.getCenter(), o = jt({}, n);
    o.geometry = !1;
    var a = this.toGeoJSON(o);
    return a.geometry = {
      type: "Polygon"
    }, {
      feature: a,
      subType: "Circle",
      coordinates: [s.x, s.y],
      radius: this.getRadius()
    };
  }, t;
}(Dv(vn));
Pi.mergeOptions(oO);
Pi.registerJSONType("Circle");
var aO = {
  numberOfShellPoints: 81
}, as = function(i) {
  Ot(t, i), t.fromJSON = function(n) {
    var s = n.feature, o = new t(n.coordinates, n.width, n.height, n.options);
    return o.setProperties(s.properties), o;
  };
  function t(r, n, s, o) {
    var a;
    return a = i.call(this, null, o) || this, r && a.setCoordinates(r), a.width = n, a.height = s, a;
  }
  var e = t.prototype;
  return e.getWidth = function() {
    return this.width;
  }, e.setWidth = function(n) {
    return this.width = n, this.onShapeChanged(), this;
  }, e.getHeight = function() {
    return this.height;
  }, e.setHeight = function(n) {
    return this.height = n, this.onShapeChanged(), this;
  }, e.getShell = function() {
    return this.isRotated() ? this.getRotatedShell() : this._getShell();
  }, e._getShell = function() {
    for (var n = this._getMeasurer(), s = this.getCoordinates(), o = this.options.numberOfShellPoints - 1, a = this.getWidth(), l = this.getHeight(), h = [], u = Math.pow(a / 2, 2) * Math.pow(l / 2, 2), c = Math.pow(a / 2, 2), f = Math.pow(l / 2, 2), d, p, g, m, v = 0; v < o; v++) {
      d = 360 * v / o, p = d * Math.PI / 180, g = Math.sqrt(u / (c * Math.pow(Math.tan(p), 2) + f)), m = Math.sqrt(u / (f * Math.pow(1 / Math.tan(p), 2) + c)), d > 90 && d < 270 && (g *= -1), d > 180 && d < 360 && (m *= -1);
      var _ = n.locate(s, g, m);
      _.z = s.z, h.push(_);
    }
    return h.push(h[0].copy()), h;
  }, e._getPrjShell = function() {
    var n = i.prototype._getPrjShell.call(this);
    return this._rotatePrjCoordinates(n);
  }, e.getHoles = function() {
    return [];
  }, e.animateShow = function() {
    return this.show();
  }, e._containsPoint = function(n, s) {
    var o = this.getMap();
    if (o.isTransforming())
      return i.prototype._containsPoint.call(this, n, s);
    var a = o.getProjection(), l = this._hitTestTolerance() + (s || 0), h = a.projectCoords([this._coordinates, o.locate(this._coordinates, this.getWidth() / 2, this.getHeight() / 2)], this.options.antiMeridian), u = o._prjToContainerPoint(h[0]), c = o._prjToContainerPoint(h[1]);
    return LT(n, u, c, l);
  }, e._computePrjExtent = function() {
    return this.isRotated() ? this._computeRotatedPrjExtent() : Pi.prototype._computePrjExtent.apply(this, arguments);
  }, e._computeExtent = function() {
    return Pi.prototype._computeExtent.apply(this, arguments);
  }, e._getMinMax = function(n) {
    if (!n || !this._coordinates || W(this.width) || W(this.height))
      return null;
    var s = this.getWidth(), o = this.getHeight(), a = n.locate(this._coordinates, -s / 2, 0), l = n.locate(this._coordinates, s / 2, 0), h = n.locate(this._coordinates, 0, -o / 2), u = n.locate(this._coordinates, 0, o / 2);
    return [a, l, h, u];
  }, e._computeGeodesicLength = function() {
    if (W(this.width) || W(this.height))
      return 0;
    var n = this.width > this.height ? this.width : this.height;
    return 2 * Math.PI * n / 2 - 4 * Math.abs(this.width - this.height);
  }, e._computeGeodesicArea = function() {
    return W(this.width) || W(this.height) ? 0 : Math.PI * this.width * this.height / 4;
  }, e._exportGeoJSONGeometry = function() {
    var n = lt.toNumberArrays([this.getShell()]);
    return {
      type: "Polygon",
      coordinates: n
    };
  }, e._toJSON = function(n) {
    var s = jt({}, n), o = this.getCenter();
    s.geometry = !1;
    var a = this.toGeoJSON(s);
    return a.geometry = {
      type: "Polygon"
    }, {
      feature: a,
      subType: "Ellipse",
      coordinates: [o.x, o.y],
      width: this.getWidth(),
      height: this.getHeight()
    };
  }, t;
}(Dv(vn));
as.mergeOptions(aO);
as.registerJSONType("Ellipse");
var Fo = function(i) {
  Ot(t, i), t.fromJSON = function(n) {
    var s = n.feature, o = new t(n.coordinates, n.width, n.height, n.options);
    return o.setProperties(s.properties), o;
  };
  function t(r, n, s, o) {
    var a;
    return a = i.call(this, null, o) || this, r && a.setCoordinates(r), a._width = n, a._height = s, a;
  }
  var e = t.prototype;
  return e.getCoordinates = function() {
    return this._coordinates;
  }, e.setCoordinates = function(n) {
    if (this._coordinates = n instanceof lt ? n : new lt(n), !this._coordinates || !this.getMap())
      return this.onPositionChanged(), this;
    var s = this._getProjection();
    return this._setPrjCoordinates(s.project(this._coordinates)), this;
  }, e.getWidth = function() {
    return this._width;
  }, e.setWidth = function(n) {
    return this._width = n, this.onShapeChanged(), this;
  }, e.getHeight = function() {
    return this._height;
  }, e.setHeight = function(n) {
    return this._height = n, this.onShapeChanged(), this;
  }, e.getShell = function() {
    return this.isRotated() ? this.getRotatedShell() : this._getShell();
  }, e._getShell = function() {
    var n = this._getMeasurer(), s = this._coordinates, o = this.getMap(), a = 1, l = -1;
    if (o) {
      var h = o.getFullExtent();
      h.left > h.right && (a = -1), h.bottom > h.top && (l = 1);
    }
    var u = [];
    u.push(s);
    var c = n.locate(s, a * this._width, 0);
    c.z = s.z, u.push(c);
    var f = n.locate(s, a * this._width, l * this._height);
    f.z = s.z, u.push(f);
    var d = n.locate(s, 0, l * this._height);
    return u.push(d), d.z = s.z, u.push(s), u;
  }, e.getHoles = function() {
    return [];
  }, e.animateShow = function() {
    return this.show();
  }, e._getPrjCoordinates = function() {
    var n = this._getProjection();
    return this._verifyProjection(), !this._pnw && n && this._coordinates && (this._pnw = n.project(this._coordinates)), this._pnw;
  }, e._setPrjCoordinates = function(n) {
    this._pnw = n, this.onPositionChanged();
  }, e._getPrjShell = function() {
    var n = i.prototype._getPrjShell.call(this), s = this._getProjection();
    if (!s.isSphere())
      return this._rotatePrjCoordinates(n);
    for (var o = s.getSphereExtent(), a = o.sx, l = o.sy, h = this._getProjection().getCircum(), u = n[0], c = 1, f = n.length; c < f; c++) {
      var d = n[c], p = 0, g = 0;
      a * (u.x - d.x) > 0 && (p = h.x * a), l * (u.y - d.y) < 0 && (g = h.y * l), n[c]._add(p, g);
    }
    return this._rotatePrjCoordinates(n);
  }, e._updateCache = function() {
    this._clearCache();
    var n = this._getProjection();
    this._pnw && n && (this._coordinates = n.unproject(this._pnw));
  }, e._clearProjection = function() {
    this._pnw = null, i.prototype._clearProjection.call(this);
  }, e._computeCenter = function(n) {
    return n.locate(this._coordinates, this._width / 2, -this._height / 2);
  }, e._containsPoint = function(n, s) {
    var o = this.getMap();
    if (o.isTransforming())
      return i.prototype._containsPoint.call(this, n, s);
    var a = W(s) ? this._hitTestTolerance() : s, l = o._getResolution() * a, h = this._getPrjExtent().expand(l), u = o._containerPointToPrj(n);
    return h.contains(u);
  }, e._computePrjExtent = function(n) {
    if (this.isRotated())
      return this._computeRotatedPrjExtent();
    var s = this._getSouthEast(n);
    if (!s)
      return null;
    var o = n.projectCoords([new lt(this._coordinates.x, s.y), new lt(s.x, this._coordinates.y)], this.options.antiMeridian);
    return new dn(o[0], o[1]);
  }, e._computeExtent = function(n) {
    var s = this._getSouthEast(n);
    return s ? new dn(this._coordinates, s, this._getProjection()) : null;
  }, e._getSouthEast = function(n) {
    if (!n || !this._coordinates || W(this._width) || W(this._height))
      return null;
    var s = this.getWidth(), o = this.getHeight(), a = s, l = -o;
    if (n.fullExtent) {
      var h = n.fullExtent, u = h.right > h.left ? 1 : -1, c = h.top > h.bottom ? 1 : -1;
      a *= u, l *= c;
    }
    var f = n.locate(this._coordinates, a, 0), d = n.locate(this._coordinates, 0, l);
    return f.y = d.y, f;
  }, e._computeGeodesicLength = function() {
    return W(this._width) || W(this._height) ? 0 : 2 * (this._width + this._height);
  }, e._computeGeodesicArea = function() {
    return W(this._width) || W(this._height) ? 0 : this._width * this._height;
  }, e._exportGeoJSONGeometry = function() {
    var n = lt.toNumberArrays([this.getShell()]);
    return {
      type: "Polygon",
      coordinates: n
    };
  }, e._toJSON = function(n) {
    var s = jt({}, n), o = this.getCoordinates();
    s.geometry = !1;
    var a = this.toGeoJSON(s);
    return a.geometry = {
      type: "Polygon"
    }, {
      feature: a,
      subType: "Rectangle",
      coordinates: [o.x, o.y],
      width: this.getWidth(),
      height: this.getHeight()
    };
  }, t;
}(vn);
Fo.registerJSONType("Rectangle");
var lO = {
  numberOfShellPoints: 60
}, Ko = function(i) {
  Ot(t, i), t.fromJSON = function(n) {
    var s = n.feature, o = new t(n.coordinates, n.radius, n.startAngle, n.endAngle, n.options);
    return o.setProperties(s.properties), o;
  };
  function t(r, n, s, o, a) {
    var l;
    return l = i.call(this, r, n, a) || this, l.startAngle = s, l.endAngle = o, l;
  }
  var e = t.prototype;
  return e.getStartAngle = function() {
    return this.startAngle;
  }, e.setStartAngle = function(n) {
    return this.startAngle = n, this.onShapeChanged(), this;
  }, e.getEndAngle = function() {
    return this.endAngle;
  }, e.setEndAngle = function(n) {
    return this.endAngle = n, this.onShapeChanged(), this;
  }, e.getShell = function() {
    return this.isRotated() ? this.getRotatedShell() : this._getShell();
  }, e._getShell = function() {
    for (var n = this._getMeasurer(), s = this.getCoordinates(), o = this.options.numberOfShellPoints - 2, a = this.getRadius(), l = [s.copy()], h = this.getStartAngle(), u = this.getEndAngle() - h, c, f, d, p = 0; p < o; p++) {
      c = (u * p / (o - 1) + h) * Math.PI / 180, f = a * Math.cos(c), d = a * Math.sin(c);
      var g = n.locate(s, f, d);
      g.z = s.z, l.push(g);
    }
    return l.push(s.copy()), l;
  }, e.getRotateOffsetAngle = function() {
    return 90;
  }, e._getPrjShell = function() {
    var n = i.prototype._getPrjShell.call(this);
    return this._rotatePrjCoordinates(n);
  }, e._computePrjExtent = function() {
    return this.isRotated() ? this._computeRotatedPrjExtent() : Pi.prototype._computePrjExtent.apply(this, arguments);
  }, e._containsPoint = function(n, s) {
    var o = this.getMap();
    if (o.isTransforming())
      return i.prototype._containsPoint.call(this, n, s);
    var a = o._pointToContainerPoint(this._getCenter2DPoint()), l = this._hitTestTolerance() + (s || 0), h = this.getSize(), u = a, c = n, f = c.x - u.x, d = u.y - c.y, p = Math.atan2(d, f), g = p < 0 ? (p + 2 * Math.PI) * 360 / (2 * Math.PI) : p * 360 / (2 * Math.PI), m = this.startAngle % 360, v = this.endAngle % 360, _ = !1;
    return m > v ? _ = !(g > v && g < m) : _ = g >= m && g <= v, c.distanceTo(u) <= h.width / 2 + l && _;
  }, e._computeGeodesicLength = function() {
    return W(this._radius) ? 0 : Math.PI * 2 * this._radius * Math.abs(this.startAngle - this.endAngle) / 360 + 2 * this._radius;
  }, e._computeGeodesicArea = function() {
    return W(this._radius) ? 0 : Math.PI * Math.pow(this._radius, 2) * Math.abs(this.startAngle - this.endAngle) / 360;
  }, e._toJSON = function(n) {
    var s = jt({}, n), o = this.getCenter();
    s.geometry = !1;
    var a = this.toGeoJSON(s);
    return a.geometry = {
      type: "Polygon"
    }, {
      feature: a,
      subType: "Sector",
      coordinates: [o.x, o.y],
      radius: this.getRadius(),
      startAngle: this.getStartAngle(),
      endAngle: this.getEndAngle()
    };
  }, t;
}(Pi);
Ko.mergeOptions(lO);
Ko.registerJSONType("Sector");
var hO = {
  enableSimplify: !1,
  enableClip: !1
}, Fu = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e._arc = function(n, s, o) {
    for (var a = this.options.arcDegree * Math.PI / 180, l = 1, h = s.length; l < h; l++) {
      var u = Ct._arcBetween(n, s[l - 1], s[l], a), c = [s[l - 1].x + s[l].x - u[0], s[l - 1].y + s[l].y - u[1]];
      s[l - 1].nextCtrlPoint = c, s[l].prevCtrlPoint = c, Ct._stroke(n, o);
    }
  }, e._quadraticCurve = function(n, s) {
    if (s.length <= 2) {
      Ct._path(n, s);
      return;
    }
    var o, a;
    for (o = 2, a = s.length; o < a; o += 2)
      n.quadraticCurveTo(s[o - 1].x, s[o - 1].y, s[o].x, s[o].y);
    if (o -= 1, o < a)
      for (; o < a; o++)
        n.lineTo(s[o].x, s[o].y);
  }, e._bezierCurve = function(n, s) {
    if (s.length <= 3) {
      Ct._path(n, s);
      return;
    }
    var o, a;
    for (o = 1, a = s.length; o + 2 < a; o += 3)
      n.bezierCurveTo(s[o].x, s[o].y, s[o + 1].x, s[o + 1].y, s[o + 2].x, s[o + 2].y);
    if (o < a)
      for (; o < a; o++)
        n.lineTo(s[o].x, s[o].y);
  }, e._getCurveArrowPoints = function(n, s, o, a, l, h) {
    var u = s.length, c;
    for (c = h; c < u; c += h) {
      var f = this._getArrowShape(s[c - 1], s[c], o, a, l);
      f && n.push(f);
    }
    if (c -= h, c < u - 1)
      for (c += 1; c < u; c++) {
        var d = this._getArrowShape(s[c - 1], s[c], o, a, l);
        d && n.push(d);
      }
  }, t;
}(Tn);
Fu.mergeOptions(hO);
var uO = {
  arcDegree: 90
}, Ld = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e._toJSON = function(n) {
    return {
      feature: this.toGeoJSON(n),
      subType: "ArcCurve"
    };
  }, e._paintOn = function(n, s, o) {
    n.beginPath(), this._arc(n, s, o), Ct._stroke(n, o), this._paintArrow(n, s, o);
  }, t.fromJSON = function(n) {
    var s = n.feature, o = new t(s.geometry.coordinates, n.options);
    return o.setProperties(s.properties), o;
  }, t;
}(Fu);
Ld.registerJSONType("ArcCurve");
Ld.mergeOptions(uO);
var eA = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  t.fromJSON = function(n) {
    var s = n.feature, o = new t(s.geometry.coordinates, n.options);
    return o.setProperties(s.properties), o;
  };
  var e = t.prototype;
  return e._toJSON = function(n) {
    return {
      feature: this.toGeoJSON(n),
      subType: "CubicBezierCurve"
    };
  }, e._paintOn = function(n, s, o) {
    n.beginPath(), n.moveTo(s[0].x, s[0].y), this._bezierCurve(n, s), Ct._stroke(n, o), this._paintArrow(n, s, o);
  }, e._getArrowPoints = function(n, s, o, a, l) {
    return this._getCurveArrowPoints(n, s, o, a, l, 3);
  }, t;
}(Fu);
eA.registerJSONType("CubicBezierCurve");
var nA = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  t.fromJSON = function(n) {
    var s = n.feature, o = new t(s.geometry.coordinates, n.options);
    return o.setProperties(s.properties), o;
  };
  var e = t.prototype;
  return e._toJSON = function(n) {
    return {
      feature: this.toGeoJSON(n),
      subType: "QuadBezierCurve"
    };
  }, e._paintOn = function(n, s, o) {
    n.beginPath(), n.moveTo(s[0].x, s[0].y), this._quadraticCurve(n, s, o), Ct._stroke(n, o), this._paintArrow(n, s, o);
  }, e._getArrowPoints = function(n, s, o, a, l) {
    return this._getCurveArrowPoints(n, s, o, a, l, 2);
  }, t;
}(Fu);
nA.registerJSONType("QuadBezierCurve");
var cO = {
  textFaceName: "monospace",
  textSize: 12,
  textLineSpacing: 8,
  textWrapCharacter: `
`,
  textHorizontalAlignment: "middle",
  textVerticalAlignment: "middle"
}, fO = {
  markerType: "square",
  markerLineColor: "#000",
  markerLineWidth: 2,
  markerLineOpacity: 1,
  markerFill: "#fff",
  markerOpacity: 1
}, Fv = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.getContent = function() {
    return this._content;
  }, e.setContent = function(n) {
    var s = this._content;
    return this._content = Cd(n), this._refresh(), this._fireEvent("contentchange", {
      old: s,
      new: n
    }), this;
  }, e.onAdd = function() {
    this._refresh();
  }, e.toJSON = function() {
    var n = i.prototype.toJSON.call(this);
    return delete n.symbol, n;
  }, e.setSymbol = function(n) {
    if (this._refreshing || !n)
      return i.prototype.setSymbol.call(this, n);
    var s = this._parseSymbol(n);
    if (this.setTextStyle) {
      var o = this.getTextStyle() || {};
      o.symbol = s[0], this.setTextStyle(o);
    } else this.setTextSymbol && this.setTextSymbol(s[0]);
    if (this.setBoxStyle) {
      var a = this.getBoxStyle() || {};
      a.symbol = s[1], this.setBoxStyle(a);
    } else this.setBoxSymbol && this.setBoxSymbol(s[1]);
    return this;
  }, e._parseSymbol = function(n) {
    var s = {}, o = {};
    for (var a in n)
      Fl(n, a) && (a.indexOf("text") === 0 ? s[a] = n[a] : o[a] = n[a]);
    return [s, o];
  }, e._getTextSize = function(n) {
    return yv(this._content, n).size;
  }, e._getInternalSymbol = function() {
    return this._symbol;
  }, e._getDefaultTextSymbol = function() {
    return jt({}, cO);
  }, e._getDefaultBoxSymbol = function() {
    return jt({}, fO);
  }, e._getDefaultPadding = function() {
    return [12, 8];
  }, t;
}(xn), dO = {
  textStyle: {
    wrap: !0,
    padding: [12, 8],
    verticalAlignment: "middle",
    horizontalAlignment: "middle"
  },
  boxSymbol: null
}, td = function(i) {
  Ot(t, i);
  function t(r, n, s, o, a) {
    var l;
    return a === void 0 && (a = {}), l = i.call(this, n, a) || this, l._content = Cd(r), l._width = W(s) ? 100 : s, l._height = W(o) ? 40 : o, a.boxSymbol && l.setBoxSymbol(a.boxSymbol), a.textStyle && l.setTextStyle(a.textStyle), l._refresh(), l;
  }
  var e = t.prototype;
  return e.getWidth = function() {
    return this._width;
  }, e.setWidth = function(n) {
    return this._width = n, this._refresh(), this;
  }, e.getHeight = function() {
    return this._height;
  }, e.setHeight = function(n) {
    return this._height = n, this._refresh(), this;
  }, e.getBoxSymbol = function() {
    return jt({}, this.options.boxSymbol);
  }, e.setBoxSymbol = function(n) {
    return this.options.boxSymbol = n && jt({}, n), this.getSymbol() && this._refresh(), this;
  }, e.getTextStyle = function() {
    return this.options.textStyle ? jt({}, this.options.textStyle) : null;
  }, e.setTextStyle = function(n) {
    return this.options.textStyle = n && jt({}, n), this.getSymbol() && this._refresh(), this;
  }, t.fromJSON = function(n) {
    var s = n.feature, o = new t(n.content, s.geometry.coordinates, n.width, n.height, n.options);
    return o.setProperties(s.properties), o.setId(s.id), n.symbol && o.setSymbol(n.symbol), o;
  }, e._toJSON = function(n) {
    return {
      feature: this.toGeoJSON(n),
      width: this.getWidth(),
      height: this.getHeight(),
      subType: "TextBox",
      content: this._content
    };
  }, e._refresh = function() {
    var n = this.getTextStyle() || {}, s = n.padding || [12, 8], o, a;
    if (_n(this._width)) {
      o = JSON.parse(JSON.stringify(this._width));
      var l = o.stops;
      if (l)
        for (var h = 0; h < l.length; h++)
          l[h][1] = l[h][1] - 2 * s[0];
    } else
      o = this._width - 2 * s[0];
    if (_n(this._height)) {
      a = JSON.parse(JSON.stringify(this._height));
      var u = a.stops;
      if (u)
        for (var c = 0; c < u.length; c++)
          u[c][1] = u[c][1] - 2 * s[1];
    } else
      a = this._height - 2 * s[1];
    var f = jt({}, n.symbol || this._getDefaultTextSymbol(), this.options.boxSymbol || this._getDefaultBoxSymbol(), {
      textName: this._content,
      markerWidth: this._width,
      markerHeight: this._height,
      textHorizontalAlignment: "middle",
      textVerticalAlignment: "middle",
      textMaxWidth: o,
      textMaxHeight: a
    });
    n.wrap && !f.textWrapWidth && (f.textWrapWidth = o);
    var d = n.horizontalAlignment;
    f.textDx = f.markerDx || 0;
    var p;
    if (_n(this._width)) {
      p = JSON.parse(JSON.stringify(this._width));
      var g = p.stops;
      if (g)
        for (var m = 0; m < g.length; m++)
          g[m][1] = g[m][1] / 2 - s[0], d === "left" && (g[m][1] *= -1);
    } else
      p = f.markerWidth / 2 - s[0], d === "left" && (p *= -1);
    d === "left" ? (f.textHorizontalAlignment = "right", f.textDx = p) : d === "right" && (f.textHorizontalAlignment = "left", f.textDx = p);
    var v = n.verticalAlignment;
    f.textDy = f.markerDy || 0;
    var _;
    if (_n(this._height)) {
      _ = JSON.parse(JSON.stringify(this._height));
      var y = _.stops;
      if (y)
        for (var x = 0; x < y.length; x++)
          y[x][1] = y[x][1] / 2 - s[1], v === "top" && (y[x][1] *= -1);
    } else
      _ = f.markerHeight / 2 - s[1], v === "top" && (_ *= -1);
    v === "top" ? (f.textVerticalAlignment = "bottom", f.textDy = _) : v === "bottom" && (f.textVerticalAlignment = "top", f.textDy = _), this._refreshing = !0, this.updateSymbol(f), delete this._refreshing;
  }, e.startEdit = function(n) {
    var s = this._getCompiledSymbol();
    if (_n(this._width)) {
      var o = s.markerWidth;
      this._oldWidth = this._width, this.setWidth(o);
    }
    if (_n(this._height)) {
      var a = s.markerHeight;
      this._oldHeight = this._height, this.setHeight(a);
    }
    i.prototype.startEdit.call(this, n);
  }, e.endEdit = function() {
    var n = this.getMap(), s = n && n.getZoom();
    if (this._oldWidth) {
      for (var o = this._width, a = Gf(this._oldWidth), l = a(s), h = o / l, u = this._oldWidth.stops, c = 0; c < u.length; c++)
        u[c][1] *= h;
      this.setWidth(this._oldWidth), delete this._oldWidth;
    }
    if (this._oldHeight) {
      for (var f = this._height, d = Gf(this._oldHeight), p = d(s), g = f / p, m = this._oldHeight.stops, v = 0; v < m.length; v++)
        m[v][1] *= g;
      this.setHeight(this._oldHeight), delete this._oldHeight;
    }
    i.prototype.endEdit.call(this);
  }, t;
}(Fv);
td.mergeOptions(dO);
td.registerJSONType("TextBox");
var pO = {
  boxStyle: null,
  textSymbol: null
}, ul = function(i) {
  Ot(t, i);
  function t(r, n, s) {
    var o;
    return s === void 0 && (s = {}), o = i.call(this, n, s) || this, s.textSymbol && o.setTextSymbol(s.textSymbol), s.boxStyle && o.setBoxStyle(s.boxStyle), o._content = Cd(r), o._refresh(), o;
  }
  var e = t.prototype;
  return e.getBoxStyle = function() {
    return this.options.boxStyle ? jt({}, this.options.boxStyle) : null;
  }, e.setBoxStyle = function(n) {
    return this.options.boxStyle = n && jt({}, n), this._refresh(), this;
  }, e.getTextSymbol = function() {
    return jt({}, this._getDefaultTextSymbol(), this.options.textSymbol);
  }, e.setTextSymbol = function(n) {
    return this.options.textSymbol = n && jt({}, n), this._refresh(), this;
  }, t.fromJSON = function(n) {
    var s = n.feature, o = new t(n.content, s.geometry.coordinates, n.options);
    return o.setProperties(s.properties), o.setId(s.id), n.symbol && o.setSymbol(n.symbol), o;
  }, e._canEdit = function() {
    return !1;
  }, e._toJSON = function(n) {
    return {
      feature: this.toGeoJSON(n),
      subType: "Label",
      content: this._content
    };
  }, e._refresh = function() {
    var n = jt({}, this.getTextSymbol(), {
      textName: this._content
    }), s = this.getBoxStyle();
    if (s) {
      jt(n, s.symbol);
      var o = this._getBoxSize(n), a = o[1], l = s.padding || this._getDefaultPadding(), h = o[0];
      n.markerWidth = h.width, n.markerHeight = h.height;
      var u = n.textDx || 0, c = n.textDy || 0, f = Es(a, n.textHorizontalAlignment, n.textVerticalAlignment)._add(u, c), d = s.horizontalAlignment || "middle";
      n.markerDx = f.x, d === "left" ? n.markerDx += n.markerWidth / 2 - l[0] : d === "right" ? n.markerDx -= n.markerWidth / 2 - a.width - l[0] : n.markerDx += a.width / 2;
      var p = s.verticalAlignment || "middle";
      n.markerDy = f.y, p === "top" ? n.markerDy += n.markerHeight / 2 - l[1] : p === "bottom" ? n.markerDy -= n.markerHeight / 2 - a.height - l[1] : n.markerDy += a.height / 2;
    }
    this._refreshing = !0, this.updateSymbol(n), delete this._refreshing;
  }, e._getBoxSize = function(n) {
    n.markerType || (n.markerType = "square");
    var s = this.getBoxStyle(), o = this._getTextSize(n), a, l, h = s.padding || this._getDefaultPadding();
    return a = o.width + h[0] * 2, l = o.height + h[1] * 2, s.minWidth && (!a || a < s.minWidth) && (a = s.minWidth), s.minHeight && (!l || l < s.minHeight) && (l = s.minHeight), [new zn(a, l), o];
  }, t;
}(Fv);
ul.mergeOptions(pO);
ul.registerJSONType("Label");
var rA = function(t) {
  return function(e) {
    Ot(r, e);
    function r() {
      return e.apply(this, arguments) || this;
    }
    r._hasConnectors = function(o) {
      return !W(o.__connectors) && o.__connectors.length > 0;
    }, r._getConnectors = function(o) {
      return o.__connectors;
    };
    var n = r.prototype;
    return n.getConnectSource = function() {
      return this._connSource;
    }, n.setConnectSource = function(o) {
      var a = this._connTarget;
      return this.onRemove(), this._connSource = o, this._connTarget = a, this.onAdd(), this;
    }, n.getConnectTarget = function() {
      return this._connTarget;
    }, n.setConnectTarget = function(o) {
      var a = this._connSource;
      return this.onRemove(), this._connSource = a, this._connTarget = o, this._updateCoordinates(), this._registerEvents(), this;
    }, n._updateCoordinates = function() {
      var o = this.getMap();
      if (!o && this._connSource && (o = this._connSource.getMap()), !o && this._connTarget && (o = this._connTarget.getMap()), !!o && !(!this._connSource || !this._connTarget)) {
        for (var a = this._connSource._getConnectPoints(), l = this._connTarget._getConnectPoints(), h = 0, u = this.getCoordinates(), c, f, d = 0, p = a.length; d < p; d++)
          for (var g = a[d], m = 0, v = l.length; m < v; m++) {
            var _ = l[m], y = o.computeLength(g, _);
            d === 0 && m === 0 ? (c = g, f = _, h = y) : y < h && (c = g, f = _);
          }
        (!sn(u) || !u[0].equals(c) || !u[1].equals(f)) && this.setCoordinates([c, f]);
      }
    }, n.onAdd = function() {
      this._registerEvents(), this._updateCoordinates();
    }, n.onRemove = function() {
      if (this._connSource && (this._connSource.__connectors && zf(this, this._connSource.__connectors), this._connSource.off("dragging positionchange", this._updateCoordinates, this).off("remove", this.onRemove, this), this._connSource.off("dragstart mousedown mouseover", this._showConnect, this), this._connSource.off("dragend mouseup mouseout", this.hide, this), this._connSource.off("show", this._showConnect, this).off("hide", this.hide, this), delete this._connSource), this._connTarget && (zf(this, this._connTarget.__connectors), this._connTarget.off("dragging positionchange", this._updateCoordinates, this).off("remove", this.onRemove, this), this._connTarget.off("show", this._showConnect, this).off("hide", this.hide, this), delete this._connTarget), !(this._connSource instanceof nn) || !(this._connTarget instanceof nn)) {
        var o = this.getMap();
        o && o.off("movestart moving moveend zoomstart zooming zoomend rotate pitch fovchange spatialreferencechange", this._updateCoordinates, this);
      }
    }, n._showConnect = function() {
      !this._connSource || !this._connTarget || this._connSource.isVisible() && this._connTarget.isVisible() && (this._updateCoordinates(), this.show());
    }, n._registerEvents = function() {
      if (!(!this._connSource || !this._connTarget)) {
        this._connSource.__connectors || (this._connSource.__connectors = []), this._connTarget.__connectors || (this._connTarget.__connectors = []), this._connSource.__connectors.push(this), this._connTarget.__connectors.push(this), this._connSource.on("dragging positionchange", this._updateCoordinates, this).on("remove", this.remove, this), this._connTarget.on("dragging positionchange", this._updateCoordinates, this).on("remove", this.remove, this), this._connSource.on("show", this._showConnect, this).on("hide", this.hide, this), this._connTarget.on("show", this._showConnect, this).on("hide", this.hide, this);
        var o = this.options.showOn;
        if (this.hide(), o === "moving" ? (this._connSource.on("dragstart", this._showConnect, this).on("dragend", this.hide, this), this._connTarget.on("dragstart", this._showConnect, this).on("dragend", this.hide, this)) : o === "click" ? (this._connSource.on("mousedown", this._showConnect, this).on("mouseup", this.hide, this), this._connTarget.on("mousedown", this._showConnect, this).on("mouseup", this.hide, this)) : o === "mouseover" ? (this._connSource.on("mouseover", this._showConnect, this).on("mouseout", this.hide, this), this._connTarget.on("mouseover", this._showConnect, this).on("mouseout", this.hide, this)) : this._showConnect(), !(this._connSource instanceof nn) || !(this._connTarget instanceof nn)) {
          var a = this.getMap();
          a && a.on("movestart moving moveend zoomstart zooming zoomend rotate pitch fovchange spatialreferencechange", this._updateCoordinates, this);
        }
      }
    }, r;
  }(t);
}, iA = {
  showOn: "always"
}, ed = function(i) {
  Ot(t, i);
  function t(e, r, n) {
    var s;
    return s = i.call(this, null, n) || this, arguments.length === 1 && (n = e, e = null, r = null), s._connSource = e, s._connTarget = r, s;
  }
  return t;
}(rA(Tn));
ed.mergeOptions(iA);
ed.registerJSONType("ConnectorLine");
var sA = function(i) {
  Ot(t, i);
  function t(e, r, n) {
    var s;
    return s = i.call(this, null, n) || this, arguments.length === 1 && (n = e, e = null, r = null), s._connSource = e, s._connTarget = r, s;
  }
  return t;
}(rA(Ld));
sA.mergeOptions(iA);
sA.registerJSONType("ArcConnectorLine");
function oc(i) {
  return i && i instanceof nn;
}
var gO = {
  drawImmediate: !1,
  geometryEvents: !0,
  geometryEventTolerance: 1
}, q1 = [], Lv = function(i) {
  Ot(t, i);
  function t(r, n, s) {
    var o;
    n && !oc(n) && !Array.isArray(n) && Ew.indexOf(n.type) < 0 && (s = n, n = null), o = i.call(this, r, s) || this, o._maxZIndex = 0, o._minZIndex = 0, o._initCache(), n && o.addGeometry(n);
    var a = o.options.style;
    return a && o.setStyle(a), o;
  }
  var e = t.prototype;
  return e.getGeometryById = function(n) {
    return W(n) || n === "" || !this._geoMap[n] ? null : this._geoMap[n];
  }, e.getGeometries = function(n, s) {
    if (!n)
      return this._geoList.slice(0);
    for (var o = [], a, l, h = 0, u = this._geoList.length; h < u; h++)
      a = this._geoList[h], s ? l = n.call(s, a) : l = n(a), l && o.push(a);
    return o;
  }, e.getFirstGeometry = function() {
    return this._geoList.length ? this._geoList[0] : null;
  }, e.getLastGeometry = function() {
    var n = this._geoList.length;
    return n === 0 ? null : this._geoList[n - 1];
  }, e.getCount = function() {
    return this._geoList.length;
  }, e.getExtent = function() {
    if (this.getCount() === 0)
      return null;
    var n = new dn(this.getProjection());
    return this.forEach(function(s) {
      n._combine(s.getExtent());
    }), n;
  }, e.forEach = function(n, s) {
    for (var o = this._geoList.slice(0), a = 0, l = o.length; a < l; a++)
      s ? n.call(s, o[a], a) : n(o[a], a);
    return this;
  }, e.filter = function(n, s) {
    var o = [], a = Be(n), l = a ? n : pv(n);
    return this.forEach(function(h) {
      var u = a ? h : Bm(h);
      (s ? l.call(s, u) : l(u)) && o.push(h);
    }, this), o;
  }, e.isEmpty = function() {
    return !this._geoList.length;
  }, e.addGeometry = function(n, s) {
    if (!n)
      return this;
    if (n.type === "FeatureCollection")
      return this.addGeometry(wi.toGeometry(n), s);
    if (Array.isArray(n)) {
      if (n.length === 0)
        return this;
    } else {
      var o = arguments.length, a = arguments[o - 1];
      return n = Array.prototype.slice.call(arguments, 0, o - 1), s = a, a && ji(a) && ("type" in a || oc(a)) && (n.push(a), s = !1), this.addGeometry(n, s);
    }
    this._initCache();
    var l;
    s && (l = new dn()), this._toSort = this._maxZIndex > 0;
    for (var h = [], u = 0, c = n.length; u < c; u++) {
      var f = n[u];
      if (!(f && (wi._isGeoJSON(f) || oc(f))))
        throw new Error("Invalid geometry to add to layer(" + this.getId() + ") at index:" + u);
      if (!(f.getLayer && f.getLayer() === this)) {
        if (!oc(f) && (f = nn.fromJSON(f), Array.isArray(f)))
          for (var d = 0, p = f.length; d < p; d++)
            this._add(f[d], l, u), h.push(f[d]);
        if (!f)
          throw new Error("Invalid geometry to add to layer(" + this.getId() + ") at index:" + u);
        Array.isArray(f) || (this._add(f, l, u), h.push(f));
      }
    }
    var g = this.getMap();
    if (g && (this._getRenderer().onGeometryAdd(h), l && !W(l.xmin))) {
      var m = l.getCenter(), v = g.getFitZoom(l);
      if (ji(s)) {
        var _ = Be(s.step) ? s.step : function() {
        };
        g.animateTo({
          center: m,
          zoom: v
        }, jt({
          duration: g.options.zoomAnimationDuration,
          easing: "out"
        }, s), _);
      } else s === !0 && g.setCenterAndZoom(m, v);
    }
    return this.fire("addgeo", {
      geometries: n
    }), this;
  }, e.getGeoMinZIndex = function() {
    return this._minZIndex;
  }, e.getGeoMaxZIndex = function() {
    return this._maxZIndex;
  }, e._add = function(n, s, o) {
    this._toSort || (this._toSort = n.getZIndex() !== 0), this._updateZIndex(n.getZIndex());
    var a = n.getId();
    if (!W(a)) {
      if (!W(this._geoMap[a]))
        throw new Error("Duplicate geometry id in layer(" + this.getId() + "):" + a + ", at index:" + o);
      this._geoMap[a] = n;
    }
    var l = Ls();
    n._setInternalId(l), this._geoList.push(n), this.onAddGeometry(n), n._bindLayer(this), n.onAdd && n.onAdd(), s && s._combine(n.getExtent()), n._fireEvent("add", {
      layer: this
    }), this._cookedStyles && this._styleGeometry(n);
  }, e.removeGeometry = function(n) {
    if (!Array.isArray(n))
      return this.removeGeometry([n]);
    for (var s = n.length - 1; s >= 0; s--)
      n[s] instanceof nn || (n[s] = this.getGeometryById(n[s])), !(!n[s] || this !== n[s].getLayer()) && n[s].remove();
    return this.fire("removegeo", {
      geometries: n
    }), this;
  }, e.clear = function() {
    this._clearing = !0, this.forEach(function(o) {
      o.remove();
    }), this._geoMap = {};
    var n = this._geoList;
    this._geoList = [];
    var s = this._getRenderer();
    return s && (s.onGeometryRemove(n), s.clearImageData && (s.clearImageData(), delete s._lastGeosToDraw)), this._clearing = !1, this.fire("clear"), this;
  }, e.onRemoveGeometry = function(n) {
    if (!(!n || this._clearing) && this === n.getLayer()) {
      var s = n._getInternalId();
      if (!W(s)) {
        var o = n.getId();
        W(o) || delete this._geoMap[o];
        var a = this._findInList(n);
        a >= 0 && this._geoList.splice(a, 1), this._getRenderer() && this._getRenderer().onGeometryRemove([n]);
      }
    }
  }, e.getStyle = function() {
    return this.options.style ? this.options.style : null;
  }, e.setStyle = function(n) {
    return this.options.style = n, n = tT(n), this._cookedStyles = Zw(n), this.forEach(function(s) {
      this._styleGeometry(s);
    }, this), this.fire("setstyle", {
      style: n
    }), this;
  }, e._styleGeometry = function(n) {
    if (!this._cookedStyles)
      return !1;
    for (var s = Bm(n), o = 0, a = this._cookedStyles.length; o < a; o++)
      if (this._cookedStyles[o].filter(s) === !0)
        return n._setExternSymbol(this._cookedStyles[o].symbol), !0;
    return !1;
  }, e.removeStyle = function() {
    return this.options.style ? (delete this.options.style, delete this._cookedStyles, this.forEach(function(n) {
      n._setExternSymbol(null);
    }, this), this.fire("removestyle"), this) : this;
  }, e.onAddGeometry = function(n) {
    var s = this.getStyle();
    s && this._styleGeometry(n);
  }, e.hide = function() {
    for (var n = 0, s = this._geoList.length; n < s; n++)
      this._geoList[n].onHide();
    return gr.prototype.hide.call(this);
  }, e._initCache = function() {
    this._geoList || (this._geoList = [], this._geoMap = {});
  }, e._updateZIndex = function() {
    for (var n = arguments.length, s = new Array(n), o = 0; o < n; o++)
      s[o] = arguments[o];
    this._maxZIndex = Math.max(this._maxZIndex, Math.max.apply(Math, s)), this._minZIndex = Math.min(this._minZIndex, Math.min.apply(Math, s));
  }, e._sortGeometries = function() {
    var n = this;
    this._toSort && (this._maxZIndex = 0, this._minZIndex = 0, this._geoList.sort(function(s, o) {
      return n._updateZIndex(s.getZIndex(), o.getZIndex()), n._compare(s, o);
    }), this._toSort = !1);
  }, e._compare = function(n, s) {
    return n.getZIndex() === s.getZIndex() ? n._getInternalId() - s._getInternalId() : n.getZIndex() - s.getZIndex();
  }, e._findInList = function(n) {
    var s = this._geoList.length;
    if (s === 0)
      return -1;
    this._sortGeometries();
    for (var o = 0, a = s - 1, l; o <= a; ) {
      if (l = Math.floor((o + a) / 2), this._geoList[l] === n)
        return l;
      this._compare(this._geoList[l], n) > 0 ? a = l - 1 : o = l + 1;
    }
    return -1;
  }, e._onGeometryEvent = function(n) {
    if (!(!n || !n.target)) {
      var s = n.type;
      s === "idchange" ? this._onGeometryIdChange(n) : s === "zindexchange" ? this._onGeometryZIndexChange(n) : s === "positionchange" ? this._onGeometryPositionChange(n) : s === "shapechange" ? this._onGeometryShapeChange(n) : s === "symbolchange" ? this._onGeometrySymbolChange(n) : s === "show" ? this._onGeometryShow(n) : s === "hide" ? this._onGeometryHide(n) : s === "propertieschange" && this._onGeometryPropertiesChange(n);
    }
  }, e._onGeometryIdChange = function(n) {
    if (!(n.new === n.old && this._geoMap[n.old] && this._geoMap[n.old] === n.target)) {
      if (!W(n.new)) {
        if (this._geoMap[n.new])
          throw new Error("Duplicate geometry id in layer(" + this.getId() + "):" + n.new);
        this._geoMap[n.new] = n.target;
      }
      !W(n.old) && n.new !== n.old && delete this._geoMap[n.old];
    }
  }, e._onGeometryZIndexChange = function(n) {
    n.old !== n.new && (this._updateZIndex(n.new), this._toSort = !0, this._getRenderer() && this._getRenderer().onGeometryZIndexChange(n));
  }, e._onGeometryPositionChange = function(n) {
    this._getRenderer() && this._getRenderer().onGeometryPositionChange(n);
  }, e._onGeometryShapeChange = function(n) {
    this._getRenderer() && this._getRenderer().onGeometryShapeChange(n);
  }, e._onGeometrySymbolChange = function(n) {
    this._getRenderer() && this._getRenderer().onGeometrySymbolChange(n);
  }, e._onGeometryShow = function(n) {
    this._getRenderer() && this._getRenderer().onGeometryShow(n);
  }, e._onGeometryHide = function(n) {
    this._getRenderer() && this._getRenderer().onGeometryHide(n);
  }, e._onGeometryPropertiesChange = function(n) {
    this._getRenderer() && this._getRenderer().onGeometryPropertiesChange(n);
  }, e._hasGeoListeners = function(n) {
    if (!n)
      return !1;
    Array.isArray(n) || (q1[0] = n, n = q1);
    for (var s = this.getGeometries() || [], o = 0, a = s.length; o < a; o++) {
      var l = s[o];
      if (l) {
        if (l.options.cursor)
          return !0;
        for (var h = 0, u = n.length; h < u; h++) {
          var c = n[h], f = l.listens(c);
          if (f > 0)
            return !0;
        }
      }
    }
    return !1;
  }, t;
}(gr);
Lv.mergeOptions(gO);
var mO = new Se(), vO = {
  debug: !1,
  enableSimplify: !0,
  defaultIconSize: [20, 20],
  cacheVectorOnCanvas: !0,
  cacheSvgOnCanvas: Ce.gecko,
  enableAltitude: !1,
  altitudeProperty: "altitude",
  drawAltitude: !1,
  sortByDistanceToCamera: !1,
  roundPoint: !1,
  altitude: 0,
  clipBBoxBufferSize: 3,
  collision: !1,
  collisionBufferSize: 2,
  collisionDelay: 250,
  collisionScope: "layer",
  progressiveRender: !1,
  progressiveRenderCount: 1e3,
  progressiveRenderDebug: !1
}, Rs = function(i) {
  Ot(t, i);
  function t(r, n, s) {
    return i.call(this, r, n, s) || this;
  }
  var e = t.prototype;
  return e.onConfig = function(n) {
    if (i.prototype.onConfig.call(this, n), n.enableAltitude || n.drawAltitude || n.altitudeProperty) {
      var s = this.getRenderer();
      s && s.setToRedraw && s.setToRedraw();
    }
  }, e.identify = function(n, s) {
    s === void 0 && (s = {});
    var o = this.getRenderer();
    n instanceof lt || (n = new lt(n));
    var a = this.getMap().coordToContainerPoint(n);
    return s.onlyVisible && o && o.identifyAtPoint ? o.identifyAtPoint(a, s) : this._hitGeos(this._geoList, a, s);
  }, e.identifyAtPoint = function(n, s) {
    s === void 0 && (s = {});
    var o = this.getRenderer();
    return n instanceof Y || (n = new Y(n)), s.onlyVisible && o && o.identifyAtPoint ? o.identifyAtPoint(n, s) : this._hitGeos(this._geoList, n, s);
  }, e._hitGeos = function(n, s, o) {
    if (o === void 0 && (o = {}), !n || !n.length)
      return [];
    var a = o.filter, l = [], h = o.tolerance, u = this.getMap(), c = this.getRenderer(), f = c && c.getImageData && c.getImageData();
    if (f) {
      var d = 0, p = c.maxTolerance;
      if (Ut(p))
        d = p;
      else
        for (var g = n.length - 1; g >= 0; g--) {
          var m = n[g]._hitTestTolerance() + (h || 0);
          m > d && (d = m);
        }
      var v = u.getDevicePixelRatio();
      f.r = v;
      for (var _ = !1, y = s.x - d, x = s.y - d, w = -d; w <= d; w++) {
        for (var b = -d; b <= d; b++) {
          var T = Math.round((y + w) * v), A = Math.round((x + b) * v), M = A * f.width * 4 + T * 4;
          if (f.data[M + 3] > 0) {
            _ = !0;
            break;
          }
        }
        if (_)
          break;
      }
      if (!_)
        return l;
    }
    for (var S = o.onlyVisible, P = n.length - 1; P >= 0; P--) {
      var C = n[P];
      if (!(!C || !C.options.interactive) && !(!S && !C.isVisible())) {
        var k = C._getPainter();
        if (k) {
          var O = k.getRenderBBOX && k.getRenderBBOX();
          if (O) {
            var R = s.x, I = s.y;
            if (R < O[0] || I < O[1] || R > O[2] || I > O[3])
              continue;
          }
          if (!(C instanceof Tn) || !C._getArrowStyle() && !(C instanceof Fu)) {
            var D = C.getContainerExtent(mO);
            if (h && (D = D._expand(h)), !D || !D.contains(s))
              continue;
          }
          if (C._containsPoint(s, h) && (!a || a(C)) && (l.push(C), o.count && l.length >= o.count))
            break;
        }
      }
    }
    return l;
  }, e.getAltitude = function() {
    return this.options.altitude || 0;
  }, e.toJSON = function(n) {
    n || (n = {});
    var s = {
      type: this.getJSONType(),
      id: this.getId(),
      options: this.config()
    };
    if (W(n.geometries) || n.geometries) {
      var o;
      if (n.clipExtent) {
        var a = this.getMap(), l = a ? a.getProjection() : null;
        o = new dn(n.clipExtent, l);
      }
      for (var h = [], u = this.getGeometries(), c = 0, f = u.length; c < f; c++) {
        var d = u[c], p = d.getExtent();
        if (!(!p || o && !o.intersects(p))) {
          var g = d.toJSON(n.geometries);
          h.push(g);
        }
      }
      s.geometries = h;
    }
    return s;
  }, t.fromJSON = function(n) {
    if (!n || n.type !== "VectorLayer")
      return null;
    for (var s = new t(n.id, n.options), o = n.geometries, a = [], l = 0; l < o.length; l++) {
      var h = nn.fromJSON(o[l]);
      h && a.push(h);
    }
    return s.addGeometry(a), s;
  }, t.getPainterClass = function() {
    return Iv;
  }, t.getCollectionPainterClass = function() {
    return $T;
  }, t;
}(Lv);
Rs.mergeOptions(vO);
Rs.registerJSONType("VectorLayer");
var ac = "_map_tool", Y1 = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.addTo = function(n) {
    return n ? (this._map = n, n[ac] && n[ac].disable(), this.onAdd && this.onAdd(), this.enable(), n[ac] = this, this._fireEvent("add"), this) : this;
  }, e.getMap = function() {
    return this._map;
  }, e.enable = function() {
    var n = this._map;
    return !n || this._enabled ? this : (this._enabled = !0, this._switchEvents("off"), this._registerEvents(), this.onEnable && this.onEnable(), this._fireEvent("enable"), this);
  }, e.disable = function() {
    return !this._enabled || !this._map ? this : (this._enabled = !1, this._switchEvents("off"), this.onDisable && this.onDisable(), this._fireEvent("disable"), this);
  }, e.isEnabled = function() {
    return !!this._enabled;
  }, e.remove = function() {
    return this._map ? (this.disable(), this._map && (delete this._map[ac], delete this._map), this._fireEvent("remove"), this) : this;
  }, e._registerEvents = function() {
    this._switchEvents("on");
  }, e._switchEvents = function(n) {
    var s = this.getEvents();
    s && this._map[n](s, this);
  }, e._fireEvent = function(n, s) {
    s || (s = {}), this.fire(n, s);
  }, t;
}(ls(pi)), yO = {
  symbol: {
    lineColor: "#000",
    lineWidth: 2,
    lineOpacity: 1,
    polygonFill: "#fff",
    polygonOpacity: 0.3
  },
  doubleClickZoom: !1,
  mode: null,
  once: !1,
  autoPanAtEdge: !1,
  ignoreMouseleave: !0,
  blockGeometryEvents: !1,
  zIndex: Number.MAX_VALUE,
  enableAltitude: !0
}, J1 = {}, mr = function(i) {
  Ot(t, i), t.registerMode = function(n, s) {
    J1[n.toLowerCase()] = s;
  }, t.getRegisterMode = function(n) {
    return J1[n.toLowerCase()];
  };
  function t(r) {
    var n;
    return n = i.call(this, r) || this, n._checkMode(), n._events = {
      click: n._clickHandler,
      "mousemove touchmove": n._mouseMoveHandler,
      dblclick: n._doubleClickHandler,
      "mousedown touchstart": n._mouseDownHandler,
      "mouseup touchend": n._mouseUpHandler,
      mousemove: n._mouseMoveHandler,
      mousedown: n._mouseDownHandler,
      mouseup: n._mouseUpHandler
    }, n;
  }
  var e = t.prototype;
  return e.getMode = function() {
    return this.options.mode ? this.options.mode.toLowerCase() : null;
  }, e.setMode = function(n) {
    return this._geometry && (this._geometry.remove(), delete this._geometry), this._clearStage(), this._switchEvents("off"), this.options.mode = n, this._checkMode(), this.isEnabled() && (this._switchEvents("on"), this._restoreMapCfg(), this._saveMapCfg()), this;
  }, e.getSymbol = function() {
    var n = this.options.symbol;
    return Ni(n || this.options.symbol);
  }, e.setSymbol = function(n) {
    return n ? (this.options.symbol = n, this._geometry && this._geometry.setSymbol(n), this) : this;
  }, e.getCurrentGeometry = function() {
    return this._geometry;
  }, e.onAdd = function() {
    this._checkMode();
  }, e.onEnable = function() {
    this._saveMapCfg(), this._drawToolLayer = this._getDrawLayer(), this._clearStage(), this._loadResources();
    var n = this.getMap();
    return this.options.autoPanAtEdge && (this._mapAutoPanAtEdge = n.options.autoPanAtEdge, this._mapAutoPanAtEdge || n.config({
      autoPanAtEdge: !0
    })), this._geometryEvents = n.options.geometryEvents, this.options.blockGeometryEvents && n.config("geometryEvents", !1), this;
  }, e.onDisable = function() {
    var n = this.getMap();
    return this._restoreMapCfg(), this.endDraw({
      ignoreEndEvent: !0
    }), this._map && (n.removeLayer(this._getDrawLayer()), this.options.autoPanAtEdge && (this._mapAutoPanAtEdge || n.config({
      autoPanAtEdge: !1
    }))), this.options.blockGeometryEvents && n.config("geometryEvents", this._geometryEvents), this;
  }, e.undo = function() {
    var n = this._getRegisterMode(), s = n.action;
    if (!this._shouldRecordHistory(s) || !this._historyPointer)
      return this;
    var o = this._clickCoords.slice(0, --this._historyPointer);
    return n.update(this.getMap().getProjection(), o, this._geometry), this;
  }, e.redo = function() {
    var n = this._getRegisterMode(), s = n.action;
    if (!this._shouldRecordHistory(s) || W(this._historyPointer) || this._historyPointer === this._clickCoords.length)
      return this;
    var o = this._clickCoords.slice(0, ++this._historyPointer);
    return n.update(this.getMap().getProjection(), o, this._geometry), this;
  }, e._shouldRecordHistory = function(n) {
    return Array.isArray(n) && n[0] === "click" && n[1] === "mousemove" && n[2] === "dblclick";
  }, e._checkMode = function() {
    this._getRegisterMode();
  }, e._saveMapCfg = function() {
    var n = this.getMap();
    this._mapDoubleClickZoom = n.options.doubleClickZoom, n.config({
      doubleClickZoom: this.options.doubleClickZoom
    });
    for (var s = this._getRegisterMode().action, o = !1, a = 0; a < s.length; a++)
      if (s[a].indexOf("mousedown") >= 0 || s[a].indexOf("touchstart") >= 0) {
        o = !0;
        break;
      }
    if (o) {
      var l = this.getMap();
      this._mapDraggable = l.options.draggable, l.config({
        draggable: !1
      });
    }
  }, e._restoreMapCfg = function() {
    var n = this.getMap();
    n.config({
      doubleClickZoom: this._mapDoubleClickZoom
    }), W(this._mapDraggable) || n.config("draggable", this._mapDraggable), delete this._mapDraggable, delete this._mapDoubleClickZoom;
  }, e._loadResources = function() {
    var n = this.getSymbol(), s = Ou(n);
    s.length > 0 && this._drawToolLayer._getRenderer().loadResources(s);
  }, e._getProjection = function() {
    return this._map.getProjection();
  }, e._getRegisterMode = function() {
    var n = this.getMode(), s = t.getRegisterMode(n);
    if (!s)
      throw new Error(n + " is not a valid mode of DrawTool.");
    return s;
  }, e.getEvents = function() {
    var n = this._getRegisterMode().action, s = {};
    if (Array.isArray(n)) {
      for (var o = 0; o < n.length; o++)
        s[n[o]] = this._events[n[o]];
      return s;
    }
    return null;
  }, e._mouseDownHandler = function(n) {
    this._createGeometry(n);
  }, e._mouseUpHandler = function(n) {
    this.endDraw(n);
  }, e._clickHandler = function(n) {
    n.enableAltitude = this.options.enableAltitude;
    var s = this.getMap(), o = this._getRegisterMode();
    if (this._clickCoords && this._clickCoords.length) {
      var a = this._clickCoords.length, l = s._pointToPrj(n.point2d);
      if (this._clickCoords[a - 1].equals(l))
        return;
    }
    if (!this._geometry)
      this._createGeometry(n);
    else {
      var h = s._pointToPrj(n.point2d);
      W(this._historyPointer) || (this._clickCoords = this._clickCoords.slice(0, this._historyPointer));
      var u = this._geometry.snapTo;
      if (u && Be(u)) {
        var c = this._getSnapResult(u, n.containerPoint);
        if (h = c.prjCoord, this._clickCoords = this._clickCoords.concat(c.effectedVertex), this._clickCoords[this._clickCoords.length - 1].equals(h))
          return;
      }
      if (this._clickCoords.push(h), this._historyPointer = this._clickCoords.length, n.drawTool = this, o.update(s.getProjection(), this._clickCoords, this._geometry, n), this.getMode() === "point") {
        this.endDraw(n);
        return;
      }
      this._clickCoords.length <= 1 ? this._fireEvent("drawstart", n) : this._fireEvent("drawvertex", n), o.clickLimit && o.clickLimit === this._historyPointer && this.endDraw(n);
    }
  }, e._createGeometry = function(n) {
    var s = this.getMode(), o = this._getRegisterMode(), a = this.getMap()._pointToPrj(n.point2d), l = this.getSymbol();
    if (!this._geometry) {
      this._fireEvent("drawprepare", n), this._clickCoords = [a], n.drawTool = this, this._geometry = o.create(this.getMap().getProjection(), this._clickCoords, n), l && s !== "point" ? this._geometry.setSymbol(l) : this.options.hasOwnProperty("symbol") && this._geometry.setSymbol(this.options.symbol), this._addGeometryToStage(this._geometry), this._fireEvent("drawstart", n);
      var h = this._geometry.snapTo;
      if (h && Be(h)) {
        var u = this._getSnapResult(h, n.containerPoint), c = this.getMap();
        if (c && u) {
          var f = u.prjCoord;
          this._clickCoords = [f], o.update(c.getProjection(), this._clickCoords, this._geometry, n);
        }
      }
    }
    s === "point" && n.type !== "mousemove" && this.endDraw(n);
  }, e._mouseMoveHandler = function(n) {
    n.enableAltitude = this.options.enableAltitude;
    var s = this.getMap();
    if (!(!s || s.isInteracting())) {
      if (this.getMode() === "point" && !this._geometry) {
        this._createGeometry(n);
        return;
      }
      if (this._geometry) {
        var o = this._getMouseContainerPoint(n);
        if (this._isValidContainerPoint(o)) {
          var a = s._pointToPrj(n.point2d), l = [], h = this._geometry.snapTo;
          if (h && Be(h)) {
            var u = this._getSnapResult(h, o);
            a = u.prjCoord, l = u.effectedVertex;
          }
          var c = s.getProjection();
          n.drawTool = this;
          var f = this._getRegisterMode();
          if (this._shouldRecordHistory(f.action)) {
            var d = this._clickCoords.slice(0, this._historyPointer);
            if (d && d.length > 0 && a.equals(d[d.length - 1]))
              return;
            f.update(c, d.concat(l, [a]), this._geometry, n);
          } else
            f.update(c, a, this._geometry, n);
          this._fireEvent("mousemove", n);
        }
      }
    }
  }, e._doubleClickHandler = function(n) {
    if (n.enableAltitude = this.options.enableAltitude, !!this._geometry) {
      var s = this._getMouseContainerPoint(n);
      if (this._isValidContainerPoint(s)) {
        var o = this._getRegisterMode(), a = this._clickCoords;
        if (!(!a || a.length < 2)) {
          var l = this.getMode();
          if (!(l && l.indexOf("polygon") > -1 && a.length < 3)) {
            for (var h = this.getMap().getProjection(), u = [a[0]], c = 1, f = a.length; c < f; c++)
              (a[c].x !== a[c - 1].x || a[c].y !== a[c - 1].y) && u.push(a[c]);
            u.length < 2 || this._geometry && this._geometry instanceof vn && u.length < 3 || (n.drawTool = this, o.update(h, u, this._geometry, n), this.endDraw(n));
          }
        }
      }
    }
  }, e._addGeometryToStage = function(n) {
    var s = this._getDrawLayer();
    s.addGeometry(n);
  }, e.endDraw = function(n) {
    if (!this._geometry || this._ending)
      return this;
    this._ending = !0;
    var s = this._geometry;
    return this._clearStage(), n = n || {}, this._geometry = s, n.ignoreEndEvent || this._fireEvent("drawend", n), delete this._geometry, this.options.once && this.disable(), delete this._ending, delete this._historyPointer, this._vertexes && (this._vertexes = []), this;
  }, e._clearStage = function() {
    this._getDrawLayer().clear(), delete this._geometry, delete this._clickCoords;
  }, e._getMouseContainerPoint = function(n) {
    var s = this._getRegisterMode().action;
    return (s[0].indexOf("mousedown") >= 0 || s[0].indexOf("touchstart") >= 0) && Jr(n.domEvent), n.containerPoint;
  }, e._isValidContainerPoint = function(n) {
    var s = this._map.getSize(), o = s.width, a = s.height;
    return n.x < 0 || n.y < 0 ? !1 : !(n.x > o || n.y > a);
  }, e._getSnapResult = function(n, s) {
    var o = this.getMap(), a = [];
    if (this.options.edgeAutoComplete) {
      var l = this._clickCoords[(this._historyPointer || 1) - 1];
      a.push(o._prjToContainerPoint(l));
      var h = this._clickCoords[(this._historyPointer || 1) - 2];
      h && a.push(o._prjToContainerPoint(h));
    }
    var u = n(s, a);
    s = (u.effectedVertex ? u.point : u) || s;
    var c = o._containerPointToPrj(s);
    return u.effectedVertex && (u.effectedVertex = u.effectedVertex.map(function(f) {
      return o._containerPointToPrj(f);
    })), {
      prjCoord: c,
      effectedVertex: u.effectedVertex || []
    };
  }, e._getDrawLayer = function() {
    var n = Eu + "drawtool", s = this._map.getLayer(n);
    return s || (s = new Rs(n, {
      enableSimplify: !1,
      enableAltitude: this.options.enableAltitude,
      zIndex: this.options.zIndex
    }), this._map.addLayer(s)), this._pushLayers(s), s;
  }, e._fireEvent = function(n, s) {
    s || (s = {}), s = jt({}, s), this._geometry && (s.geometry = this._getRegisterMode().generate(this._geometry, {
      drawTool: this
    }), s.tempGeometry = this._geometry), Y1.prototype._fireEvent.call(this, n, s);
  }, e._pushLayers = function(n) {
    var s = this;
    return n ? (Array.isArray(n) || (n = [n]), this._layers = this._layers || [], n.forEach(function(o) {
      s._layers.indexOf(o) === -1 && s._layers.push(o);
    }), this) : this;
  }, e._outLayers = function(n) {
    var s = this;
    return n ? (Array.isArray(n) || (n = [n]), this._layers = this._layers || [], n.forEach(function(o) {
      for (var a = 0, l = s._layers.length; a < l; a++)
        if (o === s._layers[a]) {
          s._layers.splice(a, 1);
          break;
        }
    }), this) : this;
  }, e.setLayerZIndex = function(n) {
    return Ut(n) ? (this.options.zIndex = n, this._layers = this._layers || [], this._layers.forEach(function(s) {
      s && s.setZIndex && s.setZIndex(n);
    }), this) : this;
  }, t;
}(Y1);
mr.mergeOptions(yO);
var _O = function(i) {
  Ot(t, i);
  function t(r) {
    var n;
    return n = i.call(this, r) || this, n.drawTool = new mr({
      mode: "boxZoom",
      ignoreMouseleave: !1
    }), n;
  }
  var e = t.prototype;
  return e.addHooks = function() {
    this.target.on("_mousedown", this._onMouseDown, this);
  }, e.removeHooks = function() {
    this.target.off("_mousedown", this._onMouseDown, this), this.drawTool.isEnabled() && this.drawTool.remove();
  }, e._onMouseDown = function(n) {
    this.target.options.boxZoom && n.domEvent.shiftKey && this.drawTool.setSymbol(this.target.options.boxZoomSymbol).on("drawend", this._boxZoom, this).addTo(this.target);
  }, e._boxZoom = function(n) {
    var s = this.target;
    this.drawTool.remove();
    var o = n.geometry, a = o.getCenter(), l = o.getSymbol(), h = l.markerWidth, u = l.markerHeight, c = new dn(a, s.locateByPoint(a, h, u), s.getProjection()), f = s.getFitZoom(c);
    s._animateTo({
      center: c.getCenter(),
      zoom: f
    });
  }, t;
}(Xi);
xe.mergeOptions({
  boxZoom: !0,
  boxZoomSymbol: {
    markerType: "rectangle",
    markerLineWidth: 3,
    markerLineColor: "#1bbc9b",
    markerLineDasharray: [10, 5],
    markerFillOpacity: 0.1,
    markerFill: "#1bbc9b",
    markerWidth: 1,
    markerHeight: 1
  }
});
xe.addOnLoadHook("addHandler", "boxZoom", _O);
var js = 30, xO = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.addHooks = function() {
    this.target && this.target.on("_mousemove", this._onMouseMove, this);
  }, e.removeHooks = function() {
    this.target && this.target.off("_mousemove", this._onMouseMove, this);
  }, e._onMouseMove = function(n) {
    var s = this.target;
    if (s.options.autoPanAtEdge) {
      var o = n.containerPoint, a = s.getContainerExtent();
      if (a) {
        var l = o.x, h = o.y, u = a.xmax, c = a.ymax, f;
        l < js && (f = [Math.abs(l - js), 0]), h < js && (f = [0, Math.abs(h - js)]), l + js > u && (f = [-Math.abs(l + js - u), 0]), h + js > c && (f = [0, -Math.abs(h + js - c)]), f && s.panBy(f, {
          duration: 1
        });
      }
    }
  }, t;
}(Xi);
xe.mergeOptions({
  autoPanAtEdge: !1
});
xe.addOnLoadHook("addHandler", "autoPanAtEdge", xO);
xe.include({
  animateTo: function(t, e, r) {
    var n = this;
    e === void 0 && (e = {}), t = jt({}, this.getView(), t), Be(e) && (r = e, e = {});
    var s = this.getProjection(), o = this.getView(), a = {}, l = !0;
    for (var h in t)
      if (Fl(t, h) && !W(t[h]) && (h === "prjCenter" || !W(o[h])))
        if (l = !1, h === "center") {
          var u = new lt(o[h]), c = new lt(t[h]);
          u.equals(c) || (a.center = [u, c]);
        } else if (h === "prjCenter") {
          var f = new lt(this._getPrjCenter()), d = new lt(t[h]);
          f.equals(d) || (a.prjCenter = [f, d]);
        } else o[h] !== t[h] && h !== "around" && (a[h] = [o[h], t[h]]);
    if (l)
      return null;
    this._animPlayer && (this._isInternalAnimation ? this._animPlayer.playState === "running" && (this._animPlayer.pause(), this._prevAnimPlayer = this._animPlayer) : (delete this._prevAnimPlayer, this._stopAnim(this._animPlayer)));
    var p = t.around || new Y(this.width / 2, this.height / 2), g = this._getRenderer(), m = function(y) {
      g.callInNextFrame(y);
    }, v = this._animPlayer = dr.animate(a, {
      easing: e.easing || "out",
      duration: e.duration || this.options.zoomAnimationDuration,
      framer: m,
      repeat: e.repeat
    }, function(_) {
      if (n.isRemoved()) {
        v.finish();
        return;
      }
      if (v.playState === "running") {
        if (_.styles.center) {
          var y = _.styles.center;
          n._setPrjCenter(s.project(y)), n.onMoving(n._parseEventFromCoord(n.getCenter()));
        } else if (_.styles.prjCenter) {
          var x = _.styles.prjCenter;
          n._setPrjCenter(x), n.onMoving(n._parseEventFromCoord(n.getCenter()));
        }
        W(_.styles.zoom) || n.onZooming(_.styles.zoom, p), W(_.styles.pitch) || n._setPitch(_.styles.pitch), W(_.styles.bearing) || n._setBearing(_.styles.bearing), n._fireEvent("animating");
      } else (v.playState !== "paused" || v === n._mapAnimPlayer) && (v._interupted || (a.center ? n._setPrjCenter(s.project(a.center[1])) : a.prjCenter && n._setPrjCenter(a.prjCenter[1]), W(a.pitch) || n._setPitch(a.pitch[1]), W(a.bearing) || n._setBearing(a.bearing[1])), n._endAnim(v, a, p, e));
      r && r(_);
    }, this);
    return this._startAnim(a, p), v;
  },
  _animateTo: function(t, e, r) {
    return e === void 0 && (e = {}), this._mapAnimPlayer && this._stopAnim(this._mapAnimPlayer), this._isInternalAnimation = !0, this._mapAnimPlayer = this.animateTo(t, e, r), delete this._isInternalAnimation, this._mapAnimPlayer;
  },
  flyTo: function(t, e, r) {
    var n = this;
    e === void 0 && (e = {}), t = jt({}, this.getView(), t), this._animPlayer && (this._isInternalAnimation ? this._animPlayer.playState === "running" && (this._animPlayer.pause(), this._prevAnimPlayer = this._animPlayer) : (delete this._prevAnimPlayer, this._stopAnim(this._animPlayer))), Be(e) && (r = e, e = {}), e = jt({
      curve: 1.42
    }, e);
    var s = this;
    function o(st, pt) {
      return s.getResolution(pt) / s.getResolution(st);
    }
    var a = t.around || new Y(this.width / 2, this.height / 2), l = this.getMinZoom(), h = this.getMaxZoom(), u = this.getProjection(), c = this.getView(), f = c.zoom, d = c.bearing, p = c.pitch, g = "zoom" in t ? Hf(+t.zoom, l, h) : f, m = "bearing" in t ? +t.bearing : d, v = "pitch" in t ? +t.pitch : p, _ = u.project(t.center && new lt(t.center) || this.getCenter()), y = o(g, f), x = u.project(this.getCenter()), w = _.sub(x), b = e.curve, T = Math.max(this.width, this.height), A = T / y, M = w.mag();
    if ("minZoom" in e) {
      var S = Hf(Math.min(e.minZoom, f, g), l, h), P = T / o(S, f);
      b = Math.sqrt(P / M * 2);
    }
    var C = b * b;
    function k(st) {
      var pt = (A * A - T * T + (st ? -1 : 1) * C * C * M * M) / (2 * (st ? A : T) * C * M);
      return Math.log(Math.sqrt(pt * pt + 1) - pt);
    }
    function O(st) {
      return (Math.exp(st) - Math.exp(-st)) / 2;
    }
    function R(st) {
      return (Math.exp(st) + Math.exp(-st)) / 2;
    }
    function I(st) {
      return O(st) / R(st);
    }
    var D = k(0), z = function(pt) {
      return R(D) / R(D + b * pt);
    }, H = function(pt) {
      return T * ((R(D) * I(D + b * pt) - O(D)) / C) / M;
    }, G = (k(1) - D) / b;
    if (Math.abs(M) < 1e-6 || !isFinite(G)) {
      if (Math.abs(T - A) < 1e-6) return this.animateTo(t, e, r);
      var $ = A < T ? -1 : 1;
      G = Math.abs(Math.log(A / T)) / b, H = function() {
        return 0;
      }, z = function(pt) {
        return Math.exp($ * b * pt);
      };
    }
    var K = this._getRenderer(), dt = function(pt) {
      K.callInNextFrame(pt);
    }, it = this._animPlayer = dr.animate({
      k: [0, 1]
    }, {
      easing: e.easing || "out",
      duration: e.duration || 8,
      framer: dt
    }, function(st) {
      if (n.isRemoved()) {
        it.finish();
        return;
      }
      var pt = st.styles.k, Ht = pt * G, Rt = 1 / z(Ht), Tt = {};
      if (t.center) {
        var $t = pt === 1 ? _ : x.add(w.multi(H(Ht)));
        Tt.prjCenter = [_, $t];
      }
      if (f !== g) {
        var Wt = pt === 1 ? g : n.getZoomForScale(Rt, f, !0);
        Tt.zoom = [f, Wt];
      }
      if (p !== v) {
        var re = K1(p, v, pt);
        Tt.pitch = [v, re];
      }
      if (d !== m) {
        var ie = K1(d, m, pt);
        Tt.bearing = [m, ie];
      }
      if (it.playState === "running") {
        if (Tt.prjCenter) {
          var Kt = Tt.prjCenter;
          n._setPrjCenter(Kt[1]), n.onMoving(n._parseEventFromCoord(n.getCenter()));
        }
        Tt.zoom && n.onZooming(Tt.zoom[1], a), Tt.pitch && n._setPitch(Tt.pitch[1]), Tt.bearing && n._setBearing(Tt.bearing[1]), n._fireEvent("animating");
      } else (it.playState !== "paused" || it === n._mapAnimPlayer) && (it._interupted || (Tt.prjCenter && n._setPrjCenter(Tt.prjCenter[1]), Tt.pitch && n._setPitch(Tt.pitch[1]), Tt.bearing && n._setBearing(Tt.bearing[1])), n._endAnim(it, Tt, a, e));
      r && r(st);
    });
    return this._startAnim({
      center: t.center,
      zoom: t.zoom !== f,
      pitch: v !== p,
      bearing: m !== d
    }, a), this;
  },
  isAnimating: function() {
    return !!this._animPlayer;
  },
  isRotating: function() {
    return this.isDragRotating() || !!this._animRotating;
  },
  _endAnim: function(t, e, r, n) {
    delete this._animRotating;
    var s = t._interupted ? "animateinterrupted" : "animateend";
    if (t === this._animPlayer && delete this._animPlayer, t === this._mapAnimPlayer && delete this._mapAnimPlayer, e.center) {
      var o;
      t._interupted ? o = this.getCenter() : o = e.center[1], this.onMoveEnd(this._parseEventFromCoord(o));
    } else if (e.prjCenter) {
      var a;
      t._interupted ? a = this._getPrjCenter() : a = e.prjCenter[1];
      var l = this._parseEventFromCoord(this.getProjection().unproject(a));
      l.point2d = this._prjToPoint(a), this.onMoveEnd(l);
    }
    W(e.zoom) || (t._interupted ? this.onZoomEnd(this.getZoom()) : n.wheelZoom ? this.onZooming(e.zoom[1], r) : this.onZoomEnd(e.zoom[1])), s && this._fireEvent(s), !W(e.pitch) && !this.getPitch() && this.getRenderer().setToRedraw(), n.wheelZoom || this._resumePrev(t);
  },
  _startAnim: function(t, e) {
    this._animPlayer && ((t.center || t.prjCenter) && this.onMoveStart(), t.zoom && !this.isZooming() && this.onZoomStart(t.zoom[1], e), (t.pitch || t.bearing) && (this._animRotating = !0), this._fireEvent("animatestart"), this._animPlayer.play());
  },
  _stopAnim: function(t) {
    t && (delete this._animRotating, t.playState !== "finished" && (t._interupted = !0, t.cancel()), t === this._animPlayer && delete this._animPlayer, t === this._mapAnimPlayer && delete this._mapAnimPlayer);
  },
  _resumePrev: function(t) {
    if (this._prevAnimPlayer) {
      var e = this._prevAnimPlayer;
      e.playState !== "paused" && delete this._prevAnimPlayer, t !== e && (this._animPlayer = e, e.play());
    }
  }
});
function K1(i, t, e) {
  return i * (1 - e) + t * e;
}
function Q1(i) {
  i.stopPropagation(), i.preventDefault();
}
var t_ = ["dragstart", "dragenter", "dragend", "dragleave", "dragover"].join(" ").toString(), e_ = "mousedown mouseup mouseover mouseout mouseenter mouseleave mousemove click dblclick contextmenu keypress touchstart touchmove touchend drop ";
xe.include({
  _registerDomEvents: function() {
    var t = this._panels.mapWrapper || this._containerDOM;
    Gi(t, e_, this._handleDOMEvent, this), Gi(t, t_, Q1, this);
  },
  _removeDomEvents: function() {
    var t = this._panels.mapWrapper || this._containerDOM;
    Ho(t, e_, this._handleDOMEvent), Ho(t, t_, Q1);
  },
  _handleDOMEvent: function(t) {
    if (t && t.type === "drop") {
      t.stopPropagation(), t.preventDefault();
      var e = this._parseEvent(t, t.type);
      e = jt({}, e, {
        dataTransfer: t.dataTransfer
      }), this._fireEvent(t.type, e);
      return;
    }
    var r = this.options.clickTimeThreshold, n = t.type;
    if (!(Xf(n) && !xs.isTest && lT(this, this.options.mousemoveThrottleTime))) {
      var s = n === "mousedown" || n === "touchstart" && (!t.touches || t.touches.length === 1);
      s && (this._domMouseDownTime = Je(), this._domMouseDownView = this.getView());
      var o = n === "contextmenu" && bO(this);
      if (n === "contextmenu") {
        ks(t);
        var a = this._domMouseDownTime, l = Je();
        l - a <= r && !o && this._fireDOMEvent(this, t, "dom:" + t.type);
      } else
        this._fireDOMEvent(this, t, "dom:" + t.type);
      if (!(this._ignoreEvent(t) || this._isEventOutMap(t))) {
        var h = !1;
        if (s)
          this._mouseDownTime = Je();
        else if (n === "click" || n === "touchend" || n === "contextmenu")
          if (this._mouseDownTime) {
            var u = this._mouseDownTime;
            delete this._mouseDownTime;
            var c = Je();
            if (c - u > r) {
              if (n === "click" || n === "contextmenu")
                return;
            } else if (n === "contextmenu") {
              if (o)
                return;
            } else n === "touchend" && (h = !0);
          } else
            return;
        var f;
        h && (this._clickTime && Je() - this._clickTime <= r ? (delete this._clickTime, f = "dblclick", this._fireDOMEvent(this, t, "dom:dblclick")) : (this._clickTime = Je(), f = "click", this._fireDOMEvent(this, t, "dom:click"))), !(this._ignoreEvent(t) || this._isEventOutMap(t)) && (this._fireDOMEvent(this, t, n), f && this._fireDOMEvent(this, t, f));
      }
    }
  },
  _ignoreEvent: function(t) {
    if (!t || !this._panels.control)
      return !1;
    var e = t.srcElement || t.target, r;
    if (e)
      for (; e && e !== this._containerDOM; ) {
        if (e.className && e.className.indexOf && (e.className.indexOf("maptalks-control") >= 0 || e.className.indexOf("maptalks-ui") >= 0 && r && !r.eventsPropagation))
          return !0;
        r = e, e = e.parentNode;
      }
    return !1;
  },
  _isEventOutMap: function(t) {
    if (this.getPitch() > this.options.maxVisualPitch) {
      var e = this._getActualEvent(t), r = ai(e, this._containerDOM);
      if (!this.getContainerExtent().contains(r))
        return !0;
    }
    return !1;
  },
  _wrapTerrainData: function(t) {
    t.containerPoint && !t.terrain && (t.terrain = this._queryTerrainInfo(t.containerPoint));
  },
  _parseEvent: function(t, e) {
    if (!t)
      return null;
    var r = {
      domEvent: t
    };
    if (e !== "keypress") {
      var n = this._getActualEvent(t);
      if (n && n.clientX !== void 0) {
        var s = ai(n, this._containerDOM);
        r = jt(r, {
          containerPoint: s,
          viewPoint: this.containerPointToViewPoint(s)
        });
        var o = this.options.maxVisualPitch;
        (this.getPitch() <= o || s.y >= this.height - this._getVisualHeight(o)) && (r = jt(r, {
          coordinate: this.containerPointToCoord(s),
          point2d: this._containerPointToPoint(s)
        }));
      }
    }
    return this._wrapTerrainData(r), r;
  },
  _parseEventFromCoord: function(t) {
    var e = this.coordToContainerPoint(t), r = this.containerPointToViewPoint(e), n = {
      coordinate: t,
      containerPoint: e,
      viewPoint: r,
      point2d: this.coordToPoint(t)
    };
    return n;
  },
  _getActualEvent: function(t) {
    return t.touches && t.touches.length > 0 ? t.touches[0] : t.changedTouches && t.changedTouches.length > 0 ? t.changedTouches[0] : t;
  },
  _fireDOMEvent: function(t, e, r) {
    var n = this;
    if (!this.isRemoved()) {
      var s = this._parseEvent(e, r);
      this._wrapTerrainData(s), Xf(r) ? this.getRenderer().callInNextFrame(function() {
        if (s.domEvent && s.domEvent._cancelBubble) {
          n._fireEvent("_" + r, s);
          return;
        }
        n._fireEvent(r, s);
      }) : this._fireEvent(r, s);
    }
  },
  _getEventParams: function(t) {
    var e = this, r = {
      domEvent: t
    }, n = t.touches && t.touches.length > 0 ? t.touches[0] : t.changedTouches && t.changedTouches.length > 0 ? t.changedTouches[0] : t;
    if (n) {
      var s = ai(n, e._containerDOM);
      r.coordinate = e.containerPointToCoordinate(s), r.containerPoint = s, r.viewPoint = e.containerPointToViewPoint(s), r.pont2d = e._containerPointToPoint(s);
    }
    return this._wrapTerrainData(r), r;
  }
});
xe.addOnLoadHook("_registerDomEvents");
function bO(i) {
  if (!i._domMouseDownView)
    return !0;
  var t = i.getView(), e = i._domMouseDownView;
  return t.bearing !== e.bearing || t.pitch !== e.pitch;
}
xe.include({
  isFullScreen: function() {
    return !!(document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement || document.fullscreenElement);
  },
  requestFullScreen: function(t) {
    return this._fireEvent("fullscreenstart"), this._requestFullScreen(t || this._containerDOM), this._fireEvent("fullscreenend"), this;
  },
  cancelFullScreen: function() {
    return this._cancelFullScreen(), this._fireEvent("cancelfullscreen"), this;
  },
  _requestFullScreen: function(t) {
    if (t.requestFullscreen)
      t.requestFullscreen();
    else if (t.mozRequestFullScreen)
      t.mozRequestFullScreen();
    else if (t.webkitRequestFullScreen)
      t.webkitRequestFullScreen();
    else if (t.msRequestFullScreen)
      t.msRequestFullScreen();
    else {
      var e = "fullscreen=1,status=no,resizable=yes,top=0,left=0,scrollbars=no,titlebar=no,menubar=no,location=no,toolbar=no,z-look=yes,width=" + (screen.availWidth - 8) + ",height=" + (screen.availHeight - 45), r = window.open(location.href, "_blank", e);
      r !== null && (window.opener = null, window.close());
    }
  },
  _cancelFullScreen: function() {
    if (document.exitFullscreen)
      document.exitFullscreen();
    else if (document.mozCancelFullScreen)
      document.mozCancelFullScreen();
    else if (document.webkitCancelFullScreen)
      document.webkitCancelFullScreen();
    else {
      var t = "fullscreen=no,status=yes,resizable=yes,scrollbars=no,titlebar=no,menubar=yes,location=yes,toolbar=yes,z-look=yes", e = window.open(location.href, "_blank", t);
      e !== null && (window.opener = null, window.close());
    }
  }
});
xe.include({
  panTo: function(t, e, r) {
    if (e === void 0 && (e = {}), !t)
      return this;
    if (Be(e) && (r = e, e = {}), t = new lt(t), typeof e.animation > "u" || e.animation) {
      var n = this.getProjection().project(t);
      return this._panAnimation(n, e.duration, r);
    } else
      this.setCenter(t);
    return this;
  },
  _panTo: function(t, e) {
    return e === void 0 && (e = {}), typeof e.animation > "u" || e.animation ? this._panAnimation(t, e.duration) : (this.onMoveStart(), this._setPrjCenter(t), this.onMoveEnd(this._parseEventFromCoord(this.getCenter())), this);
  },
  panBy: function(t, e, r) {
    if (e === void 0 && (e = {}), !t)
      return this;
    Be(e) && (r = e, e = {}), t = new Y(t);
    var n = this.getContainerExtent(), s = n.ymin;
    if (s > 0 && t.y > 30) {
      var o = t.y;
      t.y = 30, t.x = t.x * 30 / o, console.warn("offset is limited to panBy when pitch is above maxPitch");
    }
    if (typeof e.animation > "u" || e.animation) {
      t = t.multi(-1);
      var a = this._containerPointToPrj(new Y(this.width / 2 + t.x, this.height / 2 + t.y));
      this._panAnimation(a, e.duration, r);
    } else {
      this.onMoveStart(), this._offsetCenterByPixel(t);
      var l = this.containerPointToCoord(new Y(this.width / 2, this.height / 2));
      this.onMoveEnd(this._parseEventFromCoord(l));
    }
    return this;
  },
  _panAnimation: function(t, e, r) {
    return this._animateTo({
      prjCenter: t
    }, {
      duration: e || this.options.panAnimationDuration
    }, r);
  }
});
nn.fromJSON = function(i) {
  if (Array.isArray(i)) {
    for (var t = [], e = 0, r = i.length; e < r; e++) {
      var n = nn.fromJSON(i[e]);
      Array.isArray(i) ? t = t.concat(n) : t.push(n);
    }
    return t;
  }
  if (i && !i.feature)
    return wi.toGeometry(i);
  var s;
  return i.subType ? (s = nn.getJSONClass(i.subType).fromJSON(i), W(i.feature.id) || s.setId(i.feature.id)) : (s = wi.toGeometry(i.feature), i.options && s.config(i.options)), i.symbol && s.setSymbol(i.symbol), i.infoWindow && s.setInfoWindow(i.infoWindow), s;
};
gr.fromJSON = function(i) {
  if (!i)
    return null;
  var t = i.type, e = gr.getJSONClass(t);
  if (!e || !e.fromJSON)
    throw new Error("unsupported layer type:" + t);
  return e.fromJSON(i);
};
xe.include({
  JSON_VERSION: "1.0",
  toJSON: function(t) {
    t || (t = {});
    var e = {
      jsonVersion: this.JSON_VERSION,
      version: this.VERSION,
      extent: this.getExtent().toJSON()
    };
    e.options = this.config(), e.options.center = this.getCenter(), e.options.zoom = this.getZoom(), e.options.bearing = this.getBearing(), e.options.pitch = this.getPitch();
    var r = this.getBaseLayer();
    (W(t.baseLayer) || t.baseLayer) && r && (e.baseLayer = r.toJSON(t.baseLayer));
    var n = {};
    t.clipExtent && (t.clipExtent === !0 ? n.clipExtent = this.getExtent() : n.clipExtent = t.clipExtent);
    var s = [];
    if (W(t.layers) || t.layers && !Array.isArray(t.layers)) {
      for (var o = this.getLayers(), a = 0, l = o.length; a < l; a++)
        if (o[a].toJSON) {
          var h = jt({}, ji(t.layers) ? t.layers : {}, n);
          s.push(o[a].toJSON(h));
        }
      e.layers = s;
    } else if (sn(t.layers)) {
      for (var u = t.layers, c = 0; c < u.length; c++) {
        var f = u[c], d = this.getLayer(f.id);
        if (d.toJSON) {
          var p = jt({}, f.options, n);
          s.push(d.toJSON(p));
        }
      }
      e.layers = s;
    } else
      e.layers = [];
    return e;
  }
});
xe.fromJSON = function(i, t, e) {
  if (!i || !t)
    return null;
  e || (e = {});
  var r = new xe(i, t.options);
  if (W(e.baseLayer) || e.baseLayer) {
    var n = gr.fromJSON(t.baseLayer);
    n && r.setBaseLayer(n);
  }
  if (W(e.layers) || e.layers) {
    for (var s = [], o = t.layers, a = 0; a < o.length; a++) {
      var l = gr.fromJSON(o[a]);
      s.push(l);
    }
    r.addLayer(s);
  }
  return r;
};
xe.include({
  computeLength: function(t, e) {
    if (!this.getProjection())
      return null;
    var r = new lt(t), n = new lt(e);
    return r.equals(n) ? 0 : this.getProjection().measureLength(r, n);
  },
  computeGeometryLength: function(t) {
    return t._computeGeodesicLength(this.getProjection());
  },
  computeGeometryArea: function(t) {
    return t._computeGeodesicArea(this.getProjection());
  },
  identify: function(t, e) {
    t = t || {};
    var r = new lt(t.coordinate);
    return this._identify(t, e, function(n) {
      return n.identify(r, t);
    });
  },
  identifyAtPoint: function(t, e) {
    var r = t.includeInternals, n = t.tolerance;
    t = t || {};
    var s = new Y(t.containerPoint), o = this.containerPointToCoord(s);
    return this._identify(t, e, function(a) {
      var l, h = t.containerPoint;
      if (r && !W(a.options.geometryEventTolerance) && (t.tolerance = t.tolerance || 0, t.tolerance += a.options.geometryEventTolerance), a._hasGeoListeners && r && t.eventTypes.indexOf("mousemove") >= 0 && !a._hasGeoListeners(t.eventTypes))
        return [];
      if (a.identifyAtPoint ? l = a.identifyAtPoint(h, t) : o && a.identify ? l = a.identify(o, t) : l = [], r && (W(n) ? delete t.tolerance : t.tolerance = n), (!l || !l.length) && (a.fire("identifyempty", t), a.getLayers && Be(a.getLayers))) {
        var u = (a.getLayers() || []).filter(function(c) {
          return c;
        });
        u.forEach(function(c) {
          c.fire("identifyempty", t);
        });
      }
      return l;
    });
  },
  _identify: function(t, e, r) {
    var n = t.layers;
    if (!sn(n))
      return this;
    for (var s = t.eventTypes, o = [], a = 0, l = n.length; a < l; a++)
      De(n[a]) ? o.push(this.getLayer(n[a])) : o.push(n[a]);
    s && (o = o.filter(function(g) {
      return g._hasGeoListeners ? g._hasGeoListeners(s) : !0;
    }));
    for (var h = [], u = o.length - 1; u >= 0 && !(t.count && h.length >= t.count); u--) {
      var c = o[u];
      if (!(!c || !c.getMap() || !t.includeInvisible && !c.isVisible() || !t.includeInternals && c.getId().indexOf(Eu) >= 0)) {
        var f = r(c), d = c.getId();
        if (f)
          if (Array.isArray(f)) {
            for (var p = 0; p < f.length; p++)
              f[p] && !f[p].getLayer && W(f[p].layer) && (f[p].layer = d);
            Ui(h, f);
          } else
            !f.getLayer && W(f.layer) && (f.layer = d), h.push(f);
      }
    }
    return e.call(this, h), this;
  }
});
xe.include({
  _zoom: function(t, e) {
    !this.options.zoomable || this.isZooming() || (e = this._checkZoomOrigin(e), t = this._checkZoom(t), this.onZoomStart(t, e), this._frameZoom = this.getZoom(), this.onZoomEnd(t, e));
  },
  _zoomAnimation: function(t, e, r) {
    !this.options.zoomable || this.isZooming() || (t = this._checkZoom(t), this.getZoom() !== t && (e = this._checkZoomOrigin(e), this._startZoomAnim(t, e, r)));
  },
  _checkZoomOrigin: function(t) {
    return (!t || this.options.zoomInCenter) && (t = new Y(this.width / 2, this.height / 2)), this.options.zoomOrigin && (t = new Y(this.options.zoomOrigin)), t;
  },
  _startZoomAnim: function(t, e, r) {
    W(r) && (r = 1);
    var n = this._getResolution(this._startZoomVal) / this._getResolution(t), s = this.options.zoomAnimationDuration * Math.abs(n - r) / Math.abs(n - 1);
    this._frameZoom = this._startZoomVal, this._animateTo({
      zoom: t,
      around: e
    }, {
      continueOnViewChanged: !0,
      duration: s
    });
  },
  onZoomStart: function(t, e) {
    !this.options.zoomable || this.isZooming() || (this._mapAnimPlayer && this._stopAnim(this._mapAnimPlayer), delete this.cameraZenithDistance, this._zooming = !0, this._startZoomVal = this.getZoom(), this._startZoomCoord = this._containerPointToPrj(e), this._fireEvent("zoomstart", {
      from: this._startZoomVal,
      to: t
    }));
  },
  onZooming: function(t, e, r) {
    if (this.options.zoomable) {
      var n = this._frameZoom;
      if (n !== t) {
        W(r) && (r = 1), this._zoomTo(t, e);
        var s = this.getResolution(t), o = this.getResolution(this._startZoomVal), a = o / s / r, l = this._prjToContainerPoint(this._startZoomCoord, this._startZoomVal), h = this.getViewPoint();
        if (!this.isRotating() && !l.equals(e) && a !== 1) {
          var u = this.getPitch(), c = l._sub(e)._multi(1 / (1 - a));
          u && (c.y /= Math.cos(u * Math.PI / 180)), e = e.add(c);
        }
        var f = {
          view: [a, 0, 0, a, (e.x - h.x) * (1 - a), (e.y - h.y) * (1 - a)]
        }, d = this.getDevicePixelRatio();
        d !== 1 && (e = e.multi(d)), f.container = [a, 0, 0, a, e.x * (1 - a), e.y * (1 - a)], this._fireEvent("zooming", {
          from: this._startZoomVal,
          to: t,
          origin: e,
          matrix: f
        }), this._frameZoom = t;
      }
    }
  },
  onZoomEnd: function(t, e) {
    if (this.options.zoomable) {
      var r = this._startZoomVal;
      this._zoomTo(t, e), this._zooming = !1, this._getRenderer().onZoomEnd(), this._suppressRecenter || this._recenterOnTerrain(), this._fireEvent("zoomend", {
        from: r,
        to: t
      }), this._verifyExtent(this._getPrjCenter()) || this._panTo(this._prjMaxExtent.getCenter());
    }
  },
  _zoomTo: function(t, e) {
    if (this._zoomLevel = t, this._calcMatrices(), e) {
      var r = this._containerPointToPoint(e), n = r._sub(this._prjToPoint(this._getPrjCenter()));
      this._setPrjCoordAtOffsetToCenter(this._startZoomCoord, n);
    }
  },
  _checkZoom: function(t) {
    var e = this.getMaxZoom(), r = this.getMinZoom();
    return t < r && (t = r), t > e && (t = e), t;
  }
});
function n_(i, t, e, r, n) {
  var s = 1 / Math.tan(t / 2), o = 1 / (r - n);
  return i[0] = s / e, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = s, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = (n + r) * o, i[11] = -1, i[12] = 0, i[13] = 0, i[14] = 2 * n * r * o, i[15] = 0, i;
}
function oA(i, t, e) {
  var r = e[0], n = e[1], s = e[2], o, a, l, h, u, c, f, d, p, g, m, v;
  return t === i ? (i[12] = t[0] * r + t[4] * n + t[8] * s + t[12], i[13] = t[1] * r + t[5] * n + t[9] * s + t[13], i[14] = t[2] * r + t[6] * n + t[10] * s + t[14], i[15] = t[3] * r + t[7] * n + t[11] * s + t[15]) : (o = t[0], a = t[1], l = t[2], h = t[3], u = t[4], c = t[5], f = t[6], d = t[7], p = t[8], g = t[9], m = t[10], v = t[11], i[0] = o, i[1] = a, i[2] = l, i[3] = h, i[4] = u, i[5] = c, i[6] = f, i[7] = d, i[8] = p, i[9] = g, i[10] = m, i[11] = v, i[12] = o * r + u * n + p * s + t[12], i[13] = a * r + c * n + g * s + t[13], i[14] = l * r + f * n + m * s + t[14], i[15] = h * r + d * n + v * s + t[15]), i;
}
function t0(i, t, e) {
  var r = e[0], n = e[1], s = e[2];
  return i[0] = t[0] * r, i[1] = t[1] * r, i[2] = t[2] * r, i[3] = t[3] * r, i[4] = t[4] * n, i[5] = t[5] * n, i[6] = t[6] * n, i[7] = t[7] * n, i[8] = t[8] * s, i[9] = t[9] * s, i[10] = t[10] * s, i[11] = t[11] * s, i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i;
}
function wO(i, t, e) {
  var r = Math.sin(e), n = Math.cos(e), s = t[4], o = t[5], a = t[6], l = t[7], h = t[8], u = t[9], c = t[10], f = t[11];
  return t !== i && (i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[4] = s * n + h * r, i[5] = o * n + u * r, i[6] = a * n + c * r, i[7] = l * n + f * r, i[8] = h * n - s * r, i[9] = u * n - o * r, i[10] = c * n - a * r, i[11] = f * n - l * r, i;
}
function TO(i, t, e) {
  var r = Math.sin(e), n = Math.cos(e), s = t[0], o = t[1], a = t[2], l = t[3], h = t[4], u = t[5], c = t[6], f = t[7];
  return t !== i && (i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[0] = s * n + h * r, i[1] = o * n + u * r, i[2] = a * n + c * r, i[3] = l * n + f * r, i[4] = h * n - s * r, i[5] = u * n - o * r, i[6] = c * n - a * r, i[7] = f * n - l * r, i;
}
function Th(i, t, e) {
  var r = t[0], n = t[1], s = t[2], o = t[3], a = t[4], l = t[5], h = t[6], u = t[7], c = t[8], f = t[9], d = t[10], p = t[11], g = t[12], m = t[13], v = t[14], _ = t[15], y = e[0], x = e[1], w = e[2], b = e[3];
  return i[0] = y * r + x * a + w * c + b * g, i[1] = y * n + x * l + w * f + b * m, i[2] = y * s + x * h + w * d + b * v, i[3] = y * o + x * u + w * p + b * _, y = e[4], x = e[5], w = e[6], b = e[7], i[4] = y * r + x * a + w * c + b * g, i[5] = y * n + x * l + w * f + b * m, i[6] = y * s + x * h + w * d + b * v, i[7] = y * o + x * u + w * p + b * _, y = e[8], x = e[9], w = e[10], b = e[11], i[8] = y * r + x * a + w * c + b * g, i[9] = y * n + x * l + w * f + b * m, i[10] = y * s + x * h + w * d + b * v, i[11] = y * o + x * u + w * p + b * _, y = e[12], x = e[13], w = e[14], b = e[15], i[12] = y * r + x * a + w * c + b * g, i[13] = y * n + x * l + w * f + b * m, i[14] = y * s + x * h + w * d + b * v, i[15] = y * o + x * u + w * p + b * _, i;
}
function r_(i, t) {
  var e = t[0], r = t[1], n = t[2], s = t[3], o = t[4], a = t[5], l = t[6], h = t[7], u = t[8], c = t[9], f = t[10], d = t[11], p = t[12], g = t[13], m = t[14], v = t[15], _ = e * a - r * o, y = e * l - n * o, x = e * h - s * o, w = r * l - n * a, b = r * h - s * a, T = n * h - s * l, A = u * g - c * p, M = u * m - f * p, S = u * v - d * p, P = c * m - f * g, C = c * v - d * g, k = f * v - d * m, O = _ * k - y * C + x * P + w * S - b * M + T * A;
  return O ? (O = 1 / O, i[0] = (a * k - l * C + h * P) * O, i[1] = (n * C - r * k - s * P) * O, i[2] = (g * T - m * b + v * w) * O, i[3] = (f * b - c * T - d * w) * O, i[4] = (l * S - o * k - h * M) * O, i[5] = (e * k - n * S + s * M) * O, i[6] = (m * x - p * T - v * y) * O, i[7] = (u * T - f * x + d * y) * O, i[8] = (o * C - a * S + h * A) * O, i[9] = (r * S - e * C - s * A) * O, i[10] = (p * b - g * x + v * _) * O, i[11] = (c * x - u * b - d * _) * O, i[12] = (a * M - o * P - l * A) * O, i[13] = (e * P - r * M + n * A) * O, i[14] = (g * y - p * w - m * _) * O, i[15] = (u * w - c * y + f * _) * O, i) : null;
}
function zv(i) {
  return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
}
function i_(i, t) {
  return i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i;
}
function Lr(i, t, e, r) {
  return i[0] = t, i[1] = e, i[2] = r, i;
}
function AO(i, t, e) {
  return i[0] = t[0] + e[0], i[1] = t[1] + e[1], i[2] = t[2] + e[2], i;
}
function Ah(i, t, e) {
  return i[0] = t[0] - e[0], i[1] = t[1] - e[1], i[2] = t[2] - e[2], i;
}
function s_(i) {
  var t = i[0], e = i[1], r = i[2];
  return Math.sqrt(t * t + e * e + r * r);
}
function cl(i, t) {
  var e = t[0], r = t[1], n = t[2], s = e * e + r * r + n * n;
  return s > 0 && (s = 1 / Math.sqrt(s), i[0] = t[0] * s, i[1] = t[1] * s, i[2] = t[2] * s), i;
}
function aA(i, t) {
  return i[0] * t[0] + i[1] * t[1] + i[2] * t[2];
}
function MO(i, t, e) {
  return i[0] = t[0] * e, i[1] = t[1] * e, i[2] = t[2] * e, i;
}
function $p(i, t, e) {
  var r = t[0], n = t[1], s = t[2], o = e[0], a = e[1], l = e[2];
  return i[0] = n * l - s * a, i[1] = s * o - r * l, i[2] = r * a - n * o, i;
}
function e0(i, t) {
  var e = t[0] - i[0], r = t[1] - i[1], n = t[2] - i[2];
  return Math.hypot ? Math.hypot(e, r, n) : CO(e, r, n);
}
function SO(i, t, e) {
  var r = t[0], n = t[1], s = t[2], o = e[3] * r + e[7] * n + e[11] * s + e[15];
  return o = o || 1, i[0] = (e[0] * r + e[4] * n + e[8] * s + e[12]) / o, i[1] = (e[1] * r + e[5] * n + e[9] * s + e[13]) / o, i[2] = (e[2] * r + e[6] * n + e[10] * s + e[14]) / o, i;
}
function CO() {
  for (var i = 0, t = arguments.length; t--; )
    i += arguments[t] * arguments[t];
  return Math.sqrt(i);
}
function o_(i, t) {
  cl(i, i), cl(t, t);
  var e = aA(i, t);
  return e > 1 ? 0 : e < -1 ? Math.PI : Math.acos(e);
}
function Wp(i, t, e) {
  var r = t[0], n = t[1], s = t[2], o = 1 / (e[3] * r + e[7] * n + e[11] * s + e[15]);
  return i[0] = (e[0] * r + e[4] * n + e[8] * s + e[12]) * o, i[1] = (e[1] * r + e[5] * n + e[9] * s + e[13]) * o, i[2] = (e[2] * r + e[6] * n + e[10] * s + e[14]) * o, i;
}
function PO(i, t) {
  var e = t[0], r = t[4], n = t[8], s = t[1], o = t[5], a = t[9], l = t[2], h = t[6], u = t[10], c = e + o + u, f;
  return c > 0 ? (f = 0.5 / Math.sqrt(c + 1), i.w = 0.25 / f, i.x = (h - a) * f, i.y = (n - l) * f, i.z = (s - r) * f) : e > o && e > u ? (f = 2 * Math.sqrt(1 + e - o - u), i.w = (h - a) / f, i.x = 0.25 * f, i.y = (r + s) / f, i.z = (n + l) / f) : o > u ? (f = 2 * Math.sqrt(1 + o - e - u), i.w = (n - l) / f, i.x = (r + s) / f, i.y = 0.25 * f, i.z = (a + h) / f) : (f = 2 * Math.sqrt(1 + u - e - o), i.w = (s - r) / f, i.x = (n + l) / f, i.y = (a + h) / f, i.z = 0.25 * f), this;
}
function EO(i, t) {
  var e = i, r = t.x, n = t.y, s = t.z, o = t.w, a = r + r, l = n + n, h = s + s, u = r * a, c = r * l, f = r * h, d = n * l, p = n * h, g = s * h, m = o * a, v = o * l, _ = o * h;
  return e[0] = 1 - (d + g), e[4] = c - _, e[8] = f + v, e[1] = c + _, e[5] = 1 - (u + g), e[9] = p - m, e[2] = f - v, e[6] = p + m, e[10] = 1 - (u + d), e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
}
function OO(i, t) {
  var e = i;
  return e[12] = t[0], e[13] = t[1], e[14] = t[2], i;
}
function kO(i, t, e, r) {
  var n = [0, 0, 0], s = [0, 0, 0], o = [0, 0, 0];
  return Ah(o, t, e), s_(o) === 0 && (o[2] = 1), cl(o, o), $p(n, r, o), s_(o) === 0 && (Math.abs(r[2]) === 1 ? o[0] += 1e-4 : o[2] += 1e-4, cl(o, o), $p(n, r, o)), cl(n, n), $p(s, o, n), i[0] = n[0], i[4] = s[0], i[8] = o[0], i[1] = n[1], i[5] = s[1], i[9] = o[1], i[2] = n[2], i[6] = s[2], i[10] = o[2], i;
}
var ei = Math.PI / 180, RO = 0.6435011087932844, Zp = new lt(0, 0), a_ = new Y(0, 0), IO = [0, -1, 0], l_ = [], DO = function(t) {
  if (Ut(t))
    return t !== 0;
  if (Array.isArray(t) && t.length > 0) {
    for (var e = 0, r = t.length; e < r; e++)
      if (Ut(t[e]) && t[e] !== 0)
        return !0;
  }
  return !1;
};
xe.include({
  getFov: function() {
    return this._fov || (this._fov = RO), this._fov / ei;
  },
  setFov: function(t) {
    if (this.isZooming())
      return this;
    if (t = Math.max(0.01, Math.min(60, t)), this._fov === t) return this;
    var e = this.getFov();
    return this._fov = t * ei, this._calcMatrices(), this._renderLayers(), this._fireEvent("fovchange", {
      from: e,
      to: this.getFov()
    }), this;
  },
  getBearing: function() {
    return this._angle ? -this._angle / ei : 0;
  },
  setBearing: function(t) {
    return this._mapAnimPlayer && this._stopAnim(this._mapAnimPlayer), this._setBearing(t);
  },
  _setBearing: function(t) {
    if (Ce.ie9)
      throw new Error("map can't rotate in IE9.");
    var e = -Ps(t, -180, 180) * ei;
    if (this._angle === e) return this;
    var r = this.getBearing();
    return this._fireEvent("rotatestart", {
      from: r,
      to: e
    }), this._angle = e, this._calcMatrices(), this._renderLayers(), this._fireEvent("rotate", {
      from: r,
      to: e
    }), this._fireEvent("rotateend", {
      from: r,
      to: e
    }), this;
  },
  getPitch: function() {
    return this._pitch ? this._pitch / Math.PI * 180 : 0;
  },
  setPitch: function(t) {
    return this._mapAnimPlayer && this._stopAnim(this._mapAnimPlayer), this._setPitch(t);
  },
  _setPitch: function(t) {
    if (Ce.ie9)
      throw new Error("map can't tilt in IE9.");
    var e = Hf(t, 0, this.options.maxPitch) * ei;
    if (this._pitch === e) return this;
    var r = this.getPitch();
    return this._fireEvent("pitchstart", {
      from: r,
      to: e
    }), this._pitch = e, this._calcMatrices(), this._renderLayers(), this._fireEvent("pitch", {
      from: r,
      to: e
    }), this._fireEvent("pitchend", {
      from: r,
      to: e
    }), this;
  },
  setCameraMovements: function(t, e) {
    var r = this;
    if (!Array.isArray(t) || !t.length)
      return this;
    if (this.setView({
      center: t[0].center,
      zoom: t[0].zoom,
      pitch: t[0].pitch,
      bearing: t[0].bearing
    }), t.length === 1) return this;
    var n = 1, s = function(d) {
      if (d.state.playState === "finished") {
        n++, n === t.length - 1 && (s = null);
        var p = t[n];
        p.duration = p.timestamp - t[n - 1].timestamp, e && e.autoRotate && (p.bearing = FO(t[n - 1].center, p.center)), r._setCameraMovement(p, s);
      }
    };
    t.length === 2 && (s = null);
    var o = this.getBearing();
    this._setCameraMovement(Lm({
      bearing: o
    }, t[n], {
      duration: t[n].timestamp - t[n - 1].timestamp
    }), s);
    var a = function() {
      r._animPlayer.play();
    }, l = function() {
      r._animPlayer.pause();
    }, h = function() {
      r._animPlayer.cancel();
    }, u = function() {
      r._animPlayer.finish();
    }, c = function() {
      r._animPlayer.reverse();
    };
    return {
      play: a,
      pause: l,
      cancel: h,
      finish: u,
      reverse: c
    };
  },
  _setCameraMovement: function(t, e) {
    this.animateTo({
      zoom: t.zoom,
      center: t.center,
      pitch: t.pitch,
      bearing: t.bearing
    }, {
      duration: t.duration,
      easing: "out"
    }, e);
  },
  setCameraOrientation: function(t) {
    var e = t.position, r = t.pitch, n = t.bearing, s = this.getFitZoomForCamera(e, r), o = s.zoom, a = s.cameraToGroundDistance, l = Math.sin(r * ei) * a, h = Ps(n, -180, 180), u = h * ei, c = this.getGLRes(), f = new lt(e[0], e[1]), d = this.coordToPointAtRes(f, c), p = new Y(0, 0);
    p.x = d.x + l * Math.sin(u), p.y = d.y + l * Math.cos(u);
    var g = this._pointToPrjAtRes(p, this.getGLRes());
    return this._setPrjCenter(g), this.setView({
      bearing: n,
      pitch: r,
      zoom: o
    }), this;
  },
  setCameraPosition: function(t) {
    var e = this.getGLRes(), r = this.coordToPointAtRes(t, e);
    r.z = this.altitudeToPoint(t.z || 0, e);
    var n = this.getCenter(), s = this.coordToPointAtRes(n, e);
    s.z = this.altitudeToPoint(n.z, e);
    var o = Ah([], r.toArray(), s.toArray());
    Lr(this.cameraUp || [0, 0, 0], 0, 0, 1), this._pitch = o_(o, this.cameraUp), Lr(l_, o[0], o[1], 0), this._angle = -o_(l_, IO), this._zoomLevel = this.getFitZoomForCamera(t, this._pitch).zoom, this._calcMatrices();
  },
  getFitZoomForCamera: function(t, e) {
    var r = Array.isArray(t) ? t[2] : t.z, n = r * this._meterToGLPoint, s = this.centerAltitude || 0, o = s * this._meterToGLPoint, a = n - o, l = e * ei, h = a / Math.cos(l), u = h + o, c = this._getFitZoomForDistance(u);
    return {
      zoom: c,
      cameraToGroundDistance: h
    };
  },
  _getFitZoomForDistance: function(t) {
    var e = this._getFovRatio(), r = t * e * 2 / (this.height || 1) * this.getGLRes(), n = this._getResolutions(), s = 0;
    for (s; s < n.length - 1; s++) {
      if (n[s] === r)
        return s;
      if (n[s + 1] === r)
        return s + 1;
      if (r < n[s] && r > n[s + 1])
        return s = (r - n[s]) / (n[s + 1] - n[s]) + s, s - 1;
    }
    return s;
  },
  isTransforming: function() {
    return !!(this._pitch || this._angle);
  },
  getFrustumAltitude: function() {
    return this._frustumAltitude;
  },
  _calcFrustumAltitude: function() {
    var t = 90 - this.getPitch(), e = this.getFov() / 2, r = this.cameraPosition ? this.cameraPosition[2] : 0;
    if (e <= t)
      return r;
    e = Math.PI * e / 180;
    var n = new Y(this.cameraPosition).distanceTo(new Y(this.cameraLookAt)), s = r * Math.tan(e * 2), o = Math.tan(e) * (n + s);
    return r + o;
  },
  _pointToContainerPoint: function(t, e, r, n) {
    r === void 0 && (r = 0);
    var s = this._getResolution(e);
    return this._pointAtResToContainerPoint(t, s, r, n);
  },
  _pointAtResToContainerPoint: function(t, e, r, n) {
    r === void 0 && (r = 0), n || (n = new Y(0, 0)), t = this._pointAtResToPoint(t, e, n);
    var s = this.isTransforming(), o;
    return !s && !r && (o = this._prjToPoint(this._getPrjCenter(), void 0, Zp)), this._toContainerPoint(n, s, r, o), n;
  },
  _pointsAtResToContainerPoints: function(t, e, r, n) {
    r === void 0 && (r = []), n === void 0 && (n = []);
    var s = this.getPitch(), o = this.getBearing(), a = e / this._getResolution();
    if (s === 0 && o === 0 && !DO(r)) {
      var l = this._get2DExtent(), h = l.xmin, u = l.ymin, c = l.xmax, f = l.ymax;
      if (c > h && f > u) {
        for (var d = this.getSize(), p = d.width, g = d.height, m = (c - h) / p, v = (f - u) / g, _ = 0, y = t.length; _ < y; _++) {
          if (!t[_]) {
            n[_] = null;
            continue;
          }
          var x = n[_];
          x.x = t[_].x, x.y = t[_].y, x._multi(a), x.x = (x.x - h) * m, x.y = g - (x.y - u) * v;
        }
        return n;
      }
    }
    for (var w = Array.isArray(r), b = this.isTransforming(), T = this._prjToPoint(this._getPrjCenter(), void 0, Zp), A = 0, M = t.length; A < M; A++) {
      if (!t[A]) {
        n[A] = null;
        continue;
      }
      var S = n[A];
      S.x = t[A].x, S.y = t[A].y, S._multi(a);
      var P = w ? r[A] || 0 : r;
      this._toContainerPoint(S, b, P, T);
    }
    return n;
  },
  _toContainerPoint: /* @__PURE__ */ function() {
    var i = [0, 0, 0];
    return function(t, e, r, n) {
      var s = this.width / 2, o = this.height / 2;
      if (e || r) {
        this._altitudeScale || (this._altitudeScale = this.altitudeToPoint(100, this.getGLRes()) / 100);
        var a = this._glScale;
        Lr(i, t.x * a, t.y * a, r * this._altitudeScale);
        var l = this._projIfBehindCamera(i, this.cameraPosition, this.cameraForward);
        Wp(l, l, this.projViewMatrix), t.x = l[0] * s + s, t.y = -(l[1] * o) + o;
      } else
        t._sub(n.x, n.y), t.set(t.x, -t.y), t._add(s, o);
    };
  }(),
  _projIfBehindCamera: function() {
    var i = new Array(3), t = new Array(3), e = new Array(3);
    return function(r, n, s) {
      Ah(i, r, n);
      var o = aA(s, i);
      return o <= 0 && (MO(t, s, o * 1.01), AO(r, n, Ah(e, i, t))), r;
    };
  }(),
  _containerPointToPoint: function(t, e, r) {
    var n = this._getResolution(e);
    return this._containerPointToPointAtRes(t, n, r);
  },
  _containerPointToPointAtRes: /* @__PURE__ */ function() {
    var i = [0, 0, 0], t = [0, 0, 0, 1], e = [0, 0, 0, 1];
    return function(r, n, s) {
      if (this.isTransforming()) {
        var o = this.width / 2 || 1, a = this.height / 2 || 1;
        Lr(i, (r.x - o) / o, (a - r.y) / a, 0), Lr(t, i[0], i[1], 0), Lr(e, i[0], i[1], 1), t[3] = e[3] = 1, Wp(t, t, this.projViewMatrixInverse), Wp(e, e, this.projViewMatrixInverse);
        var l = t[0], h = e[0], u = t[1], c = e[1], f = t[2], d = e[2], p = f === d ? 0 : (0 - f) / (d - f), g = Nf(l, h, p), m = Nf(u, c, p);
        return s ? (s.x = g, s.y = m) : s = new Y(g, m), s._multi(1 / this._glScale), this._getResolution() === n ? s : this._pointToPointAtRes(s, n, s);
      }
      var v = this._prjToPointAtRes(this._getPrjCenter(), n, s), _ = this._getResolution() / n, y = _ * (r.x - this.width / 2), x = _ * (r.y - this.height / 2);
      return v._add(y, -x);
    };
  }(),
  _calcMatrices: function() {
    var i = yi();
    return function() {
      delete this._mapRes, delete this._mapGlRes, delete this._mapExtent2D, delete this._mapGlExtent2D;
      var t = this.getSize(), e = t.width || 1, r = t.height || 1;
      this._glScale = this.getGLScale();
      var n = this._getCameraWorldMatrix(), s = this.getFov() * Math.PI / 180, o = this._getCameraFar(s, this.getPitch());
      this.cameraFar = o, this.cameraNear = this.cameraCenterDistance / 20;
      var a = this.projMatrix || yi();
      n_(a, s, e / r, this.cameraNear, o), this.projMatrix = a, this.viewMatrix = r_(this.viewMatrix || yi(), n), this.projViewMatrix = Th(this.projViewMatrix || yi(), a, this.viewMatrix), this._calcCascadeMatrixes(), this.projViewMatrixInverse = Th(this.projViewMatrixInverse || yi(), n, r_(i, a)), this.domCssMatrix = this._calcDomMatrix(), this._frustumAltitude = this._calcFrustumAltitude(), this._mapRes = this._getResolution(), this._mapGlRes = this.getGLRes(), this._mapExtent2D = this._get2DExtent(), this._mapGlExtent2D = this._get2DExtentAtRes(this._mapGlRes);
    };
  }(),
  _getCameraFar: function(t, e) {
    var r = this.cameraCenterDistance = e0(this.cameraPosition, this.cameraLookAt), n = r, s = (this.options.cameraInfiniteFar ? 10 : 4) * r;
    if (e > 0 && (e = e * Math.PI / 180, 2 / Math.PI - e > t / 2)) {
      var o = Math.tan(t / 2), a = Math.tan(e);
      s = Math.max(r * o / (1 / a - o), s);
    }
    return n += s, n + 1;
  },
  _calcCascadeMatrixes: function() {
    var i = yi();
    function t(e, r, n) {
      var s = this.width, o = this.height, a = this.getFov() * Math.PI / 180, l = this._getCameraFar(a, r), h = this.cameraCenterDistance;
      l = h + (l - h) / Math.cos((90 - r) * Math.PI / 180) * Math.cos((90 - e) * Math.PI / 180), n_(i, a, s / o, 0.1, l);
      var u = this.viewMatrix;
      return Th(n, i, u);
    }
    return function() {
      var e = this.getPitch(), r = this.options.cascadePitches[0], n = this.options.cascadePitches[1], s = this.cascadeFrustumMatrix0 = this.cascadeFrustumMatrix0 || yi(), o = this.cascadeFrustumMatrix1 = this.cascadeFrustumMatrix1 || yi();
      e > r ? t.call(this, e, r, s) : i_(this.cascadeFrustumMatrix0, this.projViewMatrix), e > n ? t.call(this, e, n, o) : i_(this.cascadeFrustumMatrix1, this.cascadeFrustumMatrix0);
    };
  }(),
  _calcDomMatrix: function() {
    var i = yi(), t = yi(), e = [1, -1, 1], r = [0, 0, 0];
    return function() {
      var n = this.width || 1, s = this.height || 1, o = 0.5 / Math.tan(this._fov / 2) * s;
      return t0(i, this.projMatrix, e), oA(i, i, Lr(r, 0, 0, -o)), this._pitch && wO(i, i, this._pitch), this._angle && TO(i, i, this._angle), zv(t), t0(t, t, Lr(r, n / 2, -s / 2, 1)), Th(this.domCssMatrix || yi(), t, i);
    };
  }(),
  _getFovZ: function(t) {
    var e = this.getGLScale(t), r = this._getFovRatio();
    return e * (this.height || 1) / 2 / r;
  },
  _getCameraWorldMatrix: /* @__PURE__ */ function() {
    var i = {};
    return function() {
      var t = this.getGLRes();
      this._meterToGLPoint || (this._meterToGLPoint = this.distanceToPointAtRes(100, 0, t).x / 100);
      var e = this._prjToPointAtRes(this._prjCenter, t, a_), r = this.getCenter().z, n = r !== void 0 ? r : this.centerAltitude || 0, s = n * this._meterToGLPoint;
      this.cameraLookAt = Lr(this.cameraLookAt || [0, 0, 0], e.x, e.y, s);
      var o = this.getPitch() * ei, a = this.getBearing() * ei, l = this._getFovZ(), h = this.cameraZenithDistance === void 0 ? l : this.cameraZenithDistance, u = h - s, c = u * Math.cos(o), f = Math.sin(o) * u, d = e.x - f * Math.sin(a), p = e.y - f * Math.cos(a);
      this.cameraPosition = Lr(this.cameraPosition || [0, 0, 0], d, p, c + s), this.cameraToCenterDistance = l;
      var g = f || 1, m = this.cameraUp = this.getPitch() > 0 ? Lr(this.cameraUp || [0, 0, 0], 0, 0, 1) : Lr(this.cameraUp || [0, 0, 0], Math.sin(a) * g, Math.cos(a) * g, 0), v = this.cameraWorldMatrix = this.cameraWorldMatrix || yi();
      kO(v, this.cameraPosition, this.cameraLookAt, m);
      var _ = this.cameraForward || [0, 0, 0];
      return Ah(_, this.cameraLookAt, this.cameraPosition), this.cameraForward = cl(_, _), PO(i, v), EO(v, i), OO(v, this.cameraPosition), v;
    };
  }(),
  updateCenterAltitude: function() {
    this.getRenderer().setToRedraw(), !this.centerAltitude && this._hasAltitudeLayer() && (this.centerAltitude = 0), this._recenterOnTerrain();
  },
  _recenterOnTerrain: function() {
    if (!(this.centerAltitude === void 0 || this._centerZ !== void 0)) {
      var t = this._queryTerrainByProjCoord(this._prjCenter);
      W(t) && this._hasAltitudeLayer() && (t = this.centerAltitude);
      var e = t || 0, r = this.getPitch() * ei, n = this.getBearing() * ei, s = (e - this.centerAltitude) * this._meterToGLPoint, o = this._getFovZ(), a = this.cameraZenithDistance === void 0 ? o : this.cameraZenithDistance, l = a - this.centerAltitude * this._meterToGLPoint, h = l - s / Math.cos(r), u = this.cameraPosition, c = Math.sin(r) * h, f = a_;
      f.x = u[0] + c * Math.sin(n), f.y = u[1] + c * Math.cos(n);
      var d = e * this._meterToGLPoint;
      this.cameraZenithDistance = (u[2] - d) / Math.cos(r) + d, this.centerAltitude = e;
      var p = this.pointAtResToCoordinate(f, this.getGLRes(), Zp);
      this._eventSilence = !0, this._suppressRecenter = !0, this.setCenter(p), delete this._suppressRecenter, delete this._eventSilence, W(t) && delete this.centerAltitude;
    }
  },
  _queryTerrainByProjCoord: function(t) {
    for (var e = this._getLayers(), r = 0; r < e.length; r++)
      if (e[r].queryTerrainByProjCoord)
        return e[r].queryTerrainByProjCoord(t)[0];
    return 0;
  },
  _hasAltitudeLayer: function() {
    for (var t = this._getLayers(), e = 0; e < t.length; e++)
      if (t[e].getTerrainLayer && t[e].getTerrainLayer())
        return !0;
    return !1;
  },
  _queryTerrainInfo: function(t) {
    for (var e = this._getLayers() || [], r = 0; r < e.length; r++) {
      var n = e[r];
      if (t && n && n.queryTerrainAtPoint && n.getTerrainLayer && n.getTerrainLayer()) {
        var s = n.queryTerrainAtPoint(t);
        if (s)
          return {
            coordinate: s,
            altitude: s.z
          };
        break;
      }
    }
    return null;
  },
  _getFovRatio: function() {
    var t = this.getFov();
    return Math.tan(t / 2 * ei);
  },
  _renderLayers: function() {
    if (!this.isInteracting()) {
      var t = this._getLayers();
      t.forEach(function(e) {
        if (e) {
          var r = e._getRenderer();
          r && r.setToRedraw && r.setToRedraw();
        }
      });
    }
  }
});
function yi() {
  return zv(new Array(16));
}
function FO(i, t) {
  var e = Vn(i[0]), r = Vn(t[0]), n = Vn(i[1]), s = Vn(t[1]), o = Math.sin(r - e) * Math.cos(s), a = Math.cos(n) * Math.sin(s) - Math.sin(n) * Math.cos(s) * Math.cos(r - e);
  return av(Math.atan2(o, a));
}
xe.include({
  _onViewChange: function(t) {
    this._viewHistory || (this._viewHistory = [], this._viewHistoryPointer = 0);
    for (var e = this._getCurrentView(), r = this._viewHistory.length - 1; r >= 0; r--)
      if (jf(t, this._viewHistory[r])) {
        this._viewHistoryPointer = r, this._fireViewChange(e, t);
        return;
      }
    this._viewHistoryPointer < this._viewHistory.length - 1 && this._viewHistory.splice(this._viewHistoryPointer + 1), this._viewHistory.push(t);
    var n = this.options.viewHistoryCount;
    n > 0 && this._viewHistory.length > n && this._viewHistory.splice(0, this._viewHistory.length - n), this._viewHistoryPointer = this._viewHistory.length - 1, this._fireViewChange(e, t);
  },
  zoomToPreviousView: function(t) {
    if (t === void 0 && (t = {}), !this.hasPreviousView())
      return null;
    var e = this._viewHistory[--this._viewHistoryPointer];
    return this._zoomToView(e, t), e;
  },
  hasPreviousView: function() {
    return !(!this._viewHistory || this._viewHistoryPointer === 0);
  },
  zoomToNextView: function(t) {
    if (t === void 0 && (t = {}), !this.hasNextView())
      return null;
    var e = this._viewHistory[++this._viewHistoryPointer];
    return this._zoomToView(e, t), e;
  },
  hasNextView: function() {
    return !(!this._viewHistory || this._viewHistoryPointer === this._viewHistory.length - 1);
  },
  _zoomToView: function(t, e) {
    var r = this, n = this.getView();
    e.animation ? this._animateTo(t, {
      duration: e.duration
    }, function(s) {
      s.state.playState === "finished" && r._fireViewChange(n, t);
    }) : (this.setView(t), this._fireViewChange(n, t));
  },
  getViewHistory: function() {
    return this._viewHistory;
  },
  _fireViewChange: function(t, e) {
    this._fireEvent("viewchange", {
      old: t,
      new: e
    }), this._insertUICollidesQueue();
  },
  _getCurrentView: function() {
    return this._viewHistory ? this._viewHistory[this._viewHistoryPointer] : null;
  }
});
xe.mergeOptions({
  viewHistory: !0,
  viewHistoryCount: 10
});
var LO = new Ru();
xe.include({
  getCollisionIndex: function() {
    return this._collisionIndex || this.createCollisionIndex(), this._collisionIndex || this.createCollisionIndex();
  },
  createCollisionIndex: function() {
    return this.clearCollisionIndex(), this._collisionIndex = new Ru(), this._collisionIndex;
  },
  clearCollisionIndex: function() {
    return this.collisionFrameTime = 0, this._collisionIndex && this._collisionIndex.clear(), this;
  },
  _insertUICollidesQueue: function() {
    return this._uiCollidesQueue || (this._uiCollidesQueue = []), this._uiCollidesQueue.push(1), this;
  },
  uiCollides: function() {
    if (!this.uiList || this.uiList.length === 0 || !this._uiCollidesQueue || this._uiCollidesQueue.length === 0)
      return this;
    var t = LO;
    t.clear();
    for (var e = this.uiList, r = 0, n = e.length; r < n; r++) {
      var s = e[r], o = s.options, a = o.collisionBufferSize, l = o.collision;
      if (l) {
        var h = s.getDOM();
        if (!(!s.isVisible() || !h) && h.getBoundingClientRect) {
          s.bbox || (s.bbox = [0, 0, 0, 0]);
          var u = h.getBoundingClientRect(), c = u.x, f = u.y, d = u.width, p = u.height;
          if (d === 0 || p === 0) {
            var g = s.getSize();
            g && (d = g.width, p = g.height);
          }
          var m = c - a, v = c + d + a, _ = f - a, y = f + p + a;
          if (s.bbox[0] = m, s.bbox[1] = _, s.bbox[2] = v, s.bbox[3] = y, t.collides(s.bbox)) {
            s._collidesEffect(!1);
            continue;
          }
          t.insertBox(s.bbox), s._collidesEffect(!0);
        }
      }
    }
    return this._uiCollidesQueue = [], this;
  },
  _addUI: function(t) {
    this.uiList || (this.uiList = []);
    var e = this.uiList.indexOf(t);
    return e > -1 ? this : (this.uiList.push(t), this.uiList = this.uiList.sort(function(r, n) {
      return n.options.collisionWeight - r.options.collisionWeight;
    }), this);
  },
  _removeUI: function(t) {
    if (!this.uiList)
      return -1;
    var e = this.uiList.indexOf(t);
    return e < 0 || this.uiList.splice(e, 1), e;
  }
});
var zO = {
  start: "起点",
  units: {
    mile: " 英里",
    feet: " 英尺",
    kilometer: " 公里",
    meter: " 米"
  }
}, NO = {
  units: {
    mile: " 平方英里",
    feet: " 平方英尺",
    kilometer: " 平方公里",
    meter: " 平方米"
  }
}, HO = {
  distancetool: zO,
  areatool: NO
}, BO = {
  start: "Inicio",
  units: {
    mile: " mi",
    feet: " ft",
    kilometer: " km",
    meter: " m"
  }
}, jO = {
  units: {
    mile: " mi²",
    feet: " ft²",
    kilometer: " km²",
    meter: " m²"
  }
}, GO = {
  distancetool: BO,
  areatool: jO
}, VO = {
  start: "Start",
  units: {
    mile: " mi",
    feet: " ft",
    kilometer: " km",
    meter: " m"
  }
}, UO = {
  units: {
    mile: " mi²",
    feet: " ft²",
    kilometer: " km²",
    meter: " m²"
  }
}, $O = {
  distancetool: VO,
  areatool: UO
}, ca = function(i) {
  Ot(t, i);
  function t(e) {
    var r;
    return r = i.call(this, "Translator: " + e) || this, r.name = "TranslatorError", r;
  }
  return t;
}(Nm(Error)), lA = function(i) {
  Ot(t, i);
  function t(r) {
    var n;
    return n = i.call(this) || this, n.languages = {
      "zh-CN": HO,
      "es-MX": GO,
      "en-US": $O
    }, n.nodes = {}, n.setLang(r || "zh-CN"), n;
  }
  var e = t.prototype;
  return e.setLang = function(n) {
    var s = this.languages[n];
    if (!s) throw new ca("Setted Lang does not exist");
    this.nodes = s;
  }, e._validateNestedProps = function(n) {
    n.forEach(function(s) {
      if (s === "") throw new ca('Any of sides of a dot "." cannot be empty');
    });
  }, e.translate = function(n) {
    if (n === void 0 && (n = null), n == null) throw new ca("Missing parameter textNode");
    if (typeof n == "string") {
      var s = null;
      if (n.includes(".")) {
        var o = n.split(".");
        if (o.length > 3) throw new ca("Translate function can only access through 3 nested properties, trying to access -> " + o.length);
        this._validateNestedProps(o);
        try {
          var a = null;
          switch (o.length) {
            case 2:
              a = this.nodes[o[0]][o[1]];
              break;
            case 3:
              a = this.nodes[o[0]][o[1]][o[2]];
              break;
          }
          return a;
        } catch (l) {
          throw new ca("Unable to find the text translated in lang json" + l.message);
        }
      } else
        return s = this.nodes[n], s;
    } else
      throw new ca("Param passed has to be a String");
  }, t;
}(pi), WO = {
  formatLabelContent: null,
  decimalPlaces: 2,
  mode: "LineString",
  language: "zh-CN",
  metric: !0,
  imperial: !1,
  symbol: {
    lineColor: "#000",
    lineWidth: 3,
    lineOpacity: 1
  },
  vertexSymbol: {
    markerType: "ellipse",
    markerFill: "#fff",
    markerLineColor: "#000",
    markerLineWidth: 3,
    markerWidth: 11,
    markerHeight: 11
  },
  labelOptions: {
    textSymbol: {
      textFaceName: "monospace",
      textLineSpacing: 1,
      textHorizontalAlignment: "right",
      textDx: 15
    },
    boxStyle: {
      padding: [6, 2],
      symbol: {
        markerType: "square",
        markerFill: "#fff",
        markerFillOpacity: 0.9,
        markerLineColor: "#b4b3b3"
      }
    }
  },
  clearButtonSymbol: [{
    markerType: "square",
    markerFill: "#fff",
    markerLineColor: "#b4b3b3",
    markerLineWidth: 2,
    markerWidth: 15,
    markerHeight: 15,
    markerDx: 20
  }, {
    markerType: "x",
    markerWidth: 10,
    markerHeight: 10,
    markerDx: 20
  }]
}, hA = function(i) {
  Ot(t, i);
  function t(r) {
    var n;
    return n = i.call(this, r) || this, n.on("enable", n._afterEnable, kn(kn(n))).on("disable", n._afterDisable, kn(kn(n))), n._measureLayers = [], n.translator = new lA(n.options.language), n;
  }
  var e = t.prototype;
  return e.clear = function() {
    if (sn(this._measureLayers))
      for (var n = 0; n < this._measureLayers.length; n++)
        this._measureLayers[n].remove();
    return delete this._lastMeasure, delete this._lastVertex, this._outLayers(this._measureLayers), this._measureLayers = [], this;
  }, e.getMeasureLayers = function() {
    return this._measureLayers;
  }, e.getLastMeasure = function() {
    return this._lastMeasure ? this._lastMeasure : 0;
  }, e.undo = function() {
    i.prototype.undo.call(this);
    var n = this._historyPointer;
    if (n !== this._vertexes.length)
      for (var s = n; s < this._vertexes.length; s++)
        this._vertexes[s].label && this._vertexes[s].label.remove(), this._vertexes[s].marker.remove();
    return this;
  }, e.redo = function() {
    i.prototype.redo.call(this);
    var n = this._historyPointer - 1;
    return this._vertexes[n] && (this._vertexes[n].marker.getLayer() || (this._vertexes[n].label && this._vertexes[n].label.addTo(this._measureMarkerLayer), this._vertexes[n].marker.addTo(this._measureMarkerLayer))), this;
  }, e._formatLabelContent = function(n) {
    var s = this.options.formatLabelContent;
    return s && Be(s) ? s.call(this, n) + "" : null;
  }, e._measure = function(n) {
    var s = this.getMap(), o;
    n instanceof nn ? o = s.computeGeometryLength(n) : Array.isArray(n) && (o = s.getProjection().measureLength(n)), this._lastMeasure = o;
    var a = this._formatLabelContent(o);
    if (a)
      return a;
    var l = [this.translator.translate("distancetool.units.meter"), this.translator.translate("distancetool.units.kilometer"), this.translator.translate("distancetool.units.feet"), this.translator.translate("distancetool.units.mile")], h = "", u = this.options.decimalPlaces;
    return this.options.metric && (h += o < 1e3 ? o.toFixed(u) + l[0] : (o / 1e3).toFixed(u) + l[1]), this.options.imperial && (o *= 3.2808399, h.length > 0 && (h += `
`), h += o < 5280 ? o.toFixed(u) + l[2] : (o / 5280).toFixed(u) + l[3]), h;
  }, e._registerMeasureEvents = function() {
    this.on("drawstart", this._msOnDrawStart, this).on("drawvertex", this._msOnDrawVertex, this).on("mousemove", this._msOnMouseMove, this).on("drawend", this._msOnDrawEnd, this);
  }, e._afterEnable = function() {
    this._registerMeasureEvents();
  }, e._afterDisable = function() {
    this.off("drawstart", this._msOnDrawStart, this).off("drawvertex", this._msOnDrawVertex, this).off("mousemove", this._msOnMouseMove, this).off("drawend", this._msOnDrawEnd, this);
  }, e._msOnDrawStart = function(n) {
    var s = this.getMap(), o = Ls(), a = "distancetool_" + o, l = "distancetool_markers_" + o, h = this.options.zIndex, u = this.options.enableAltitude;
    s.getLayer(a) ? (this._measureLineLayer = s.getLayer(a), this._measureMarkerLayer = s.getLayer(l)) : (this._measureLineLayer = new Rs(a, {
      zIndex: h,
      enableAltitude: u
    }).addTo(s), this._measureMarkerLayer = new Rs(l, {
      zIndex: h,
      enableAltitude: u
    }).addTo(s)), this._measureLayers.push(this._measureLineLayer), this._measureLayers.push(this._measureMarkerLayer), this._pushLayers([this._measureLineLayer, this._measureMarkerLayer]);
    var c = this._getFirstCoordinate() || n.coordinate, f = new xn(c.copy(), {
      symbol: this.options.vertexSymbol
    }), d = this.translator.translate("distancetool.start"), p = new ul(d, c.copy(), this.options.labelOptions);
    this._lastVertex = p, this._addVertexMarker(f, p);
  }, e._msOnMouseMove = function(n) {
    var s = this._measure(this._msGetCoordsToMeasure(n));
    if (!this._tailMarker) {
      var o = Ni(this.options.vertexSymbol);
      o.markerWidth /= 2, o.markerHeight /= 2, this._tailMarker = new xn(n.coordinate, {
        symbol: o
      }).addTo(this._measureMarkerLayer), this._tailLabel = new ul(s, n.coordinate, this.options.labelOptions).addTo(this._measureMarkerLayer);
    }
    var a = this._getLasttCoordinate() || n.coordinate;
    this._tailMarker.setCoordinates(a.copy()), this._tailLabel.setContent(s), this._tailLabel.setCoordinates(a.copy());
  }, e._msGetCoordsToMeasure = function(n) {
    return n.geometry.getCoordinates().concat([n.coordinate]);
  }, e._msOnDrawVertex = function(n) {
    var s = this._getLasttCoordinate() || n.coordinate, o = n.geometry, a = new xn(s.copy(), {
      symbol: this.options.vertexSymbol
    }), l = this._measure(o), h = new ul(l, s.copy(), this.options.labelOptions);
    this._addVertexMarker(a, h), this._lastVertex = h;
  }, e._addVertexMarker = function(n, s) {
    this._vertexes || (this._vertexes = []), this._historyPointer !== void 0 && this._vertexes.length > this._historyPointer - 1 && (this._vertexes.length = this._historyPointer - 1), this._vertexes.push({
      label: s,
      marker: n
    }), this._measureMarkerLayer.addGeometry(n), s && this._measureMarkerLayer.addGeometry(s);
  }, e._msOnDrawEnd = function(n) {
    if (this._clearTailMarker(), n.geometry.getCoordinates().length < 2) {
      this._lastMeasure = 0, this._clearMeasureLayers();
      return;
    }
    var s = this._lastVertex.getSize();
    s || (s = new zn(10, 10)), this._addClearMarker(this._lastVertex.getCoordinates(), this._lastVertex._getPrjCoordinates(), s.width);
    var o = n.geometry.copy();
    o.setCoordinates(n.geometry.getCoordinates()), o.addTo(this._measureLineLayer), this._lastMeasure = o.getLength();
  }, e._addClearMarker = function(n, s, o) {
    var a = this.options.clearButtonSymbol, l = {
      markerDx: (a.markerDx || 0) + o,
      textDx: (a.textDx || 0) + o
    };
    Array.isArray(a) && (l = a.map(function(f) {
      return f ? {
        markerDx: (f.markerDx || 0) + o,
        textDx: (f.textDx || 0) + o
      } : null;
    })), a = Ni(a, l);
    var h = new xn(n, {
      symbol: a
    }), u = this._measureLineLayer, c = this._measureMarkerLayer;
    h.on("click", function() {
      return u.remove(), c.remove(), !1;
    }, this), h.addTo(this._measureMarkerLayer);
  }, e._clearTailMarker = function() {
    this._tailMarker && (this._tailMarker.remove(), delete this._tailMarker), this._tailLabel && (this._tailLabel.remove(), delete this._tailLabel);
  }, e._clearMeasureLayers = function() {
    this._measureLineLayer.remove(), this._measureMarkerLayer.remove();
  }, e._getFirstCoordinate = function() {
    if (!this._geometry)
      return null;
    var n = this._geometry.getCoordinates() || [];
    return n[0];
  }, e._getLasttCoordinate = function() {
    if (!this._geometry)
      return null;
    var n = this._geometry.getCoordinates() || [];
    return n[n.length - 1];
  }, t;
}(mr);
hA.mergeOptions(WO);
var ZO = {
  mode: "Polygon",
  symbol: {
    lineColor: "#000000",
    lineWidth: 2,
    lineOpacity: 1,
    lineDasharray: "",
    polygonFill: "#ffffff",
    polygonOpacity: 0.5
  },
  language: "zh-CN"
}, XO = function(i) {
  Ot(t, i);
  function t(r) {
    var n;
    return n = i.call(this, r) || this, n.translator = new lA(n.options.language), n._measureLayers = [], n;
  }
  var e = t.prototype;
  return e._measure = function(n) {
    var s = this.getMap(), o;
    n instanceof nn ? o = s.computeGeometryArea(n) : Array.isArray(n) && (o = s.getProjection().measureArea(n)), this._lastMeasure = o;
    var a = this._formatLabelContent(o);
    if (a)
      return a;
    var l = [this.translator.translate("areatool.units.meter"), this.translator.translate("areatool.units.kilometer"), this.translator.translate("areatool.units.feet"), this.translator.translate("areatool.units.mile")], h = "", u = this.options.decimalPlaces;
    if (this.options.metric && (h += o < 1e6 ? o.toFixed(u) + l[0] : (o / 1e6).toFixed(u) + l[1]), this.options.imperial) {
      o *= Math.pow(3.2808399, 2), h.length > 0 && (h += `
`);
      var c = 5280 * 5280;
      h += o < c ? o.toFixed(u) + l[2] : (o / c).toFixed(u) + l[3];
    }
    return h;
  }, e._msGetCoordsToMeasure = function(n) {
    return n.geometry.getShell().concat([n.coordinate]);
  }, e._msOnDrawVertex = function(n) {
    var s = this._getLasttCoordinate() || n.coordinate, o = new xn(s.copy(), {
      symbol: this.options.vertexSymbol
    });
    this._measure(n.geometry), this._lastVertex = o, this._addVertexMarker(o);
  }, e._msOnDrawEnd = function(n) {
    this._clearTailMarker();
    var s;
    if (n.point2d)
      s = this.getMap()._pointToPrj(n.point2d);
    else {
      var o = n.geometry._getPrjCoordinates() || [];
      o = o.slice(0, o.length - 1), s = o[o.length - 1];
    }
    if (n.geometry.getShell().length < 3) {
      this._lastMeasure = 0, this._clearMeasureLayers();
      return;
    }
    var a = this._measure(n.geometry), l = this._getLasttCoordinate(), h = new ul(a, l.copy(), this.options.labelOptions).addTo(this._measureMarkerLayer), u = h.getSize();
    u || (u = new zn(10, 10)), this._addClearMarker(l.copy(), s, u.width);
    var c = n.geometry.copy();
    c.setCoordinates(n.geometry.getCoordinates()), c.addTo(this._measureLineLayer), this._lastMeasure = c.getArea();
  }, t;
}(hA);
XO.mergeOptions(ZO);
function $i(i, t, e) {
  var r = Array.isArray(t);
  r || (t = [t]);
  var n;
  if (!e || !e.target || !e.target._queryTerrainInfo)
    return n = t.map(function(a) {
      return i.unproject(a);
    }), r ? n : n[0];
  var s = e.target, o = e.enableAltitude;
  return n = t.map(function(a) {
    if (o) {
      var l = s._prjToContainerPoint(a), h = s._queryTerrainInfo(l);
      if (h && h.coordinate)
        return h.coordinate;
    }
    return i.unproject(a);
  }), r ? n : n[0];
}
var uA = {
  create: function(t, e, r) {
    var n = $i(t, e[0], r), s = new Pi(n, 0);
    return s;
  },
  update: function(t, e, r, n) {
    var s = r.getMap(), o = Array.isArray(e) ? e[e.length - 1] : e, a = $i(t, o, n), l = s.computeLength(r.getCenter(), a);
    r.setRadius(l);
  },
  generate: function(t) {
    return t;
  }
};
mr.registerMode("circle", jt({
  clickLimit: 2,
  action: ["click", "mousemove", "click"]
}, uA));
mr.registerMode("freeHandCircle", jt({
  action: ["mousedown touchstart", "mousemove touchmove", "mouseup touchend"]
}, uA));
var cA = {
  create: function(t, e, r) {
    var n = $i(t, e[0], r), s = new as(n, 0, 0);
    return s;
  },
  update: function(t, e, r, n) {
    var s = r.getMap(), o = r.getCenter(), a = Array.isArray(e) ? e[e.length - 1] : e, l = $i(t, a, n), h = s.computeLength(o, new lt({
      x: l.x,
      y: o.y
    })), u = s.computeLength(o, new lt({
      x: o.x,
      y: l.y
    }));
    r.setWidth(h * 2), r.setHeight(u * 2);
  },
  generate: function(t) {
    return t;
  }
};
mr.registerMode("ellipse", jt({
  clickLimit: 2,
  action: ["click", "mousemove", "click"]
}, cA));
mr.registerMode("freeHandEllipse", jt({
  action: ["mousedown touchstart", "mousemove touchmove", "mouseup touchend"]
}, cA));
var fA = {
  create: function(t, e) {
    var r = new vn([]);
    return r._firstClick = e[0], r;
  },
  update: function(t, e, r, n) {
    var s = r.getMap(), o = n.containerPoint, a = s._prjToContainerPoint(r._firstClick), l = [[a.x, a.y], [o.x, a.y], [o.x, o.y], [a.x, o.y]], h = l.map(function(c) {
      return s._containerPointToPrj(new Y(c));
    }), u = $i(t, h, n);
    r.setCoordinates(u);
  },
  generate: function(t) {
    return t;
  }
};
mr.registerMode("rectangle", jt({
  clickLimit: 2,
  action: ["click", "mousemove", "click"]
}, fA));
mr.registerMode("freeHandRectangle", jt({
  action: ["mousedown touchstart", "mousemove touchmove", "mouseup touchend"]
}, fA));
mr.registerMode("point", {
  clickLimit: 1,
  action: ["click", "mousemove"],
  create: function(t, e, r) {
    var n = $i(t, e[0], r), s = new xn(n);
    return s;
  },
  generate: function(t) {
    return t;
  },
  update: function(t, e, r, n) {
    if (Array.isArray(e) && (e = e[e.length - 1]), !e)
      return r;
    var s = $i(t, e, n);
    return r.setCoordinates(s), r;
  }
});
var dA = {
  create: function(t, e, r) {
    var n = $i(t, e, r), s = new Tn(n);
    return s.setCoordinates(n), s;
  },
  update: function(t, e, r, n) {
    var s = r.getSymbol(), o;
    Array.isArray(e) ? o = e : (o = r._drawPrjs || [], o.push(e)), r._drawPrjs = o;
    var a = $i(t, o, n);
    r.setCoordinates(a);
    var l = r.getLayer();
    if (l) {
      var h = l.getGeometryById("polygon");
      if (!h && o.length >= 3) {
        if (h = new vn([a], {
          id: "polygon"
        }), s) {
          var u = Ni(s, {
            lineOpacity: 0
          });
          h.setSymbol(u);
        }
        h.addTo(l);
      }
      h && h.setCoordinates([a]);
    }
  },
  generate: function(t) {
    var e = new vn(t.getCoordinates(), {
      symbol: t.getSymbol()
    });
    return e._projCode = t._projCode, e;
  }
};
mr.registerMode("polygon", jt({
  action: ["click", "mousemove", "dblclick"]
}, dA));
mr.registerMode("freeHandPolygon", jt({
  action: ["mousedown touchstart", "mousemove touchmove", "mouseup touchend"]
}, dA));
var Lu = {
  create: function(t, e, r) {
    var n = $i(t, e, r), s = new Tn(n);
    return s.setCoordinates(n), s;
  },
  update: function(t, e, r, n) {
    var s;
    Array.isArray(e) ? s = e : (s = r._drawPrjs || [], s.push(e)), r._drawPrjs = s;
    var o = $i(t, s, n);
    r.setCoordinates(o);
  },
  generate: function(t) {
    return t;
  }
};
mr.registerMode("linestring", jt({
  action: ["click", "mousemove", "dblclick"]
}, Lu));
mr.registerMode("freeHandLinestring", jt({
  action: ["mousedown touchstart", "mousemove touchmove", "mouseup touchend"]
}, Lu));
mr.registerMode("arccurve", {
  action: ["click", "mousemove", "dblclick"],
  create: function(t, e) {
    var r = e.map(function(s) {
      return t.unproject(s);
    }), n = new Ld(r);
    return n._setPrjCoordinates(e), n;
  },
  update: Lu.update,
  generate: function(t) {
    return t;
  }
});
mr.registerMode("quadbeziercurve", {
  action: ["click", "mousemove", "dblclick"],
  create: function(t, e) {
    var r = e.map(function(s) {
      return t.unproject(s);
    }), n = new nA(r);
    return n._setPrjCoordinates(e), n;
  },
  update: Lu.update,
  generate: function(t) {
    return t;
  }
});
mr.registerMode("cubicbeziercurve", {
  action: ["click", "mousemove", "dblclick"],
  create: function(t, e) {
    var r = e.map(function(s) {
      return t.unproject(s);
    }), n = new eA(r);
    return n._setPrjCoordinates(e), n;
  },
  update: Lu.update,
  generate: function(t) {
    return t;
  }
});
mr.registerMode("boxZoom", {
  action: ["mousedown", "mousemove", "mouseup"],
  create: function(t, e) {
    e = e[0];
    var r = t.unproject(e), n = new xn(r);
    return n._firstClick = e, n;
  },
  update: function(t, e, r, n) {
    var s = r.getMap(), o = s._prjToContainerPoint(r._firstClick), a = n.containerPoint;
    e = s._containerPointToPrj(new lt(Math.min(o.x, a.x), Math.min(o.y, a.y)));
    var l = t.unproject(e);
    r.setCoordinates(l)._setPrjCoordinates(e), r.updateSymbol({
      markerWidth: Math.abs(o.x - a.x),
      markerHeight: Math.abs(o.y - a.y)
    });
  },
  generate: function(t) {
    return t;
  }
});
function h_(i) {
  for (var t = i.tileInfo, e = [t.cols, t.rows], r = [], n = t.lods, s = 0, o = n.length; s < o; s++)
    r.push(n[s].resolution);
  var a = i.fullExtent, l = t.origin, h = [1, -1, l.x, l.y];
  return delete a.spatialReference, {
    spatialReference: {
      resolutions: r,
      fullExtent: a
    },
    tileSystem: h,
    tileSize: e
  };
}
Ci.loadArcgis = function(i, t, e) {
  if (e === void 0 && (e = {
    jsonp: !0
  }), De(i) && i.substring(0, 1) !== "{")
    Wr.getJSON(i, function(n, s) {
      if (n) {
        t(n);
        return;
      }
      var o = h_(s);
      t(null, o);
    }, e);
  else {
    De(i) && (i = tu(i));
    var r = h_(i);
    t(null, r);
  }
  return this;
};
function qO(i) {
  for (var t = "", e = i.split(""), r = e.length, n = r - 1; n >= 0 && !isNaN(e[n]); n--)
    t = e[n] + t;
  return t;
}
function YO(i) {
  var t = i.indexOf("EPSG") > -1 ? i : "EPSG:" + i;
  return t = pA(t, [["4490", "4326"], ["102100", "3857"], ["900913", "3857"]]), t;
}
function pA(i, t) {
  return t === void 0 && (t = []), t.forEach(function(e) {
    var r = e[0], n = e[1];
    i = i.replace(r, n);
  }), i;
}
function JO(i) {
  var t = i.projection, e = i.isArcgis, r = i.isGeoServer, n = i.isSuperMap, s = 2645833333333333e-19;
  return (e || r || n) && (s = 28e-5), t && t.indexOf("4326") > -1 && (s = 23767925226029154e-25, (e || n) && (s = 2518101729011901e-24), r && (s = 251528279553466e-23)), s;
}
var KO = "wmts";
function to(i, t) {
  var e = i.getElementsByTagName(t);
  if (e && e.length)
    return e;
  var r = KO + ":" + t;
  return i.getElementsByTagName(r);
}
function QO(i, t) {
  for (var e = 0; e < i.length; e++) {
    var r = i[e];
    if (r = r.getElementsByTagName("ows:Identifier")[0], r && r.textContent === t)
      return i[e];
  }
  return null;
}
function tk(i, t, e) {
  e.isArcgis == null && (e.isArcgis = i.indexOf("arcgis") > -1), e.isSuperMap == null && (e.isSuperMap = i.indexOf("supermap") > -1);
  var r = new DOMParser(), n = r.parseFromString(i, "text/xml"), s = n.querySelectorAll("Contents")[0];
  if (!s)
    return [];
  var o = to(s, "Layer");
  if (!o.length)
    return [];
  for (var a = [], l = 0, h = s.childNodes.length; l < h; l++)
    s.childNodes[l].localName === "TileMatrixSet" && a.push(s.childNodes[l]);
  if (!a.length)
    return [];
  for (var u = [], c = 0, f = o.length; c < f; c++) {
    var d = o[c], p = d.querySelectorAll("Style")[0];
    p && (p = p.getElementsByTagName("ows:Identifier")[0], p && (p = p.textContent));
    var g = d.getElementsByTagName("ows:Identifier")[0];
    g && (g = g.textContent);
    var m = to(d, "TileMatrixSetLink");
    if (m.length !== 0)
      for (var v = 0, _ = m.length; v < _; v++) {
        var y = m[v];
        y = to(y, "TileMatrixSet")[0], y && (y = y.textContent);
        var x = QO(a, y);
        if (x) {
          var w = d.querySelectorAll("ResourceURL")[0], b = "";
          w && (b = w.attributes.template.value);
          var T = ek(x, e), A = T.resolutions, M = T.tileSize, S = T.tileSystem, P = T.projection, C = T.TileMatrixSet, k = T.isGeoServer, O = T.levelStr;
          b.length || (b = t.substr(0, t.lastIndexOf("?")), b += "?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER={LAYER}&STYLE={Style}&TILEMATRIXSET={TileMatrixSet}&FORMAT={tiles}&TILEMATRIX={TileMatrix}&TILEROW={TileRow}&TILECOL={TileCol}");
          var R = pA(b, [["{LAYER}", g], ["{Layer}", g], ["{layer}", g], ["{STYLE}", p], ["{Style}", p], ["{style}", p], ["{TileMatrixSet}", C], ["{TileMatrix}", k ? O + ":{z}" : "{z}"], ["{TileRow}", "{y}"], ["{TileCol}", "{x}"], ["{tiles}", k ? "image/png" : "tiles"]]);
          u.push({
            tileSize: M,
            tileSystem: S,
            spatialReference: {
              resolutions: A,
              projection: P
            },
            urlTemplate: R,
            info: {
              layerName: g,
              TileMatrixSet: C,
              style: p,
              tileSize: M,
              tileSystem: S,
              resolutions: A,
              projection: P,
              urlTemplate: R
            }
          });
        }
      }
  }
  return u;
}
function ek(i, t) {
  t === void 0 && (t = {});
  var e = to(i, "TileMatrix"), r = [], n = [], s = [], o, a, l = !1, h;
  if (!o) {
    var u = i.getElementsByTagName("ows:SupportedCRS")[0];
    u && (o = u.textContent, o = o.split("EPSG")[1], o = qO(o), o = YO(o));
  }
  a || (a = i.getElementsByTagName("ows:Identifier")[0], a && (a = a.textContent)), t.projection = o;
  for (var c = 1 / 0, f = 0; f < e.length; f++) {
    var d = e[f], p = d.getElementsByTagName("ows:Identifier")[0].textContent;
    isNaN(parseInt(p)) ? (h = p.substr(0, p.lastIndexOf(":")), p = p.split(":"), p = p[p.length - 1], p = parseInt(p), l = !0, t.isGeoServer = !0) : p = parseInt(p), c = Math.min(c, p);
    var g = to(d, "ScaleDenominator")[0].textContent, m = to(d, "TopLeftCorner")[0].textContent, v = to(d, "TileWidth")[0].textContent, _ = to(d, "TileHeight")[0].textContent;
    if (s.length === 0 && s.push(parseInt(v), parseInt(_)), n.length === 0) {
      var y = m.split(" ").filter(function(S) {
        return S !== "";
      }).map(function(S) {
        return parseFloat(S);
      }), x = y[0], w = y[1];
      x > 0 ? n.push(1, -1, w, x) : n.push(1, -1, x, w);
    }
    var b = JO(t), T = parseFloat(g) * b;
    r.push(T);
  }
  if (c > 0)
    for (var A = r[0], M = c - 1; M >= 0; M--)
      A = A * 2, r.splice(0, 0, A);
  return {
    resolutions: r,
    tileSize: s,
    tileSystem: n,
    projection: o,
    TileMatrixSet: a,
    isGeoServer: l,
    levelStr: h
  };
}
Ci.loadWMTS = function(i, t, e) {
  return e === void 0 && (e = {
    jsonp: !0
  }), De(i) && Wr.get(i, function(r, n) {
    if (r) {
      t(r);
      return;
    }
    var s = tk(n, i, e);
    t(null, s);
  }, e), this;
};
var nk = {
  eventsPropagation: !1,
  eventsToStop: null,
  dx: 0,
  dy: 0,
  autoPan: !1,
  autoPanDuration: 600,
  single: !0,
  animation: "scale",
  animationOnHide: !1,
  animationDuration: 500,
  pitchWithMap: !1,
  rotateWithMap: !1,
  visible: !0,
  roundPoint: !1,
  collision: !1,
  collisionBufferSize: 2,
  collisionWeight: 0,
  collisionFadeIn: !1,
  zIndex: 0
}, Uo = function(i) {
  Ot(t, i);
  function t(r) {
    var n;
    return n = i.call(this, r) || this, n.proxyOptions(), n;
  }
  var e = t.prototype;
  return e.addTo = function(n) {
    return this._owner = n, this._switchEvents("on"), this.onAdd && this.onAdd(), this.fire("add"), this;
  }, e.getMap = function() {
    return this._owner ? this._owner.getBaseLayer ? this._owner : this._owner.getMap() : null;
  }, e._collides = function() {
    var n = this.getMap();
    return n ? (n._addUI(this), n._insertUICollidesQueue(), this) : this;
  }, e._collidesEffect = function(n) {
    var s = this.getDOM();
    if (!s)
      return this;
    var o = n ? "visible" : "hidden";
    if (s.style.visibility = o, !s.classList || !s.classList.add)
      return this;
    if (!this.options.collisionFadeIn)
      return this;
    var a = s.classList, l = "mtk-ui-fadein", h = a.contains(l);
    return n && !h ? s.classList.add(l) : !n && h && s.classList.remove(l), this;
  }, e.show = function(n) {
    var s = this, o = this.getMap();
    if (!o)
      return this;
    this.options.visible = !0, n = n || this._coordinate || this._owner.getCenter(), n instanceof lt || (n = new lt(n));
    var a = this.isVisible();
    this._showBySymbolChange || this.fire("showstart");
    var l = this._getUIContainer();
    this._coordinate = n, this._removePrevDOM(), this._mapEventsOn || this._switchMapEvents("on");
    var h = this.__uiDOM = this.buildOn(o);
    h.eventsPropagation = this.options.eventsPropagation, this._observerDomSize(h);
    var u = this.options.zIndex;
    if (!h)
      return this._showBySymbolChange || this.fire("showend"), this._collides(), this.setZIndex(u), this;
    this._measureSize(h), this._singleton() && (h._uiComponent = this, o[this._uiDomKey()] = h), this._setPosition(), h.style[qu] = null, l.appendChild(h);
    var c = this._getAnimation();
    if (a && (c.ok = !1), c.ok && (c.fade && (h.style.opacity = 0), c.scale)) {
      if (this.getTransformOrigin) {
        var f = this.getTransformOrigin();
        h.style[hE] = f;
      }
      h.style[Ba] = this._toCSSTranslate(this._pos) + " scale(0)";
    }
    this.isSupportZoomFilter() || (h.style.display = ""), this.options.eventsToStop && Cn(h, this.options.eventsToStop, Jr);
    var d = c.transition;
    return c.ok && d && (h.offsetHeight, d && (h.style[qu] = d), c.fade && (h.style.opacity = 1), c.scale && (h.style[Ba] = this._toCSSTranslate(this._pos) + " scale(1)")), this._showBySymbolChange || this.fire("showend"), this._collides(), clearTimeout(this._autoPanId), this.options.autoPan && (this._autoPanId = setTimeout(function() {
      s._autoPan();
    }, 32)), this.setZIndex(u), this;
  }, e.hide = function() {
    var n = this;
    if (!this.getDOM())
      return this;
    this._onDomMouseout && this._onDomMouseout(), this.options.visible = !1;
    var s = this._getAnimation(), o = this.getDOM();
    return this.options.animationOnHide || (s.ok = !1), s.ok ? (o.offsetHeight, o.style[qu] = s.transition, setTimeout(function() {
      o.style.display = "none", n.fire("hide");
    }, this.options.animationDuration)) : (o.style.display = "none", this.fire("hide")), s.fade && (o.style.opacity = 0), s.scale && (o.style[Ba] = this._toCSSTranslate(this._pos) + " scale(0)"), this._switchMapEvents("off"), this._collides(), this;
  }, e.isVisible = function() {
    if (!this.options.visible)
      return !1;
    var n = this.getDOM();
    return this.getMap() && n && n.parentNode && n.style.display !== "none";
  }, e.remove = function() {
    if (delete this._mapEventsOn, !this._owner)
      return this;
    var n = this.getMap();
    return n && n._removeUI(this), this.hide(), this._switchEvents("off"), this.onRemove && this.onRemove(), !this._singleton() && this.__uiDOM && this._removePrevDOM(), delete this._owner, this.fire("remove"), this._collides(), this;
  }, e.getSize = function() {
    return this._domContentRect && this._size && (this._size.width = this._domContentRect.width, this._size.height = this._domContentRect.height), this._size ? this._size.copy() : null;
  }, e.getOwner = function() {
    return this._owner;
  }, e.getDOM = function() {
    return this.__uiDOM;
  }, e.setZIndex = function(n) {
    if (!Ut(n))
      return this;
    var s = this.getDOM();
    return s ? (s.style.zIndex = n, n !== this.options.zIndex && (this.options.zIndex = n), this) : this;
  }, e._roundPoint = function(n) {
    return this.options.roundPoint && (n = n._round()), n;
  }, e.getPosition = function() {
    if (!this.getMap())
      return null;
    var n = this._roundPoint(this._getViewPoint());
    if (this.getOffset) {
      var s = this._roundPoint(this.getOffset());
      s && n._add(s);
    }
    return n;
  }, e._getAnimation = function() {
    for (var n = {
      fade: !1,
      scale: !1
    }, s = this.options.animation ? this.options.animation.split(",") : [], o = 0; o < s.length; o++) {
      var a = gv(s[o]);
      a === "fade" ? n.fade = !0 : a === "scale" && (n.scale = !0);
    }
    var l = null;
    return n.fade && (l = "opacity " + this.options.animationDuration + "ms"), n.scale && (l = l ? l + "," : "", l += Ba + " " + this.options.animationDuration + "ms"), n.transition = l, n.ok = l !== null, n;
  }, e._getViewPoint = function() {
    var n = 0, s = this._coordinate || {};
    Ut(s.z) ? n = s.z : this._owner && this._owner.getAltitude && (n = this._owner.getAltitude() || 0, Ut(n) || (n = 0));
    var o = this._meterToPoint(this._coordinate, n);
    return this.getMap().coordToViewPoint(this._coordinate, void 0, o)._add(this.options.dx, this.options.dy);
  }, e._meterToPoint = function(n, s) {
    return s;
  }, e._autoPan = function() {
    var n = this.getMap(), s = this.getDOM();
    if (!(!s || !n || n.isMoving())) {
      var o = this._getViewPoint()._round(), a = n.width, l = n.height, h = n.getContainer();
      if (s && h && s.getBoundingClientRect) {
        var u = h.getBoundingClientRect(), c = u.left, f = u.top, d = 50, p = s.getBoundingClientRect(), g = 0, m = 0, v = p.left, _ = p.right, y = p.top, x = p.bottom, w = p.width, b = p.height;
        if (v -= c, _ -= c, y -= f, x -= f, w > 0 && b > 0) {
          if (v < d && (g = d - v), g === 0 && _ + d > a && (g = -(_ + d - a)), y < d && (m = d - y), m === 0 && x + d > l && (m = -(x + d - l)), g !== 0 || m !== 0) {
            var T = n.getPitch();
            T > 40 && m !== 0 && this._coordinate ? n.animateTo({
              center: this._coordinate
            }, {
              duration: n.options.panAnimationDuration
            }) : n.panBy([Math.ceil(g), Math.ceil(m)]);
          }
          return;
        }
      }
      var A = n.viewPointToContainerPoint(o), M = this.getOffset(), S = A.add(M), P = n._viewPointToPrj(o), C = parseInt(s.clientWidth), k = parseInt(s.clientHeight), O = 50, R = 0, I = 0;
      if (S.x < 0 ? R = -S.x + O : S.x + C > a && (R = -(S.x + C - a) - O), S.y - k < 0 ? I = Math.abs(S.y - k) + O : S.y + k > l && (I = l - (S.y + k) - O), C >= a && (R = a / 2 - A.x), I !== 0 || R !== 0) {
        var D = A.add(R, I), z = n._containerPointToPoint(D)._sub(n._prjToPoint(n._getPrjCenter())), H = n._pointToPrj(n._prjToPoint(P).sub(z));
        n._panAnimation(H);
      }
    }
  }, e._measureSize = function(n) {
    var s = this._getUIContainer();
    n.style.position = "absolute";
    var o = n.style.bottom ? "bottom" : "top";
    if (n.style.display = "", s.appendChild(n), n.getBoundingClientRect) {
      var a = n.getBoundingClientRect();
      this._size = new zn(a.width, a.height);
    } else
      this._size = new zn(n.clientWidth, n.clientHeight);
    return n.style.display = "none", n.style.left = "0px", n.style[o] = "0px", this._size;
  }, e._removePrevDOM = function() {
    this.onDomRemove && this.onDomRemove();
    var n = this.options.eventsToStop;
    if (this._singleton()) {
      var s = this.getMap(), o = this._uiDomKey();
      if (s[o]) {
        n && Un(s[o], n, Jr);
        var a = s[o]._uiComponent;
        a && a !== this && a.isVisible() && a.fire("hide"), Ml(s[o]), a && !this.hideDom && a._switchMapEvents("off"), delete s[o];
      }
      delete this.__uiDOM;
    } else this.__uiDOM && (n && Un(this.__uiDOM, n, Jr), Ml(this.__uiDOM), delete this.__uiDOM);
    this._resizeObserver && (this._resizeObserver.disconnect(), delete this._resizeObserver, delete this._domContentRect);
  }, e._uiDomKey = function() {
    return "__ui_" + this._getClassName();
  }, e._singleton = function() {
    return this.options.single;
  }, e._getUIContainer = function() {
    return this.getMap()._panels.ui;
  }, e._getClassName = function() {
    return "UIComponent";
  }, e._switchMapEvents = function(n) {
    var s = this.getMap();
    if (s) {
      this._mapEventsOn = n === "on";
      var o = this._getDefaultEvents();
      if (this.getEvents && jt(o, this.getEvents()), o)
        for (var a in o)
          o.hasOwnProperty(a) && s[n](a, o[a], this);
    }
  }, e._switchEvents = function(n) {
    var s = this._getOwnerEvents();
    if (this._owner)
      for (var o in s)
        s.hasOwnProperty(o) && this._owner[n](o, s[o], this);
  }, e._getDefaultEvents = function() {
    return {
      "zooming rotate pitch": this.onEvent,
      zoomend: this.onZoomEnd,
      moving: this.onMoving,
      moveend: this.onMoving,
      resize: this.onResize
    };
  }, e._getOwnerEvents = function() {
    var n = {};
    return this._owner && this._owner instanceof nn && (n.positionchange = this.onGeometryPositionChange, n.symbolchange = this._updatePosition), this.getOwnerEvents && jt(n, this.getOwnerEvents()), n;
  }, e.onGeometryPositionChange = function(n) {
    this._owner && this.isVisible() && (this._showBySymbolChange = !0, this.show(n.target.getCenter()), delete this._showBySymbolChange);
  }, e.onMoving = function() {
    this.isVisible() && this.getMap().isTransforming() && this._updatePosition();
  }, e.onEvent = function() {
    this.isVisible() && this._updatePosition();
  }, e.onZoomEnd = function() {
    this.isVisible() && this._setPosition();
  }, e.onResize = function() {
    this.isVisible() && this._setPosition();
  }, e.onDomSizeChange = function() {
    this.isVisible() && (this._setPosition(), this._collides());
  }, e._updatePosition = function() {
    if (!this.getMap())
      return this;
    var n = this.getMap()._getRenderer();
    return n.callInNextFrame(this._setPosition.bind(this)), this;
  }, e._setPosition = function() {
    var n = this.getDOM();
    if (n) {
      n.style[qu] = null;
      var s = this.getPosition();
      this._pos = s, n.style[Ba] = this._toCSSTranslate(s) + " scale(1)";
    }
  }, e._toCSSTranslate = function(n) {
    if (!n)
      return "";
    if (Ce.any3d) {
      var s = this.getMap(), o = s ? s.getBearing() : 0, a = s ? s.getPitch() : 0, l = "";
      return this.options.pitchWithMap && a && (l += " rotateX(" + Math.round(a) + "deg)"), this.options.rotateWithMap && o && (l += " rotateZ(" + Math.round(-o) + "deg)"), "translate3d(" + Math.fround(n.x) + "px," + Math.fround(n.y) + "px, 0px)" + l;
    } else
      return "translate(" + n.x + "px," + n.y + "px)";
  }, e._observerDomSize = function(n) {
    var s = this;
    return !n || !Ce.resizeObserver || this._resizeObserver ? this : (this._resizeObserver = new ResizeObserver(function(o) {
      if (o.length) {
        var a = o[0].borderBoxSize;
        a && a.length ? s._domContentRect = {
          width: a[0].inlineSize,
          height: a[0].blockSize
        } : s._domContentRect = o[0].contentRect;
      } else
        delete s._domContentRect;
      s.onDomSizeChange && s.onDomSizeChange();
    }), this._resizeObserver.observe(n), this);
  }, e.isSupportZoomFilter = function() {
    return !1;
  }, e.onConfig = function() {
    return this._updatePosition(), this;
  }, t.isSupport = function(n) {
    return !!(n && Be(n.on) && Be(n.off) && Be(n.getCenter));
  }, e._bindDomEvents = function(n, s) {
    if (n) {
      var o = this._getDomEvents() || {}, a = s === "on" ? Cn : Un;
      for (var l in o)
        a(n, l, o[l], this);
    }
  }, e._getDomEvents = function() {
    return {
      mouseover: this._onDomMouseover,
      mouseout: this._onDomMouseout
    };
  }, e._configMapPreventWheelScroll = function(n) {
    var s = this.getMap();
    s && (this.options.eventsPropagation || (s.options.preventWheelScroll = n));
  }, e._onDomMouseover = function(n) {
    this._configMapPreventWheelScroll(!1);
  }, e._onDomMouseout = function(n) {
    this._configMapPreventWheelScroll(!0);
  }, t;
}(ls(pi));
Uo.mergeOptions(nk);
var rk = {
  containerClass: null,
  eventsPropagation: !0,
  draggable: !1,
  single: !1,
  content: null,
  altitude: 0,
  minZoom: 0,
  maxZoom: null,
  horizontalAlignment: "middle",
  verticalAlignment: "middle"
}, u_ = "mousedown mouseup mouseenter mouseover mouseout mousemove click dblclick contextmenu keypress touchstart touchmove touchend", Nv = function(i) {
  Ot(t, i);
  function t(r, n) {
    var s;
    return s = i.call(this, n) || this, s._markerCoord = new lt(r), s;
  }
  var e = t.prototype;
  return e._getClassName = function() {
    return "UIMarker";
  }, e.setCoordinates = function(n) {
    return this._markerCoord = n, this.fire("positionchange"), this.isVisible() && (this._coordinate = this._markerCoord, this._setPosition(), this._collides()), this;
  }, e.getCoordinates = function() {
    return this._markerCoord;
  }, e.getCenter = function() {
    return this.getCoordinates();
  }, e.getAltitude = function() {
    var n = this.getCoordinates() || {};
    return Ut(n.z) ? n.z : this.options.altitude || 0;
  }, e.setAltitude = function(n) {
    return Ut(n) && this._markerCoord && (this._markerCoord.z = n, this._updatePosition && (this._updatePosition(), this._collides())), this;
  }, e.setContent = function(n) {
    var s = this.options.content;
    return this.options.content = n, this.fire("contentchange", {
      old: s,
      new: n
    }), this.isVisible() && this.show(), this;
  }, e.getContent = function() {
    return this.options.content;
  }, e.onAdd = function() {
    if (this._owner && !this._owner.isMap)
      throw new Error("UIMarker Can only be added to the map, but owner is:", this._owner.getJSONType && this._owner.getJSONType());
    return this.show(), this;
  }, e.show = function() {
    return i.prototype.show.call(this, this._markerCoord);
  }, e.flash = function(n, s, o, a) {
    return hv.call(this, n, s, o, a);
  }, e.buildOn = function() {
    var n = this.getDOM();
    this._bindDomEvents(n, "off");
    var s, o = this.options.content, a = De(o);
    return a || Be(o) ? (s = ve("div"), a ? s.innerHTML = this.options.content : o.bind(this)(s)) : s = this.options.content, this.options.containerClass && (s.className = this.options.containerClass), this._registerDOMEvents(s), this._bindDomEvents(s, "on"), s;
  }, e.getOffset = function() {
    var n = this.getSize(), s = -n.width / 2, o = -n.height / 2, a = this.options, l = a.horizontalAlignment, h = a.verticalAlignment;
    return l === "left" ? s = -n.width : l === "right" && (s = 0), h === "top" ? o = -n.height : h === "bottom" && (o = 0), new Y(s, o);
  }, e.getTransformOrigin = function() {
    return "center center";
  }, e.onDomRemove = function() {
    var n = this.getDOM();
    this._removeDOMEvents(n);
  }, e.isDragging = function() {
    return this.draggable ? this.draggable.isDragging() : !1;
  }, e._registerDOMEvents = function(n) {
    Cn(n, u_, this._onDomEvents, this);
  }, e._onDomEvents = function(n) {
    var s = this.getMap()._parseEvent(n, n.type), o = n.type;
    if (o === "mousedown" && (this._mousedownEvent = n), o === "mouseup" && (this._mouseupEvent = n), !(o === "click" && this._mouseClickPositionIsChange()) && (o === "touchstart" && (this._touchstartTime = Je()), this.fire(n.type, s), o === "touchend" && Ce.touch)) {
      var a = this.getMap().options.clickTimeThreshold || 280;
      Je() - this._touchstartTime < a && this._onDomEvents(jt({}, n, {
        type: "click"
      }));
    }
  }, e._removeDOMEvents = function(n) {
    Un(n, u_, this._onDomEvents);
  }, e._mouseClickPositionIsChange = function() {
    var n = this._mousedownEvent || {}, s = n.x, o = n.y, a = this._mouseupEvent || {}, l = a.x, h = a.y;
    return s !== l || o !== h;
  }, e._getConnectPoints = function() {
    var n = this.getMap(), s = n.coordToContainerPoint(this.getCoordinates()), o = this.getSize(), a = o.width, l = o.height, h = [n.containerPointToCoordinate(s.add(-a / 2, 0)), n.containerPointToCoordinate(s.add(a / 2, 0)), n.containerPointToCoordinate(s.add(0, l / 2)), n.containerPointToCoordinate(s.add(0, -l / 2))];
    return h;
  }, e._getViewPoint = function() {
    var n = 0;
    if (this._owner) {
      var s = this.getAltitude();
      s > 0 && (n = this._meterToPoint(this._coordinate, s));
    }
    return this.getMap().coordToViewPoint(this._coordinate, void 0, n)._add(this.options.dx, this.options.dy);
  }, e._getDefaultEvents = function() {
    return jt({}, i.prototype._getDefaultEvents.call(this), {
      "zooming zoomend": this.onZoomFilter
    });
  }, e._setPosition = function() {
    this.onZoomFilter(), i.prototype._setPosition.call(this);
  }, e.onZoomFilter = function() {
    var n = this.getDOM();
    n && (!this.isVisible() && n.style.display !== "none" ? n.style.display = "none" : this.isVisible() && n.style.display === "none" && (n.style.display = ""));
  }, e.isVisible = function() {
    var n = this.getMap();
    if (!n || !this.options.visible)
      return !1;
    var s = n.getZoom(), o = this.options, a = o.minZoom, l = o.maxZoom;
    if (!W(a) && s < a || !W(l) && s > l)
      return !1;
    var h = this.getDOM();
    return h && !0;
  }, e.isSupportZoomFilter = function() {
    return !0;
  }, t;
}(Av(Uo));
Nv.mergeOptions(rk);
var c_ = Ce.touch ? "touchstart mousedown" : "mousedown", ik = function(i) {
  Ot(t, i);
  function t(r) {
    return i.call(this, r) || this;
  }
  var e = t.prototype;
  return e.addHooks = function() {
    this.target.on(c_, this._startDrag, this);
  }, e.removeHooks = function() {
    this.target.off(c_, this._startDrag, this);
  }, e._startDrag = function(n) {
    var s = n.domEvent;
    s.touches && s.touches.length > 1 || s.button === 2 || this.isDragging() || (this.target.on("click", this._endDrag, this), this._lastCoord = n.coordinate, this._lastPoint = n.containerPoint, this._prepareDragHandler(), this._dragHandler.onMouseDown(n.domEvent), this.target.fire("dragstart", n));
  }, e._prepareDragHandler = function() {
    this._dragHandler = new Iu(this.target.getDOM(), {
      cancelOn: this._cancelOn.bind(this),
      ignoreMouseleave: !0
    }), this._dragHandler.on("mousedown", this._onMouseDown, this), this._dragHandler.on("dragging", this._dragging, this), this._dragHandler.on("mouseup", this._endDrag, this), this._dragHandler.enable();
  }, e._cancelOn = function(n) {
    var s = n.srcElement || n.target, o = s.tagName.toLowerCase();
    return o === "button" || o === "input" || o === "select" || o === "option" || o === "textarea";
  }, e._onMouseDown = function(n) {
    Jr(n.domEvent);
  }, e._dragging = function(n) {
    var s = this.target, o = s.getMap(), a = o._parseEvent(n.domEvent), l = a.domEvent;
    if (!(l.touches && l.touches.length > 1)) {
      if (!this._isDragging) {
        this._isDragging = !0;
        return;
      }
      var h = a.coordinate, u = a.containerPoint;
      this._lastCoord || (this._lastCoord = h), this._lastPoint || (this._lastPoint = u);
      var c = h.sub(this._lastCoord), f = u.sub(this._lastPoint);
      this._lastCoord = h, this._lastPoint = u, this.target.setCoordinates(this.target.getCoordinates().add(c)), a.coordOffset = c, a.pointOffset = f, s.fire("dragging", a);
    }
  }, e._endDrag = function(n) {
    var s = this.target, o = s.getMap();
    if (this._dragHandler && (s.off("click", this._endDrag, this), this._dragHandler.disable(), delete this._dragHandler), delete this._lastCoord, delete this._lastPoint, this._isDragging = !1, !!o) {
      var a = o._parseEvent(n.domEvent);
      s && s._mouseClickPositionIsChange && s._mouseClickPositionIsChange() && s.fire("dragend", a);
    }
  }, e.isDragging = function() {
    return !!this._isDragging;
  }, t;
}(Xi);
Nv.addInitHook("addHandler", "draggable", ik);
var sk = /\{ *([\w_]+) *\}/g, gA = {
  containerClass: "maptalks-msgBox",
  autoPan: !0,
  autoCloseOn: null,
  autoOpenOn: "click",
  width: "auto",
  minHeight: 120,
  custom: !1,
  title: null,
  content: null,
  enableTemplate: !1
}, ok = new zn(0, 0), n0 = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e._getClassName = function() {
    return "InfoWindow";
  }, e.addTo = function(n) {
    return n instanceof nn && (n.getInfoWindow() && n.getInfoWindow() !== this && n.removeInfoWindow(), n._infoWindow = this), i.prototype.addTo.call(this, n);
  }, e.setContent = function(n) {
    var s = this.options.content;
    return this.options.content = n, this.fire("contentchange", {
      old: s,
      new: n
    }), this.isVisible() && this.show(this._coordinate), this;
  }, e.getContent = function() {
    return this.options.content;
  }, e.setTitle = function(n) {
    var s = n;
    return this.options.title = n, this.fire("contentchange", {
      old: s,
      new: n
    }), this.isVisible() && this.show(this._coordinate), this;
  }, e.getTitle = function() {
    return this.options.title;
  }, e.buildOn = function() {
    var n = Be(this.options.content), s = De(this.options.content);
    if (this.options.custom) {
      var o = this.getDOM(), a;
      if (this._bindDomEvents(o, "off"), s || n) {
        var l = ve("div");
        s ? (l.innerHTML = this.options.content, this._replaceTemplate(l)) : this.options.content.bind(this)(l), a = l;
      } else
        this._replaceTemplate(this.options.content), a = this.options.content;
      return this._bindDomEvents(a, "on"), a;
    }
    this._bindDomEvents(this.getDOM(), "off");
    var h = ve("div");
    this.options.containerClass && (h.className = this.options.containerClass);
    var u = this._getWindowWidth();
    h.style.width = Ut(u) ? u + "px" : "auto", h.style.bottom = "0px";
    var c = '<em class="maptalks-ico"></em>';
    this.options.title && (c += "<h2>" + this.options.title + "</h2>"), c += '<a href="javascript:void(0);" class="maptalks-close">×</a><div class="maptalks-msgContent"></div>', h.innerHTML = c, this._replaceTemplate(h);
    var f = h.querySelector(".maptalks-msgContent");
    s || n ? s ? f.innerHTML = this.options.content : this.options.content.bind(this)(f) : f.appendChild(this.options.content), this._onCloseBtnClick = this.hide.bind(this);
    var d = h.querySelector(".maptalks-close");
    return Gi(d, "click touchend", this._onCloseBtnClick), n || this._replaceTemplate(f), this._bindDomEvents(h, "on"), h;
  }, e._replaceTemplate = function(n) {
    if (this.options.enableTemplate && this._owner && this._owner.getProperties && n && n.innerHTML) {
      var s = this._owner.getProperties() || {};
      if (ji(s)) {
        var o = n.innerHTML;
        n.innerHTML = o.replace(sk, function(a, l) {
          return s[l];
        });
      }
    }
    return this;
  }, e.getTransformOrigin = function() {
    var n = this.getSize();
    return n.width / 2 + "px bottom";
  }, e.getOffset = function() {
    var n = this.getSize(), s = new Y(-n.width / 2, 0);
    this.options.custom ? s._sub(0, n.height) : s._sub(4, 12);
    var o = this.getOwner();
    if (o instanceof xn || o instanceof jo) {
      var a, l;
      if (o instanceof xn)
        a = o._getPainter(), l = o.getSize();
      else {
        var h = o.getGeometries();
        if (!h || !h.length)
          return s;
        a = h[0]._getPainter(), l = h[0].getSize();
      }
      if (l || (l = ok), a) {
        var u = a.getFixedExtent();
        s._add(u.xmax - l.width / 2, u.ymin);
      } else
        s._add(0, -l.height);
    }
    return s;
  }, e.show = function(n) {
    return this.getMap() ? this.getMap().options.enableInfoWindow ? i.prototype.show.call(this, n) : this : this;
  }, e.getEvents = function() {
    if (!this.options.autoCloseOn)
      return null;
    var n = {};
    return n[this.options.autoCloseOn] = this.hide, n;
  }, e.getOwnerEvents = function() {
    var n = this.getOwner();
    if (!this.options.autoOpenOn || !n)
      return null;
    var s = {};
    return s[this.options.autoOpenOn] = this._onAutoOpen, s;
  }, e.onRemove = function() {
    this._onDomMouseout(), this.onDomRemove();
  }, e.onDomRemove = function() {
    if (this._onCloseBtnClick) {
      var n = this.getDOM(), s = n.childNodes[2];
      Ho(s, "click touchend", this._onCloseBtnClick), delete this._onCloseBtnClick;
    }
  }, e._onAutoOpen = function(n) {
    var s = this, o = this.getOwner();
    setTimeout(function() {
      o instanceof xn || o instanceof Uo ? s.show(o.getCoordinates()) : o instanceof jo ? s.show(o.findClosest(n.coordinate)) : ((o instanceof Tn || o instanceof Go) && s.getMap().getScale() >= 8 && (n.coordinate = s._rectifyMouseCoordinte(o, n.coordinate)), s.show(n.coordinate));
    }, 1);
  }, e._rectifyMouseCoordinte = function(n, s) {
    var o = this;
    return n instanceof Tn ? this._rectifyLineStringMouseCoordinate(n, s).coordinate : n instanceof Go ? n.getGeometries().map(function(a) {
      return o._rectifyLineStringMouseCoordinate(a, s);
    }).sort(function(a, l) {
      return a.dis - l.dis;
    })[0].coordinate : s;
  }, e._rectifyLineStringMouseCoordinate = function(n, s) {
    for (var o = this.getMap(), a = n.getCoordinates() || [], l = o.getGLRes(), h = a.map(function(Ze) {
      var yn = o.coordToPointAtRes(Ze, l), Cr = Ze.z || 0;
      return o._pointAtResToContainerPoint(yn, l, Cr);
    }), u = o.coordToContainerPoint(s), c = 1 / 0, f = -1, d = 0, p = h.length; d < p; d++) {
      var g = h[d], m = u.distanceTo(g);
      m < c && (c = m, f = d);
    }
    for (var v = [f - 1, f, f + 1].filter(function(Ze) {
      return Ze >= 0 && Ze <= h.length - 1;
    }), _ = v.map(function(Ze) {
      return h[Ze];
    }), y = [], x = o.getSize(), w = x.width, b = x.height, T = 0, A = _.length - 1; T < A; T++) {
      var M = T, S = _[T], P = _[T + 1];
      if (S.x === P.x)
        for (var C = Math.max(0, Math.min(S.y, P.y)), k = Math.min(b, Math.max(S.y, P.y)), O = C; O <= k; O++)
          y.push({
            point: new Y(S.x, O),
            coordinateIndex: M
          });
      else
        for (var R = (P.y - S.y) / (P.x - S.x), I = Math.max(0, Math.min(S.x, P.x)), D = Math.min(w, Math.max(S.x, P.x)), z = I; z <= D; z++) {
          var H = R * (z - S.x) + S.y;
          y.push({
            point: new Y(z, H),
            coordinateIndex: M
          });
        }
    }
    for (var G = 1 / 0, $ = -1, K = -1, dt, it = 0, st = y.length; it < st; it++) {
      var pt = y[it], Ht = pt.point, Rt = pt.coordinateIndex, Tt = u.distanceTo(Ht);
      Tt < G && (G = Tt, $ = it, K = Rt, dt = Ht);
    }
    if ($ < 0)
      return {
        dis: G,
        coordinate: s
      };
    var $t = _[K], Wt = _[K + 1], re = $t.distanceTo(Wt), ie = dt.distanceTo($t), Kt = ie / re, fe = v.map(function(Ze) {
      return a[Ze];
    }), Xt = fe[K], Re = fe[K + 1], Oe = Xt.x, oe = Xt.y, nr = Xt.z || 0, Ke = Re.x, Ye = Re.y, We = Re.z || 0, bn = Ke - Oe, wn = Ye - oe, On = We - nr, $e = Oe + bn * Kt, be = oe + wn * Kt, Ee = nr + On * Kt;
    return {
      dis: G,
      coordinate: new lt($e, be, Ee)
    };
  }, e._getWindowWidth = function() {
    var n = gA.width, s = this.options.width;
    return s || (s = n), s;
  }, t;
}(Uo);
n0.mergeOptions(gA);
var f_ = "remove hide shapechange positionchange dragend animatestart", ak = {
  width: 0,
  height: 0,
  animation: "fade",
  containerClass: "maptalks-tooltip",
  showTimeout: 400
}, lk = function(i) {
  Ot(e, i);
  var t = e.prototype;
  t._getClassName = function() {
    return "ToolTip";
  };
  function e(r, n) {
    var s;
    return n === void 0 && (n = {}), s = i.call(this, n) || this, s._content = r, s;
  }
  return t.addTo = function(n) {
    if (e.isSupport(n))
      return n.on("mousemove", this.onMouseMove, this), n.on("mouseout", this.onMouseOut, this), n.on(f_, this.hideDom, this), i.prototype.addTo.call(this, n);
    throw new Error("Invalid geometry or UIMarker the tooltip is added to.");
  }, t.setStyle = function(n) {
    return this.options.containerClass = n, this;
  }, t.getStyle = function() {
    return this.options.containerClass;
  }, t.getContent = function() {
    return this._content;
  }, t.buildOn = function() {
    var n = ve("div"), s = this.options || {};
    s.height && (n.style.height = s.height + "px"), s.width && (n.style.width = s.width + "px");
    var o = s.containerClass || s.cssName;
    return !o && s.height && (n.style.lineHeight = s.height + "px"), Be(this._content) ? this._content.bind(this)(n) : n.innerHTML = '<div class="' + o + '">' + this._content + "</div>", n;
  }, t.onMouseOut = function() {
    clearTimeout(this._timeout), this.isVisible() && this._removePrevDOM(), this._switchMapEvents("off");
  }, t.onMouseMove = function(n) {
    var s = this;
    clearTimeout(this._timeout);
    var o = this.getMap();
    if (o) {
      var a = o.locateByPoint(n.coordinate, -5, 25);
      this.options.showTimeout === 0 ? this.show(a) : this._timeout = setTimeout(function() {
        o && s.show(a);
      }, this.options.showTimeout);
    }
  }, t.onRemove = function() {
    clearTimeout(this._timeout), this._owner && (this._owner.off("mouseover", this.onMouseOver, this), this._owner.off("mouseout", this.onMouseOut, this), this._owner.off(f_, this.hideDom, this));
  }, t.hideDom = function() {
    return this.hide();
  }, t.onEvent = function() {
    return i.prototype.onEvent.call(this), this.hideDom(), this;
  }, t._getViewPoint = function() {
    return this.getMap().coordToViewPoint(this._coordinate, void 0, 0)._add(this.options.dx, this.options.dy);
  }, e;
}(Uo);
lk.mergeOptions(ak);
var hk = {
  containerClass: "maptalks-menu",
  animation: null,
  animationDelay: 10,
  animationOnHide: !1,
  autoPan: !1,
  width: 160,
  maxHeight: 0,
  custom: !1,
  items: []
}, mA = function(i) {
  Ot(t, i);
  function t(r) {
    return i.call(this, r) || this;
  }
  var e = t.prototype;
  return e._getClassName = function() {
    return "Menu";
  }, e.addTo = function(n) {
    return n._menu && n._menu !== this && n.removeMenu(), n._menu = this, this._owner = n, Uo.prototype.addTo.apply(this, arguments);
  }, e.setItems = function(n) {
    return this.options.items = n, this;
  }, e.getItems = function() {
    return this.options.items || [];
  }, e.buildOn = function() {
    if (this.options.custom)
      if (De(this.options.items)) {
        var n = ve("div");
        return n.innerHTML = this.options.items, n;
      } else
        return this.options.items;
    else {
      var s = ve("div");
      this.options.containerClass && rl(s, this.options.containerClass), s.style.width = this._getMenuWidth() + "px";
      var o = this._createMenuItemDom();
      return s.appendChild(o), Cn(s, "contextmenu", ks), s;
    }
  }, e.getOffset = function() {
    if (!this.getMap())
      return null;
    var n = this.getMap().getSize(), s = this.getMap().viewPointToContainerPoint(this._getViewPoint()), o = this.getSize(), a = 0, l = 0;
    return s.x + o.width > n.width && (a = -o.width), s.y + o.height > n.height && (l = -o.height), new Y(a, l);
  }, e.getTransformOrigin = function() {
    var n = this.getOffset()._multi(-1);
    return n.x + "px " + n.y + "px";
  }, e.getEvents = function() {
    return {
      "_zoomstart _zoomend _movestart _dblclick _click": this._removePrevDOM
    };
  }, e._createMenuItemDom = function() {
    var n = this, s = this.getMap(), o = ve("ul");
    rl(o, "maptalks-menu-items");
    var a = this.getItems();
    function l(g) {
      return function(m) {
        var v = s._parseEvent(m, "click");
        v.target = n, v.owner = n._owner, v.index = g;
        var _ = this._callback(v);
        _ !== !1 && (n.hide(), n._owner && n._owner.fire("closemenu"));
      };
    }
    for (var h, u, c = 0, f = a.length; c < f; c++) {
      if (h = a[c], h === "-" || h === "_")
        u = ve("li"), rl(u, "maptalks-menu-splitter");
      else {
        u = ve("li");
        var d = h.item;
        Be(d) && (d = d({
          owner: this._owner,
          index: c
        })), u.innerHTML = d, u._callback = h.click, Cn(u, "click", l(c));
      }
      o.appendChild(u);
    }
    var p = this.options.maxHeight || 0;
    return p > 0 && Od(o, "max-height: " + p + "px; overflow-y: auto;"), o;
  }, e._getMenuWidth = function() {
    var n = 160, s = this.options.width || n;
    return s;
  }, t;
}(Uo);
mA.mergeOptions(hk);
var vA = {
  setMenu: function(t) {
    return this._menuOptions = t, this._menu ? this._menu.setOptions(t) : this.on("contextmenu", this._defaultOpenMenu, this), this;
  },
  getMenu: function() {
    return this._menu;
  },
  openMenu: function(t) {
    var e = this instanceof xe ? this : this.getMap();
    return t || (t = this.getCenter()), this._menu ? this._menu.show(t) : this._menuOptions && e && (this._bindMenu(), this._menu.show(t)), this.fire("openmenu", {
      coordinate: t
    }), this;
  },
  setMenuItems: function(t) {
    return this._menuOptions || (this._menuOptions = {}), Array.isArray(t) && (this._menuOptions.custom = !1), this._menuOptions.items = t, this.setMenu(this._menuOptions), this;
  },
  getMenuItems: function() {
    return this._menu ? this._menu.getItems() : this._menuOptions ? this._menuOptions.items || [] : [];
  },
  closeMenu: function() {
    return this._menu && this._menu.hide(), this.fire("closemenu", {}), this;
  },
  removeMenu: function() {
    return this.off("contextmenu", this._defaultOpenMenu, this), this._unbindMenu(), delete this._menuOptions, this.fire("removemenu", {}), this;
  },
  _bindMenu: function() {
    return this._menuOptions ? (this._menu = new mA(this._menuOptions), this._menu.addTo(this), this) : this;
  },
  _unbindMenu: function() {
    return this._menu && (this.closeMenu(), this._menu.remove(), delete this._menu), this;
  },
  _defaultOpenMenu: function(t) {
    return this.openMenu(t.coordinate), !1;
  }
};
xe.include(vA);
nn.include(vA);
var Wi = function(i) {
  Ot(t, i);
  function t(r) {
    return r && r.position && !De(r.position) && (r.position = jt({}, r.position)), i.call(this, r) || this;
  }
  var e = t.prototype;
  return e.addTo = function(n) {
    if (this.remove(), !n.options.control)
      return this;
    this._map = n;
    var s = n._panels.control;
    return this.__ctrlContainer = ve("div"), Od(this.__ctrlContainer, "position:absolute;overflow:visible;"), this.update(), s.appendChild(this.__ctrlContainer), this.onAdd && this.onAdd(), this.fire("add", {
      dom: s
    }), this;
  }, e.update = function() {
    return this.__ctrlContainer.innerHTML = "", this._controlDom = this.buildOn(this.getMap()), this._controlDom && (this._updatePosition(), this.__ctrlContainer.appendChild(this._controlDom)), this;
  }, e.getMap = function() {
    return this._map;
  }, e.getPosition = function() {
    return jt({}, this._parse(this.options.position));
  }, e.setPosition = function(n) {
    return De(n) ? this.options.position = n : this.options.position = jt({}, n), this._updatePosition(), this;
  }, e.getContainerPoint = function() {
    var n = this.getPosition(), s = this.getMap().getSize(), o, a;
    return W(n.left) ? W(n.right) || (o = s.width - parseInt(n.right)) : o = parseInt(n.left), W(n.top) ? W(n.bottom) || (a = s.height - parseInt(n.bottom)) : a = parseInt(n.top), new Y(o, a);
  }, e.getContainer = function() {
    return this.__ctrlContainer;
  }, e.getDOM = function() {
    return this._controlDom;
  }, e.show = function() {
    return this.__ctrlContainer.style.display = "", this;
  }, e.hide = function() {
    return this.__ctrlContainer.style.display = "none", this;
  }, e.isVisible = function() {
    return this.__ctrlContainer && this.__ctrlContainer.style.display === "";
  }, e.remove = function() {
    return this._map ? (Ml(this.__ctrlContainer), this.onRemove && this.onRemove(), delete this._map, delete this.__ctrlContainer, delete this._controlDom, this.fire("remove"), this) : this;
  }, e._parse = function(n) {
    var s = n;
    return De(n) && (s = t.positions[s]), s;
  }, e._updatePosition = function() {
    var n = this.getPosition();
    n || (n = {
      top: 20,
      left: 20
    });
    for (var s in n)
      if (n.hasOwnProperty(s)) {
        var o = n[s] || 0;
        Ut(o) && (o += "px"), this.__ctrlContainer.style[s] = o;
      }
    this.fire("positionchange", {
      position: jt({}, n)
    });
  }, t;
}(ls(pi));
Wi.positions = {
  "top-left": {
    top: 20,
    left: 20
  },
  "top-right": {
    top: 20,
    right: 20
  },
  "bottom-left": {
    bottom: 20,
    left: 20
  },
  "bottom-right": {
    bottom: 20,
    right: 20
  }
};
xe.mergeOptions({
  control: !0
});
xe.include({
  addControl: function(t) {
    return this._containerDOM.getContext ? this : (t.addTo(this), this);
  },
  removeControl: function(t) {
    return !t || t.getMap() !== this ? this : (t.remove(), this);
  }
});
var uk = {
  position: {
    bottom: 0,
    left: 0
  },
  content: '<a href="http://maptalks.org" target="_blank">maptalks</a>'
}, d_ = "addlayer removelayer setbaselayer baselayerremove", yA = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.buildOn = function() {
    return this._attributionContainer = ve("div"), this._attributionContainer.className = "maptalks-attribution", this._update(), this._attributionContainer;
  }, e.onAdd = function() {
    this.getMap().on(d_, this._update, this);
  }, e.onRemove = function() {
    this.getMap().off(d_, this._update, this);
  }, e._update = function() {
    var n = this.getMap();
    if (n) {
      var s = n._getLayers(function(a) {
        return a.options.attribution;
      }).reverse().map(function(a) {
        return a.options.attribution;
      }), o = this.options.content + (s.length > 0 ? " - " + s.join(", ") : "");
      this._attributionContainer.innerHTML = '<span style="padding:0px 4px">' + o + "</span>";
    }
  }, t;
}(Wi);
yA.mergeOptions(uk);
xe.mergeOptions({
  attribution: !0
});
xe.addOnLoadHook(function() {
  var i = this.options.attribution || this.options.attributionControl;
  i && (this.attributionControl = new yA(i), this.addControl(this.attributionControl));
});
var ck = {
  position: {
    top: 120,
    left: 20
  }
}, _A = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.buildOn = function(n) {
    var s = this._getCompass();
    return this._compass = s, this._registerDomEvents(), n.on("resize moving moveend zooming zoomend rotate rotateend dragrotating dragrotateend viewchange", this._rotateCompass, this), s;
  }, e.onAdd = function() {
    this._rotateCompass();
  }, e._getCompass = function() {
    var n = ve("div", "maptalks-compass");
    return n;
  }, e._registerDomEvents = function() {
    Cn(this._compass, "click", this._resetView, this);
  }, e._rotateCompass = function() {
    var n = this.getMap().getBearing().toFixed(1);
    n <= 180 && (n *= -1), n !== this._bearing && (this._bearing = n, Od(this._compass, "transform: rotate(" + this._bearing + "deg);"));
  }, e.onRemove = function() {
    this.getMap().off("resize moving moveend zooming zoomend rotate rotateend dragrotating dragrotateend viewchange", this._rotateCompass, this), delete this._compass, delete this._bearing;
  }, e._resetView = function() {
    var n = {
      bearing: 0
    };
    this.getMap().animateTo(n);
  }, t;
}(Wi);
_A.mergeOptions(ck);
xe.mergeOptions({
  compassControl: !1
});
xe.addOnLoadHook(function() {
  this.options.compassControl && (this.compassControl = new _A(this.options.compassControl), this.addControl(this.compassControl));
});
var fk = {
  position: "top-right",
  baseTitle: "Base Layers",
  overlayTitle: "Layers",
  excludeLayers: [],
  containerClass: "maptalks-layer-switcher"
}, xA = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.buildOn = function() {
    var n = this.container = ve("div", this.options.containerClass), s = this.panel = ve("div", "panel"), o = this.button = ve("button");
    return n.appendChild(o), n.appendChild(s), n;
  }, e.onAdd = function() {
    Cn(this.button, "mouseover", this._show, this), Cn(this.panel, "mouseleave", this._hide, this), Cn(this.getMap(), "click", this._hide, this);
  }, e.onRemove = function() {
    this.panel && (Un(this.button, "mouseover", this._show), Un(this.panel, "mouseleave", this._hide), Un(this.getMap(), "click", this._hide), Ml(this.panel), Ml(this.button), delete this.panel, delete this.button, delete this.container);
  }, e._show = function() {
    sT(this.container, "shown") || (rl(this.container, "shown"), this._createPanel());
  }, e._hide = function(n) {
    this.panel.contains(n.toElement || n.relatedTarget) || bv(this.container, this.options.containerClass);
  }, e._createPanel = function() {
    this.panel.innerHTML = "";
    var n = ve("ul");
    this.panel.appendChild(n), this._renderLayers(this.getMap(), n);
  }, e._renderLayers = function(n, s) {
    var o = this, a = n.getBaseLayer(), l = n.getLayers(), h = l.length;
    if (a) {
      var u = a.layers || [a], c = ve("li", "group"), f = ve("ul"), d = ve("label");
      d.innerHTML = this.options.baseTitle, c.appendChild(d);
      for (var p = 0, g = u.length; p < g; p++) {
        var m = u[p];
        this._isExcluded(m) && (f.appendChild(this._renderLayer(u[p], !0)), c.appendChild(f), s.appendChild(c));
      }
    }
    if (h) {
      var v = ve("li", "group"), _ = ve("ul"), y = ve("label"), x = ve("input");
      x.type = "checkbox", x.checked = !0, y.innerHTML = this.options.overlayTitle, v.appendChild(x), v.appendChild(y);
      for (var w = function(M) {
        var S = M.target.checked, P = M.target.parentNode;
        if (P) {
          var C = P.getElementsByTagName("ul")[0];
          if (C) {
            var k = function(I) {
              var D = I._layer;
              D && D[S ? "show" : "hide"]();
            }, O = function(I) {
              var D = I._layer, z = I.childNodes[0];
              z && (z.checked = S), D && D[S ? "show" : "hide"]();
            };
            k(P), C.childNodes.forEach(function(R) {
              O(R);
              var I = R.getElementsByTagName("ul")[0];
              I && (k(R), I.childNodes.forEach(function(D) {
                O(D);
              }));
            });
          }
        }
      }, b = 0; b < h; b++) {
        var T = l[b];
        this._isExcluded(T) && (T.getLayers ? function() {
          var A = ve("li", "group"), M = ve("ul"), S = ve("label"), P = ve("input");
          S.innerHTML = T.getId(), P.type = "checkbox", P.checked = T.isVisible(), P.onchange = w, A.appendChild(P), A.appendChild(S), A.appendChild(M), A._layer = T, _.appendChild(A);
          var C = T.getLayers() || [];
          C.forEach(function(k) {
            M.appendChild(o._renderLayer(k, !1, P.checked));
          });
        }() : _.appendChild(this._renderLayer(T)), T && !T.isVisible() && (x.checked = !1));
      }
      v.appendChild(_), s.appendChild(v), x.onchange = w;
    }
  }, e._isExcluded = function(n) {
    var s = n.getId(), o = this.options.excludeLayers;
    return !(o.length && o.indexOf(s) >= 0);
  }, e._renderLayer = function(n, s, o) {
    var a = this;
    o === void 0 && (o = !0);
    var l = ve("li", "layer"), h = ve("label"), u = ve("input"), c = this.getMap(), f = n.options.visible;
    n.options.visible = !0;
    var d = n.isVisible();
    return n.options.visible = f, l.className = "layer", s ? (u.type = "radio", u.name = "base") : u.type = "checkbox", u.checked = f && d, o || (u.checked = !1), d || u.setAttribute("disabled", "disabled"), u.onchange = function(p) {
      if (p.target.type === "radio") {
        var g = c.getBaseLayer(), m = g.layers;
        if (m)
          for (var v = 0, _ = m.length; v < _; v++) {
            var y = m[v];
            y[y === n ? "show" : "hide"]();
          }
        else g.isVisible() || g.show();
        c._fireEvent("setbaselayer");
      } else
        n[p.target.checked ? "show" : "hide"]();
      a.fire("layerchange", {
        target: n
      });
    }, l.appendChild(u), h.innerHTML = n.getId(), l.appendChild(h), l._layer = n, l;
  }, t;
}(Wi);
xA.mergeOptions(fk);
xe.mergeOptions({
  layerSwitcherControl: !1
});
xe.addOnLoadHook(function() {
  this.options.layerSwitcherControl && (this.layerSwitcherControl = new xA(this.options.layerSwitcherControl), this.addControl(this.layerSwitcherControl));
});
var dk = {
  level: 4,
  position: {
    right: 1,
    bottom: 1
  },
  size: [300, 200],
  maximize: !0,
  symbol: {
    lineWidth: 3,
    lineColor: "#1bbc9b",
    polygonFill: "#1bbc9b",
    polygonOpacity: 0.4
  },
  containerClass: "maptalks-overview",
  buttonClass: "maptalks-overview-button"
}, bA = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.buildOn = function() {
    var n = this.options.size;
    this.options.maximize || (n = [0, 0]);
    var s = ve("div"), o = this.mapContainer = ve("div");
    o.style.width = n[0] + "px", o.style.height = n[1] + "px", o.className = this.options.containerClass;
    var a = this.button = ve("div");
    return a.className = this.options.buttonClass, s.appendChild(o), s.appendChild(a), s;
  }, e.onAdd = function() {
    this.options.maximize && this._createOverview(), this.getMap().on("resize moving zooming rotate dragrotating viewchange", this._update, this).on("setbaselayer", this._updateBaseLayer, this).on("spatialreferencechange", this._updateSpatialReference, this), Cn(this.button, "click", this._onButtonClick, this), this._updateButtonText();
  }, e.onRemove = function() {
    this.getMap().off("resize moving zooming rotate dragrotating viewchange", this._update, this).off("setbaselayer", this._updateBaseLayer, this).off("spatialreferencechange", this._updateSpatialReference, this), this._overview && (this._overview.remove(), delete this._overview, delete this._perspective), Un(this.button, "click", this._onButtonClick);
  }, e.maxmize = function() {
    var n = this.options.size, s = this.mapContainer;
    return s.style.width = n[0] + "px", s.style.height = n[1] + "px", this._createOverview(), this;
  }, e.minimize = function() {
    this._overview && this._overview.remove(), delete this._overview, delete this._perspective;
    var n = this.mapContainer;
    return n.style.width = "0px", n.style.height = "0px", this;
  }, e.getOverviewMap = function() {
    return this._overview;
  }, e._onButtonClick = function() {
    this._overview ? this.minimize() : this.maxmize(), this._updateButtonText();
  }, e._updateButtonText = function() {
    this._overview ? this.button.innerHTML = "-" : this.button.innerHTML = "+";
  }, e._createOverview = function() {
    var n = this.getMap(), s = this.mapContainer, o = n.config();
    jt(o, {
      center: n.getCenter(),
      zoom: this._getOverviewZoom(),
      zoomAnimationDuration: 150,
      pitch: 0,
      bearing: 0,
      scrollWheelZoom: !1,
      checkSize: !1,
      doubleClickZoom: !1,
      touchZoom: !1,
      control: !1,
      draggable: !1,
      maxExtent: null
    }), this._overview = new xe(s, o), this._updateBaseLayer(), this._perspective = new vn(this._getPerspectiveCoords(), {
      draggable: !0,
      cursor: "move",
      symbol: this.options.symbol
    }).on("dragend", this._onDragEnd, this), new Rs("perspective_layer", this._perspective).addTo(this._overview), this.fire("load");
  }, e._getOverviewZoom = function() {
    var n = this.getMap(), s = n.getZoom(), o = n.getMinZoom(), a = this.options.level;
    if (a > 0) {
      for (var l = a; l > 0; l--)
        if (s - l >= o)
          return s - l;
    } else
      for (var h = a; h < 0; h++)
        if (s - h >= o)
          return s - h;
    return s;
  }, e._onDragEnd = function() {
    var n = this._perspective.getCenter();
    this._overview.setCenter(n), this.getMap().panTo(n);
  }, e._getPerspectiveCoords = function() {
    var n = this.getMap(), s = n.getProjection();
    return n.getContainerExtent().toArray().map(function(o) {
      if (s) {
        var a = n._containerPointToPrj(o);
        return n._fixPrjOnWorldWide(a), s.unproject(a);
      }
      return n.containerPointToCoordinate(o);
    });
  }, e._update = function() {
    if (this._overview) {
      Ed(this._overview._containerDOM);
      var n = this._getPerspectiveCoords();
      this._perspective.setCoordinates(n), this._overview.setCenterAndZoom(this.getMap().getCenter(), this._getOverviewZoom());
    }
  }, e._updateSpatialReference = function() {
    if (this._overview) {
      var n = this.getMap(), s = n.options.spatialReference;
      this._overview.setSpatialReference(s);
    }
  }, e._updateBaseLayer = function() {
    if (this._overview) {
      var n = this.getMap(), s = n.getBaseLayer();
      if (!s) {
        this._overview.setBaseLayer(null);
        return;
      }
      var o = s.layers, a = 0;
      if (o)
        for (var l = 0, h = o.length; l < h; l++) {
          var u = o[l];
          if (u.isVisible()) {
            a = l;
            break;
          }
        }
      var c = s.toJSON(), f = null;
      o ? (f = c.layers[a].options, f.visible = !0) : f = c.options, this._overview.setMinZoom(f.minZoom || null).setMaxZoom(f.maxZoom || null), delete f.minZoom, delete f.maxZoom, delete c.options.canvas, c.options.visible = !0, c.options.renderer = "canvas";
      var d = gr.fromJSON(c);
      for (var p in s)
        Be(s[p]) && s.hasOwnProperty(p) && s[p] !== s.constructor.prototype[p] && (d[p] = s[p]);
      this._overview.setBaseLayer(d);
    }
  }, t;
}(Wi);
bA.mergeOptions(dk);
xe.mergeOptions({
  overviewControl: !1
});
xe.addOnLoadHook(function() {
  this.options.overviewControl && (this.overviewControl = new bA(this.options.overviewControl), this.addControl(this.overviewControl));
});
var pk = {
  position: "top-right",
  draggable: !0,
  custom: !1,
  content: "",
  closeButton: !0
}, gk = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.buildOn = function() {
    var n;
    if (this.options.custom)
      De(this.options.content) ? (n = ve("div"), n.innerHTML = this.options.content) : n = this.options.content;
    else {
      if (n = ve("div", "maptalks-panel"), this.options.closeButton) {
        var s = ve("a", "maptalks-close");
        s.innerText = "×", s.href = "javascript:;", s.onclick = function() {
          n.style.display = "none";
        }, n.appendChild(s);
      }
      var o = ve("div", "maptalks-panel-content");
      o.innerHTML = this.options.content, n.appendChild(o);
    }
    return this.draggable = new Iu(n, {
      cancelOn: this._cancelOn.bind(this),
      ignoreMouseleave: !0
    }), this.draggable.on("dragstart", this._onDragStart, this).on("dragging", this._onDragging, this).on("dragend", this._onDragEnd, this), this.options.draggable && this.draggable.enable(), n;
  }, e.update = function() {
    return this.draggable && (this.draggable.disable(), delete this.draggable), Wi.prototype.update.call(this);
  }, e.setContent = function(n) {
    var s = this.options.content;
    return this.options.content = n, this.fire("contentchange", {
      old: s,
      new: n
    }), this.isVisible() && this.update(), this;
  }, e.getContent = function() {
    return this.options.content;
  }, e._cancelOn = function(n) {
    var s = n.srcElement || n.target, o = s.tagName.toLowerCase();
    return o === "button" || o === "input" || o === "select" || o === "option" || o === "textarea";
  }, e._onDragStart = function(n) {
    this._startPos = n.mousePos, this._startPosition = jt({}, this.getPosition()), this.fire("dragstart", n);
  }, e._onDragging = function(n) {
    var s = n.mousePos, o = s.sub(this._startPos), a = this._startPosition, l = this.getPosition();
    W(l.top) || (l.top = parseInt(a.top) + o.y), W(l.bottom) || (l.bottom = parseInt(a.bottom) - o.y), W(l.left) || (l.left = parseInt(a.left) + o.x), W(l.right) || (l.right = parseInt(a.right) - o.x), this.setPosition(l), this.fire("dragging", n);
  }, e._onDragEnd = function(n) {
    delete this._startPos, delete this._startPosition, this.fire("dragend", n);
  }, e._getConnectPoints = function() {
    var n = this.getMap(), s = this.getContainerPoint(), o = this.getDOM(), a = parseInt(o.clientWidth), l = parseInt(o.clientHeight), h = [n.containerPointToCoordinate(s.add(a / 2, 0)), n.containerPointToCoordinate(s.add(a, l / 2)), n.containerPointToCoordinate(s.add(a / 2, l)), n.containerPointToCoordinate(s.add(0, l / 2))];
    return h;
  }, t;
}(Wi);
gk.mergeOptions(pk);
var mk = {
  position: {
    top: 156,
    left: 20
  },
  view: null
}, wA = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.buildOn = function() {
    var n = this._getReset();
    return this._reset = n, this._registerDomEvents(), n;
  }, e.onAdd = function() {
    this._view = this.options.view ? this.options.view : this.getMap().getView();
  }, e.setView = function(n) {
    this._view = n;
  }, e._getReset = function() {
    var n = ve("div", "maptalks-reset");
    return n;
  }, e._registerDomEvents = function() {
    Cn(this._reset, "click", this._resetView, this);
  }, e.onRemove = function() {
    delete this._reset, delete this._view;
  }, e._resetView = function() {
    this.getMap().setView(this._view);
  }, t;
}(Wi);
wA.mergeOptions(mk);
xe.mergeOptions({
  resetControl: !1
});
xe.addOnLoadHook(function() {
  this.options.resetControl && (this.resetControl = new wA(this.options.resetControl), this.addControl(this.resetControl));
});
var vk = {
  position: "bottom-left",
  maxWidth: 100,
  metric: !0,
  imperial: !1,
  containerClass: null
}, p_ = "zoomend moving moveend", TA = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.buildOn = function(n) {
    return this._map = n, this._scaleContainer = ve("div", this.options.containerClass), this._addScales(), n.on(p_, this._update, this), this._map._loaded && this._update(), this._scaleContainer;
  }, e.onRemove = function() {
    this.getMap().off(p_, this._update, this);
  }, e._addScales = function() {
    var n = "border: 2px solid #000000;border-top: none;line-height: 1.1;padding: 0px;color: #000000;font-size: 11px;text-align:center;white-space: nowrap;overflow: hidden;-moz-box-sizing: content-box;box-sizing: content-box;background: #fff; background: rgba(255, 255, 255, 0);";
    this.options.metric && (this._mScale = p1("div", this.options.containerClass ? null : n, this._scaleContainer)), this.options.imperial && (this._iScale = p1("div", this.options.containerClass ? null : n, this._scaleContainer));
  }, e._update = function() {
    var n = this._map, s = n.pixelToDistance(this.options.maxWidth, 0);
    this._updateScales(s);
  }, e._updateScales = function(n) {
    this.options.metric && n && this._updateMetric(n), this.options.imperial && n && this._updateImperial(n);
  }, e._updateMetric = function(n) {
    var s = this._getRoundNum(n), o = s < 1e3 ? s + " m" : s / 1e3 + " km";
    this._updateScale(this._mScale, o, s / n);
  }, e._updateImperial = function(n) {
    var s = n * 3.2808399, o, a, l;
    s > 5280 ? (o = s / 5280, a = this._getRoundNum(o), this._updateScale(this._iScale, a + " mile", a / o)) : (l = this._getRoundNum(s), this._updateScale(this._iScale, l + " feet", l / s));
  }, e._updateScale = function(n, s, o) {
    n.style.width = Math.round(this.options.maxWidth * o) + "px", n.innerHTML = s;
  }, e._getRoundNum = function(n) {
    var s = Math.pow(10, (Math.floor(n) + "").length - 1), o = n / s;
    return o = o >= 10 ? 10 : o >= 5 ? 5 : o >= 3 ? 3 : o >= 2 ? 2 : 1, s * o;
  }, t;
}(Wi);
TA.mergeOptions(vk);
xe.mergeOptions({
  scaleControl: !1
});
xe.addOnLoadHook(function() {
  this.options.scaleControl && (this.scaleControl = new TA(this.options.scaleControl), this.addControl(this.scaleControl));
});
var yk = {
  height: 28,
  vertical: !1,
  position: "top-right",
  reverseMenu: !1,
  items: {}
}, _k = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.buildOn = function(n) {
    this._map = n;
    var s = ve("div"), o = ve("ul", "maptalks-toolbar-hx");
    s.appendChild(o), this.options.vertical ? rl(s, "maptalks-toolbar-vertical") : rl(s, "maptalks-toolbar-horizonal");
    var a = this;
    function l(m, v, _, y) {
      var x = a._getItems()[v];
      return function(w) {
        return Jr(w), m({
          target: x,
          index: v,
          childIndex: _,
          dom: y
        });
      };
    }
    var h = this.options.items;
    if (sn(h))
      for (var u = 0, c = h.length; u < c; u++) {
        var f = h[u], d = ve("li");
        if (this.options.height !== 28 && (d.style.lineHeight = this.options.height + "px"), d.style.height = this.options.height + "px", d.style.cursor = "pointer", dE(f.item)) {
          d.style.textAlign = "center";
          var p = pE("div", f.item);
          d.innerHTML = '<div style="margin-top:' + (this.options.height - p.height) / 2 + 'px;">' + f.item + "</div>";
        } else
          d.innerHTML = f.item;
        if (f.click && Cn(d, "click", l(f.click, u, null, d)), sn(f.children)) {
          var g = this._createDropMenu(u);
          d.appendChild(g), d._menu = g, Cn(d, "mouseover", function() {
            this._menu.style.display = "";
          }), Cn(d, "mouseout", function() {
            this._menu.style.display = "none";
          });
        }
        o.appendChild(d);
      }
    return s;
  }, e._createDropMenu = function(n) {
    var s = this;
    function o(w, b, T) {
      var A = s._getItems()[b].children[T];
      return function(M) {
        return Jr(M), w({
          target: A,
          index: b,
          childIndex: T
        });
      };
    }
    var a = ve("div", "maptalks-dropMenu"), l = this._getItems(), h = l.length, u = ve("ul"), c = l[n].children;
    n === h - 1 && c && (a.style.cssText = "right: 0px;", u.style.cssText = "right: 0px;position: absolute;", this.options.reverseMenu && (u.style.bottom = 0)), a.appendChild(ve("em", "maptalks-ico"));
    for (var f = 0, d = 0, p = c.length; d < p; d++) {
      var g = mv(c[d].item, "12px");
      g.width > f && (f = g.width);
    }
    for (var m = 0, v = c.length; m < v; m++) {
      var _ = c[m], y = ve("li");
      y.innerHTML = '<a href="javascript:;">' + _.item + "</a>", y.style.cursor = "pointer", y.style.width = f + 24 + "px", Cn(y.childNodes[0], "click", o(_.click, n, m)), u.appendChild(y);
    }
    if (this.options.vertical) {
      var x = f < 95 ? 95 : f;
      this.options.reverseMenu ? a.style.right = -(x + 10 * 2 + 2) + "px" : a.style.left = -(x + 10 * 2 + 2) + "px";
    } else this.options.reverseMenu ? a.style.bottom = "28px" : a.style.top = "29px";
    return a.appendChild(u), a.style.display = "none", a;
  }, e._getItems = function() {
    return this.options.items || [];
  }, t;
}(Wi);
_k.mergeOptions(yk);
var xk = {
  position: "top-left",
  zoomLevel: !0,
  seamless: !1
}, AA = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.buildOn = function(n) {
    var s = this.options, o = ve("div", "maptalks-zoom");
    if (s.zoomLevel) {
      var a = ve("span", "maptalks-zoom-zoomlevel"), l = ve("span", "maptalks-zoom-zoomlevel-text");
      a.appendChild(l), o.appendChild(a), this._levelDOM = l;
    }
    var h = ve("div", "maptalks-zoom-slider"), u = ve("a", "maptalks-zoom-zoomin");
    u.href = "javascript:;", h.appendChild(u), this._zoomInButton = u;
    var c = ve("a", "maptalks-zoom-zoomout");
    return c.href = "javascript:;", h.appendChild(c), this._zoomOutButton = c, o.appendChild(h), n.on("_zoomend _zooming _zoomstart _spatialreferencechange", this._update, this), this._update(), this._registerDomEvents(), o;
  }, e.onRemove = function() {
    this.getMap().off("_zoomend _zooming _zoomstart _spatialreferencechange", this._update, this);
  }, e._update = function() {
    this._updateText();
  }, e._updateText = function() {
    if (this._levelDOM) {
      var n = this.getMap(), s = n.getZoom();
      ko(s) || (s = Math.floor(s * 10) / 10), this._levelDOM.innerHTML = s;
    }
  }, e._registerDomEvents = function() {
    this._zoomInButton && Cn(this._zoomInButton, "click", this._onZoomInClick, this), this._zoomOutButton && Cn(this._zoomOutButton, "click", this._onZoomOutClick, this);
  }, e._onZoomInClick = function(n) {
    ks(n), this.getMap().zoomIn();
  }, e._onZoomOutClick = function(n) {
    ks(n), this.getMap().zoomOut();
  }, t;
}(Wi);
AA.mergeOptions(xk);
xe.mergeOptions({
  zoomControl: !1
});
xe.addOnLoadHook(function() {
  this.options.zoomControl && (this.zoomControl = new AA(this.options.zoomControl), this.addControl(this.zoomControl));
});
var eo = function() {
  function i(t, e, r, n) {
    Array.isArray(t) ? (this.scale = {
      x: t[0],
      y: t[1]
    }, this.origin = {
      x: t[2],
      y: t[3]
    }) : (this.scale = {
      x: t,
      y: e
    }, this.origin = {
      x: r,
      y: n
    });
  }
  return i.getDefault = function(e) {
    var r = e.code.toLowerCase();
    return r === "baidu" ? "baidu" : r === "EPSG:4326".toLowerCase() || r === "EPSG:4490".toLowerCase() ? "tms-global-geodetic" : r === "identity" ? [1, -1, 0, 0] : "web-mercator";
  }, i;
}(), lc = 6378137 * Math.PI;
jt(eo, {
  "web-mercator": new eo([1, -1, -lc, lc]),
  "tms-global-mercator": new eo([1, 1, -lc, -lc]),
  "tms-global-geodetic": new eo([1, 1, -180, -90]),
  baidu: new eo([1, 1, 0, 0])
});
var g_ = function() {
  function i(e, r, n, s) {
    this.map = e, this.tileSize = s, this.fullExtent = n, this.prepareTileInfo(r, n), this._xScale = n.right >= n.left ? 1 : -1, this._yScale = n.top >= n.bottom ? 1 : -1;
    var o = e.getGLRes();
    this._pointOrigin = e._prjToPointAtRes(new Y(this.tileSystem.origin), o), this._glRes = o;
  }
  var t = i.prototype;
  return t.prepareTileInfo = function(r, n) {
    if (De(r) ? r = eo[r.toLowerCase()] : Array.isArray(r) && (r = new eo(r)), !r)
      throw new Error("Invalid TileSystem");
    this.tileSystem = r;
    var s = n.right > n.left ? 1 : -1, o = n.top > n.bottom ? -1 : 1, a = r.origin.x, l = r.origin.y;
    this.transformation = new AT([s, o, a, l]);
  }, t._getTileNum = function(r, n) {
    var s = this.tileSystem, o = this.tileSize, a = 1e-7, l = Math.floor(a * s.scale.x + r.x / (o.width * n)), h = Math.ceil(a * s.scale.y + r.y / (o.height * n));
    return {
      x: s.scale.x * l,
      y: s.scale.y * h
    };
  }, t.getTileIndex = function(r, n, s) {
    var o = this.tileSystem, a = this.transformation.transform(r, 1), l = this._getTileNum(a, n);
    return o.scale.x < 0 && (l.x -= 1), o.scale.y > 0 && (l.y -= 1), this.getNeighorTileIndex(l.x, l.y, 0, 0, n, s);
  }, t.getNeighorTileIndex = function(r, n, s, o, a, l) {
    var h = this.tileSystem, u = r + h.scale.x * s, c = n - h.scale.y * o, f = !1, d = u, p = c, g = this._getTileFullIndex(a);
    return l && ((l === !0 || l === "x") && (g.xmax === g.xmin ? u = g.xmin : u < g.xmin ? (u = g.xmax - (g.xmin - u) % (g.xmax - g.xmin), u === g.xmax && (u = g.xmin)) : u >= g.xmax && (u = g.xmin + (u - g.xmin) % (g.xmax - g.xmin))), (l === !0 || l === "y") && (g.ymax === g.ymin ? c = g.ymin : c >= g.ymax ? c = g.ymin + (c - g.ymin) % (g.ymax - g.ymin) : c < g.ymin && (c = g.ymax - (g.ymin - c) % (g.ymax - g.ymin), c === g.ymax && (c = g.ymin)))), (u < g.xmin || u > g.xmax || c > g.ymax || c < g.ymin) && (f = !0), {
      x: u,
      y: c,
      idx: d,
      idy: p,
      out: f
    };
  }, t._getTileFullIndex = function(r) {
    if (this._tileFullIndex || (this._tileFullIndex = {}), this._tileFullIndex[r])
      return this._tileFullIndex[r];
    var n = this.fullExtent, s = this.transformation, o = this._getTileNum(s.transform(new lt(n.left, n.top), 1), r), a = this._getTileNum(s.transform(new lt(n.right, n.bottom), 1), r), l = this.tileSystem;
    return l.scale.x < 0 && (o.x -= 1, a.x -= 1), l.scale.y > 0 && (o.y -= 1, a.y -= 1), this._tileFullIndex[r] = new dn(o, a), this._tileFullIndex[r];
  }, t.getTilePrjNW = function(r, n, s, o) {
    var a = this.tileSystem, l = this.tileSize, h = a.origin.y + this._yScale * a.scale.y * (n + (a.scale.y === 1 ? 1 : 0)) * s * l.height, u = a.origin.x + this._xScale * a.scale.x * (r + (a.scale.x === 1 ? 0 : 1)) * s * l.width;
    return o ? (o.set(u, h), o) : new lt(u, h);
  }, t.getTilePointNW = function(r, n, s, o) {
    var a = this._glRes / s, l = this.tileSystem, h = this.tileSize, u = this._pointOrigin.y * a + this._yScale * l.scale.y * (n + (l.scale.y === 1 ? 1 : 0)) * h.height, c = this._pointOrigin.x * a + this._xScale * l.scale.x * (r + (l.scale.x === 1 ? 0 : 1)) * h.width;
    return o ? (o.set(c, u), o) : new Y(c, u);
  }, t.getTilePrjSE = function(r, n, s, o) {
    var a = this.tileSystem, l = this.tileSize, h = a.origin.y + this._yScale * a.scale.y * (n + (a.scale.y === 1 ? 0 : 1)) * s * l.height, u = a.origin.x + this._xScale * a.scale.x * (r + (a.scale.x === 1 ? 1 : 0)) * s * l.width;
    return o ? (o.set(u, h), o) : new lt(u, h);
  }, t.getTilePointSE = function(r, n, s, o) {
    var a = this._glRes / s, l = this.tileSystem, h = this.tileSize, u = this._pointOrigin.y * a + this._yScale * l.scale.y * (n + (l.scale.y === 1 ? 0 : 1)) * h.height, c = this._pointOrigin.x * a + this._xScale * l.scale.x * (r + (l.scale.x === 1 ? 1 : 0)) * h.width;
    return o ? (o.set(c, u), o) : new Y(c, u);
  }, t.getTilePrjExtent = function(r, n, s) {
    var o = this.getTilePrjNW(r, n, s), a = this.getTilePrjSE(r, n, s);
    return new dn(o, a);
  }, i;
}(), bk = 1, Yl = new Y(0, 0), wk = 32, hc = typeof Set < "u", m_ = function() {
  function i() {
    this._table = hc ? /* @__PURE__ */ new Set() : {};
  }
  var t = i.prototype;
  return t.add = function(r) {
    hc ? this._table.add(r) : this._table[r] = !0;
  }, t.has = function(r) {
    return hc ? this._table.has(r) : this._table[r];
  }, t.reset = function() {
    hc ? this._table.clear() : this._table = {};
  }, i;
}(), Tk = {
  urlTemplate: null,
  subdomains: null,
  errorUrl: null,
  repeatWorld: !0,
  background: !0,
  loadingLimitOnInteracting: 3,
  loadingLimit: 0,
  tileRetryCount: 0,
  placeholder: !1,
  crossOrigin: null,
  tileSize: [256, 256],
  offset: [0, 0],
  tileSystem: null,
  fadeAnimation: !tr,
  fadeDuration: 1e3 / 60 * 10,
  debug: !1,
  spatialReference: null,
  maxCacheSize: 256,
  renderer: function() {
    return Ce.webgl ? "gl" : "canvas";
  }(),
  clipByPitch: !0,
  maxAvailableZoom: null,
  cascadeTiles: !0,
  zoomOffset: 0,
  pyramidMode: 1,
  decodeImageInWorker: !1,
  tileLimitPerFrame: 0,
  tileStackStartDepth: 7,
  tileStackDepth: 6,
  awareOfTerrain: !0,
  bufferPixel: 0.5,
  mipmapTexture: !0,
  depthMask: !0,
  currentTilesFirst: !0
}, Ak = /\{ *([\w_]+) *\}/g, Mk = new Y(0, 0), uc = new Y(0, 0), Jl = new Y(0, 0), Gs = new Y(0, 0), Sk = new Y(0, 0), Ck = new Y(0, 0), br = [[0, 0, 0], [0, 0, 0]], Xp = [0, 0, 0], qp = [0, 0, 0], Yp = [], Pn = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  t.fromJSON = function(n) {
    return !n || n.type !== "TileLayer" ? null : new t(n.id, n.options);
  };
  var e = t.prototype;
  return e.forceReload = function() {
    return this.fire("forcereloadstart"), this.clear(), this.load(), this.fire("forcereloadend"), this;
  }, e.getTileSize = function() {
    if (this._tileSize)
      return this._tileSize;
    var n = this.options.tileSize;
    return Ut(n) && (n = [n, n]), this._tileSize = new zn(n), this._tileSize;
  }, e.getTiles = function(n, s) {
    return this._coordCache = {}, this._isPyramidMode() ? this._getPyramidTiles(n, s) : this._getCascadeTiles(n, s);
  }, e._isPyramidMode = function() {
    var n = this.getSpatialReference();
    return !this._disablePyramid && !this._hasOwnSR && this.options.pyramidMode && n && n.isPyramid();
  }, e._getTileFullExtent = function() {
    if (this._tileFullExtent)
      return this._tileFullExtent;
    var n = this.getSpatialReference(), s = n.getFullExtent(), o = n.getResolution(0), a = this.getMap();
    return this._tileFullExtent = s.convertTo(function(l) {
      return a._prjToPointAtRes(l, o, Yl);
    }), this._tileFullExtent;
  }, e._getRootNodes = function(n) {
    var s = this.getMap();
    if (this._rootNodes) {
      var o = this._rootNodes, a = o.tiles, l = o.mapWidth, h = o.mapHeight;
      if (s.width !== l || s.height !== h) {
        for (var u = this._getRootError(), c = 0; c < a.length; c++)
          a[c].error = u;
        this._rootNodes.mapWidth = s.width, this._rootNodes.mapHeight = s.height;
      }
      for (var f = 0; f < a.length; f++)
        a[f].offset[0] = n[0], a[f].offset[1] = n[1];
      return this._rootNodes;
    }
    var d = this.getSpatialReference(), p = d.getResolution(0), g = this._getTileConfig(), m = d.getFullExtent(), v = g.tileSystem, _ = v.origin, y = v.scale, x = g.getTilePrjExtent(0, 0, p), w = x.getWidth(), b = x.getHeight(), T = 1e-5, A = Math.abs((_.x - m.left) / w);
    A = Math.ceil(A - T);
    var M = Math.abs((m.right - _.x) / w);
    M = Math.ceil(M - T);
    var S = Math.ceil(Math.abs(m.top - _.y) / b);
    S = Math.ceil(S - T);
    var P = Math.ceil(Math.abs(m.bottom - _.y) / b);
    if (P = Math.ceil(P - T), (M + A) * (P + S) > wk)
      return {
        status: 0,
        error: "Too many root nodes"
      };
    for (var C = this._getRootError(), k = [], O = 0, R = -A; R < M; R++)
      for (var I = -S; I < P; I++) {
        var D = y.y < 0 ? I : -(I + 1);
        k.push(this.createTileNode(R, D, O, R, D, p, C));
      }
    return this._rootNodes = {
      status: 1,
      tiles: k,
      mapWidth: s.width,
      mapHeight: s.height
    }, this._getRootNodes(n);
  }, e.createTileNode = function(n, s, o, a, l, h, u, c, f, d) {
    var p = this.getMap(), g = this.options.zoomOffset;
    if (!f) {
      var m = this._getTileConfig();
      f = m.getTilePrjExtent(n, s, h).convertTo(function(_) {
        return p._prjToPointAtRes(_, h, Yl);
      });
    }
    var v = this._getTileOffset(o);
    return {
      parent: c,
      layer: this.getId(),
      x: n,
      y: s,
      z: o,
      idx: a,
      idy: l,
      res: h,
      extent2d: f,
      id: d || this._getTileId(n, s, o),
      url: this.getTileUrl(n, s, o + g),
      offset: v,
      error: u,
      children: []
    };
  }, e._getRootError = function() {
    var n = this.getMap(), s = Vn(n.getFov()), o = n.width / n.height, a = n.cameraPosition[2], l = a * Math.tan(0.5 * s), h = l * o, u = Math.sqrt(a * a + l * l + h * h), c = n._getFovZ(0), f = c * (u / a), d = this.getSpatialReference(), p = d.getResolution(0);
    return f * p / n.getResolution(0);
  }, e._getPyramidTiles = function(n, s) {
    var o = this.getMap();
    isNaN(+n) && (n = this._getTileZoom(o.getZoom()));
    var a = this.getSpatialReference(), l = Math.min(n, this.getMaxZoom(), this.getMaxAvailableZoom() || 1 / 0), h = o.projViewMatrix, u = this._getTileFullExtent(), c = this._getTileOffset(0), f;
    if (this.options.repeatWorld) {
      var d = o.getContainerExtent(), p = this._convertToExtent2d(d), g = a.getResolution(0) / o.getResolution();
      if (p.within(u.copy()._scale(g))) {
        var b = this._getRootNodes(c);
        if (b.status !== 1)
          return console.warn(b.error), this._disablePyramid = !0, this.getTiles(n, s);
        f = b.tiles.concat();
      } else {
        var m = o.getPitch(), v = o.options.cascadePitches[1], _ = Math.floor(o._getVisualHeight(v)), y = m <= v ? d : new Se(0, o.height - _, o.width, o.height);
        this._visitedTiles = new m_();
        var x = this._getTiles(0 - this.options.zoomOffset, y, 2, s && s.getRenderer(), !0), w = this._getRootError() * Math.pow(2, this.options.zoomOffset);
        x.tiles.forEach(function(O) {
          O.error = w;
        }), f = x.tiles;
      }
    } else {
      var T = this._getRootNodes(c);
      if (T.status !== 1)
        return console.warn(T.error), this._disablePyramid = !0, this.getTiles(n, s);
      f = T.tiles.concat();
    }
    for (var A = o.getGLRes(), M = {
      0: c
    }, S = new Se(), P = [], C = []; f.length > 0; ) {
      var k = f.pop();
      if (k.z === l) {
        S._combine(k.extent2d), P.push(k);
        continue;
      }
      M[k.z + 1] || (M[k.z + 1] = this._getTileOffset(k.z + 1)), this._splitNode(k, h, f, P, S, l, M[k.z + 1], s && s.getRenderer(), A), this.isParentTile(n, l, k) && C.push(k);
    }
    return C.sort(Ek), {
      tileGrids: [{
        extent: S,
        count: P.length,
        tiles: P,
        parents: C,
        offset: [0, 0],
        zoom: n
      }],
      count: P.length
    };
  }, e.isParentTile = function(n, s, o) {
    var a = Math.max(this.getMinZoom(), n - this.options.tileStackStartDepth), l = Math.min(s, a + this.options.tileStackDepth);
    return o.z >= a && o.z < l;
  }, e._splitNode = function(n, s, o, a, l, h, u, c, f) {
    for (var d = n.z + 1, p = this.getSpatialReference(), g = n.idx, m = n.idy, v = c || this.getRenderer(), _ = !1, y = [], x = p.getResolution(d), w = x / f, b = 0; b < 4; b++) {
      var T = b % 2, A = b >> 1, M = (g << 1) + T, S = (m << 1) + A;
      n.children || (n.children = []);
      var P = n.children[b];
      P || (P = this._getTileId(M, S, d), n.children[b] = P);
      var C = v.isTileCachedOrLoading(P), k = C && C.info;
      k || (this.tileInfoCache || (this.tileInfoCache = new Tv(this.options.maxCacheSize * 4)), k = this.tileInfoCache.get(P), k || (k = this._createChildNode(n, T, A, u, P))), k.error = n.error / 2, k.offset[0] = u[0], k.offset[1] = u[1];
      var O = this._isTileVisible(k, s, w, h, u);
      if (O === 1)
        _ = !0;
      else {
        if (O === -1)
          continue;
        if (O === 0 && d !== h) {
          a.push(n), l._combine(n.extent2d);
          return;
        }
      }
      y.push(k);
    }
    d === h ? _ ? o.push.apply(o, y) : (a.push(n), l._combine(n.extent2d)) : o.push.apply(o, y);
  }, e._createChildNode = function(n, s, o, a, l) {
    var h = n.x, u = n.y, c = n.idx, f = n.idy, d = n.extent2d, p = n.z + 1, g = (h << 1) + s, m = (u << 1) + o, v = (c << 1) + s, _ = (f << 1) + o, y = 2, x = d.getWidth() / 2 * y, w = d.getHeight() / 2 * y, b = d.xmin * y, T = d.ymax * y, A = d.ymin * y, M = this._getTileConfig().tileSystem, S = M.scale.y;
    l = l || this._getTileId(v, _, p);
    var P;
    if (S < 0) {
      var C = b + s * x, k = T - o * w;
      P = new Se(C, k - w, C + x, k);
    } else {
      var O = b + s * x, R = A + o * w;
      P = new Se(O, R, O + x, R + w);
    }
    var I = this.createTileNode(g, m, p, v, _, n.res / 2, n.error / 2, n.id, P, l);
    return this.tileInfoCache.add(l, I), I;
  }, e._isTileVisible = function(n, s, o, a, l) {
    if (n.z === 0)
      return 1;
    if (!this._isTileInFrustum(n, s, o, l))
      return -1;
    var h = this.options.maxError;
    W(h) && (h = bk);
    var u = this._getScreenSpaceError(n, o, a, l);
    return u >= h ? 1 : 0;
  }, e._isTileInFrustum = function(n, s, o, a) {
    if (!this._zScale) {
      var l = this.getMap(), h = l.getGLRes();
      this._zScale = l.altitudeToPoint(100, h) / 100;
    }
    var u = this.getRenderer(), c = n.extent2d, f = c.xmin, d = c.ymin, p = c.xmax, g = c.ymax;
    br[0][0] = (f - a[0]) * o, br[0][1] = (d - a[1]) * o;
    var m = n.minAltitude || u && u.avgMinAltitude || 0;
    br[0][2] = m * this._zScale, br[1][0] = (p - a[0]) * o, br[1][1] = (g - a[1]) * o;
    var v = n.maxAltitude || u && u.avgMaxAltitude || 0;
    return br[1][2] = v * this._zScale, cp(s, br);
  }, e._getScreenSpaceError = function(n, s, o, a) {
    var l = n.error, h = this.getMap(), u = n.extent2d, c = u.xmin, f = u.ymin, d = u.xmax, p = u.ymax;
    Xp[0] = (c - a[0]) * s, Xp[1] = (f - a[1]) * s, qp[0] = (d - a[0]) * s, qp[1] = (p - a[1]) * s;
    var g = Pk(Xp, qp, h.cameraPosition), m = Math.max(Math.abs(g), 1e-7), v = Math.abs(n.z - o), _;
    h.height < 1e3 ? _ = 1 : _ = v <= 1 ? 1 : v <= 2 ? 0.7 : 0.605;
    var y = l * _ / m;
    return y;
  }, e._getCascadeTiles = function(n, s) {
    var o = this.getMap(), a = o.getPitch(), l = s && s.getRenderer(), h = o.getContainerExtent(), u = [], c = 0, f = this.getMinZoom(), d = o.options.cascadePitches[0], p = o.options.cascadePitches[1], g = Math.floor(o._getVisualHeight(p)), m = W(n) ? this._getTileZoom(o.getZoom()) : n;
    if (this._visitedTiles = new m_(), !W(n) || !this.options.cascadeTiles || a <= d || !W(f) && m <= f) {
      var v = a <= p ? h : new Se(0, o.height - g, o.width, o.height), _ = this._getTiles(m, v, 2, l);
      return _ && (c += _.tiles.length, u.push(_)), {
        tileGrids: u,
        count: c
      };
    }
    var y = Math.floor(o._getVisualHeight(d)), x = new Se(0, o.height - y, o.width, o.height), w = this._getTiles(m, x, 0, l);
    c += w ? w.tiles.length : 0, u.push(w);
    var b = x.ymin, T = o.getSpatialReference().getZoomDirection(), A = T, M;
    if (a > p) {
      m - A <= f && (A = 0);
      var S = new Se(0, o.height - g, o.width, b);
      M = this._getTiles(m - A, S, 1, l), c += M ? M.tiles.length : 0, b = S.ymin, A += 4 * T, u.push(M);
    }
    var P;
    if (m - A >= f) {
      var C = new Se(0, h.ymin, o.width, b);
      P = this._getTiles(m - A, C, 2, l), c += P ? P.tiles.length : 0, u.push(P);
    }
    return M && P && (u[1] = P, u[2] = M), {
      tileGrids: u,
      count: c
    };
  }, e.getTileUrl = function(n, s, o) {
    var a = this.options.urlTemplate, l = "";
    if (this.options.subdomains) {
      var h = this.options.subdomains;
      if (sn(h)) {
        var u = h.length, c = (n + s) % u;
        c < 0 && (c = 0), l = h[c];
      }
    }
    if (Be(a))
      return a(n, s, o, l);
    var f = {
      x: n,
      y: s,
      z: o,
      s: l
    };
    return this.options.token && (f.token = this.options.token), this.options.customTags && jt(f, this.options.customTags), a.replace(Ak, function(d, p) {
      var g = f[p];
      if (g === void 0)
        throw new Error("No value provided for variable " + d);
      return typeof g == "function" && (g = g(f)), g;
    });
  }, e.clear = function() {
    return this._renderer && this._renderer.clear(), this.tileInfoCache && this.tileInfoCache.reset(), this.fire("clear"), this;
  }, e.toJSON = function() {
    var n = {
      type: this.getJSONType(),
      id: this.getId(),
      options: this.config()
    };
    return n;
  }, e.getSpatialReference = function() {
    var n = this.getMap();
    if (n && (!this.options.spatialReference || Ci.equals(this.options.spatialReference, n.options.spatialReference)))
      return n.getSpatialReference();
    if (this._sr)
      return this._sr;
    var s = this.options.spatialReference;
    if (De(s) && (s = Ci.getPreset(s), !s))
      throw new Error("Unsupported spatial reference: " + this.options.spatialReference + ", possible values: " + Ci.getAllPresets().join());
    return this._sr = new Ci(s), this._srMinZoom = this._sr.getMinZoom(), this._srMaxZoom = this._sr.getMaxZoom(), this._hasOwnSR = this._sr.toJSON().projection !== n.getSpatialReference().toJSON().projection, this._sr;
  }, e.getMinZoom = function() {
    var n = this.options.minZoom || 0, s = this.getSpatialReference();
    return s !== this.getMap().getSpatialReference() ? Math.max(n, this._srMinZoom) : n;
  }, e.getMaxZoom = function() {
    var n = this.getSpatialReference();
    return n !== this.getMap().getSpatialReference() ? Math.min(i.prototype.getMaxZoom.call(this), this._srMaxZoom) : i.prototype.getMaxZoom.call(this);
  }, e._getTileZoom = function(n) {
    if (!this._hasOwnSR) {
      var s = this.getMap().getResolution(n), o = this.getSpatialReference().getResolution(n), a = Math.log(o / s) * Math.LOG2E;
      n += a;
    }
    var l = this.getMaxAvailableZoom();
    return !W(l) && n > l && (n = l), ko(n) || (n = Math.round(n)), n = Math.max(0, n), n;
  }, e.getMaxAvailableZoom = function() {
    var n = this.getSpatialReference();
    return this.options.maxAvailableZoom || n && n.getMaxZoom();
  }, e._getTiles = function(n, s, o, a, l) {
    var h = this.getMap(), u = n, c = h.projViewMatrix, f = h.getResolution(n) / h.getResolution(n - 1) === 0.5;
    o < 2 && (o === 0 && f && (u -= 1), c = o === 0 ? h.cascadeFrustumMatrix0 : o === 1 ? h.cascadeFrustumMatrix1 : h.projViewMatrix);
    var d = u + this.options.zoomOffset, p = this._getTileOffset(u), g = p[0] || p[1], m = {
      zoom: u,
      extent: null,
      offset: p,
      tiles: []
    };
    if (d < 0 || !h || !this.isVisible() || !h.width || !h.height)
      return m;
    if (!l) {
      var v = this.getMinZoom(), _ = this.getMaxZoom();
      if (!W(v) && u < v || !W(_) && u > _)
        return m;
    }
    var y = this._getTileConfig();
    if (!y)
      return m;
    var x = {
      zoom: p
    }, w = this.getSpatialReference(), b = w.getResolution(u), T;
    this._hasOwnSR ? T = h.getGLScale(u) : T = b / h.getGLRes();
    var A = !this._hasOwnSR && this.options.repeatWorld, M = this._convertToExtent2d(s), S = this._getMask2DExtent();
    if (S) {
      var P = S.intersection(M);
      if (!P)
        return m;
      s = P.convertTo(function(an) {
        return h._pointToContainerPoint(an, void 0, 0, Yl);
      });
    }
    var C = h._containerPointToPrj(s.getCenter(), Mk), k = h._prjToPoint(C, u, uc), O;
    g ? O = this._project(h._pointToPrj(k._add(p), u, uc), uc) : O = this._project(C, uc);
    var R = h.getGLScale() / h.getGLScale(u);
    Jl.x = M.xmin * R, Jl.y = M.ymax * R, Gs.x = M.xmax * R, Gs.y = M.ymin * R;
    for (var I = this._project(h._pointToPrj(Jl._add(p), u, Jl), Jl), D = this._project(h._pointToPrj(Gs._add(p), u, Gs), Gs), z = y.getTileIndex(O, b, A), H = y.getTileIndex(I, b, A), G = y.getTileIndex(D, b, A), $ = Math.ceil(Math.abs(z.idy - H.idy)), K = Math.ceil(Math.abs(z.idx - H.idx)), dt = Math.ceil(Math.abs(z.idy - G.idy)), it = Math.ceil(Math.abs(z.idx - G.idx)), st = ($ + dt + 1) * (K + it + 1), pt = this.getTileSize(), Ht = this.getRenderer() || a, Rt = this._getTileConfig().tileSystem.scale, Tt = [], $t = new Se(), Wt = new Y(0, 0), re = -$; re <= dt; re++)
      for (var ie = -K, Kt = -1 / 0, fe = !1; ie >= Kt && ie <= it; ) {
        var Xt = y.getNeighorTileIndex(z.idx, z.idy, ie, re, b, A);
        Kt === -1 / 0 ? ie++ : ie--;
        var Re = this._getTileId(Xt.idx, Xt.idy, u);
        if (!(Xt.out || this._visitedTiles && this._visitedTiles.has(Re))) {
          var Oe = Ht && Ht.isTileCachedOrLoading(Re);
          Oe && (Oe = Oe.info);
          var oe = void 0;
          if (Oe) {
            var nr = Oe, Ke = nr.extent2d;
            Wt.set(Ke.xmin, Ke.ymax), oe = Wt;
          } else if (!this._hasOwnSR)
            oe = y.getTilePointNW(Xt.x, Xt.y, b);
          else {
            var Ye = y.getTilePrjNW(Xt.x, Xt.y, b);
            oe = h._prjToPoint(this._unproject(Ye, Gs), u);
          }
          var We = void 0, bn = void 0;
          if (!this._hasOwnSR)
            We = pt.width, bn = pt.height;
          else {
            var wn = void 0;
            if (!this._hasOwnSR)
              wn = y.getTilePointSE(Xt.x, Xt.y, b);
            else {
              var On = y.getTilePrjSE(Xt.x, Xt.y, b);
              wn = h._prjToPoint(this._unproject(On, Gs), u, Gs);
            }
            We = Math.ceil(Math.abs(wn.x - oe.x)), bn = Math.ceil(Math.abs(wn.y - oe.y));
          }
          var $e = Rt.x * (Xt.idx - Xt.x) * We, be = Rt.y * (Xt.idy - Xt.y) * bn;
          !Oe && ($e || be) && oe._add($e, be);
          var Ee = Oe && Oe.extent2d || new Se(oe.x, oe.y - bn, oe.x + We, oe.y);
          if (st <= 4 || fe || this._isTileInExtent(c, Ee, p, T)) {
            var Ze = this._hasOwnSR ? h._getResolution(u) : b;
            this._visitedTiles && o === 0 && this._visitedTiles.add(Re), f && o === 0 ? (this._splitTiles(c, Tt, Ht, Xt, u + 1, Ze, Ee, $e, be, x), $t._combine(Ee)) : (Oe ? (Oe.offset[0] = p[0], Oe.offset[1] = p[1]) : Oe = this.createTileNode(Xt.x, Xt.y, u, Xt.idx, Xt.idy, Ze, 0, null, Ee, Re), Tt.push(Oe), $t._combine(Ee)), Kt === -1 / 0 ? (Kt = ie, ie = it) : fe || (fe = !0);
          }
        }
      }
    if (Tt.length) {
      var yn = h._containerPointToPoint(s.getCenter(), u, Yl)._add(p), Cr = new Y(0, 0), vr = new Y(0, 0);
      Tt.sort(function(an, Ve) {
        return Cr.set((an.extent2d.xmin + an.extent2d.xmax) / 2, (an.extent2d.ymin + an.extent2d.ymax) / 2), vr.set((Ve.extent2d.xmin + Ve.extent2d.xmax) / 2, (Ve.extent2d.ymin + Ve.extent2d.ymax) / 2), Cr.distanceTo(yn) - vr.distanceTo(yn);
      });
    }
    return {
      offset: p,
      zoom: n,
      extent: $t,
      tiles: Tt
    };
  }, e._convertToExtent2d = function(n) {
    var s = this, o = this.getMap();
    return n.convertTo(function(a) {
      var l;
      if (a.y > 0 && a.y < o.height) {
        var h = (a.x === 0 ? 0 : 1) + a.y;
        s._coordCache[h] || (s._coordCache[h] = o._containerPointToPoint(a)), l = s._coordCache[h];
      }
      return l = o._containerPointToPoint(a, void 0, Yl), l;
    });
  }, e._splitTiles = function(n, s, o, a, l, h, u, c, f, d) {
    var p = this._getTileConfig().tileSystem.scale.y, g = this.getMap().getGLScale(l), m = Sk.set(u.xmin * 2, p < 0 ? u.ymax * 2 : u.ymin * 2), v = u.getWidth(), _ = u.getHeight(), y = a.idx * 2, x = a.idy * 2, w = a.x * 2, b = a.y * 2, T = this._checkAndAddTile(n, o, y, x, w, b, l, h, 0, 0, v, _, m, g, d);
    T && s.push(T), T = this._checkAndAddTile(n, o, y, x, w, b, l, h, 0, 1, v, _, m, g, d), T && s.push(T), T = this._checkAndAddTile(n, o, y, x, w, b, l, h, 1, 0, v, _, m, g, d), T && s.push(T), T = this._checkAndAddTile(n, o, y, x, w, b, l, h, 1, 1, v, _, m, g, d), T && s.push(T);
  }, e._checkAndAddTile = function(n, s, o, a, l, h, u, c, f, d, p, g, m, v, _) {
    var y = this._getTileId(o + f, a + d, u);
    if (this._visitedTiles && this._visitedTiles.has(y))
      return null;
    var x = _[u];
    x || (x = _[u] = this._getTileOffset(u));
    var w = this._getTileConfig().tileSystem.scale.y, b = new Se(m.x + f * p, m.y + w * d * g, m.x + (f + 1) * p, m.y + w * (d + 1) * g);
    if (!this._isSplittedTileInExtent(n, b, x, v))
      return null;
    var T = c / 2, A = s && s.isTileCachedOrLoading(y);
    return A ? A = A.info : A = this.createTileNode(l + f, h + d, u, o + f, o + h, T, 0, null, b, y), A;
  }, e._getTileOffset = function() {
    var n = this.options.offset;
    if (Be(n)) {
      for (var s, o = arguments.length, a = new Array(o), l = 0; l < o; l++)
        a[l] = arguments[l];
      n = (s = n).call.apply(s, [this].concat(a));
    }
    return Ut(n) && (n = [n, n]), n || [0, 0];
  }, e.getTileId = function(n, s, o, a) {
    return this._getTileId(n, s, o, a);
  }, e._getTileId = function(n, s, o, a) {
    return (a || this.getId()) + "_" + n + "_" + s + "_" + o;
  }, e._project = function(n, s) {
    if (this._hasOwnSR) {
      var o = this.getMap(), a = o.getProjection(), l = this.getSpatialReference().getProjection();
      return l.project(a.unproject(n, s), s);
    } else
      return n;
  }, e._unproject = function(n, s) {
    if (this._hasOwnSR) {
      var o = this.getMap(), a = this.getSpatialReference(), l = o.getProjection(), h = a.getProjection();
      return l.project(h.unproject(n, s), s);
    } else
      return n;
  }, e._initTileConfig = function() {
    var n = this.getMap(), s = this.getTileSize(), o = this.getSpatialReference(), a = o.getProjection(), l = o.getFullExtent();
    this._defaultTileConfig = new g_(n, eo.getDefault(a), l, s), this.options.hasOwnProperty("tileSystem") && (this._tileConfig = new g_(n, this.options.tileSystem, l, s)), delete this._rootNodes, delete this._tileFullExtent, delete this._disablePyramid;
  }, e._getTileConfig = function() {
    return this._defaultTileConfig || this._initTileConfig(), this._tileConfig || this._defaultTileConfig;
  }, e._bindMap = function(n) {
    var s = n.getBaseLayer();
    return s === this && (s.options.hasOwnProperty("forceRenderOnMoving") || this.config({
      forceRenderOnMoving: !0
    })), this._onSpatialReferenceChange(), i.prototype._bindMap.apply(this, arguments);
  }, e._isTileInExtent = function(n, s, o, a) {
    var l = this.getMap(), h;
    if (n !== l.projViewMatrix) {
      var u = s.getCenter(Ck)._sub(o[0], o[1])._multi(a);
      Lr(Yp, u.x, u.y, 0);
      var c = SO(Yp, Yp, l.projViewMatrix);
      h = c[1] < 0 ? l.projViewMatrix : n;
    } else
      h = l.projViewMatrix;
    return br[0][0] = (s.xmin - o[0]) * a, br[0][1] = (s.ymin - o[1]) * a, br[1][0] = (s.xmax - o[0]) * a, br[1][1] = (s.ymax - o[1]) * a, cp(h, br);
  }, e._isSplittedTileInExtent = function(n, s, o, a) {
    var l = this.getMap();
    return br[0][0] = (s.xmin - o[0]) * a, br[0][1] = (s.ymin - o[1]) * a, br[1][0] = (s.xmax - o[0]) * a, br[1][1] = (s.ymax - o[1]) * a, cp(l.projViewMatrix, br);
  }, e.getEvents = function() {
    return {
      spatialreferencechange: this._onSpatialReferenceChange
    };
  }, e._onSpatialReferenceChange = function() {
    delete this._tileConfig, delete this._defaultTileConfig, delete this._sr, delete this._srMinZoom, delete this._hasOwnSR, delete this._rootNodes, this.tileInfoCache && this.tileInfoCache.reset();
    var n = this.getRenderer();
    n && n.clear();
  }, e.getPolygonOffsetCount = function() {
    return 2;
  }, e.getPolygonOffset = function() {
    return this._polygonOffset || 0;
  }, e.setPolygonOffset = function(n) {
    return this._polygonOffset = n, this;
  }, t;
}(gr);
Pn.registerJSONType("TileLayer");
Pn.mergeOptions(Tk);
function Pk(i, t, e) {
  var r = Math.max(i[0] - e[0], 0, e[0] - t[0]), n = Math.max(i[1] - e[1], 0, e[1] - t[1]), s = Math.max(i[2] - e[2], 0, e[2] - t[2]);
  return Math.sqrt(r * r + n * n + s * s);
}
function Ek(i, t) {
  return i.z - t.z;
}
var Ok = {
  maxCacheSize: 1024
}, kk = new zn(256, 256), fa = "show hide remove setzindex forcereloadstart";
function v_(i) {
  return Array.isArray(i) || (i = [i]), i;
}
var MA = function(i) {
  Ot(t, i), t.fromJSON = function(n) {
    if (!n || n.type !== "GroupTileLayer")
      return null;
    var s = n.layers.map(function(o) {
      return gr.fromJSON(o);
    });
    return new t(n.id, s, n.options);
  };
  function t(r, n, s) {
    var o;
    return o = i.call(this, r, s) || this, o.layers = n || [], o._checkChildren(), o.layerMap = {}, o._groupChildren = [], o;
  }
  var e = t.prototype;
  return e.getLayers = function() {
    return this.layers;
  }, e.addLayer = function(n) {
    var s = this;
    n === void 0 && (n = []), n = v_(n);
    var o = this.layers.length;
    return n.forEach(function(a) {
      a instanceof Pn && s.layers.indexOf(a) === -1 && !s.layerMap[a.getId()] && s.layers.push(a);
    }), o !== this.layers.length && (this._sortLayers(), this._refresh(), this._renderLayers()), this;
  }, e.removeLayer = function(n) {
    var s = this;
    n === void 0 && (n = []), n = v_(n);
    var o = this.layers.length;
    return n.forEach(function(a) {
      if (a instanceof Pn || (a = s.layerMap[a]), a instanceof Pn) {
        var l = s.layers.indexOf(a);
        l >= 0 && (s.layers.splice(l, 1), a._doRemove(), a.off(fa, s._onLayerShowHide, s));
      }
    }), o !== this.layers.length && (this._refresh(), this._renderLayers()), this;
  }, e.clearLayers = function() {
    var n = this;
    return this.layers.forEach(function(s) {
      s._doRemove(), s.off(fa, n._onLayerShowHide, n);
    }), this.layers = [], this._refresh(), this._renderLayers(), this;
  }, e.toJSON = function() {
    var n = {
      type: this.getJSONType(),
      id: this.getId(),
      layers: this.layers.map(function(s) {
        return s.toJSON();
      }),
      options: this.config()
    };
    return n;
  }, e.getTileSize = function(n) {
    var s = this.getLayer(n);
    return s ? s.getTileSize() : kk;
  }, e.getTiles = function(n, s) {
    for (var o = this.layers, a = [], l = 0, h = 0, u = o.length; h < u; h++) {
      var c = o[h];
      if (!(!c || !c.options.visible || !c.isVisible() || !c.getMap())) {
        var f = c.getTiles(n, s || this);
        !f || f.count === 0 || (l += f.count, Ui(a, f.tileGrids));
      }
    }
    return {
      count: l,
      tileGrids: a
    };
  }, e.onAdd = function() {
    this._sortLayers(), this._refresh(), i.prototype.onAdd.call(this);
  }, e.onRemove = function() {
    var n = this;
    this.layers.forEach(function(s) {
      s._doRemove(), s.off(fa, n._onLayerShowHide, n);
    }), this.layerMap = {}, this._groupChildren = [], i.prototype.onRemove.call(this);
  }, e.getLayer = function(n) {
    return this.getChildLayer(n);
  }, e.getChildLayer = function(n) {
    var s = this.layerMap[n];
    if (s)
      return s;
    for (var o = 0; o < this._groupChildren.length; o++) {
      var a = this._groupChildren[o].getChildLayer(n);
      if (a)
        return a;
    }
    return null;
  }, e._removeChildTileCache = function(n) {
    if (!n)
      return this;
    var s = this.getRenderer();
    if (!s)
      return this;
    var o, a = n.getId(), l = function() {
      return o && o.info && o.info.layer === a;
    };
    if (s.tileCache) {
      var h = s.tileCache.keys();
      h.forEach(function(p) {
        o = s.tileCache.get(p), l() && s.tileCache.remove(p);
      });
    }
    var u = s.tilesInView || {};
    for (var c in u)
      o = u[c], l() && delete u[c];
    var f = s.tilesLoading || {};
    for (var d in f)
      o = f[d], l() && s.abortTileLoading(o.image, o.info);
    return this;
  }, e._onLayerShowHide = function(n) {
    var s = n || {}, o = s.type, a = s.target;
    return o === "remove" && a ? (this.layers.splice(this.layers.indexOf(a), 1), a._doRemove(), a.off(fa, this._onLayerShowHide, this), this._refresh()) : o === "setzindex" ? this._sortLayers() : o === "forcereloadstart" && this._removeChildTileCache(a), this._renderLayers(), this;
  }, e._renderLayers = function() {
    var n = this.getRenderer();
    return n && n.setToRedraw(), this;
  }, e._refresh = function() {
    var n = this, s = this.getMap();
    return this._groupChildren = [], this.layerMap = {}, this.layers.forEach(function(o) {
      n.layerMap[o.getId()] = o, o.getChildLayer && n._groupChildren.push(o), o.getMap() || o._bindMap(s), o.off(fa, n._onLayerShowHide, n), o.on(fa, n._onLayerShowHide, n);
    }), this;
  }, e.isVisible = function() {
    if (!i.prototype.isVisible.call(this))
      return !1;
    for (var n = this.layers, s = 0, o = n.length; s < o; s++)
      if (n[s].isVisible())
        return !0;
    return !1;
  }, e._checkChildren = function() {
    var n = this, s = {};
    this.layers.forEach(function(o) {
      var a = o.getId();
      if (s[a])
        throw new Error("Duplicate child layer id (" + a + ") in the GroupTileLayer (" + n.getId() + ")");
      s[a] = 1;
    });
  }, e._sortLayers = function() {
    this.layers.sort(function(n, s) {
      return n.options.zIndex - s.options.zIndex;
    });
  }, t;
}(Pn);
MA.registerJSONType("GroupTileLayer");
MA.mergeOptions(Ok);
var SA = {
  crs: null,
  uppercase: !1,
  detectRetina: !1
}, Rk = {
  service: "WMS",
  request: "GetMap",
  layers: "",
  styles: "",
  format: "image/jpeg",
  transparent: !1,
  version: "1.1.1"
}, Jp, Hv = function(i) {
  Ot(t, i);
  function t(r, n) {
    var s;
    return s = i.call(this, r) || this, Jp || (Jp = jt({}, s.options)), s.wmsParams = jt({}, Rk), s.setOptions(n), s.setZIndex(n.zIndex), Ce.proxy || s._optionsHook(n), s;
  }
  var e = t.prototype;
  return e._optionsHook = function(n) {
    n === void 0 && (n = {});
    for (var s in n)
      s === "tileSize" && (this._tileSize = null), s in Jp || (this.wmsParams[s] = n[s]);
    var o = this.getTileSize();
    return this.wmsParams.width = o.width, this.wmsParams.height = o.height, this._wmsVersion = parseFloat(this.wmsParams.version), this;
  }, e.onAdd = function() {
    var n = this.getMap().getDevicePixelRatio(), s = SA.detectRetina ? n : 1;
    this.wmsParams.width *= s, this.wmsParams.height *= s;
    var o = this.options.crs || this.getMap().getProjection().code, a = this._wmsVersion >= 1.3 ? "crs" : "srs";
    this.wmsParams[a] = o, i.prototype.onAdd.call(this);
  }, e.getTileUrl = function(n, s, o) {
    var a = this.getSpatialReference().getResolution(o), l = this._getTileConfig(), h = l.getTilePrjExtent(n, s, a), u = h.getMax(), c = h.getMin(), f = (this._wmsVersion >= 1.3 && (this.wmsParams.crs === "EPSG:4326" || this.wmsParams.crs === "EPSG:4490") ? [c.y, c.x, u.y, u.x] : [c.x, c.y, u.x, u.y]).join(","), d = i.prototype.getTileUrl.call(this, n, s, o);
    return d + Ik(this.wmsParams, d, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + f;
  }, e.toJSON = function() {
    return {
      type: "WMSTileLayer",
      id: this.getId(),
      options: this.config()
    };
  }, t.fromJSON = function(n) {
    return !n || n.type !== "WMSTileLayer" ? null : new t(n.id, n.options);
  }, t;
}(Pn);
Hv.registerJSONType("WMSTileLayer");
Hv.mergeOptions(SA);
function Ik(i, t, e) {
  var r = [];
  for (var n in i)
    r.push(encodeURIComponent(e ? n.toUpperCase() : n) + "=" + encodeURIComponent(i[n]));
  return (!t || t.indexOf("?") === -1 ? "?" : "&") + r.join("&");
}
var Bv = function(i) {
  Ot(t, i);
  function t(r, n) {
    var s;
    return s = i.call(this, r, n) || this, s.options.hasOwnProperty("forceRenderOnMoving") || (s.options.forceRenderOnMoving = !1), s;
  }
  var e = t.prototype;
  return e.drawTile = function() {
  }, e.toJSON = function() {
    return {
      type: "CanvasTileLayer",
      id: this.getId(),
      options: this.config()
    };
  }, t.fromJSON = function(n) {
    return !n || n.type !== "CanvasTileLayer" ? null : new t(n.id, n.options);
  }, t;
}(Pn);
Bv.registerJSONType("CanvasTileLayer");
function Dk(i, t) {
  for (var e = {
    alpha: !0,
    stencil: !0,
    preserveDrawingBuffer: !0,
    antialias: !1
  }, r = ["webgl", "experimental-webgl"], n = null, s = 0; s < r.length; ++s) {
    try {
      n = i.getContext(r[s], t || e);
    } catch {
    }
    if (n)
      break;
  }
  return n;
}
function y_(i, t, e) {
  var r = i.createShader(t);
  i.shaderSource(r, e), i.compileShader(r);
  var n = i.getShaderParameter(r, i.COMPILE_STATUS);
  if (!n) {
    var s = i.getShaderInfoLog(r);
    throw i.deleteShader(r), new Error("Failed to compile shader: " + s);
  }
  return r;
}
function CA(i, t, e) {
  var r = y_(i, i.VERTEX_SHADER, t), n = y_(i, i.FRAGMENT_SHADER, e);
  if (!r || !n)
    return null;
  var s = i.createProgram();
  return s ? (i.attachShader(s, r), i.attachShader(s, n), i.linkProgram(s), {
    program: s,
    vertexShader: r,
    fragmentShader: n
  }) : null;
}
function PA(i, t, e) {
  if (Array.isArray(e[0])) {
    for (var r = Float32Array.BYTES_PER_ELEMENT, n = 0, s = 0; s < e.length; s++)
      n += e[s][1] || 0;
    for (var o = 0, a = 0; a < e.length; a++) {
      var l = i.getAttribLocation(t, e[a][0]);
      if (l < 0)
        throw new Error("Failed to get the storage location of " + e[a][0]);
      i.vertexAttribPointer(l, e[a][1], i[e[a][2] || "FLOAT"], !1, r * n, r * o), o += e[a][1] || 0, i.enableVertexAttribArray(l);
    }
  } else {
    var h = i.getAttribLocation(t, e[0]);
    i.vertexAttribPointer(h, e[1], i[e[2] || "FLOAT"], !1, 0, 0), i.enableVertexAttribArray(h);
  }
}
var Fk = {
  never: 512,
  "<": 513,
  "=": 514,
  "<=": 515,
  ">": 516,
  "!=": 517,
  ">=": 518,
  always: 519
};
function Lk(i) {
  return Fk[i];
}
var __ = [1, 1, 1, 1], x_ = {
  vertexShader: `
        attribute vec2 a_position;

        attribute vec2 a_texCoord;

        uniform mat4 u_matrix;

        varying vec2 v_texCoord;

        void main() {
            gl_Position = u_matrix * vec4(a_position, 0., 1.);

            v_texCoord = a_texCoord;
        }
    `,
  fragmentShader: `
        precision mediump float;

        uniform sampler2D u_image;

        uniform float u_opacity;
        uniform float u_debug_line;
        uniform vec4 u_base_color;
        uniform float u_alpha_test;
        varying vec2 v_texCoord;

        void main() {
            if (u_debug_line == 1.) {
                gl_FragColor = vec4(0., 1., 0., 1.);
            } else {
                gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;
            }
            gl_FragColor *= u_base_color;
            if (gl_FragColor.a < u_alpha_test) {
                discard;
            }
        }
    `
}, Vs = [0, 0], Kl = [0, 0, 0], zk = new Array(16), Nk = new Y(20, 20), jv = function(t) {
  var e = function(r) {
    Ot(n, r);
    function n() {
      return r.apply(this, arguments) || this;
    }
    var s = n.prototype;
    return s.drawGLImage = function(a, l, h, u, c, f, d, p, g) {
      this.gl.program !== this.program && this.useProgram(this.program);
      var m = this.gl;
      this.loadTexture(a);
      var v = this.canvas.gl && this.canvas.gl.wrap;
      if (v) {
        var _ = this.layer && this.layer.options.opacity;
        W(_) && (_ = 1), d *= _;
      }
      Kl[0] = l || 0, Kl[1] = h || 0, Kl[2] = 0;
      var y = this.layer;
      if (y) {
        var x = y.options.altitude, w = Ut(x);
        if (w || (this._layerAlt = 0), this._layerAltitude !== x && w) {
          var b = y.getMap();
          if (b) {
            var T = b.altitudeToPoint(x, b.getGLRes());
            this._layerAltitude = x, this._layerAlt = T;
          }
        }
      }
      Kl[2] = this._layerAlt || 0;
      var A = zv(zk);
      oA(A, A, Kl), t0(A, A, [f, f, 1]), Th(A, this.getMap().projViewMatrix, A), m.uniformMatrix4fv(this.program.u_matrix, !1, A), m.uniform1f(this.program.u_opacity, d), m.uniform1f(this.program.u_debug_line, 0), m.uniform4fv(this.program.u_base_color, g || __), m.uniform1f(this.program.u_alpha_test, this.layer.options.alphaTest || 0);
      var M = a.glBuffer;
      M && (M.width !== u || M.height !== c) && (this.saveImageBuffer(M), delete a.glBuffer), a.glBuffer ? m.bindBuffer(m.ARRAY_BUFFER, M) : a.glBuffer = this.bufferTileData(0, 0, u, c), Vs[0] = "a_position", Vs[1] = 2, Vs[2] = a.glBuffer.type, this.enableVertexAttrib(Vs), m.bindBuffer(m.ARRAY_BUFFER, this.texBuffer), Vs[0] = "a_texCoord", Vs[1] = 2, Vs[2] = "UNSIGNED_BYTE", this.enableVertexAttrib(Vs), m.drawArrays(m.TRIANGLE_STRIP, 0, 4), p && this.drawDebug(A, 0, 0, u, c, p);
    }, s.drawDebug = function(a, l, h, u, c, f) {
      var d = this.gl;
      d.disable(d.DEPTH_TEST), d.bindBuffer(d.ARRAY_BUFFER, this._debugBuffer), this.enableVertexAttrib(["a_position", 2, "FLOAT"]), d.bufferData(d.ARRAY_BUFFER, new Float32Array([l, h, l + u, h, l + u, h - c, l, h - c, l, h]), d.DYNAMIC_DRAW), d.uniformMatrix4fv(this.program.u_matrix, !1, a), d.uniform1f(this.program.u_opacity, 1), d.uniform1f(this.program.u_debug_line, 1), d.uniform4fv(this.program.u_base_color, __), d.uniform1f(this.program.u_alpha_test, this.layer.options.alphaTest || 0), d.drawArrays(d.LINE_STRIP, 0, 5);
      var p = this._debugInfoCanvas;
      if (!p) {
        var g = this.getMap().getDevicePixelRatio() > 1 ? 2 : 1;
        p = this._debugInfoCanvas = document.createElement("canvas"), p.width = 256 * g, p.height = 32 * g;
        var m = p.getContext("2d");
        m.font = "20px monospace", m.scale(g, g);
      }
      var v = p.getContext("2d");
      v.clearRect(0, 0, p.width, p.height);
      var _ = this.layer.options.debugOutline;
      Ct.fillText(v, f, Nk, _), this.loadTexture(p), d.texImage2D(d.TEXTURE_2D, 0, d.RGBA, d.RGBA, d.UNSIGNED_BYTE, p), u = 256;
      var y = l, x = l + u, w = h - c + 32, b = h - c;
      d.bufferData(d.ARRAY_BUFFER, this.set8(y, w, y, b, x, w, x, b), d.DYNAMIC_DRAW), d.uniform1f(this.program.u_debug_line, 0), d.bindBuffer(d.ARRAY_BUFFER, this.texBuffer), this.enableVertexAttrib(["a_texCoord", 2, "UNSIGNED_BYTE"]), d.drawArrays(d.TRIANGLE_STRIP, 0, 4), d.enable(d.DEPTH_TEST);
    }, s.bufferTileData = function(a, l, h, u, c) {
      var f = a, d = a + h, p = l, g = l - u, m;
      ko(f) && ko(d) && ko(p) && ko(g) ? m = this.set8Int(f, p, f, g, d, p, d, g) : m = this.set8(f, p, f, g, d, p, d, g);
      var v = this.loadImageBuffer(m, c);
      return v.width = h, v.height = u, v.type = m instanceof Int16Array ? "SHORT" : "FLOAT", v;
    }, s.drawTinImage = function(a, l, h, u, c) {
      var f = this.gl;
      this.loadTexture(a), f.uniformMatrix4fv(this.program.u_matrix, !1, this.getMap().projViewMatrix), f.uniform1f(this.program.u_opacity, c), f.bindBuffer(f.ARRAY_BUFFER, this.posBuffer), this.enableVertexAttrib(["a_position", 3]), f.bufferData(f.ARRAY_BUFFER, new Float32Array(l), f.DYNAMIC_DRAW), f.bindBuffer(f.ARRAY_BUFFER, this.texBuffer), this.enableVertexAttrib(["a_texCoord", 2]), f.bufferData(f.ARRAY_BUFFER, new Float32Array(h), f.DYNAMIC_DRAW), f.bufferData(f.ELEMENT_ARRAY_BUFFER, new Uint16Array(u), f.DYNAMIC_DRAW), f.drawElements(f.TRIANGLES, u.length, f.UNSIGNED_SHORT, 0);
    }, s.createCanvas2 = function() {
      this.canvas2 = Ct.createCanvas(this.canvas.width, this.canvas.height);
    }, s.createGLContext = function() {
      this.canvas.gl && this.canvas.gl.wrap ? this.gl = this.canvas.gl.wrap() : this.gl = Dk(this.canvas2 || this.canvas, this.layer.options.glOptions);
      var a = this.gl;
      a.clearColor(0, 0, 0, 0), a.enable(a.DEPTH_TEST), a.enable(a.STENCIL_TEST), a.enable(a.BLEND), a.blendFunc(a.ONE, a.ONE_MINUS_SRC_ALPHA), this.program = this.createProgram(x_.vertexShader, this.layer.options.fragmentShader || x_.fragmentShader), this._debugBuffer = this.createBuffer(), this.useProgram(this.program), this.texBuffer = this.createBuffer(), a.bindBuffer(a.ARRAY_BUFFER, this.texBuffer), this.enableVertexAttrib(["a_texCoord", 2, "UNSIGNED_BYTE"]), a.bufferData(a.ARRAY_BUFFER, new Uint8Array([0, 0, 0, 1, 1, 0, 1, 1]), a.STATIC_DRAW), this.enableSampler("u_image"), a.activeTexture(a.TEXTURE0), a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0);
    }, s.resizeGLCanvas = function() {
      this.gl && this.gl.viewport(0, 0, this.canvas.width, this.canvas.height), this.canvas2 && (this.canvas2.width !== this.canvas.width || this.canvas2.height !== this.canvas.height) && (this.canvas2.width = this.canvas.width, this.canvas2.height = this.canvas.height);
    }, s.clearGLCanvas = function() {
      this.gl && (this.gl.clearStencil(255), this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.STENCIL_BUFFER_BIT)), this.gl.wrap || this.gl.clear(this.gl.DEPTH_BUFFER_BIT);
    }, s.disposeImage = function(a) {
      a && (a.texture && this.saveTexture(a.texture), a.glBuffer && this.saveImageBuffer(a.glBuffer), delete a.texture, delete a.glBuffer);
    }, s._createTexture = function(a) {
      var l = this.gl, h = this.getTexture() || l.createTexture();
      l.bindTexture(l.TEXTURE_2D, h), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MIN_FILTER, l.LINEAR), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MAG_FILTER, l.LINEAR), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_S, l.CLAMP_TO_EDGE), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_T, l.CLAMP_TO_EDGE);
      var u = this.layer.options.mipmapTexture;
      return u && (!Xa(a.width) || !Xa(a.height)) && (a = Hk(a)), l.texImage2D(l.TEXTURE_2D, 0, l.RGBA, l.RGBA, l.UNSIGNED_BYTE, a), u && l.generateMipmap(l.TEXTURE_2D), h;
    }, s.getTexture = function() {
      this._textures || (this._textures = []);
      var a = this._textures;
      return a && a.length > 0 ? a.pop() : null;
    }, s.saveTexture = function(a) {
      this._textures.push(a);
    }, s.loadTexture = function(a) {
      var l = this.getMap(), h = this.gl, u = a.texture;
      u || (u = this._createTexture(a), a.texture = u), h.bindTexture(h.TEXTURE_2D, u);
      var c = this.layer.options.mipmapTexture;
      return c && (l.isMoving() && l.getRenderer().isViewChanged() ? h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, h.LINEAR_MIPMAP_LINEAR) : h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, h.LINEAR)), u;
    }, s.getImageBuffer = function() {
      this._imageBuffers || (this._imageBuffers = []);
      var a = this._imageBuffers;
      return a && a.length > 0 ? a.pop() : null;
    }, s.saveImageBuffer = function(a) {
      this._imageBuffers || (this._imageBuffers = []), this._imageBuffers.push(a);
    }, s.loadImageBuffer = function(a, l) {
      var h = this.gl, u = l || this.createImageBuffer();
      return h.bindBuffer(h.ARRAY_BUFFER, u), h.bufferData(h.ARRAY_BUFFER, a, h.STATIC_DRAW), u;
    }, s.createImageBuffer = function() {
      return this.getImageBuffer() || this.createBuffer();
    }, s.removeGLCanvas = function() {
      var a = this.gl;
      if (a) {
        if (this._debugBuffer && (a.deleteBuffer(this._debugBuffer), delete this._debugBuffer), this._buffers && (this._buffers.forEach(function(u) {
          a.deleteBuffer(u);
        }), delete this._buffers), this._textures && (this._textures.forEach(function(u) {
          return a.deleteTexture(u);
        }), delete this._textures), this._debugInfoCanvas) {
          var l = this._debugInfoCanvas.texture;
          l && a.deleteTexture(l), delete this._debugInfoCanvas.texture, delete this._debugInfoCanvas;
        }
        var h = a.program;
        a.deleteShader(h.fragmentShader), a.deleteShader(h.vertexShader), a.deleteProgram(h), delete this.gl, delete this.canvas2;
      }
    }, s.createBuffer = function() {
      var a = this.gl, l = a.createBuffer();
      if (!l)
        throw new Error("Failed to create the buffer object");
      return this._buffers || (this._buffers = []), this._buffers.push(l), l;
    }, s.enableVertexAttrib = function(a) {
      PA(this.gl, this.gl.program, a);
    }, s.createProgram = function(a, l) {
      for (var h = this.gl, u = CA(h, a, l), c = u.program, f = u.vertexShader, d = u.fragmentShader, p = h.getProgramParameter(c, 35718), g = [], m = 0; m < p; ++m) {
        var v = h.getActiveUniform(c, m);
        g.push(v.name);
      }
      return c.vertexShader = f, c.fragmentShader = d, this._initUniforms(c, g), c;
    }, s.useProgram = function(a) {
      var l = this.gl;
      return l.useProgram(a), l.program = a, this;
    }, s.enableSampler = function(a, l) {
      var h = this.gl, u = this._getUniform(h.program, a);
      return l || (l = 0), h.uniform1i(u, l), u;
    }, s._initUniforms = function(a, l) {
      for (var h = 0; h < l.length; h++) {
        var u = l[h], c = l[h], f = u.indexOf("[");
        f >= 0 && (u = u.substring(0, f), tr || (c = c.substring(0, f))), a[u] = this._getUniform(a, c);
      }
    }, s._getUniform = function(a, l) {
      var h = this.gl, u = h.getUniformLocation(a, l);
      if (!u)
        throw new Error("Failed to get the storage location of " + l);
      return u;
    }, n;
  }(t);
  return jt(e.prototype, {
    set8: function() {
      var r = Ce.ie9 ? null : new Float32Array(8);
      return function(n, s, o, a, l, h, u, c) {
        return r[0] = n, r[1] = s, r[2] = o, r[3] = a, r[4] = l, r[5] = h, r[6] = u, r[7] = c, r;
      };
    }(),
    set8Int: function() {
      var r = Ce.ie9 ? null : new Int16Array(8);
      return function(n, s, o, a, l, h, u, c) {
        return r[0] = n, r[1] = s, r[2] = o, r[3] = a, r[4] = l, r[5] = h, r[6] = u, r[7] = c, r;
      };
    }()
  }), e;
};
function Hk(i) {
  if (Xa(i.width) && Xa(i.height))
    return i;
  var t = i.width, e = i.height;
  Xa(t) || (t = b_(t)), Xa(e) || (e = b_(e));
  var r = document.createElement("canvas");
  r.width = t, r.height = e;
  var n = r.getContext("2d");
  return n.imageSmoothingEnabled = !1, n.drawImage(i, 0, 0, t, e), r;
}
function Xa(i) {
  return (i & i - 1) === 0 && i !== 0;
}
function b_(i) {
  return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
}
var Bk = {
  renderer: Ce.webgl ? "gl" : "canvas",
  crossOrigin: null,
  alphaTest: 0,
  depthMask: !0,
  depthFunc: "<="
}, jk = new Y(0, 0), Gv = function(i) {
  Ot(t, i);
  function t(r, n, s) {
    var o;
    return n && !Array.isArray(n) && !n.url && (s = n, n = null), o = i.call(this, r, s) || this, o._images = n, o;
  }
  var e = t.prototype;
  return e.onAdd = function() {
    this._prepareImages(this._images);
  }, e.setImages = function(n) {
    return this._images = n, this._prepareImages(n), this;
  }, e.getImages = function() {
    return this._images;
  }, e._prepareImages = function(n) {
    n = n || [], Array.isArray(n) || (n = [n]);
    var s = this.getMap(), o = s.getGLRes();
    this._imageData = n.map(function(l) {
      var h = new dn(l.extent);
      return jt({}, l, {
        extent: h,
        extent2d: h.convertTo(function(u) {
          return s.coordToPointAtRes(u, o);
        })
      });
    }), this._images = n;
    var a = this.getRenderer();
    a && a.refreshImages();
  }, t;
}(gr);
Gv.mergeOptions(Bk);
var Gk = [], Vv = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.isDrawable = function() {
    return this.getMap().getPitch() ? (console && console.warn("ImageLayer with canvas renderer can't be pitched, use gl renderer ('renderer' : 'gl') instead."), !1) : !0;
  }, e.checkResources = function() {
    var n = this;
    if (this._imageLoaded)
      return Gk;
    var s = this.layer, o = s._imageData.map(function(h) {
      return [h.url, null, null];
    });
    if (this.resources) {
      var a = [], l = new Bo();
      o.forEach(function(h) {
        if (n.resources.isResourceLoaded(h)) {
          var u = n.resources.getImage(h);
          l.addResource(h, u);
        } else
          a.push(h);
      }), this.resources.forEach(function(h, u) {
        l.isResourceLoaded(h) || n.retireImage(u.image);
      }), this.resources = l, o = a;
    }
    return this._imageLoaded = !0, o;
  }, e.retireImage = function(n) {
    n.close && n.close();
  }, e.refreshImages = function() {
    this._imageLoaded = !1, this.setToRedraw();
  }, e.draw = function(n, s) {
    this.isDrawable() && (this.prepareCanvas(), this._painted = !1, this._drawImages(n, s), this.completeRender());
  }, e._drawImages = function() {
    var n = this.layer._imageData, s = this.getMap(), o = s._get2DExtentAtRes(s.getGLRes());
    if (n && n.length)
      for (var a = 0; a < n.length; a++) {
        var l = n[a].extent2d, h = this.resources && this.resources.getImage(n[a].url);
        h && o.intersects(l) && (this._painted = !0, this._drawImage(h, l, n[a].opacity || 1));
      }
  }, e._drawImage = function(n, s, o) {
    var a = 0, l = this.context;
    o < 1 && (a = l.globalAlpha, l.globalAlpha = o);
    var h = this.getMap(), u = jk.set(s.xmin, s.ymax), c = h._pointAtResToContainerPoint(u, h.getGLRes()), f = c.x, d = c.y, p = h.getBearing();
    p && (l.save(), l.translate(f, d), p && l.rotate(-p * Math.PI / 180), f = d = 0);
    var g = h.getGLScale();
    l.drawImage(n, f, d, s.getWidth() / g, s.getHeight() / g), p && l.restore(), a && (l.globalAlpha = a);
  }, e.drawOnInteracting = function() {
    this.draw();
  }, t;
}(Ll), EA = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.drawOnInteracting = function(n, s, o) {
    this.draw(s, o);
  }, e._prepareGLContext = function() {
    var n = this.gl;
    if (n) {
      n.disable(n.STENCIL_TEST), n.disable(n.POLYGON_OFFSET_FILL), n.enable(n.DEPTH_TEST), n.enable(n.BLEND), n.blendFunc(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA), n.depthFunc(Lk(this.layer.options.depthFunc));
      var s = !!this.layer.options.depthMask;
      n.depthMask(s);
    }
  }, e._drawImages = function(n, s) {
    var o = this.gl;
    if (s && s.renderTarget) {
      var a = s.renderTarget.fbo;
      if (a) {
        var l = s.renderTarget.getFramebuffer(a);
        o.bindFramebuffer(o.FRAMEBUFFER, l);
      }
    }
    if (this._prepareGLContext(), i.prototype._drawImages.call(this), s && s.renderTarget) {
      var h = s.renderTarget.fbo;
      h && o.bindFramebuffer(o.FRAMEBUFFER, null);
    }
  }, e.isDrawable = function() {
    return !0;
  }, e._drawImage = function(n, s, o) {
    this.drawGLImage(n, s.xmin, s.ymax, s.getWidth(), s.getHeight(), 1, o);
  }, e.createContext = function() {
    this.createGLContext();
  }, e.resizeCanvas = function(n) {
    this.canvas && (i.prototype.resizeCanvas.call(this, n), this.resizeGLCanvas());
  }, e.clearCanvas = function() {
    this.canvas && (i.prototype.clearCanvas.call(this), this.clearGLCanvas());
  }, e.retireImage = function(n) {
    n.close && n.close(), this.disposeImage(n);
  }, e.onRemove = function() {
    this.removeGLCanvas(), i.prototype.onRemove.call(this);
  }, t;
}(jv(Vv));
Gv.registerRenderer("canvas", Vv);
Gv.registerRenderer("gl", EA);
var Uv = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.getPrepareParams = function() {
    return [];
  }, e.getDrawParams = function() {
    return [];
  }, e.onCanvasCreate = function() {
    this.canvas && this.layer.options.doubleBuffer && (this.buffer = Ct.createCanvas(this.canvas.width, this.canvas.height, this.getMap().CanvasClass));
  }, e.needToRedraw = function() {
    if (this.layer.options.animation)
      return !0;
    var n = this.getMap();
    return n.isInteracting() && !this.layer.drawOnInteracting ? !1 : i.prototype.needToRedraw.call(this);
  }, e.draw = function() {
    this.prepareCanvas(), this.prepareDrawContext(), this._drawLayer.apply(this, arguments);
  }, e.drawOnInteracting = function() {
    this._drawLayerOnInteracting.apply(this, arguments);
  }, e.getCanvasImage = function() {
    var n = i.prototype.getCanvasImage.call(this);
    if (n && n.image && this.layer.options.doubleBuffer) {
      var s = n.image;
      (this.buffer.width !== s.width || this.buffer.height !== s.height) && (this.buffer.width = s.width, this.buffer.height = s.height);
      var o = this.buffer.getContext("2d"), a = this.layer.doubleBuffer(o, this.context);
      (a === void 0 || a) && (Ct.image(o, s, 0, 0), n.image = this.buffer);
    }
    return n;
  }, e.remove = function() {
    return delete this._drawContext, i.prototype.remove.call(this);
  }, e.onZoomStart = function(n) {
    this.layer.onZoomStart(n), i.prototype.onZoomStart.call(this, n);
  }, e.onZooming = function(n) {
    this.layer.onZooming(n), i.prototype.onZooming.call(this, n);
  }, e.onZoomEnd = function(n) {
    this.layer.onZoomEnd(n), i.prototype.onZoomEnd.call(this, n);
  }, e.onMoveStart = function(n) {
    this.layer.onMoveStart(n), i.prototype.onMoveStart.call(this, n);
  }, e.onMoving = function(n) {
    this.layer.onMoving(n), i.prototype.onMoving.call(this, n);
  }, e.onMoveEnd = function(n) {
    this.layer.onMoveEnd(n), i.prototype.onMoveEnd.call(this, n);
  }, e.onResize = function(n) {
    this.layer.onResize(n), i.prototype.onResize.call(this, n);
  }, e.prepareDrawContext = function() {
    if (!this._predrawed) {
      var n = w_(this.getPrepareParams());
      this._drawContext = this.layer.prepareToDraw.apply(this.layer, [this.context].concat(n)), this._drawContext || (this._drawContext = []), Array.isArray(this._drawContext) || (this._drawContext = [this._drawContext]), this._predrawed = !0;
    }
  }, e._prepareDrawParams = function() {
    if (!this.getMap())
      return null;
    var n = this.getViewExtent();
    if (n.maskExtent && !n.extent.intersects(n.maskExtent))
      return this.completeRender(), null;
    var s = [this.context, n], o = w_(this.getDrawParams());
    return s.push.apply(s, o), s.push.apply(s, this._drawContext), s;
  }, e._drawLayer = function() {
    var n = this._prepareDrawParams();
    if (n) {
      for (var s = arguments.length, o = new Array(s), a = 0; a < s; a++)
        o[a] = arguments[a];
      this.layer.draw.apply(this.layer, n.concat(o)), this.completeRender();
    }
  }, e._drawLayerOnInteracting = function() {
    if (this.layer.drawOnInteracting) {
      var n = this._prepareDrawParams();
      if (n) {
        for (var s = arguments.length, o = new Array(s), a = 0; a < s; a++)
          o[a] = arguments[a];
        this.layer.drawOnInteracting.apply(this.layer, n.concat(o)), this.completeRender();
      }
    }
  }, t;
}(Ll);
function w_(i) {
  return i || (i = []), Array.isArray(i) || (i = [i]), i;
}
var Vk = {
  doubleBuffer: !1,
  animation: !1
}, $v = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.isCanvasRender = function() {
    return !0;
  }, e.prepareToDraw = function() {
  }, e.draw = function() {
  }, e.redraw = function() {
    return this._getRenderer() && this._getRenderer().setToRedraw(), this;
  }, e.play = function() {
    return this.config("animation", !0), this;
  }, e.pause = function() {
    return this.config("animation", !1), this;
  }, e.isPlaying = function() {
    return this.options.animation;
  }, e.clearCanvas = function() {
    return this._getRenderer() && this._getRenderer().clearCanvas(), this;
  }, e.requestMapToRender = function() {
    return this._getRenderer() && this._getRenderer().requestMapToRender(), this;
  }, e.completeRender = function() {
    return this._getRenderer() && this._getRenderer().completeRender(), this;
  }, e.onCanvasCreate = function() {
    return this;
  }, e.onZoomStart = function() {
  }, e.onZooming = function() {
  }, e.onZoomEnd = function() {
  }, e.onMoveStart = function() {
  }, e.onMoving = function() {
  }, e.onMoveEnd = function() {
  }, e.onResize = function() {
  }, e.doubleBuffer = function(n) {
    return n.clearRect(0, 0, n.canvas.width, n.canvas.height), this;
  }, t;
}(gr);
$v.mergeOptions(Vk);
$v.registerRenderer("canvas", Uv);
var Uk = new Y(0, 0), $k = {
  animation: !0
}, OA = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.getParticles = function() {
  }, e.draw = function(n, s) {
    var o = this.getParticles(Je());
    if (!o || o.length === 0) {
      var a = this._getRenderer();
      a && (this._getRenderer()._shouldClear = !0);
      return;
    }
    var l = this.getMap(), h = s.extent;
    s.maskExtent && (h = s.extent.intersection(s.maskExtent)), h = h.convertTo(function(m) {
      return l._pointToContainerPoint(m, void 0, 0, Uk);
    });
    for (var u = 2 * Math.PI, c = 0, f = o.length; c < f; c++) {
      var d = o[c].point;
      if (h.contains(d)) {
        var p = o[c].color || this.options.lineColor || "#fff", g = o[c].r;
        n.fillStyle !== p && (n.fillStyle = p), g <= 2 ? n.fillRect(d.x - g / 2, d.y - g / 2, g, g) : (n.beginPath(), n.arc(d.x, d.y, g / 2, 0, u), n.fill());
      }
    }
    this._fillCanvas(n);
  }, e._fillCanvas = function(n) {
    var s = n.globalCompositeOperation;
    n.globalCompositeOperation = "destination-out";
    var o = this.options.trail || 30;
    n.fillStyle = "rgba(0, 0, 0, " + 1 / o + ")", n.fillRect(0, 0, n.canvas.width, n.canvas.height), n.globalCompositeOperation = s;
  }, t;
}($v);
OA.mergeOptions($k);
OA.registerRenderer("canvas", function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.draw = function() {
    (!this.canvas || !this.layer.options.animation || this._shouldClear) && (this.prepareCanvas(), this._shouldClear = !1), this.prepareDrawContext(), this._drawLayer();
  }, e.drawOnInteracting = function() {
    this.draw(), this._shouldClear = !1;
  }, e.onSkipDrawOnInteracting = function() {
    this._shouldClear = !0;
  }, t;
}(Uv));
var Ql = new Bo(), th, eh, Wk = function(i) {
  Ot(t, i);
  function t(r, n, s) {
    var o;
    o = i.call(this, s) || this, o.target = r, r.once("remove", o.delete, kn(kn(o)));
    var a = o.options.symbol, l = a.markerLineWidth || 1;
    return o.w = a.markerWidth + l, o.h = a.markerHeight + l, o.opacity = W(a.opacity) ? 1 : a.opacity, o.map = n, o.events = s.events, o._fetchImage(), o.addTo(n), o;
  }
  var e = t.prototype;
  return e.getCursor = function() {
    return this.options.cursor || "default";
  }, e._fetchImage = function() {
    var n = this.map, s = this.options.symbol, o = s.markerFile;
    this.url = o || ku(s);
    var a = Ql.getImage(this.url);
    if (!a) {
      var l = this.w, h = this.h;
      if (o)
        a = new Image(), a.onload = function() {
          var f = n.getRenderer();
          f && f.setToRedraw();
        }, a.src = this.url;
      else {
        var u = document.createElement("canvas");
        u.width = l, u.height = h;
        var c = u.getContext("2d");
        a = NT(c, {
          x: l / 2,
          y: h / 2
        }, s, Ql);
      }
      Ql.addResource([this.url, l, h], a);
    }
    Ql.login(this.url), this._img = a;
  }, e.setContainerPoint = function(n) {
    this._point = n, this._point._sub(this.w / 2, this.h / 2);
  }, e.getContainerPoint = function() {
    return this._point.add(this.w / 2, this.h / 2);
  }, e.offset = function(n) {
    this._point._add(n);
  }, e.render = function(n) {
    if (!this._img)
      return !1;
    var s = this.options.symbol, o = s.markerDx || 0, a = s.markerDy || 0, l = this.map, h = this._point, u = h.x, c = h.y, f = this.w, d = this.h;
    if (u + f > 0 && u < l.width && c + d > 0 && c < l.height) {
      var p = l.getDevicePixelRatio();
      return n.globalAlpha = this.opacity, n.drawImage(this._img, Math.round((u + o) * p), Math.round((c + a) * p), Math.round(f * p), Math.round(d * p)), !0;
    }
    return !1;
  }, e.delete = function() {
    if (this.map) {
      var n = this.map.getRenderer();
      n && n.removeTopElement(this);
    }
    Ql.logout(this.url), this._dragger && (this._dragger.disable(), delete this._dragger), delete this.map;
  }, e.hitTest = function(n) {
    var s = this.options.symbol, o = s.markerDx || 0, a = s.markerDy || 0, l = this.w, h = this.h, u = this._point.x + o, c = this._point.y + a;
    return n.x >= u && n.x <= u + l && n.y >= c && n.y <= c + h;
  }, e.addTo = function(n) {
    this.map = n;
    var s = n.getRenderer();
    s.addTopElement(this);
  }, e.onEvent = function(n) {
    this.fire(n.type, n);
  }, e.mousedown = function(n) {
    var s = n.target, o = this.options.cursor;
    o && s.setCursor(o), this.onDragstart(n);
  }, e.onDragstart = function(n) {
    var s = n.containerPoint, o = n.target, a = o._panels.mapWrapper || o._containerDOM, l = this._dragger = new Iu(a);
    l.on("dragging", this.onDragging, this).on("mouseup", this.onDragend, this).enable(), l.type = "handle", l.onMouseDown(n.domEvent), th = s.x, eh = s.y, this.fire("dragstart", {
      containerPoint: s
    });
  }, e.onDragging = function(n) {
    if (this._dragger) {
      var s = this.map, o = ai(n.domEvent, s._containerDOM), a = {
        x: o.x - th,
        y: o.y - eh
      }, l = s.containerPointToCoord(new Y(th, eh)), h = s.containerPointToCoord(o);
      th = o.x, eh = o.y, this.offset(a), this.fire("dragging", {
        containerPoint: o,
        coordOffset: h._sub(l)
      });
    }
  }, e.onDragend = function(n) {
    if (this._dragger) {
      var s = this.map;
      s.resetCursor();
      var o = ai(n.domEvent, s._containerDOM), a = {
        x: o.x - th,
        y: o.y - eh
      };
      this.offset(a), this._dragger.disable(), delete this._dragger, this.fire("dragend", {
        containerPoint: o
      });
    }
  }, e.needCollision = function() {
    var n = this.target;
    return n && n.options && n.options.collision;
  }, e.getRenderBBOX = function(n) {
    var s = this.target, o = this.map;
    if (!s || !s.options || !o)
      return null;
    var a = this.options.symbol, l = a.markerDx || 0, h = a.markerDy || 0, u = this._point, c = u.x, f = u.y, d = this.w, p = this.h;
    n = n || o.getDevicePixelRatio(), this.bbox = this.bbox || Jo();
    var g = Math.round((c + l) * n), m = Math.round((f + h) * n), v = Math.round(d * n), _ = Math.round(p * n);
    this.bbox[0] = g, this.bbox[1] = m, this.bbox[2] = g + v, this.bbox[3] = m + _;
    var y = s.options, x = y.collisionBufferSize || 0;
    return wT(this.bbox, x), this.bbox;
  }, t;
}(ls(pi)), Zk = function() {
  function i(e, r) {
    this.target = e, e.once("remove", this.delete, this), this.map = r, this.addTo(r);
  }
  var t = i.prototype;
  return t.setPoints = function(r) {
    this.points = r;
    var n = r.map(function(o) {
      return o.x;
    }), s = r.map(function(o) {
      return o.y;
    });
    this.xmin = Math.min.apply(Math, n), this.xmax = Math.max.apply(Math, n), this.ymin = Math.min.apply(Math, s), this.ymax = Math.max.apply(Math, s);
  }, t.hitTest = function() {
    return !1;
  }, t.render = function(r) {
    var n = this.map;
    if (this.xmax <= 0 || this.xmin >= n.width || this.ymax <= 0 || this.ymin >= n.height)
      return;
    var s = n.getDevicePixelRatio(), o = 0.5;
    function a(u) {
      return Math.round(u) * s + o;
    }
    r.lineWidth = 1, r.strokeStyle = "#000", r.globalAlpha = 1, r.beginPath();
    var l = this.points;
    r.moveTo(a(l[0].x), a(l[0].y));
    for (var h = 1; h < this.points.length; h++)
      r.lineTo(a(l[h].x), a(l[h].y));
    r.closePath(), r.stroke();
  }, t.addTo = function(r) {
    this.map = r;
    var n = r.getRenderer();
    n.addTopElement(this);
  }, t.delete = function() {
    if (this.map) {
      var r = this.map.getRenderer();
      r && r.removeTopElement(this);
    }
  }, i;
}(), Xk = Eu + "_edit_stage_";
function Kp(i, t) {
  return {
    markerType: i,
    markerFill: "#fff",
    markerLineColor: "#000",
    markerLineWidth: 2,
    markerWidth: 10,
    markerHeight: 10,
    opacity: t
  };
}
var qk = {
  fixAspectRatio: !1,
  symbol: null,
  removeVertexOn: "contextmenu",
  centerHandleSymbol: Kp("ellipse", 1),
  vertexHandleSymbol: Kp("square", 1),
  newVertexHandleSymbol: Kp("square", 0.4),
  collision: !1,
  collisionBufferSize: 0
}, kA = function(i) {
  Ot(t, i);
  function t(r, n) {
    var s;
    return s = i.call(this, n) || this, s._geometry = r, s._geometry ? s : kn(s);
  }
  var e = t.prototype;
  return e.getMap = function() {
    return this._geometry.getMap();
  }, e.prepare = function() {
    var n = this.getMap();
    n && (n.on("drawtopstart", this._refresh, this), this.options.symbol && (this._originalSymbol = this._geometry.getSymbol(), this._geometry.setSymbol(this.options.symbol)), this._prepareEditStageLayer());
  }, e._prepareEditStageLayer = function() {
    var n = this._geometry.getLayer();
    if (n.options.renderer === "canvas") {
      var s = this.getMap(), o = Ls(), a = Xk + o + "_shadow";
      if (this._shadowLayer = s.getLayer(a), !this._shadowLayer) {
        var l = n.constructor;
        this._shadowLayer = new l(a), s.addLayer(this._shadowLayer);
      }
    }
  }, e.start = function() {
    if (!(!this._geometry || !this._geometry.getMap() || this._geometry.editing)) {
      this.editing = !0, this.prepare();
      var n = this._geometry, s, o = this._geometry.getLayer(), a = o.options.renderer === "canvas";
      this._geometryDraggble = n.options.draggable, a ? (n.config("draggable", !1), s = n.copy(), s.setSymbol(n._getInternalSymbol()), s.copyEventListeners(n), n._getParent() && s.copyEventListeners(n._getParent()), s._setEventTarget(n), s.setId(null).config({
        draggable: !1
      }), this._shadow = s, n.hide()) : n instanceof xn && n.config("draggable", !0), this._switchGeometryEvents("on"), (n instanceof xn || n instanceof Pi || n instanceof Fo || n instanceof as) && this._createOrRefreshOutline(), this._shadowLayer && this._shadowLayer.bringToFront().addGeometry(s), n instanceof xn ? s && (s.config("draggable", !0), s.on("dragend", this._onMarkerDragEnd, this)) : this._createCenterHandle(), n instanceof xn && this.options.resize !== !1 ? this.createMarkerEditor() : n instanceof Pi ? this.createCircleEditor() : n instanceof Fo ? this.createEllipseOrRectEditor() : n instanceof as ? this.createEllipseOrRectEditor() : n instanceof Ko || (n instanceof vn || n instanceof Tn) && this.createPolygonEditor();
    }
  }, e.stop = function() {
    delete this._history, delete this._historyPointer, delete this._editOutline, this._switchGeometryEvents("off");
    var n = this.getMap();
    if (!n) {
      this.fire("remove");
      return;
    }
    this._geometry.config("draggable", this._geometryDraggble), this._shadow && (delete this._shadow, delete this._geometryDraggble, this._geometry.show()), this._shadowLayer && (this._shadowLayer.remove(), delete this._shadowLayer), this._refreshHooks = [], this.options.symbol && (this._geometry.setSymbol(this._originalSymbol), delete this._originalSymbol), this.editing = !1, this.fire("remove");
  }, e.isEditing = function() {
    return W(this.editing) ? !1 : this.editing;
  }, e._getGeometryEvents = function() {
    return {
      symbolchange: this._onGeoSymbolChange,
      dragstart: this._onDragStart,
      dragend: this._onDragEnd,
      "positionchange shapechange": this._exeAndReset
    };
  }, e._switchGeometryEvents = function(n) {
    if (this._geometry) {
      var s = this._getGeometryEvents();
      for (var o in s)
        this._geometry[n](o, s[o], this);
    }
  }, e._onGeoSymbolChange = function(n) {
    this._shadow && this._shadow.setSymbol(n.target._getInternalSymbol());
  }, e._onMarkerDragEnd = function() {
    this._update("setCoordinates", this._shadow.getCoordinates().toArray());
  }, e._createOrRefreshOutline = function() {
    var n = this._geometry, s = this._editOutline;
    s || (this._editOutline = new Zk(this, this.getMap()), this._addRefreshHook(this._createOrRefreshOutline));
    var o = this._editOutline.points;
    if (n instanceof xn)
      this._editOutline.setPoints(n.getContainerExtent().toArray(o));
    else {
      var a = this.getMap(), l = n._getPrjExtent();
      o = l.toArray(o), o.forEach(function(h) {
        return a._prjToContainerPoint(h, null, h);
      }), this._editOutline.setPoints(o);
    }
    return s;
  }, e._createCenterHandle = function() {
    var n = this, s = this.getMap(), o = this.options.centerHandleSymbol, a, l = s.coordToContainerPoint(this._geometry.getCenter()), h = this.createHandle(l, {
      symbol: o,
      cursor: "move",
      onDown: function() {
        if (n._shadow) {
          a = n._shadow.copy();
          var c = Zf(a._getInternalSymbol(), 0.5);
          a.setSymbol(c).addTo(n._geometry.getLayer());
        }
      },
      onMove: function(c) {
        var f = c.coordOffset;
        a ? a.translate(f) : n._geometry.translate(f);
      },
      onUp: function() {
        if (a) {
          var c = a.getFirstCoordinate(), f = n._geometry.getFirstCoordinate(), d = c.sub(f);
          n._update("translate", d), a.remove();
        }
      }
    });
    this._addRefreshHook(function() {
      var u = n._geometry.getCenter();
      h.setContainerPoint(s.coordToContainerPoint(u));
    });
  }, e._createHandleInstance = function(n, s) {
    var o = this.getMap(), a = fv(s.symbol, function() {
      return [o.getZoom(), {
        "{bearing}": o.getBearing(),
        "{pitch}": o.getPitch(),
        "{zoom}": o.getZoom()
      }];
    }), l = this.options.removeVertexOn, h = new Wk(this, o, {
      symbol: a,
      cursor: s.cursor,
      events: l
    });
    return h.setContainerPoint(n), h;
  }, e.createHandle = function(n, s) {
    s || (s = {});
    var o = this._createHandleInstance(n, s), a = this;
    function l(c) {
      return this._updating = !0, s.onDown && (s.onDown.call(a, c.containerPoint, c), this._geometry.fire("handledragstart")), !1;
    }
    function h(c) {
      return a._hideContext(), s.onMove && (s.onMove.call(a, c), this._geometry.fire("handledragging")), !1;
    }
    function u(c) {
      return s.onUp && (s.onUp.call(a, c), this._geometry.fire("handledragend")), this._updating = !1, !1;
    }
    return o.on("dragstart", l, this), o.on("dragging", h, this), o.on("dragend", u, this), s.onRefresh && (o.refresh = s.onRefresh), o;
  }, e._createResizeHandles = function(n, s, o) {
    var a = this, l = ["nw-resize", "n-resize", "ne-resize", "w-resize", "e-resize", "sw-resize", "s-resize", "se-resize"], h = [null, "y", null, "x", "x", null, "y", null], u = this._geometry, c = u instanceof xn;
    function f() {
      if (c) {
        var y = u.getContainerExtent();
        return [new Y(y.xmin, y.ymin), new Y((y.xmax + y.xmin) / 2, y.ymin), new Y(y.xmax, y.ymin), new Y(y.xmin, (y.ymin + y.ymax) / 2), new Y(y.xmax, (y.ymin + y.ymax) / 2), new Y(y.xmin, y.ymax), new Y((y.xmax + y.xmin) / 2, y.ymax), new Y(y.xmax, y.ymax)];
      }
      var x = u._getPrjExtent();
      return [new Y(x.xmin, x.ymax), new Y((x.xmax + x.xmin) / 2, x.ymax), new Y(x.xmax, x.ymax), new Y(x.xmin, (x.ymax + x.ymin) / 2), new Y(x.xmax, (x.ymax + x.ymin) / 2), new Y(x.xmin, x.ymin), new Y((x.xmax + x.xmin) / 2, x.ymin), new Y(x.xmax, x.ymin)];
    }
    n || (n = []);
    var d = this, p = [], g = {}, m = this.getMap(), v = this.options.vertexHandleSymbol, _ = function() {
      for (var x = f(), w = function(M) {
        if (Array.isArray(n)) {
          var S = n.some(function(O) {
            return O === M;
          });
          if (S)
            return "continue";
        }
        var P = x[M], C = c ? P : m._prjToContainerPoint(P);
        if (p.length < x.length - n.length) {
          var k = a.createHandle(C, {
            symbol: v,
            cursor: l[M],
            axis: h[M],
            onMove: /* @__PURE__ */ function(O) {
              return function(R) {
                d._updating = !0, s(R.containerPoint, O), u.fire("resizing");
              };
            }(M),
            onUp: function() {
              d._updating = !1, o();
            }
          });
          g[M] = p.length, p.push(k);
        } else
          p[g[M]].setContainerPoint(C);
      }, b = 0; b < x.length; b++)
        var T = w(b);
    };
    return _(), this._addRefreshHook(_), p;
  }, e.createMarkerEditor = function() {
    var n = this, s = this._shadow || this._geometry, o = this.getMap();
    if (!s._canEdit()) {
      console && console.warn("A marker can't be resized with symbol:", s.getSymbol());
      return;
    }
    this._history || this._recordHistory(v());
    var a = s._getInternalSymbol(), l = new Y(0, 0);
    Ut(a.markerDx) && (l.x = a.markerDx), Ut(a.markerDy) && (l.y = a.markerDy);
    var h = null, u = "middle", c = "middle";
    if (GT.test(a)) {
      var f = a.markerType;
      f === "pin" || f === "pie" || f === "bar" ? (h = [5, 6, 7], u = "bottom") : f === "rectangle" && (h = [0, 1, 2, 3, 5], u = "top", c = "left");
    } else (Rv.test(a) || VT.test(a)) && (u = "bottom", h = [5, 6, 7]);
    var d = [2, 1, 2, 0, 0, 2, 1, 2], p;
    if (this.options.fixAspectRatio) {
      var g = s.getSize();
      p = g.width / g.height;
    }
    var m = this._createResizeHandles(h, function(_, y) {
      if (h && h.indexOf(y) >= 0) {
        var x = o.containerPointToCoordinate(_.sub(l)), w = s.getCoordinates();
        x.x = w.x, s.setCoordinates(x), n._updateCoordFromShadow(!0);
        var b = m[m.length - 1 - y], T = b.getContainerPoint();
        _ = T;
      }
      var A = o.coordToContainerPoint(s.getCoordinates()).add(l), M = s._getInternalSymbol(), S = _.sub(A);
      u === "bottom" && _.y > A.y && (S.y = 0);
      var P = u === "middle" ? 2 : 1, C = c === "left" ? 1 : 2, k = Math.abs(S.x) * C, O = Math.abs(S.y) * P;
      p && (k = Math.max(k, O * p), O = k / p);
      var R = d[y];
      s instanceof td ? ((p || R === 0 || R === 2) && (s.setWidth(k), s !== n._geometry && n._geometry.setWidth(k)), (p || R === 1 || R === 2) && (s.setHeight(O), s !== n._geometry && n._geometry.setHeight(O))) : ((p || R === 0 || R === 2) && (M.markerWidth = Math.min(k, n._geometry.options.maxMarkerWidth || 1 / 0)), (p || R === 1 || R === 2) && (M.markerHeight = Math.min(O, n._geometry.options.maxMarkerHeight || 1 / 0)), s.setSymbol(M), s !== n._geometry && n._geometry.setSymbol(M));
    }, function() {
      n._update(v());
    });
    function v() {
      var _ = [["setCoordinates", s.getCoordinates().toArray()]];
      return s instanceof td ? (_.push(["setWidth", s.getWidth()]), _.push(["setHeight", s.getHeight()])) : _.push(["setSymbol", s.getSymbol()]), _;
    }
  }, e.createCircleEditor = function() {
    var n = this, s = this._shadow || this._geometry, o = this.getMap();
    this._history || this._recordHistory([["setCoordinates", s.getCoordinates().toArray()], ["setRadius", s.getRadius()]]), this._createResizeHandles(null, function(a) {
      var l = s.getCenter(), h = o.containerPointToCoord(a), u = new Tn([[l.x, l.y], [h.x, l.y]]), c = new Tn([[l.x, l.y], [l.x, h.y]]), f = Math.max(o.computeGeometryLength(u), o.computeGeometryLength(c));
      s.setRadius(f), s !== n._geometry && n._geometry.setRadius(f);
    }, function() {
      n._update("setRadius", s.getRadius());
    });
  }, e.createEllipseOrRectEditor = function() {
    var n = this, s = [2, 1, 2, 0, 0, 2, 1, 2], o = this._shadow || this._geometry;
    this._history || this._recordHistory(c());
    var a = this.getMap(), l = this._geometry instanceof Fo, h;
    this.options.fixAspectRatio && (h = o.getWidth() / o.getHeight());
    var u = this._createResizeHandles(null, function(f, d) {
      var p = l ? 1 : 2, g, m, v, _ = u[d], y = _.getContainerPoint(), x = s[d];
      if (l) {
        var w = u[7 - d], b = w.getContainerPoint();
        g = y.sub(b);
        var T = g.abs();
        m = a.pixelToDistance(T.x, 0), v = a.pixelToDistance(0, T.y);
        var A = o.getSize(), M = o.getCoordinates(), S = o.getWidth(), P = o.getHeight(), C = a.containerPointToCoord(f), k = a.containerPointToCoord(b), O = new Tn([[k.x, k.y], [C.x, k.y]]), R = new Tn([[k.x, k.y], [k.x, C.y]]);
        if (m = a.computeGeometryLength(O), v = a.computeGeometryLength(R), x === 0)
          if (h && (T.y = T.x / h, A.height = Math.abs(T.y), v = m / h), y.y = b.y - A.height / 2, C.y = M.y, d === 4)
            C.x = Math.min(C.x, M.x);
          else {
            var I = a.locate(M, S, 0);
            C.x = a.locate(new lt(I.x, C.y), -m, 0).x;
          }
        else if (x === 1)
          h && (T.x = T.y * h, A.width = Math.abs(T.x), m = v * h), y.x = b.x - A.width / 2, C.x = M.x, C.y = Math.max(C.y, k.y);
        else {
          if (h && (m > v * h ? (v = m / h, y.y = b.y + T.x * Ar(g.y) / h) : (m = v * h, y.x = b.x + T.y * Ar(g.x) * h)), d === 0 || d === 5) {
            var D = d === 0 ? a.locate(M, S, 0) : a.locate(M, S, -P);
            C.x = a.locate(new lt(D.x, C.y), -m, 0).x;
          } else
            C.x = Math.min(C.x, k.x);
          C.y = Math.max(C.y, k.y);
        }
        o.setCoordinates(C), n._updateCoordFromShadow(!0);
      } else {
        var z = o.getCenter(), H = a.containerPointToCoord(y), G = new Tn([[z.x, z.y], [H.x, z.y]]), $ = new Tn([[z.x, z.y], [z.x, H.y]]);
        m = a.computeGeometryLength(G), v = a.computeGeometryLength($), h && (m = Math.max(m, v * h), v = m / h);
      }
      (h || x === 0 || x === 2) && (o.setWidth(m * p), o !== n._geometry && n._geometry.setWidth(m * p)), (h || x === 1 || x === 2) && (o.setHeight(v * p), o !== n._geometry && n._geometry.setHeight(v * p));
    }, function() {
      n._update(c());
    });
    function c() {
      return [["setCoordinates", o.getCoordinates().toArray()], ["setWidth", o.getWidth()], ["setHeight", o.getHeight()]];
    }
  }, e.createPolygonEditor = function() {
    var n = this.getMap(), s = this._shadow || this._geometry, o = this;
    this._history || this._recordHistory("setCoordinates", lt.toNumberArrays(s.getCoordinates()));
    var a = s instanceof vn ? 3 : 2, l = "maptalks--editor-vertex-index", h = {
      0: []
    }, u = {
      0: []
    };
    function c(O) {
      if (O === void 0 && (O = 0), s instanceof vn) {
        var R = s.getCoordinates()[O] || [];
        return R.slice(0, R.length - 1);
      } else
        return s.getCoordinates();
    }
    function f(O) {
      return O === void 0 && (O = 0), O === 0 ? s._getPrjCoordinates() : s._getPrjHoles()[O - 1];
    }
    function d() {
      for (var O in h) {
        for (var R = h[O].length - 1; R >= 0; R--)
          h[O][R][l] = R;
        for (var I = u[O].length - 1; I >= 0; I--)
          u[O][I][l] = I;
      }
      o._updateCoordFromShadow();
    }
    function p(O) {
      o._updating = !0;
      var R = O.target, I = R[l], D = Ut(R._ringIndex) ? R._ringIndex : 0, z = f(D);
      if (!(z.length <= a)) {
        var H = s instanceof Tn && (I === 0 || I === z.length - 1);
        z.splice(I, 1), D > 0 ? s._prjHoles[D - 1] = z : s._setPrjCoordinates(z), s._updateCache(), h[D].splice(I, 1)[0].delete(), I < u[D].length && u[D].splice(I, 1)[0].delete();
        var G;
        if (I === 0 ? G = u[D].length - 1 : G = I - 1, u[D].splice(G, 1)[0].delete(), H || u[D].splice(G, 0, x.call(o, G, D)), D > 0) {
          var $ = s.getCoordinates(), K = $[D];
          K && Array.isArray(K) && K.length > 1 && (K.splice(I, 1), s !== this._geometry && s.setCoordinates($));
        }
        d(), o._updating = !1;
      }
    }
    function g(O, R, I) {
      I === void 0 && (I = 0);
      var D = o._geometry.snapTo;
      D && Be(D) && (O = o._geometry.snapTo(O) || O);
      var z = f(I), H = n._containerPointToPrj(O.sub(v())), G = z[R];
      G.x = H.x, G.y = H.y, s._updateCache(), s.onShapeChanged(), o._updateCoordFromShadow(!0);
      var $;
      R === 0 ? $ = u[I].length - 1 : $ = R - 1, u[I][R] && u[I][R].refresh(), u[I][$] && u[I][$].refresh();
    }
    var m = new Y(0, 0);
    function v() {
      var O = s._getCompiledSymbol();
      return m.x = O.lineDx || 0, m.y = O.lineDy || 0, m;
    }
    function _(O, R, I) {
      R === void 0 && (R = 0);
      var D = (I || c(R))[O], z = o.createHandle(n.coordToContainerPoint(D)._add(v()), {
        symbol: o.options.vertexHandleSymbol,
        cursor: "pointer",
        axis: null,
        onMove: function() {
          g(z.getContainerPoint(), z[l], R);
        },
        onRefresh: function(G, $) {
          D = ($ || c(R))[z[l]];
          var K = n.coordToContainerPoint(D);
          z.setContainerPoint(K._add(v()));
        },
        onUp: function() {
          o._updateCoordFromShadow();
        },
        onDown: function(G, $) {
          $ && $.domEvent && $.domEvent.button;
        }
      });
      return z[l] = O, z._ringIndex = R, z.on(o.options.removeVertexOn, p), z;
    }
    var y = !1;
    function x(O, R, I) {
      R === void 0 && (R = 0);
      var D = I || c(R), z;
      O + 1 >= D.length ? z = D[0] : z = D[O + 1];
      var H = D[O].add(z).multi(1 / 2), G = o.createHandle(H, {
        symbol: o.options.newVertexHandleSymbol,
        cursor: "pointer",
        axis: null,
        onDown: function(K, dt) {
          if (!(dt && dt.domEvent && dt.domEvent.button === 2)) {
            var it = f(R), st = G[l], pt = G.getContainerPoint(), Ht = n._containerPointToPrj(pt);
            it.splice(st + 1, 0, Ht), R > 0 ? s._prjHoles[R - 1] = it : s._setPrjCoordinates(it), s._updateCache(), G.opacity = 1, u[R].splice(st, 0, x.call(o, st, R), x.call(o, st + 1, R)), y = !0;
          }
        },
        onMove: function() {
          g(G.getContainerPoint(), G[l] + 1, R);
        },
        onUp: function(K) {
          if (K && K.domEvent && K.domEvent.button === 2) {
            y = !1;
            return;
          }
          var dt = G[l];
          zf(G, u[R]), G.delete(), h[R].splice(dt + 1, 0, _.call(o, dt + 1, R)), d(), o._updateCoordFromShadow(), y = !1;
        },
        onRefresh: function(K, dt) {
          D = dt || c(K);
          var it = G[l], st;
          it === D.length - 1 ? st = 0 : st = it + 1;
          var pt = D[it].add(D[st]).multi(1 / 2), Ht = n.coordToContainerPoint(pt);
          G.setContainerPoint(Ht._add(v()));
        }
      });
      return G[l] = O, G;
    }
    if (s instanceof vn)
      for (var w = s.getHoles().length + 1, b = 0; b < w; b++) {
        h[b] = [], u[b] = [];
        for (var T = c(b), A = 0, M = T.length; A < M; A++)
          h[b].push(_.call(this, A, b, T)), A < M - 1 && u[b].push(x.call(this, A, b, T));
        u[b].push(x.call(this, T.length - 1, b, T));
      }
    else {
      for (var S = 0, P = c(S), C = 0, k = P.length; C < k; C++)
        h[S].push(_.call(this, C, S, P)), C < k - 1 && u[S].push(x.call(this, C, S, P));
      u[S].length && s.getCoordinates().length === 2 && (u[S][0].options.symbol.markerDx = 12);
    }
    this._addRefreshHook(function() {
      if (!y) {
        for (var O in u)
          for (var R = c(O), I = u[O].length - 1; I >= 0; I--)
            u[O][I].refresh(O, R);
        u[0].length && s instanceof Tn && (s.getCoordinates().length === 2 ? u[0][0].options.symbol.markerDx = 12 : s.getCoordinates().length > 2 && (u[0][0].options.symbol.markerDx = 0));
        for (var D in h)
          for (var z = c(D), H = h[D].length - 1; H >= 0; H--)
            h[D][H].refresh(D, z);
      }
    });
  }, e._refresh = function() {
    if (this._refreshHooks)
      for (var n = this._refreshHooks.length - 1; n >= 0; n--)
        this._refreshHooks[n].call(this);
  }, e._hideContext = function() {
    this._geometry && (this._geometry.closeMenu(), this._geometry.closeInfoWindow());
  }, e._addRefreshHook = function(n) {
    n && (this._refreshHooks || (this._refreshHooks = []), this._refreshHooks.push(n));
  }, e._update = function(n) {
    for (var s = arguments.length, o = new Array(s > 1 ? s - 1 : 0), a = 1; a < s; a++)
      o[a - 1] = arguments[a];
    this._exeHistory([n, o]), this._recordHistory.apply(this, [n].concat(o));
  }, e._updateCoordFromShadow = function(n) {
    var s = this._shadow || this._geometry, o = s.getCoordinates(), a = this._geometry, l = this._updating;
    this._updating = !0, a.setCoordinates(o), n || this._recordHistory("setCoordinates", lt.toNumberArrays(a.getCoordinates())), this._updating = l;
  }, e._recordHistory = function(n) {
    this._history || (this._history = [], this._historyPointer = 0);
    for (var s = arguments.length, o = new Array(s > 1 ? s - 1 : 0), a = 1; a < s; a++)
      o[a - 1] = arguments[a];
    if (this._history.length) {
      var l = this._history[this._history.length - 1];
      if (l[0] === n && JSON.stringify(l[1]) === JSON.stringify(o))
        return;
    }
    this._historyPointer < this._history.length - 1 && this._history.splice(this._historyPointer + 1), this._history.push([n, o]), this._historyPointer = this._history.length - 1, this._geometry.fire("editrecord");
  }, e.cancel = function() {
    if (!this._history || this._historyPointer === 0)
      return this;
    this._historyPointer = 0;
    var n = this._history[0];
    return this._exeAndReset(n), this;
  }, e.undo = function() {
    if (!this._history || this._historyPointer === 0)
      return this;
    var n = this._history[--this._historyPointer];
    return this._exeAndReset(n), this;
  }, e.redo = function() {
    if (!this._history || this._historyPointer === this._history.length - 1)
      return this;
    var n = this._history[++this._historyPointer];
    return this._exeAndReset(n), this;
  }, e._exeAndReset = function(n) {
    if (!this._updating) {
      this._exeHistory(n);
      var s = this._history, o = this._historyPointer;
      this.stop(), this._history = s, this._historyPointer = o, this.start();
    }
  }, e._onDragStart = function() {
    this._updating = !0;
  }, e._onDragEnd = function() {
    this._updating = !1;
  }, e._exeHistory = function(n) {
    if (Array.isArray(n)) {
      var s = this._updating;
      this._updating = !0;
      var o = this._shadow || this._geometry, a = this._geometry;
      Array.isArray(n[0]) ? n[0].forEach(function(l) {
        var h = l[0], u = l.slice(1);
        o[h].apply(o, u), o !== a && a[h].apply(a, u);
      }) : (o[n[0]].apply(o, n[1]), o !== a && a[n[0]].apply(a, n[1])), this._updating = s;
    }
  }, t;
}(ls(pi));
kA.mergeOptions(qk);
var Yk = {
  startEditText: function() {
    return this.getMap() ? (this.hide(), this.endEditText(), this._prepareEditor(), this._fireEvent("edittextstart"), this) : this;
  },
  endEditText: function() {
    if (this._textEditor) {
      var t = this._textEditor.innerHTML;
      t = t.replace(/<p>/ig, "").replace(/<\/p>/ig, "<br/>"), this._textEditor.innerHTML = t;
      var e = this._textEditor.innerText.replace(/[\r\n]+$/gi, "");
      this.setContent(e), Un(this._textEditor, "mousedown dblclick", Jr), this.getMap().off("mousedown", this.endEditText, this), this._editUIMarker.remove(), delete this._editUIMarker, this._textEditor.onkeyup = null, delete this._textEditor, this.show(), this._fireEvent("edittextend");
    }
    return this;
  },
  isEditingText: function() {
    return !!this._textEditor;
  },
  getTextEditor: function() {
    return this._editUIMarker;
  },
  _prepareEditor: function() {
    var t = this.getMap(), e = this._createEditor();
    this._textEditor = e, t.on("mousedown", this.endEditText, this);
    var r = this._getEditorOffset();
    this._editUIMarker = new Nv(this.getCoordinates(), {
      animation: null,
      content: e,
      dx: r.dx,
      dy: r.dy
    }).addTo(t), this._setCursorToLast(this._textEditor);
  },
  _getEditorOffset: function() {
    var t = this._getInternalSymbol() || {}, e = 0, r = 0, n = t.textHorizontalAlignment;
    return n === "middle" || W(n) ? (e = (t.textDx || 0) - 2, r = (t.textDy || 0) - 2) : (e = (t.markerDx || 0) - 2, r = (t.markerDy || 0) - 2), {
      dx: e,
      dy: r
    };
  },
  _createEditor: function() {
    var t = this.getContent(), e = this.getSize(), r = this._getInternalSymbol() || {}, n = e.width, s = r.textFill || "#000000", o = r.textSize || 12, a = e.height, l = r.markerLineColor || "#000", h = r.markerFill || "#3398CC", u = r.textLineSpacing || 0, c = ve("div");
    return c.contentEditable = !0, c.style.cssText = "background:" + h + "; border:1px solid " + l + `;
            color:` + s + ";font-size:" + o + "px;width:" + (n - 2) + "px;height:" + (a - 2) + `px;margin: auto;
            line-height:` + (o + u) + `px;outline: 0; padding:0; margin:0;word-wrap: break-word;
            overflow: hidden;-webkit-user-modify: read-write-plaintext-only;`, c.innerText = t, Cn(c, "mousedown dblclick", Jr), c.onkeyup = function(f) {
      var d = c.style.height || 0;
      f.keyCode === 13 && (c.style.height = parseInt(d) + o / 2 + "px");
    }, c;
  },
  _setCursorToLast: function(t) {
    var e;
    window.getSelection ? (t.focus(), e = window.getSelection(), e.selectAllChildren(t), e.collapseToEnd()) : document.selection && (e = document.selection.createRange(), e.moveToElementText(t), e.collapse(!1), e.select());
  }
};
Fv.include(Yk);
nn.include({
  animate: function(t, e, r) {
    var n = this;
    this._animPlayer && this._animPlayer.finish(), Be(e) && (r = e), e || (e = {});
    var s = this.getMap(), o = this._getProjection(), a = this._prepareAnimationStyles(t), l, h = e.focus;
    if (delete this._animationStarted, s) {
      var u = s._getRenderer(), c = function(p) {
        u.callInNextFrame(p);
      };
      e.framer = c;
    }
    var f = dr.animate(a, e, function(d) {
      if (s && s.isRemoved()) {
        f.finish();
        return;
      }
      s && !n._animationStarted && h && s.onMoveStart();
      var p = d.styles;
      for (var g in p)
        if (g !== "symbol" && g !== "translate" && p.hasOwnProperty(g)) {
          var m = "set" + g[0].toUpperCase() + g.slice(1);
          n[m](p[g]);
        }
      var v = p.translate;
      if (v) {
        var _ = v;
        l && (_ = v.sub(l)), l = v, n.translate(_);
      }
      var y = p.symbol;
      if (y) {
        var x = n.getSymbol() || {};
        n.setSymbol(Ni(x, y));
      }
      if (s && h) {
        var w = o.project(n.getCenter());
        s._setPrjCenter(w);
        var b = s._parseEventFromCoord(o.unproject(w));
        f.playState !== "running" ? s.onMoveEnd(b) : s.onMoving(b);
      }
      n._fireAnimateEvent(f.playState), r && r(d);
    }, this);
    return this._animPlayer = f, this._animPlayer.play();
  },
  _prepareAnimationStyles: function(t) {
    var e = this._getInternalSymbol(), r = {};
    for (var n in t)
      if (t.hasOwnProperty(n)) {
        var s = t[n];
        if (n !== "translate" && n !== "symbol") {
          var o = "get" + n[0].toUpperCase() + n.substring(1), a = this[o]();
          r[n] = [a, s];
        } else if (n === "symbol") {
          var l = void 0;
          if (Array.isArray(t.symbol)) {
            if (!Array.isArray(e))
              throw new Error("geometry'symbol isn't a composite symbol, while the symbol in styles is.");
            l = [];
            for (var h = t.symbol, u = 0; u < h.length; u++) {
              if (!h[u]) {
                l.push(null);
                continue;
              }
              var c = {};
              for (var f in h[u])
                h[u].hasOwnProperty(f) && (c[f] = [e[u][f], h[u][f]]);
              l.push(c);
            }
          } else {
            if (Array.isArray(e))
              throw new Error("geometry'symbol is a composite symbol, while the symbol in styles isn't.");
            l = {};
            for (var d in s)
              s.hasOwnProperty(d) && (l[d] = [e[d], s[d]]);
          }
          r.symbol = l;
        } else n === "translate" && (r.translate = new lt(s));
      }
    return r;
  },
  _fireAnimateEvent: function(t) {
    t === "finished" ? (delete this._animationStarted, this._fireEvent("animateend")) : t === "running" && (this._animationStarted ? this._fireEvent("animating") : (this._fireEvent("animatestart"), this._animationStarted = !0));
  }
});
var Qp = Eu + "_drag_stage", T_ = Ce.touch ? "touchstart mousedown" : "mousedown", Jk = function(i) {
  Ot(t, i);
  function t(r) {
    return i.call(this, r) || this;
  }
  var e = t.prototype;
  return e.addHooks = function() {
    this.target.on(T_, this._startDrag, this);
  }, e.removeHooks = function() {
    this._endDrag(), this.target.off(T_, this._startDrag, this), delete this.container;
  }, e._prepareDragHandler = function() {
    this._dragHandler = new Iu(this.container), this._dragHandler.on("dragging", this._dragging, this).on("mouseup", this._endDrag, this).enable();
  }, e._prepareShadow = function() {
    var n = this, s = this.target, o = s.getLayer().options.renderer === "canvas";
    if (o) {
      this._prepareDragStageLayer(), this._shadow && this._shadow.remove();
      var a = this._shadow = s.copy();
      if (a.getGeometries) {
        var l = a.getGeometries(), h = s.getGeometries();
        l.forEach(function(u, c) {
          n._updateShadowSymbol(u, h[c]);
        });
      } else
        this._updateShadowSymbol(a, s);
      a.setId(null), this._prepareShadowConnectors();
    }
  }, e._updateShadowSymbol = function(n, s) {
    if (n.setSymbol(s._getInternalSymbol()), s.options.dragShadow) {
      var o = Zf(n._getInternalSymbol(), 0.5);
      n.setSymbol(o);
    }
  }, e._prepareShadowConnectors = function() {
    var n = this.target, s = this._shadow, o = this._dragStageLayer._getRenderer().resources, a = [];
    if (ed._hasConnectors(n))
      for (var l = ed._getConnectors(n), h = 0, u = l.length; h < u; h++) {
        var c = l[h], f = c.config(), d = c._getInternalSymbol();
        f.symbol = Zf(d, 0.5);
        var p = void 0;
        c.getConnectSource() === n ? p = new c.constructor(s, c.getConnectTarget(), f) : p = new c.constructor(c.getConnectSource(), s, f), a.push(p), c.getLayer() && c.getLayer()._getRenderer() && o.merge(c.getLayer()._getRenderer().resources);
      }
    this._shadowConnectors = a, a.push(s), this._dragStageLayer.bringToFront().addGeometry(a);
  }, e._onTargetUpdated = function() {
    this._shadow && this._shadow.setSymbol(this.target._getSymbol());
  }, e._prepareDragStageLayer = function() {
    var n = this.target.getMap(), s = this.target.getLayer();
    this._dragStageLayer = n.getLayer(Qp), this._dragStageLayer || (this._dragStageLayer = new Rs(Qp, {
      enableAltitude: s.options.enableAltitude,
      altitudeProperty: s.options.altitudeProperty
    }), n.addLayer(this._dragStageLayer));
    var o = new Bo();
    o.merge(s._getRenderer().resources), this._dragStageLayer._getRenderer().resources = o;
  }, e._startDrag = function(n) {
    var s = this.target.getMap();
    if (s) {
      var o = this.target._getParent();
      if (!o && !this.isDragging()) {
        var a = n.domEvent;
        a.touches && a.touches.length > 1 || a.button === 2 || (this.container = s._panels.mapWrapper || s._containerDOM, this.target.on("click", this._endDrag, this), this._lastCoord = this._correctCoord(n.coordinate), this._lastPoint = n.containerPoint, this._prepareDragHandler(), this._dragHandler.onMouseDown(n.domEvent), Cn(this.container, "mouseleave", this._endDrag, this), this._startParam = n, this._moved = !1);
      }
    }
  }, e._dragging = function(n) {
    var s = this.target, o = s.getMap();
    if (!o._isEventOutMap(n.domEvent)) {
      var a = o._parseEvent(n.domEvent), l = a.domEvent;
      if (!(l.touches && l.touches.length > 1)) {
        var h = o._getVisualHeight(o.options.maxVisualPitch);
        if (!(a.containerPoint.y < o.height - h)) {
          if (!this._moved) {
            this._moved = !0, s.on("symbolchange", this._onTargetUpdated, this), this._isDragging = !0, this._prepareShadow(), this._shadow && (s.options.dragShadow || s.hide(), this._shadow._fireEvent("dragstart", a)), this.target._fireEvent("dragstart", this._startParam || a), delete this._startParam;
            return;
          }
          var u = this._shadow || s, c = u.options.dragOnAxis, f = u.options.dragOnScreenAxis, d = a.containerPoint, p = a.coordinate;
          this._lastPoint = this._lastPoint || d, this._lastCoord = this._lastCoord || p, f ? (c === "x" ? d.y = this._lastPoint.y : c === "y" && (d.x = this._lastPoint.x), p = o.containerPointToCoord(d)) : p = this._correctCoord(p);
          var g = d.sub(this._lastPoint), m = p.sub(this._lastCoord);
          f || (c === "x" ? g.y = m.y = 0 : c === "y" && (g.x = m.x = 0)), this._lastPoint = d, this._lastCoord = p, u.translate(m), u !== s && !s.options.dragShadow && s.translate(m), a.coordOffset = m, a.pointOffset = g, u._fireEvent("dragging", a), u !== s && s._fireEvent("dragging", a);
        }
      }
    }
  }, e._endDrag = function(n) {
    if (this._dragHandler && (this._dragHandler.disable(), delete this._dragHandler), this.container && Un(this.container, "mouseleave", this._endDrag), !!this.target) {
      var s = this.target;
      s.off("click", this._endDrag, this), s.off("symbolchange", this._onTargetUpdated, this), delete this._lastCoord, delete this._lastPoint, this._isDragging = !1;
      var o = s.getMap();
      if (this.enabled() && o) {
        var a = o._parseEvent(n ? n.domEvent : null);
        this._updateTargetAndRemoveShadow(a), this._moved && s._fireEvent("dragend", a);
      }
    }
  }, e.isDragging = function() {
    return !!this._isDragging;
  }, e._updateTargetAndRemoveShadow = function(n) {
    if (this._shadow) {
      var s = this.target, o = s.getMap();
      s.options.dragShadow || s.show();
      var a = this._shadow;
      if (a) {
        if (s.options.dragShadow) {
          var l = a.getFirstCoordinate(), h = s.getFirstCoordinate(), u = l.sub(h);
          s.translate(u);
        }
        a._fireEvent("dragend", n), a.remove(), delete this._shadow;
      }
      this._shadowConnectors && (o.getLayer(Qp).removeGeometry(this._shadowConnectors), delete this._shadowConnectors), this._dragStageLayer && (this._dragStageLayer._getRenderer().resources = new Bo(), this._dragStageLayer.remove());
    }
  }, e._correctCoord = function(n) {
    var s = this.target.getMap();
    if (!s.getPitch())
      return n;
    var o = this.target;
    if (!o.getMinAltitude())
      return n;
    var a = (o.getMinAltitude() + o.getMaxAltitude()) / 2;
    return s.locateByPoint(n, 0, -a);
  }, t;
}(Xi);
nn.mergeOptions({
  draggable: !1,
  dragShadow: !0,
  dragOnAxis: null,
  dragOnScreenAxis: !1
});
nn.addInitHook("addHandler", "draggable", Jk);
nn.include({
  isDragging: function() {
    return this._getParent() ? this._getParent().isDragging() : this.draggable ? this.draggable.isDragging() : !1;
  }
});
nn.include({
  startEdit: function(t) {
    var e = this.getMap();
    return !e || !this.options.editable ? this : (this._editor && this.endEdit(), this._editor = new kA(this, t), this._editor.start(), this._getParent() || this.fire("editstart"), e.getRenderer().setToRedraw(), this);
  },
  endEdit: function() {
    if (this._editor) {
      this._editor.stop(), delete this._editor, this._getParent() || this.fire("editend");
      var t = this.getMap();
      t && t.getRenderer().setToRedraw();
    }
    return this;
  },
  redoEdit: function() {
    return this.isEditing() ? (this._editor.redo(), this._getParent() || this.fire("redoedit"), this) : this;
  },
  undoEdit: function() {
    return this.isEditing() ? (this._editor.undo(), this._getParent() || this.fire("undoedit"), this) : this;
  },
  cancelEdit: function() {
    return this.isEditing() ? (this._editor.cancel(), this._getParent() || this.fire("canceledit"), this) : this;
  },
  isEditing: function() {
    return this._editor ? this._editor.isEditing() : !1;
  }
});
nn.include({
  _onEvent: function(t, e) {
    var r = this.getMap();
    if (r) {
      var n = e || this._getEventTypeToFire(t);
      n === "contextmenu" && this.listens("contextmenu") && (Jr(t), ks(t));
      var s = r._getEventParams(t);
      Ut(this._pickGeometryIndex) && (s.pickGeometryIndex = this._pickGeometryIndex), this._fireEvent(n, s);
    }
  },
  _getEventTypeToFire: function(t) {
    return t.type;
  }
});
nn.include({
  setInfoWindow: function(t) {
    return this.removeInfoWindow(), t instanceof n0 ? (this._infoWindow = t, this._infoWinOptions = jt({}, this._infoWindow.options), this._infoWindow.addTo(this), this) : (this._infoWinOptions = jt({}, t), this._infoWindow ? this._infoWindow.setOptions(t) : this.getMap() && this._bindInfoWindow(), this);
  },
  getInfoWindow: function() {
    return this._infoWindow ? this._infoWindow : null;
  },
  openInfoWindow: function(t) {
    return this.getMap() ? (t || (t = this.getCenter()), this._infoWindow ? this._infoWindow.show(t) : this._infoWinOptions && this.getMap() && (this._bindInfoWindow(), this._infoWindow.show(t)), this) : this;
  },
  closeInfoWindow: function() {
    return this._infoWindow && this._infoWindow.hide(), this;
  },
  removeInfoWindow: function() {
    return this._unbindInfoWindow(), delete this._infoWinOptions, delete this._infoWindow, this;
  },
  _bindInfoWindow: function() {
    var t = this._infoWinOptions;
    return t ? (this._infoWindow = new n0(t), this._infoWindow.addTo(this), this) : this;
  },
  _unbindInfoWindow: function() {
    return this._infoWindow && (this.closeInfoWindow(), this._infoWindow.remove(), delete this._infoWindow), this;
  }
});
var Kk = new Y(0, 0), Qk = new Y(0, 0), A_ = new Y(0, 0), M_ = new Y(0, 0), r0 = [], tR = function(i) {
  Ot(t, i);
  function t() {
    return i.call(this, wv) || this;
  }
  var e = t.prototype;
  return e.checkUrl = function(n) {
    return !n || !De(n) ? n : Md(n);
  }, e.fetchImage = function(n, s, o, a) {
    n = this.checkUrl(n);
    var l = {
      url: n,
      fetchOptions: a
    };
    this.send(l, r0, o, s);
  }, t;
}(Id), zd = function(i) {
  Ot(t, i);
  function t(r) {
    var n;
    n = i.call(this, r) || this, n.tilesInView = {}, n.tilesLoading = {}, n._parentTiles = [], n._childTiles = [], n._tileQueue = [], n._tileQueueIds = /* @__PURE__ */ new Set();
    var s = r.getTileSize().width;
    return n.tileCache = new Tv(r.options.maxCacheSize * s / 512 * s / 512, function(o) {
      n.deleteTile(o);
    }), Ce.decodeImageInWorker && n.layer.options.decodeImageInWorker && (r.options.renderer === "gl" || !Ce.safari && !Ce.iosWeixin) && (n._tileImageWorkerConn = new tR()), n._compareTiles = nR.bind(kn(kn(n))), n;
  }
  var e = t.prototype;
  return e.getCurrentTileZoom = function() {
    return this._tileZoom;
  }, e.draw = function(n, s) {
    var o = this.getMap();
    if (this.isDrawable()) {
      var a = this.prepareCanvas();
      if (a && !a.intersects(this.canvasExtent2D)) {
        this.completeRender();
        return;
      }
      this._renderTimestamp !== n && (this._consumeTileQueue(), this._computeAvgTileAltitude(), this._renderTimestamp = n);
      var l, h = !1, u = this._frameTiles;
      if (u && n === u.timestamp) {
        if (u.empty)
          return;
        l = u;
      } else {
        if (l = this._getTilesInCurrentFrame(), !l) {
          this._frameTiles = {
            empty: !0,
            timestamp: n
          }, this.completeRender();
          return;
        }
        h = !0, this._frameTiles = l, this._frameTiles.timestamp = n, l.loadingCount && this.loadTileQueue(l.tileQueue);
      }
      var c = l, f = c.tiles, d = c.childTiles, p = c.parentTiles, g = c.placeholders, m = c.loading, v = c.loadingCount, _ = c.missedTiles, y = c.incompleteTiles;
      this._drawTiles(f, p, d, g, s, _, y), v || m || (!o.isAnimating() && (this._parentTiles.length || this._childTiles.length) && (this._parentTiles = [], this._childTiles = [], this.setToRedraw()), this.completeRender()), h && this.retireTiles();
    }
  }, e.getTileGridsInCurrentFrame = function() {
    return this._frameTileGrids;
  }, e.getCurrentTimestamp = function() {
    return this._renderTimestamp || 0;
  }, e._getTilesInCurrentFrame = function() {
    var n = this.getMap(), s = this.layer, o = s._isPyramidMode() && s.options.terrainTileMode, a = s.getTiles();
    if (this._frameTileGrids = a, a = a.tileGrids, !a || !a.length)
      return null;
    var l = a.reduce(function(Xt, Re) {
      return Xt + (Re && Re.tiles && Re.tiles.length || 0);
    }, 0);
    l >= this.tileCache.max / 2 && this.tileCache.setMaxSize(l * 2 + 1);
    var h = 0, u = !1, c = {}, f = [], d = [], p = {}, g = [], m = {}, v = [], _ = {}, y = {}, x = this.markTiles(), w = this._getLoadLimit(), b = a.length, T = this._tileZoom === void 0 && s.options.currentTilesFirst && !this._terrainHelper;
    this._tileZoom = a[0].zoom;
    var A = null, M = null;
    o && (A = [], M = /* @__PURE__ */ new Map());
    for (var S = 0; S < b; S++) {
      var P = a[S], C = P.tiles, k = P.parents || r0, O = k.length, R = T ? C : k.concat(C), I = void 0;
      R.length && (I = this._generatePlaceHolder(R[0].res));
      for (var D = 0, z = R.length; D < z; D++) {
        var H = R[D], G = H.id, $ = D < O, K = !1, dt = f.length;
        if (this._isLoadingTile(G))
          K = u = !0, this.markCurrent(this.tilesLoading[G], !0);
        else {
          var it = this.getCachedTile(H, $);
          if (it)
            $ || (it.image && this.isTileFadingIn(it.image) && (K = u = !0, this.setToRedraw()), this.isTileComplete(it) ? f.push(it) : (K = !0, o && M.set(G, it)));
          else {
            K = u = !0;
            var st = w && h + x[0] > w;
            if (!this._tileQueueIds.has(H.id) && !st && (!n.isInteracting() || n.isMoving() || n.isRotating())) {
              h++;
              var pt = G;
              y[pt] = H;
            }
          }
        }
        if (o && !$ && (f.length === dt ? A.push(H) : c[H.id] = 1), !o && !$ && K && !c[G]) {
          c[G] = 1, I && !_[G] && (H.cache = !1, v.push({
            image: I,
            info: H
          }), _[G] = 1);
          var Ht = this._findChildTiles(H);
          if (Ht.length && Ht.forEach(function(Xt) {
            m[Xt.info.id] || (g.push(Xt), m[Xt.info.id] = 1);
          }), !Ht.length || Ht.length !== 4) {
            var Rt = this._findParentTile(H);
            if (Rt) {
              var Tt = Rt.info.id;
              p[Tt] === void 0 && (p[Tt] = d.length, d.push(Rt));
            }
          }
        }
      }
    }
    var $t = [];
    if (o)
      for (var Wt = 0; Wt < A.length; Wt++) {
        var re = A[Wt].info ? A[Wt].info : A[Wt];
        if (!(!re.parent || c[re.id])) {
          var ie = this._findChildTiles(re), Kt = ie.tiles, fe = ie.missedTiles;
          if (Kt.length) {
            Ui(f, Kt), Ui($t, fe);
            continue;
          } else if (M.has(re.id)) {
            f.push(M.get(re.id)), M.delete(re.id);
            continue;
          }
          c[re.id] = 1, $t.push(re);
        }
      }
    return this.tileCache.shrink(), {
      childTiles: g,
      missedTiles: $t,
      parentTiles: d,
      tiles: f,
      incompleteTiles: M && Array.from(M.values()),
      placeholders: v,
      loading: u,
      loadingCount: h,
      tileQueue: y
    };
  }, e.removeTileCache = function(n) {
    delete this.tilesInView[n], this.tileCache.remove(n);
  }, e.isTileCachedOrLoading = function(n) {
    return this.tileCache.get(n) || this.tilesInView[n] || this.tilesLoading[n];
  }, e.isTileCached = function(n) {
    return !!(this.tileCache.get(n) || this.tilesInView[n]);
  }, e.isTileFadingIn = function(n) {
    return this._getTileFadingOpacity(n) < 1;
  }, e._drawTiles = function(n, s, o, a, l) {
    var h = this;
    s.length && (s.sort(this._compareTiles), this._parentTiles = s), o.length && (this._childTiles = o, this._childTiles.sort(this._compareTiles));
    var u = !0, c = this.canvas._parentTileTimestamp;
    (this.layer.constructor === Pn || this.layer.constructor === Hv) && (this._renderTimestamp === c ? u = !1 : this.canvas._parentTileTimestamp = this._renderTimestamp);
    var f = this.layer.options.renderer === "gl" && (!this.isGL || this.isGL()), d = {
      tiles: n,
      parentTiles: this._parentTiles,
      childTiles: this._childTiles,
      parentContext: l
    };
    if (this.onDrawTileStart(d, l), u && this.layer.options.opacity === 1) {
      this.layer._silentConfig = !0;
      var p = this.layer.options.fadeAnimation;
      this.layer.options.fadeAnimation = !1, f ? (this._drawChildTiles(o, l), this._drawParentTiles(this._parentTiles, l)) : (this._drawParentTiles(this._parentTiles, l), this._drawChildTiles(o, l)), this.layer.options.fadeAnimation = p, this.layer._silentConfig = !1;
    }
    this.drawingCurrentTiles = !0, n.sort(this._compareTiles);
    for (var g = 0, m = n.length; g < m; g++)
      this._drawTileAndCache(n[g], l);
    if (delete this.drawingCurrentTiles, u && this.layer.options.opacity < 1) {
      this.layer._silentConfig = !0;
      var v = this.layer.options.fadeAnimation;
      this.layer.options.fadeAnimation = !1, f ? (this._drawChildTiles(o, l), this._drawParentTiles(this._parentTiles, l)) : (this._drawParentTiles(this._parentTiles, l), this._drawChildTiles(o, l)), this.layer.options.fadeAnimation = v, this.layer._silentConfig = !1;
    }
    a.forEach(function(_) {
      return h._drawTile(_.info, _.image, l);
    }), this.onDrawTileEnd(d, l);
  }, e._drawChildTiles = function(n, s) {
    var o = this;
    this.drawingChildTiles = !0, n.forEach(function(a) {
      return o._drawTile(a.info, a.image, s);
    }), delete this.drawingChildTiles;
  }, e._drawParentTiles = function(n, s) {
    var o = this;
    this.drawingParentTiles = !0, this._parentTiles.forEach(function(a) {
      return o._drawTile(a.info, a.image, s);
    }), delete this.drawingParentTiles;
  }, e.onDrawTileStart = function() {
  }, e.onDrawTileEnd = function() {
  }, e._drawTile = function(n, s, o) {
    s && this.drawTile(n, s, o);
  }, e._drawTileAndCache = function(n, s) {
    this.isValidCachedTile(n) && this._addTileToCache(n.info, n.image), this._drawTile(n.info, n.image, s);
  }, e.drawOnInteracting = function(n, s, o) {
    this.draw(s, o);
  }, e.needToRedraw = function() {
    var n = this.getMap();
    return this._tileQueue.length ? !0 : n.getPitch() ? i.prototype.needToRedraw.call(this) : n.isRotating() || n.isZooming() ? !0 : n.isMoving() ? !!this.layer.options.forceRenderOnMoving : i.prototype.needToRedraw.call(this);
  }, e.hitDetect = function() {
    return !1;
  }, e._getLoadLimit = function() {
    return this.getMap().isInteracting() ? this.layer.options.loadingLimitOnInteracting : this.layer.options.loadingLimit || 0;
  }, e.isDrawable = function() {
    return this.getMap().getPitch() ? (console && console.warn("TileLayer with canvas renderer can't be pitched, use gl renderer ('renderer' : 'gl') instead."), this.clear(), !1) : !0;
  }, e.clear = function() {
    this.retireTiles(!0), this.tileCache.reset(), this.tilesInView = {}, this.tilesLoading = {}, this._tileQueue = [], this._tileQueueIds.clear(), this._parentTiles = [], this._childTiles = [], i.prototype.clear.call(this);
  }, e._isLoadingTile = function(n) {
    return !!this.tilesLoading[n];
  }, e.clipCanvas = function(n) {
    return i.prototype.clipCanvas.call(this, n);
  }, e._clipByPitch = function(n) {
    var s = this.getMap();
    if (s.getPitch() <= s.options.maxVisualPitch || !this.layer.options.clipByPitch)
      return !1;
    var o = s.getContainerExtent(), a = s.getDevicePixelRatio();
    return n.save(), n.strokeStyle = "rgba(0, 0, 0, 0)", n.beginPath(), n.rect(0, Math.ceil(o.ymin) * a, Math.ceil(o.getWidth()) * a, Math.ceil(o.getHeight()) * a), n.stroke(), n.clip(), !0;
  }, e.loadTileQueue = function(n) {
    for (var s in n)
      if (n.hasOwnProperty(s)) {
        var o = n[s], a = this.loadTile(o);
        a.loadTime === void 0 && (this.tilesLoading[o.id] = {
          image: a,
          current: !0,
          info: o
        });
      }
  }, e.loadTile = function(n) {
    var s = this, o = {};
    if (this.loadTileBitmap) {
      var a = function(u) {
        s.onTileLoad(u, n);
      };
      this.loadTileBitmap(n.url, n, a);
    } else if (this._tileImageWorkerConn && this.loadTileImage === this.constructor.prototype.loadTileImage)
      this._fetchImage(o, n);
    else {
      var l = this.layer.getTileSize(n.layer);
      o = new Image(), o.width = l.width, o.height = l.height, o.onload = this.onTileLoad.bind(this, o, n), o.onerror = this.onTileError.bind(this, o, n), this.loadTileImage(o, n.url);
    }
    return o;
  }, e._fetchImage = function(n, s) {
    var o = this;
    if (n instanceof Image)
      n.src = s.url;
    else {
      var a = s.x, l = s.y, h = Math.abs(a + l) % this._tileImageWorkerConn.workers.length;
      this._tileImageWorkerConn.fetchImage(s.url, h, function(u, c) {
        u ? o.onTileError(n, s, u) : uv(c, function(f) {
          o.onTileLoad(f, s);
        });
      }, this.layer.options.fetchOptions || {
        referrer: document.location.href,
        headers: {
          accept: "image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8"
        }
      });
    }
  }, e.loadTileImage = function(n, s) {
    var o = this.layer.options.crossOrigin;
    return W(o) || (n.crossOrigin = o), Qh(n, [s]);
  }, e.abortTileLoading = function(n, s) {
    s && s.id !== void 0 && this.removeTileLoading(s), n && n instanceof Image && (n.onload = S_, n.onerror = S_, n.src = lv);
  }, e.onTileLoad = function(n, s) {
    this.removeTileLoading(s), this._tileQueue.push({
      tileInfo: s,
      tileData: n
    }), this._tileQueueIds.add(s.id), this.setToRedraw();
  }, e.removeTileLoading = function(n) {
    delete this.tilesLoading[n.id], this.setToRedraw();
  }, e._consumeTileQueue = function() {
    for (var n = 0, s = this.layer.options.tileLimitPerFrame, o = this._tileQueue; o.length && (s <= 0 || n < s); ) {
      var a = o.shift(), l = a.tileData, h = a.tileInfo;
      this._tileQueueIds.has(h.id) && (this._tileQueueIds.delete(h.id), this.checkTileInQueue(l, h) && (this.consumeTile(l, h), n++));
    }
  }, e._computeAvgTileAltitude = function() {
    var n = 0, s = 0, o = 0;
    for (var a in this.tilesInView) {
      var l = this.tilesInView[a] && this.tilesInView[a].info;
      l && (n += l.minAltitude || 0, s += l.maxAltitude || 0, o++);
    }
    this.avgMinAltitude = n / o, this.avgMaxAltitude = s / o;
  }, e.checkTileInQueue = function() {
    return !0;
  }, e.consumeTile = function(n, s) {
    if (this.layer && this.tilesInView) {
      var o = {
        tile: s,
        tileImage: n
      };
      n = o.tileImage, this.resetTileLoadTime(n), this.removeTileLoading(s), this._addTileToCache(s, n), this.layer.fire("tileload", o), this.setToRedraw();
    }
  }, e.resetTileLoadTime = function(n) {
    n.loadTime !== 0 && (n.loadTime = Je());
  }, e.onTileError = function(n, s) {
    if (this.layer) {
      n.onerrorTick = n.onerrorTick || 0;
      var o = this.layer.options.tileRetryCount;
      if (o > n.onerrorTick) {
        n.onerrorTick++, this._fetchImage(n, s), this.removeTileLoading(s);
        return;
      }
      var a = this.layer.options.errorUrl;
      if (a)
        if (n instanceof Image && n.src !== a) {
          n.src = a, this.removeTileLoading(s);
          return;
        } else
          n = new Image(), n.src = a;
      this.abortTileLoading(n, s), n.loadTime = 0, this.removeTileLoading(s), this._addTileToCache(s, n), this.setToRedraw(), this.layer.fire("tileerror", {
        tile: s
      });
    }
  }, e.drawTile = function(n, s) {
    if (!(!s || !this.getMap())) {
      var o = n.extent2d, a = n.offset, l = Kk.set(o.xmin - a[0], o.ymax - a[1]), h = n.z, u = n.id, c = this.getMap(), f = c.getZoom(), d = this.context, p = c._pointAtResToContainerPoint(l, n.res, 0, Qk), g = c.getBearing(), m = g || f !== h, v = this.getTileOpacity(s, n), _ = d.globalAlpha;
      v < 1 && (d.globalAlpha = v), m || p._round();
      var y = p.x, x = p.y, w = n.extent2d.xmax - n.extent2d.xmin, b = n.extent2d.ymax - n.extent2d.ymin, T = this.layer, A = T ? T.options.bufferPixel : 0;
      if (m) {
        d.save(), d.translate(y, x), g && d.rotate(-g * Math.PI / 180), w += A, b += A;
        var M = c._getResolution();
        if (M !== n.res) {
          var S = n.res / M;
          d.scale(S, S);
        }
        y = x = 0;
      }
      if (Ct.image(d, s, y, x, w, b), this.layer.options.debug) {
        var P = this.layer.options.debugOutline;
        d.save(), d.strokeStyle = P, d.fillStyle = P, d.strokeWidth = 10, d.font = "20px monospace";
        var C = new Y(y, x);
        Ct.rectangle(d, C, {
          width: w,
          height: b
        }, 1, 0), Ct.fillText(d, this.getDebugInfo(u), C._add(32, b - 14), P), Ct.drawCross(d, y + w / 2, x + b / 2, 2, P), d.restore();
      }
      m && d.restore(), d.globalAlpha !== _ && (d.globalAlpha = _), this.setCanvasUpdated();
    }
  }, e.getDebugInfo = function(n) {
    var s = n.split("_"), o = s.length;
    return s[o - 3] + "/" + s[o - 2] + "/" + s[o - 1];
  }, e.findChildTiles = function(n) {
    return this._findChildTiles(n);
  }, e._findChildTiles = function(n) {
    var s = this._getLayerOfTile(n.layer), o = s && s.options.terrainTileMode && s._isPyramidMode();
    if (!s || !s.options.background && !o || n.z > this.layer.getMaxZoom())
      return r0;
    var a = this.getMap(), l = [];
    if (s._isPyramidMode()) {
      if (!o) {
        for (var h = this._getLayerOfTile(n.layer), u = 2, c = n.x * 2, f = n.y * 2, d = n.z + 1, p = [], g = 0; g < 2; g++)
          for (var m = 0; m < 2; m++)
            p.push(c + g, f + m, d);
        for (; p.length; ) {
          var v = p.pop(), _ = p.pop(), y = p.pop(), x = h._getTileId(y, _, v, n.layer), w = v + 1 <= n.z + u, b = this.tileCache.getAndRemove(x);
          if (b) {
            if (this.isValidCachedTile(b))
              l.push(b), this.tileCache.add(x, b);
            else if (w)
              for (var T = 0; T < 2; T++)
                for (var A = 0; A < 2; A++)
                  p.push(y * 2 + T, _ * 2 + A, v + 1);
          } else if (w)
            for (var M = 0; M < 2; M++)
              for (var S = 0; S < 2; S++)
                p.push(y * 2 + M, _ * 2 + S, v + 1);
        }
        return l;
      }
      var P;
      o && (P = []);
      for (var C = n.x * 2, k = n.y * 2, O = n.z + 1, R = [], I = 0; I < 2; I++)
        for (var D = 0; D < 2; D++) {
          var z = C + I, H = k + D, G = O, $ = s._getTileId(z, H, G, n.layer), K = this.tileCache.getAndRemove($);
          K && this.isValidCachedTile(K) ? (l.push(K), this.tileCache.add($, K), R.push(null)) : R.push($);
        }
      if (l.length < 4)
        for (var dt = 0, it = 0; it < 2; it++)
          for (var st = 0; st < 2; st++) {
            var pt = R[dt++];
            if (pt) {
              for (var Ht = C + it, Rt = k + st, Tt = O, $t = l.length, Wt = [], re = 0; re < 2; re++)
                for (var ie = 0; ie < 2; ie++) {
                  var Kt = Ht * 2 + re, fe = Rt * 2 + ie, Xt = Tt + 1, Re = s._getTileId(Kt, fe, Xt, n.layer), Oe = this.tileCache.getAndRemove(Re);
                  Oe && this.isValidCachedTile(Oe) ? (l.push(Oe), this.tileCache.add(Re, Oe), Wt.push(null)) : Wt.push(Re);
                }
              if (o && l.length - $t < 4) {
                var oe = s.tileInfoCache.get(pt) || s._createChildNode(n, it, st, [0, 0], pt);
                if (l.length - $t === 0)
                  P.push(oe);
                else
                  for (var nr = 0, Ke = 0; Ke < 2; Ke++)
                    for (var Ye = 0; Ye < 2; Ye++) {
                      var We = Wt[nr++];
                      if (We) {
                        var bn = this.layer.tileInfoCache.get(We) || s._createChildNode(oe, Ke, Ye, [0, 0], We);
                        P.push(bn);
                      }
                    }
              }
            }
          }
      return o ? {
        tiles: l,
        missedTiles: P
      } : l;
    }
    for (var wn = 1, On = n.res, $e = n.extent2d.getMin(), be = n.extent2d.getMax(), Ee = s._project(a._pointToPrjAtRes($e, On, A_), A_), Ze = s._project(a._pointToPrjAtRes(be, On, M_), M_), yn = 1; yn < wn; yn++)
      this._findChildTilesAt(l, Ee, Ze, s, n.z + yn);
    return l;
  }, e._findChildTilesAt = function(n, s, o, a, l) {
    var h = a.getId(), u = a.getSpatialReference().getResolution(l);
    if (u)
      for (var c = a._getTileConfig().getTileIndex(s, u), f = a._getTileConfig().getTileIndex(o, u), d = Math.min(c.idx, f.idx), p = Math.max(c.idx, f.idx), g = Math.min(c.idy, f.idy), m = Math.max(c.idy, f.idy), v, _, y = d; y < p; y++)
        for (var x = g; x < m; x++)
          v = a._getTileId(y, x, l, h), _ = this.tileCache.getAndRemove(v), _ && this.isValidCachedTile(_) && (n.push(_), this.tileCache.add(v, _));
  }, e.findParentTile = function(n, s) {
    return this._findParentTile(n, s);
  }, e._findParentTile = function(n, s) {
    var o = this.getMap(), a = this._getLayerOfTile(n.layer);
    if (!a || !a.options.background && !a.options.terrainTileMode)
      return null;
    var l = a.getMinZoom(), h = s || n.z - l;
    if (a._isPyramidMode()) {
      for (var u = n.z - h, c = n.z - 1; c >= u; c--) {
        var f = n.z - c, d = Math.pow(2, f), p = Math.floor(n.x / d), g = Math.floor(n.y / d), m = void 0;
        c === n.z - 1 ? m = n.parent : m = a._getTileId(p, g, c, n.layer);
        var v = this.tileCache.getAndRemove(m);
        if (v && this.isValidCachedTile(v))
          return this.tileCache.add(m, v), v;
      }
      return null;
    }
    for (var _ = a.getSpatialReference(), y = _.getZoomDirection(), x = n.res, w = n.extent2d.getCenter(), b = a._project(o._pointToPrjAtRes(w, x)), T = 1; T <= h; T++) {
      var A = n.z - y * T, M = _.getResolution(A);
      if (M) {
        var S = a._getTileConfig().getTileIndex(b, M), P = a._getTileId(S.x, S.y, A, n.layer), C = this.tileCache.getAndRemove(P);
        if (C)
          return this.tileCache.add(P, C), C;
      }
    }
    return null;
  }, e.isValidCachedTile = function(n) {
    return !!n.image;
  }, e.isTileComplete = function() {
    return !0;
  }, e._getLayerOfTile = function(n) {
    return this.layer.getChildLayer ? this.layer.getChildLayer(n) : this.layer;
  }, e.getCachedTile = function(n, s) {
    var o = n.id, a = this.tilesInView, l = this.tileCache.getAndRemove(o);
    if (l) {
      s || (a[o] = l);
      var h = this.tilesLoading;
      if (h && h[o]) {
        this.markCurrent(h[o], !1);
        var u = h[o], c = u.image, f = u.info;
        this.abortTileLoading(c, f), delete h[o];
      }
    } else
      l = a[o];
    return l && (l.current = !0, this.isValidCachedTile(l) && this.tileCache.add(o, l)), l;
  }, e._addTileToCache = function(n, s) {
    this.isValidCachedTile({
      info: n,
      image: s
    }) && (this.tilesInView[n.id] = {
      image: s,
      current: !0,
      info: n
    });
  }, e.getTileOpacity = function(n, s) {
    var o = this._getTileFadingOpacity(n);
    if (this.layer.getChildLayer) {
      var a = this.layer.getLayer(s.layer);
      a && (o *= a.options.opacity);
    }
    return o;
  }, e._getTileFadingOpacity = function(n) {
    return !this.layer.options.fadeAnimation || !n.loadTime ? 1 : Math.min(1, (Je() - n.loadTime) / this.layer.options.fadeDuration);
  }, e.onRemove = function() {
    this.clear(), delete this.tileCache, delete this._tilePlaceHolder, delete this._tileZoom, i.prototype.onRemove.call(this);
  }, e.markCurrent = function(n, s) {
    n.current = s;
  }, e.markTiles = function() {
    var n = 0, s = 0;
    if (this.tilesLoading)
      for (var o in this.tilesLoading)
        this.markCurrent(this.tilesLoading[o], !1), n++;
    if (this.tilesInView)
      for (var a in this.tilesInView)
        this.markCurrent(this.tilesInView[a], !1), s++;
    return [n, s];
  }, e.retireTiles = function(n) {
    for (var s in this.tilesLoading) {
      var o = this.tilesLoading[s];
      (n || !o.current) && (o.image && this.abortTileLoading(o.image, o.info), this.deleteTile(o), this.removeTileLoading(o.info));
    }
    for (var a in this.tilesInView) {
      var l = this.tilesInView[a];
      l.current || (delete this.tilesInView[a], this.tileCache.has(a) || this.deleteTile(l));
    }
  }, e.deleteTile = function(n) {
    if (!(!n || !n.image)) {
      var s = n.info.id;
      this._tileQueueIds.has(s) && this._tileQueueIds.delete(s), n.image.close && n.image.close(), n.image instanceof Image && (n.image.onload = null, n.image.onerror = null);
    }
  }, e._generatePlaceHolder = function(n) {
    var s = this.getMap(), o = this.layer.options.placeholder;
    if (!o || s.getPitch())
      return null;
    var a = this.layer.getTileSize(), l = n / s._getResolution(), h = this._tilePlaceHolder = this._tilePlaceHolder || Ct.createCanvas(1, 1, s.CanvasClass);
    return h.width = a.width * l, h.height = a.height * l, Be(o) ? o(h) : eR(h), h;
  }, e.setTerrainHelper = function(n) {
    this._terrainHelper = n;
  }, t;
}(Ll);
Pn.registerRenderer("canvas", zd);
function S_() {
  return !1;
}
function eR(i) {
  var t = i.getContext("2d"), e = i.width, r = i.height, n = e / 16, s = r / 16;
  t.beginPath();
  for (var o = 0; o < 16; o++)
    t.moveTo(0, o * s), t.lineTo(e, o * s), t.moveTo(o * n, 0), t.lineTo(o * n, r);
  t.strokeStyle = "rgba(180, 180, 180, 0.1)", t.lineWidth = 1, t.stroke(), t.beginPath();
  for (var a = [[0, 0], [e, 0], [0, r], [e, r], [0, 0], [0, r], [e, 0], [e, r], [0, r / 2], [e, r / 2], [e / 2, 0], [e / 2, r]], l = 1; l < a.length; l += 2)
    t.moveTo(a[l - 1][0], a[l - 1][1]), t.lineTo(a[l][0], a[l][1]);
  t.lineWidth = 1 * 4, t.stroke();
}
function nR(i, t) {
  return Math.abs(this._tileZoom - i.info.z) - Math.abs(this._tileZoom - t.info.z);
}
var rR = new Y(0, 0), iR = {
  properties: {}
}, Wv = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.isDrawable = function() {
    return !0;
  }, e.needToRedraw = function() {
    var n = this.getMap();
    return this.isGL() && !n.getPitch() && n.isZooming() && !n.isMoving() && !n.isRotating() ? !0 : i.prototype.needToRedraw.call(this);
  }, e.onDrawTileStart = function(n, s) {
    var o = this.gl;
    o.enable(o.DEPTH_TEST), o.depthFunc(o.LEQUAL), o.enable(o.POLYGON_OFFSET_FILL), o.enable(o.STENCIL_TEST), o.stencilOp(o.KEEP, o.KEEP, o.REPLACE);
    var a = !!this.layer.options.depthMask;
    if (o.depthMask(a), s && s.renderTarget) {
      var l = s.renderTarget.fbo;
      if (l) {
        var h = s.renderTarget.getFramebuffer(l);
        o.bindFramebuffer(o.FRAMEBUFFER, h);
      }
    }
  }, e.onDrawTileEnd = function(n, s) {
    var o = this.gl;
    if (s && s.renderTarget) {
      var a = s.renderTarget.fbo;
      a && o.bindFramebuffer(o.FRAMEBUFFER, null);
    }
  }, e.drawTile = function(n, s, o) {
    if (!(o && o.sceneFilter && !o.sceneFilter(iR))) {
      var a = this.getMap();
      if (!(!n || !a || !s)) {
        var l = n._glScale = n._glScale || n.res / a.getGLRes(), h = n.extent2d.xmax - n.extent2d.xmin, u = n.extent2d.ymax - n.extent2d.ymin;
        if (n.cache !== !1 && this._bindGLBuffer(s, h, u), !this.isGL()) {
          i.prototype.drawTile.call(this, n, s);
          return;
        }
        var c = n.extent2d, f = n.offset, d = rR.set(c.xmin - f[0], n.extent2d.ymax - f[1]), p = d.x * l, g = d.y * l, m = this.getTileOpacity(s, n), v = null;
        this.layer.options.debug && (v = this.getDebugInfo(n.id));
        var _ = this.gl;
        _.stencilFunc(_.LEQUAL, Math.abs(this.getCurrentTileZoom() - n.z), 255);
        var y = this.layer.getPolygonOffset(), x = this.drawingCurrentTiles ? y : y + 1;
        _.polygonOffset(x, x), this.drawGLImage(s, p, g, h, u, l, m, v), this._getTileFadingOpacity(s) < 1 ? this.setToRedraw() : this.setCanvasUpdated();
      }
    }
  }, e._bindGLBuffer = function(n, s, o) {
    n.glBuffer || (n.glBuffer = this.bufferTileData(0, 0, s, o));
  }, e.loadTileImage = function(n, s) {
    var o = this.layer.options.crossOrigin;
    n.crossOrigin = o !== null ? o : "", n.src = s;
  }, e.onCanvasCreate = function() {
    (!this.canvas.gl || !this.canvas.gl.wrap) && this.createCanvas2();
  }, e.createContext = function() {
    i.prototype.createContext.call(this), this.createGLContext();
  }, e.resizeCanvas = function(n) {
    this.canvas && (i.prototype.resizeCanvas.call(this, n), this.resizeGLCanvas());
  }, e.clearCanvas = function() {
    this.canvas && (i.prototype.clearCanvas.call(this), this.clearGLCanvas());
  }, e.getCanvasImage = function() {
    if (!this.isGL() || !this.canvas2)
      return i.prototype.getCanvasImage.call(this);
    var n = i.prototype.getCanvasImage.call(this);
    return n && (n.image = this.canvas2), n;
  }, e.isGL = function() {
    if (this.canvas.gl && this.canvas.gl.wrap)
      return !0;
    var n = this.getMap();
    return n && (n.getPitch() || n.getBearing()) || this.layer && !!this.layer.options.fragmentShader;
  }, e.deleteTile = function(n) {
    i.prototype.deleteTile.call(this, n), n && n.image && this.disposeImage(n.image), delete n.image;
  }, e.onRemove = function() {
    i.prototype.onRemove.call(this), this.removeGLCanvas();
  }, t;
}(jv(zd));
Pn.registerRenderer("gl", Wv);
function RA(i) {
  var t = this.layer.getTileSize(), e = this.canvas.constructor, r = this.getMap(), n = r.getDevicePixelRatio(), s = Ct.createCanvas(t.width * n, t.height * n, e);
  s.layer = this.layer;
  var o = this, a = new Y(i.extent2d.xmin, i.extent2d.ymax), l = new dn(r.pointToCoordinate(a), r.pointToCoordinate(a.add(t.width, t.height)), r.getProjection());
  return this.layer.drawTile(s, {
    url: i.url,
    point: a,
    center: r.pointToCoordinate(a.add(t.width / 2, t.height / 2)),
    extent: l,
    z: i.z,
    x: i.x,
    y: i.y
  }, function(h) {
    if (h) {
      o.onTileError(s, i);
      return;
    }
    o.onTileLoad(s, i);
  }), s;
}
var IA = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.loadTile = function() {
    return RA.apply(this, arguments);
  }, t;
}(zd), DA = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.loadTile = function() {
    return RA.apply(this, arguments);
  }, t;
}(Wv);
Bv.registerRenderer("canvas", IA);
Bv.registerRenderer("gl", DA);
var sR = typeof Int8Array < "u" ? new Int8Array([-1, 1, 0, -1, -1, 0, 1, 1, 0, 1, -1, 0]) : [], oR = `
    attribute vec3 a_position;
    uniform mat4 transform;

    void main()
    {
        gl_Position = transform * vec4(a_position, 1.0);
    }
`, aR = `
    precision mediump float;
    uniform vec3 color;
    void main()
    {
        gl_FragColor = vec4(color, 1.0);
    }
`, lR = function() {
  function i(e, r, n) {
    this.gl = e, this.quadVertices = r || sR, this.attributes = ["a_position", 3, hR(r)], this.debug = n;
  }
  var t = i.prototype;
  return t.start = function() {
    var r = this.gl;
    r.enable(r.STENCIL_TEST), r.stencilMask(255), r.stencilOp(r.KEEP, r.REPLACE, r.REPLACE), r.depthMask(!1), this._save(), this.buffer || (this._createBuffer(), this._createProgram()), r.useProgram(this.program), r.bindBuffer(r.ARRAY_BUFFER, this.buffer), PA(r, this.program, this.attributes), this.transformLoc || (this.transformLoc = r.getUniformLocation(this.program, "transform")), this.colorLoc || (this.colorLoc = r.getUniformLocation(this.program, "color")), !this.debug && r.colorMask(!1, !1, !1, !1);
  }, t.end = function() {
    var r = this.gl;
    r.depthMask(!0), this._restore(), !this.debug && r.colorMask(!0, !0, !0, !0);
  }, t.draw = function(r) {
    var n = this.gl;
    n.uniformMatrix4fv(this.transformLoc, !1, r), n.uniform3fv(this.colorLoc, [Math.random(), Math.random(), Math.random()]), n.drawArrays(n.TRIANGLE_STRIP, 0, 4);
  }, t.remove = function() {
    var r = this.gl;
    return this.buffer && r.deleteBuffer(this.buffer), this.program && (r.deleteShader(this.program.fragmentShader), r.deleteShader(this.program.vertexShader), r.deleteProgram(this.program)), delete this.transformLoc, delete this.gl, this;
  }, t.stencilMask = function(r) {
    return this.gl.stencilMask(r), this;
  }, t.stencilFunc = function(r, n, s) {
    return this.ref = n, this.gl.stencilFunc(r, n, s), this;
  }, t.stencilOp = function(r, n, s) {
    return this.gl.stencilOp(r, n, s), this;
  }, t.resetFunc = function() {
    return this.ref = 1, this.gl.stencilFunc(this.gl.ALWAYS, 1, 255), this;
  }, t._save = function() {
    var r = this.gl;
    this._savedProgram = r.program;
  }, t._restore = function() {
    var r = this.gl;
    r.program = this._savedProgram, r.program && r.useProgram(r.program);
  }, t._createBuffer = function() {
    var r = this.gl;
    if (this.buffer = r.createBuffer(), !this.buffer)
      throw new Error("Failed to create the buffer object");
    r.bindBuffer(r.ARRAY_BUFFER, this.buffer), r.bufferData(r.ARRAY_BUFFER, this.quadVertices, r.STATIC_DRAW);
  }, t._createProgram = function() {
    var r = CA(this.gl, oR, aR), n = r.program, s = r.vertexShader, o = r.fragmentShader;
    n.vertexShader = s, n.fragmentShader = o, this.program = n;
  }, i;
}();
function hR(i) {
  return i instanceof Float32Array ? "FLOAT" : i instanceof Int16Array ? "SHORT" : i instanceof Uint16Array ? "UNSIGNED_SHORT" : i instanceof Int8Array ? "BYTE" : i instanceof Uint8Array || i instanceof Uint8ClampedArray ? "UNSIGNED_BYTE" : "FLOAT";
}
var FA = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.checkResources = function() {
    var n = this._geosToCheck || [];
    if (!this._resourceChecked && this.layer._geoList && Ui(n, this.layer._geoList), !sn(n))
      return [];
    for (var s = [], o = {}, a = n.length - 1; a >= 0; a--) {
      var l = n[a], h = l._getExternalResources();
      if (h.length)
        if (!this.resources)
          s.push.apply(s, h);
        else
          for (var u = 0; u < h.length; u++) {
            var c = h[u][0];
            !this.resources.isResourceLoaded(h[u]) && !o[c] && (s.push(h[u]), o[c] = 1);
          }
    }
    return this._resourceChecked = !0, delete this._geosToCheck, s;
  }, e.render = function() {
    return this.layer._sortGeometries(), i.prototype.render.apply(this, arguments);
  }, e._addGeoToCheckRes = function(n) {
    n && (Array.isArray(n) || (n = [n]), this._geosToCheck || (this._geosToCheck = []), Ui(this._geosToCheck, n));
  }, e.onGeometryAdd = function(n) {
    this._addGeoToCheckRes(n), cs(this);
  }, e.onGeometryRemove = function() {
    cs(this);
  }, e.onGeometrySymbolChange = function(n) {
    this._addGeoToCheckRes(n.target), cs(this);
  }, e.onGeometryShapeChange = function() {
    cs(this);
  }, e.onGeometryPositionChange = function() {
    cs(this);
  }, e.onGeometryZIndexChange = function() {
    cs(this);
  }, e.onGeometryShow = function() {
    cs(this);
  }, e.onGeometryHide = function() {
    cs(this);
  }, e.onGeometryPropertiesChange = function() {
    cs(this);
  }, t;
}(Ll);
function cs(i) {
  i.layer.options.drawImmediate && i.render(), i.setToRedraw();
}
var uR = new Se(), cc = [], tg = new Se(), cR = "center", C_ = new Ru();
function P_(i) {
  if (!i)
    return null;
  var t = i.getContext("2d");
  return t.clearRect(0, 0, i.width, i.height), t;
}
function nh(i) {
  return i && i.options.progressiveRender && i.options.progressiveRenderDebug;
}
var LA = function(i) {
  Ot(t, i);
  function t() {
    return i.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.setToRedraw = function() {
    return i.prototype.setToRedraw.call(this), this._resetProgressiveRender(), this;
  }, e._geoIsCollision = function(n, s) {
    if (!n)
      return !1;
    var o = n.options.collision;
    if (!o)
      return !1;
    if (n.isPoint && n.getContainerExtent) {
      n.bbox || (n.bbox = [0, 0, 0, 0]);
      var a = this.layer.options.collisionBufferSize, l = n.getContainerExtent();
      if (!l)
        return !1;
      if (n.bbox[0] = l.xmin - a, n.bbox[1] = l.ymin - a, n.bbox[2] = l.xmax + a, n.bbox[3] = l.ymax + a, s.collides(n.bbox))
        return !0;
      s.insertBox(n.bbox);
    }
    return !1;
  }, e.getImageData = function() {
    if (!this._lastRenderTime || Je() - this._lastRenderTime < 32 || !this.context || !this.context.canvas)
      return null;
    if (!this._imageData) {
      var n = this.context.canvas, s = n.width, o = n.height;
      try {
        this._imageData = this.context.getImageData(0, 0, s, o);
      } catch (a) {
        console.warn(`hit detect failed with tainted canvas, some geometries have external resources in another domain:
`, a);
      }
    }
    return this._imageData;
  }, e.clearImageData = function() {
    this._imageData = null, delete this._imageData, this._lastRenderTime = Je();
  }, e.checkResources = function() {
    var n = this, s = i.prototype.checkResources.apply(this, arguments), o = this.layer.getStyle();
    return o && (Array.isArray(o) || (o = [o]), o.forEach(function(a) {
      for (var l = Ou(a.symbol, !0), h = 0, u = l.length; h < u; h++)
        n.resources.isResourceLoaded(l[h]) || s.push(l[h]);
    })), s;
  }, e.needToRedraw = function() {
    if (this.isProgressiveRender() && !this.renderEnd)
      return !0;
    var n = this.getMap();
    return n.isInteracting() && this.layer.options.enableAltitude ? !0 : n.isZooming() && !n.isRotating() && !n.getPitch() && !this._hasPoint && this.layer.constructor === Rs ? !1 : i.prototype.needToRedraw.call(this);
  }, e.draw = function() {
    if (this.getMap()) {
      if (!this.layer.isVisible() || this.layer.isEmpty()) {
        this.clearCanvas(), this.completeRender();
        return;
      }
      this.prepareCanvas(), this.drawGeos(), this.completeRender();
    }
  }, e.isBlank = function() {
    return !this.context || this.isProgressiveRender() ? !1 : !this.context.canvas._drawn;
  }, e.drawOnInteracting = function() {
    if (this._geosToDraw) {
      this._updateMapStateCache(), this._updateDisplayExtent();
      var n = this.getMap(), s = this.layer.getCount(), o = this.mapStateCache.resolution;
      (n.isZooming() && n.options.seamlessZoom && this._drawnRes !== void 0 && o > this._drawnRes * 1.5 && this._geosToDraw.length < s || n.isMoving() || n.isInteracting()) && (this.prepareToDraw(), this._batchConversionMarkers(this.mapStateCache.glRes), this._onlyHasPoint || this._checkGeos(), this._drawnRes = o), this._sortByDistanceToCamera(n.cameraPosition);
      var a = this.layer.options, l = a.collision, h = a.collisionDelay;
      if (l) {
        var u = Je();
        this._lastCollisionTime || (this._lastCollisionTime = u), u - this._lastCollisionTime <= h ? this._geosToDraw = this._lastGeosToDraw || this._geosToDraw : (this._collidesGeos(), this._lastCollisionTime = u);
      }
      for (var c = 0, f = this._geosToDraw.length; c < f; c++) {
        var d = this._geosToDraw[c];
        if (!d._isCheck && !d.isVisible()) {
          delete d._cPoint, delete d._inCurrentView;
          continue;
        }
        d._paint(this._displayExtent), this._geosToDraw[c]._cPoint = void 0, this._geosToDraw[c]._inCurrentView = void 0;
      }
      this.clearImageData(), this._lastGeosToDraw = this._geosToDraw, nh(this.layer) && console.log("progressiveRender on drawOnInteracting page:", this.page);
    }
  }, e.show = function() {
    this.layer.forEach(function(n) {
      n._repaint();
    }), i.prototype.show.apply(this, arguments);
  }, e.forEachGeo = function(n, s) {
    this.layer.forEach(n, s);
  }, e._checkGeos = function() {
    for (var n = this._getCurrentNeedRenderGeos(), s = 0, o = n.length; s < o; s++)
      this.checkGeo(n[s]);
    return this;
  }, e.drawGeos = function() {
    this._drawSnapshot(), this._updateMapStateCache(), this._drawnRes = this.mapStateCache.resolution, this._updateDisplayExtent(), this.prepareToDraw(), this._batchConversionMarkers(this.mapStateCache.glRes), this._onlyHasPoint || this._checkGeos(), this._sortByDistanceToCamera(this.getMap().cameraPosition), this._collidesGeos();
    for (var n = 0, s = this._geosToDraw.length; n < s; n++)
      this._geosToDraw[n]._paint(), this._geosToDraw[n]._cPoint = void 0, this._geosToDraw[n]._inCurrentView = void 0;
    this.clearImageData(), this._lastGeosToDraw = this._geosToDraw, nh(this.layer) && console.log("progressiveRender drawGeos page:", this.page), this._snapshot(), this._setDrawGeosDrawTime();
  }, e.prepareToDraw = function() {
    return this.layer._drawTime = Je(), this._hasPoint = !1, this._geosToDraw = [], this;
  }, e._setDrawGeosDrawTime = function() {
    for (var n = Je(), s = this.layer._drawTime, o = this.getGeoPainterList(), a = 0, l = o.length; a < l; a++) {
      var h = o[a];
      h && h._setDrawTime && h._setDrawTime(s);
    }
    return nh(this.layer) && console.log("_setDrawGeosDrawTime time:", Je() - n + "ms"), this;
  }, e.checkGeo = function(n) {
    if (n.isPoint && this._onlyHasPoint !== void 0) {
      n._inCurrentView && (this._hasPoint = !0, n._isCheck = !0, this._geosToDraw.push(n));
      return;
    }
    if (n._isCheck = !1, !(!n || !n.isVisible() || !n.getMap() || !n.getLayer() || !n.getLayer().isCanvasRender())) {
      var s = n._getPainter(), o = !0;
      if (n._inCurrentView)
        o = !0;
      else if (n._inCurrentView === !1)
        o = !1;
      else {
        var a = s.get2DExtent(this.resources, uR);
        (!a || !a.intersects(this._displayExtent)) && (o = !1);
      }
      o && (s.hasPoint() && (this._hasPoint = !0), n._isCheck = !0, this._geosToDraw.push(n));
    }
  }, e._collidesGeos = function() {
    var n = this.layer.options.collision;
    if (!n)
      return this;
    var s = this.layer.options.collisionScope, o = this.layer.getMap(), a = s === "map" ? o.getCollisionIndex() : C_;
    a === C_ && a.clear();
    var l = this._geosToDraw;
    this._geosToDraw = [];
    for (var h = 0, u = l.length; h < u; h++)
      this._geoIsCollision(l[h], a) || this._geosToDraw.push(l[h]);
    return this;
  }, e.onZoomEnd = function() {
    delete this.canvasExtent2D, i.prototype.onZoomEnd.apply(this, arguments);
  }, e.onRemove = function() {
    this.forEachGeo(function(n) {
      n.onHide();
    }), delete this._geosToDraw, delete this.snapshotCanvas, delete this.pageGeos, delete this.geoPainterList;
  }, e.onGeometryPropertiesChange = function(n) {
    n && this.layer._styleGeometry(n.target), i.prototype.onGeometryPropertiesChange.call(this, n);
  }, e._updateDisplayExtent = function() {
    var n = this.canvasExtent2D;
    if (this._maskExtent) {
      if (!this._maskExtent.intersects(n)) {
        this.completeRender();
        return;
      }
      n = n.intersection(this._maskExtent);
    }
    this._displayExtent = n;
  }, e.identifyAtPoint = function(n, s) {
    s === void 0 && (s = {});
    var o = this.getGeosForIdentify();
    return o ? this.layer._hitGeos(o, n, s) : [];
  }, e._updateMapStateCache = function() {
    var n = this.getMap(), s = n._pointToContainerPoint(this.middleWest)._add(0, -n.height / 2), o = n.getResolution(), a = n.getPitch(), l = n.getBearing(), h = n.getGLScale(), u = n.getGLRes(), c = n.getContainerExtent(), f = n._get2DExtent(), d = n._get2DExtentAtRes(u);
    return this.mapStateCache = {
      resolution: o,
      pitch: a,
      bearing: l,
      glScale: h,
      glRes: u,
      _2DExtent: f,
      glExtent: d,
      containerExtent: c,
      offset: s
    }, this;
  }, e._batchConversionMarkers = function(n) {
    if (this._onlyHasPoint = void 0, !this._constructorIsThis())
      return [];
    var s = [], o = [], a = [], l = {}, h = this.layer, u = h.options, c = h.getAltitude ? h.getAltitude() : 0, f = h.isCanvasRender();
    this._onlyHasPoint = !0;
    for (var d = 0, p = this._getCurrentNeedRenderGeos(), g = 0, m = p.length; g < m; g++) {
      var v = p[g];
      if (v.isPoint) {
        var _ = v._painter;
        _ || (_ = v._getPainter());
        var y = _.getRenderPoints(cR)[0][0], x = u.enableAltitude ? v._getAltitude() : c;
        l[x] === void 0 && (l[x] = _.getAltitude()), s[d] = y, a[d] = l[x], o[d] = v, d++;
      } else
        this._onlyHasPoint = !1;
    }
    if (d === 0)
      return [];
    var w = this.getMap(), b = eu(s, "_pt");
    b = w._pointsAtResToContainerPoints(s, n, a, b);
    for (var T = w.getContainerExtent(), A = T.xmax, M = T.ymax, S = T.xmin, P = T.ymin, C = {}, k = 0, O = o.length; k < O; k++) {
      var R = o[k];
      if (R._cPoint = b[k], !R._cPoint) {
        R._inCurrentView = !1;
        continue;
      }
      var I = b[k], D = I.x, z = I.y;
      if (R._inCurrentView = D >= S && z >= P && D <= A && z <= M, !R._inCurrentView) {
        var H = R.getSymbolHash(), G = void 0;
        H ? G = C[H] = C[H] || R._painter.getFixedExtent() : G = R._painter.getFixedExtent(), tg.set(G.xmin, G.ymin, G.xmax, G.ymax), tg._add(b[k]), R._inCurrentView = tg.intersects(T);
      }
      R._inCurrentView && ((!R.isVisible() || !f) && (R._inCurrentView = !1), this._onlyHasPoint && R._inCurrentView && (this._hasPoint = !0, R._isCheck = !0, this._geosToDraw.push(R)));
    }
    return b;
  }, e._sortByDistanceToCamera = function(n) {
    if (this.layer.options.sortByDistanceToCamera && this._geosToDraw.length) {
      var s = this.getMap(), o = s.distanceToPoint(1e3, 0, s.getGLScale()).x, a = o / 1e3, l = "center";
      this._geosToDraw.sort(function(h, u) {
        if (!h.isPoint || !u.isPoint)
          return 0;
        var c = h._painter, f = u._painter;
        if (!c || !f)
          return 0;
        var d = c.getRenderPoints(l)[0][0], p = f.getRenderPoints(l)[0][0], g = c.getAltitude() * a, m = f.getAltitude() * a;
        Lr(cc, d.x, d.y, g);
        var v = e0(cc, n);
        Lr(cc, p.x, p.y, m);
        var _ = e0(cc, n);
        return _ - v;
      });
    }
  }, e._constructorIsThis = function() {
    return this.constructor === t;
  }, e.isProgressiveRender = function() {
    var n = this.layer;
    if (!n)
      return !1;
    var s = n.options || {}, o = s.progressiveRender, a = s.collision;
    return a ? !1 : o;
  }, e.getGeosForIdentify = function() {
    return this.isProgressiveRender() ? this.pageGeos || [] : this._geosToDraw || [];
  }, e.getGeoPainterList = function() {
    if (!this.isProgressiveRender()) {
      for (var n = [], s = this._geosToDraw || [], o = 0, a = s.length; o < a; o++)
        n.push(s[o]._painter);
      return n;
    }
    return this.geoPainterList || [];
  }, e._checkSnapshotCanvas = function() {
    if (!this.isProgressiveRender())
      return delete this.snapshotCanvas, null;
    var n = this.canvas;
    if (!n)
      return delete this.snapshotCanvas, null;
    this.snapshotCanvas || (this.snapshotCanvas = Ct.createCanvas(1, 1));
    var s = this.snapshotCanvas, o = n.width, a = n.height, l = n.style;
    return (s.width !== o || s.height !== a) && (s.width = o, s.height = a), (s.style.width !== l.width || s.style.height !== l.height) && (s.style.width = l.width, s.style.height = l.height), s;
  }, e._getCurrentNeedRenderGeos = function() {
    var n = this.layer._geoList || [];
    if (!this.isProgressiveRender())
      return n;
    if (this.renderEnd)
      return [];
    var s = this.layer, o = s.options.progressiveRenderCount, a = o, l = this.page, h = (l - 1) * a, u = l * a, c = n.slice(h, u);
    return c;
  }, e._resetProgressiveRender = function() {
    nh(this.layer) && console.log("progressiveRender resetProgressiveRender"), this.renderEnd = !1, this.page = 1, this.pageGeos = [], this.geoPainterList = [], this.maxTolerance = 0, this._clearSnapshotCanvas();
  }, e._clearSnapshotCanvas = function() {
    var n = this._checkSnapshotCanvas();
    n && P_(n);
  }, e._snapshot = function() {
    for (var n = this.isProgressiveRender(), s = this._geosToDraw || [], o = 0, a = s.length; o < a; o++) {
      var l = s[o], h = l._hitTestTolerance() || 0;
      if (this.maxTolerance = Math.max(this.maxTolerance, h), n) {
        this.pageGeos.push(l);
        var u = l._painter;
        this.geoPainterList.push(u);
      }
    }
    if (!n)
      return this;
    var c = Je(), f = this._checkSnapshotCanvas();
    if (f && this.canvas) {
      var d = P_(f);
      d.drawImage(this.canvas, 0, 0);
    }
    var p = this.layer, g = p.options.progressiveRenderCount, m = p._geoList || [], v = Math.ceil(m.length / g);
    return this.renderEnd = this.page >= v, this.renderEnd && this._setDrawGeosDrawTime(), nh(this.layer) && console.log("snapshot time:", Je() - c + "ms"), this.page++, this;
  }, e._drawSnapshot = function() {
    if (!this.isProgressiveRender())
      return this;
    var n = this.snapshotCanvas, s = this.context;
    if (!n || !s)
      return this;
    var o = this.getMap();
    if (!o)
      return this;
    var a = o.getDevicePixelRatio() || 1, l = 1 / a;
    return s.scale(l, l), s.drawImage(n, 0, 0), s.scale(a, a), this;
  }, t;
}(FA);
Rs.registerRenderer("canvas", LA);
var zA = function(i) {
  Ot(t, i);
  function t(r) {
    var n;
    return n = i.call(this) || this, n.map = r, n._handlerQueue = [], n._thisDocVisibilitychange = n._onDocVisibilitychange.bind(kn(kn(n))), n._thisDocDragStart = n._onDocDragStart.bind(kn(kn(n))), n._thisDocDragEnd = n._onDocDragEnd.bind(kn(kn(n))), n._thisDocDPRChange = n._onDocDPRChange.bind(kn(kn(n))), n;
  }
  var e = t.prototype;
  return e.callInNextFrame = function(n) {
    this._handlerQueue.push(n);
  }, e.executeFrameCallbacks = function() {
    var n = this._handlerQueue;
    this._handlerQueue = [];
    for (var s = 0, o = n.length; s < o; s++)
      n[s]();
  }, e.offsetPlatform = function(n, s) {
    if (!this.map._panels.front)
      return this;
    if (!s && n.x === 0 && n.y === 0)
      return this;
    var o = this.map._panels, a = this._frontCount = o.back.layerDOM.childElementCount, l = this._backCount = o.front.layerDOM.childElementCount, h = this._uiCount = o.front.uiDOM.childElementCount;
    if (a || l || h) {
      var u = this.map.offsetPlatform();
      n ? u = u.add(n)._round() : u = u.round(), l && Yu(o.back, u), (a || h) && Yu(o.front, u);
    }
    return this;
  }, e.domChanged = function() {
    var n = this.map._panels;
    if (!n.front)
      return !1;
    var s = n.back.layerDOM.childElementCount;
    if (this._frontCount === void 0 || this._frontCount !== s)
      return !0;
    var o = n.front.layerDOM.childElementCount;
    if (this._backCount === void 0 || this._backCount !== o)
      return !0;
    var a = n.front.uiDOM.childElementCount;
    return this._uiCount === void 0 || this._uiCount !== a;
  }, e.resetContainer = function() {
    if (this.map && (this.map._resetMapViewPoint(), this.map._panels.front)) {
      var n = new Y(0, 0);
      Yu(this.map._panels.back, n), Yu(this.map._panels.front, n);
    }
  }, e.onZoomEnd = function() {
    this.resetContainer();
  }, e.onLoad = function() {
    this._frameLoop();
  }, e._onDocVisibilitychange = function() {
    document.visibilityState === "visible" && this.setToRedraw();
  }, e._getWrapPanel = function() {
    if (!this.map)
      return null;
    var n = this.map.getPanels();
    return n && n.mapWrapper;
  }, e._onDocDragStart = function() {
    var n = this._getWrapPanel();
    n && (n.style.overflow = "visible");
  }, e._onDocDragEnd = function() {
    var n = this._getWrapPanel();
    n && (n.style.overflow = "hidden");
  }, e._onDocDPRChange = function() {
    var n = this.map;
    if (!(!n || !n.options || n.options.devicePixelRatio || !n.checkSize || !n.getRenderer)) {
      var s = n.getRenderer();
      s && n.checkSize(!0);
    }
  }, e._containerIsOffscreen = function() {
    var n = this.map.getContainer();
    if (!n || !n.style || n.style.display === "none")
      return !0;
    var s = Math.min(n.clientWidth, n.clientHeight);
    return s <= 0;
  }, t;
}(pi), fR = new Ru(), NA = function(i) {
  Ot(t, i);
  function t(r) {
    var n;
    return n = i.call(this, r) || this, n._containerIsCanvas = !!r._containerDOM.getContext, n._registerEvents(), n._loopTime = 0, n._resizeEventList = [], n._resizeTime = -1 / 0, n;
  }
  var e = t.prototype;
  return e.load = function() {
    this.initContainer();
  }, e.renderFrame = function(n) {
    var s = this.map;
    if (!s || !s.options.renderable)
      return !1;
    if (this._handleResizeEventList(n), s.options.stopRenderOnOffscreen && this._containerIsOffscreen())
      return !0;
    this._updateDomPosition(n), delete this._isViewChanged, s._fireEvent("framestart"), this.updateMapDOM(), s.clearCollisionIndex();
    var o = this._getAllLayerToRender();
    this.drawLayers(o, n);
    var a = this.drawLayerCanvas(o);
    return a && (this.drawTops(), this._drawCenterCross(), s.options.debugSky && this._debugSky()), this._needClear = !1, s._fireEvent("frameend"), this._recordView(), this._mapview = this._getMapView(), delete this._spatialRefChanged, this._fireLayerLoadEvents(), this.executeFrameCallbacks(), this._canvasUpdated = !1, s.uiCollides(), !0;
  }, e.updateMapDOM = function() {
    var n = this.map;
    if (!n.isZooming()) {
      var s = n._getViewPointFrameOffset();
      s ? n.offsetPlatform(s) : this.domChanged() && this.offsetPlatform(null, !0);
    }
  }, e.drawLayers = function(n, s) {
    for (var o = this.map, a = o.isInteracting(), l = [], h = [], u = o.options.fpsOnInteracting || 0, c = u === 0 ? 0 : 1e3 / u, f = this.map.options.layerCanvasLimitOnInteracting, d = n.length, p = o.getBaseLayer(), g = 0, m = 0; m < d; m++) {
      var v = n[m];
      if (v.isVisible()) {
        var _ = v.isCanvasRender();
        _ && l.push(v.getId());
        var y = v._getRenderer();
        if (y) {
          var x = this._checkLayerRedraw(v);
          _ && y.isCanvasUpdated() && (x || h.push(v.getId()), this.setLayerCanvasUpdated());
          var w = y.__zoomTransformMatrix;
          if (delete y.__zoomTransformMatrix, !x) {
            _ && a && (o.isZooming() && !o.getPitch() ? (y.prepareRender(), y.__zoomTransformMatrix = this._zoomMatrix) : (o.getPitch() || o.isRotating()) && y.clearCanvas());
            continue;
          }
          if (a && _) {
            if (f > 0 && d - 1 - m > f && v !== p) {
              v._getRenderer().clearCanvas();
              continue;
            }
            g += this._drawCanvasLayerOnInteracting(v, g, c, s);
          } else a && y.drawOnInteracting ? (y.prepareRender && y.prepareRender(), y.checkAndDraw ? y.checkAndDraw(y.drawOnInteracting, this._eventParam, s) : y.drawOnInteracting(this._eventParam, s)) : (y.render(s), _ && w && y.isLoadingResource() && (y.__zoomTransformMatrix = w));
          _ && (h.push(v.getId()), this.setLayerCanvasUpdated());
        }
      }
    }
    var b = this._canvasIds || [], T = this._updatedIds || [];
    if (this._canvasIds = l, this._updatedIds = h, !this.isLayerCanvasUpdated()) {
      var A = "---";
      (b.join(A) !== l.join(A) || T.join(A) !== h.join(A)) && this.setLayerCanvasUpdated();
    }
  }, e._checkLayerRedraw = function(n) {
    if (this.isSpatialReferenceChanged())
      return !0;
    var s = this.map, o = n._getRenderer();
    return n.isCanvasRender() ? o.testIfNeedRedraw() : o.needToRedraw && o.needToRedraw() ? !0 : s.isInteracting() || this.isViewChanged();
  }, e._drawCanvasLayerOnInteracting = function(n, s, o, a) {
    var l = this.map, h = n._getRenderer(), u = h.getDrawTime(), c = o === 0 || o > 0 && s + u <= o;
    if (h.mustRenderOnInteracting && h.mustRenderOnInteracting())
      h.render(a);
    else {
      if (h.drawOnInteracting && (n === l.getBaseLayer() || c || l.isZooming() && n.options.forceRenderOnZooming || l.isMoving() && n.options.forceRenderOnMoving || l.isRotating() && n.options.forceRenderOnRotating))
        return h.prepareRender(), h.prepareCanvas(), h.checkAndDraw ? h.checkAndDraw(h.drawOnInteracting, this._eventParam, a) : h.drawOnInteracting(this._eventParam, a), u;
      l.isZooming() && !l.getPitch() && !l.isRotating() ? (h.prepareRender(), h.__zoomTransformMatrix = this._zoomMatrix) : (l.getPitch() || l.isRotating()) && h.clearCanvas();
    }
    return h.drawOnInteracting && !c && h.onSkipDrawOnInteracting(this._eventParam, a), 0;
  }, e._fireLayerLoadEvents = function() {
    if (this._updatedIds && this._updatedIds.length > 0) {
      var n = this.map;
      this._updatedIds.reverse().forEach(function(s) {
        var o = n.getLayer(s);
        if (o) {
          var a = o._getRenderer();
          !a || !a.isRenderComplete() || o.fire("layerload");
        }
      });
    }
  }, e.isLayerCanvasUpdated = function() {
    return this._canvasUpdated;
  }, e.setLayerCanvasUpdated = function() {
    this._canvasUpdated = !0;
  }, e.drawLayerCanvas = function(n) {
    var s = this.map;
    if (!s || !this.isLayerCanvasUpdated() && !this.isViewChanged() && this._needClear === !1)
      return !1;
    this.canvas || this.createCanvas(), s._fireEvent("renderstart", {
      context: this.context
    }), this._updateCanvasSize() || this.clearCanvas();
    for (var o = s.isInteracting(), a = s.options.layerCanvasLimitOnInteracting, l = n.length, h, u = [], c = 0; c < l; c++)
      if (!(!n[c].isVisible() || !n[c].isCanvasRender())) {
        var f = n[c]._getRenderer();
        if (f) {
          var d = this._getLayerImage(n[c]);
          d && d.image && (n[c] === s.getBaseLayer() ? h = [n[c], d] : u.push([n[c], d]));
        }
      }
    var p = this.canvas.width, g = this.canvas.height;
    h && (this._drawLayerCanvasImage(h[0], h[1], p, g), this._drawFog()), l = u.length;
    for (var m = o && a >= 0 && l > a ? l - a : 0, v = m; v < l; v++)
      this._drawLayerCanvasImage(u[v][0], u[v][1], p, g);
    return s._fireEvent("renderend", {
      context: this.context
    }), !0;
  }, e.setToRedraw = function() {
    var n = this._getAllLayerToRender();
    this._needClear = !0;
    for (var s = 0, o = n.length; s < o; s++) {
      var a = n[s].getRenderer();
      a && a.canvas && a.setToRedraw && a.setToRedraw();
    }
  }, e.updateMapSize = function(n) {
    if (!(!n || this._containerIsCanvas)) {
      var s = n.width + "px", o = n.height + "px", a = this.map._panels;
      a.mapWrapper.style.width = s, a.mapWrapper.style.height = o, this._updateCanvasSize();
    }
  }, e.getMainPanel = function() {
    return this.map ? this._containerIsCanvas ? this.map._containerDOM : this.map._panels ? this.map._panels.mapWrapper : null : null;
  }, e.toDataURL = function(n, s) {
    return this.canvas ? this.canvas.toDataURL(n, s) : null;
  }, e.remove = function() {
    Ce.webgl && typeof document < "u" && (bi.off(Wm, this._thisDocDPRChange, this), bi.off(Zm, this._thisDocVisibilitychange, this), bi.off(Xm, this._thisDocDragStart, this), bi.off(qm, this._thisDocDragEnd, this)), this._resizeInterval && clearInterval(this._resizeInterval), this._resizeObserver && this._resizeObserver.disconnect(), delete this.context, delete this.canvas, delete this.map, delete this._spatialRefChanged, this._cancelFrameLoop();
  }, e.hitDetect = function(n) {
    var s = this.map;
    if (!(!s || !s.options.hitDetect || s.isInteracting())) {
      var o = s._getLayers(), a = "default", l = s.options.hitDetectLimit || 0, h = 0;
      n && n._round && n._round();
      for (var u = o.length - 1; u >= 0; u--) {
        var c = o[u];
        if (!(!c.options.hitDetect || c.isEmpty && c.isEmpty() || !c.options.geometryEvents)) {
          var f = c._getRenderer();
          if (!(!f || !f.hitDetect) && !(f.isBlank && f.isBlank())) {
            if (c.options.cursor !== "default" && f.hitDetect(n)) {
              a = c.options.cursor || "pointer";
              break;
            }
            if (h++, l > 0 && h > l)
              break;
          }
        }
      }
      s._trySetCursor(a);
    }
  }, e._getLayerImage = function(n) {
    var s = n._getRenderer();
    return s.getCanvasImage ? s.getCanvasImage() : null;
  }, e.initContainer = function() {
    var n = this.map._panels;
    function s(x, w, b, T) {
      var A = ve("div", w);
      return b && (A.style.cssText = b), n[x] = A, T || uE(A), A;
    }
    var o = this.map._containerDOM;
    if (!this._containerIsCanvas) {
      o.innerHTML = "";
      var a = "position:absolute;top:0px;left:0px;", l = s("mapWrapper", "maptalks-wrapper", "position:absolute;overflow:hidden;", !0), h = s("allLayers", "maptalks-all-layers", a + "padding:0px;margin:0px;z-index:0;overflow:visible;", !0), u = s("backStatic", "maptalks-back-static", a + "z-index:0;", !0), c = s("back", "maptalks-back", a + "z-index:1;"), f = s("backLayer", "maptalks-back-layer", a), d = s("canvasContainer", "maptalks-canvas-layer", a + "border:none;z-index:2;"), p = s("frontStatic", "maptalks-front-static", a + "z-index:3;", !0), g = s("front", "maptalks-front", a + "z-index:4;", !0), m = s("frontLayer", "maptalks-front-layer", a + "z-index:0;"), v = s("ui", "maptalks-ui", a + "border:none;z-index:1;", !0), _ = s("control", "maptalks-control", "z-index:1", !0);
      o.appendChild(l), h.appendChild(u), c.appendChild(f), c.layerDOM = f, h.appendChild(c), h.appendChild(d), g.appendChild(m), g.layerDOM = m, g.uiDOM = v, h.appendChild(p), h.appendChild(g), g.appendChild(v), l.appendChild(h), l.appendChild(_), this.createCanvas(), this.resetContainer();
      var y = this.map._getContainerDomSize();
      this.updateMapSize(y);
    }
  }, e.isViewChanged = function() {
    if (this._isViewChanged !== void 0)
      return this._isViewChanged;
    var n = this._mapview, s = this._getMapView();
    return this._isViewChanged = !n || !jf(n, s), this._isViewChanged;
  }, e._recordView = function() {
    var n = this.map;
    !n._onViewChange || n.isInteracting() || n.isAnimating() || jf(n.getView(), n._getCurrentView()) || n._onViewChange(n.getView());
  }, e.isSpatialReferenceChanged = function() {
    return this._spatialRefChanged;
  }, e._getMapView = function() {
    var n = this.map, s = n._getPrjCenter();
    return {
      x: s.x,
      y: s.y,
      zoom: n.getZoom(),
      pitch: n.getPitch(),
      bearing: n.getBearing(),
      width: n.width,
      height: n.height
    };
  }, e._frameLoop = function(n) {
    var s = this;
    if (!this.map) {
      this._cancelFrameLoop();
      return;
    }
    n = n || 0, this._frameTimestamp = n, this._resizeCount = 0, this.renderFrame(n), this._animationFrame = Cs(function(o) {
      s._frameLoop(o);
    });
  }, e._cancelFrameLoop = function() {
    this._animationFrame && Kh(this._animationFrame);
  }, e._drawLayerCanvasImage = function(n, s, o, a) {
    var l = this.context, h = s.point.round(), u = this.map.getDevicePixelRatio();
    u !== 1 && h._multi(u);
    var c = s.image, f = c.width, d = c.height;
    if (!(h.x + f <= 0 || h.y + d <= 0)) {
      var p = n.options.opacity;
      if (Ut(p) || (p = 1), !(p <= 0)) {
        var g = s.opacity;
        if (Ut(g) || (g = 1), !(g <= 0)) {
          var m = l.globalAlpha;
          p < 1 && (l.globalAlpha *= p), g < 1 && (l.globalAlpha *= g), n.options.cssFilter && (l.filter = n.options.cssFilter);
          var v = n.getRenderer(), _ = v.__zoomTransformMatrix, y = v.clipCanvas(this.context);
          _ && (l.save(), l.setTransform.apply(l, _)), l.drawImage(c, 0, 0, f, d, h.x, h.y, o, a), _ && l.restore(), y && l.restore(), l.filter !== "none" && (l.filter = "none"), l.globalAlpha = m;
        }
      }
    }
  }, e._drawCenterCross = function() {
    var n = this.map.options.centerCross;
    if (n) {
      var s = this.context, o = new Y(this.canvas.width / 2, this.canvas.height / 2);
      Be(n) ? n(s, o) : Ct.drawCross(this.context, o.x, o.y, 2, "#f00");
    }
  }, e._drawContainerExtent = function() {
    var n = this.map.options.cascadePitches, s = this.map.height - this.map._getVisualHeight(n[0]), o = this.map.height - this.map._getVisualHeight(n[1]), a = this.map.getContainerExtent(), l = this.context;
    l.beginPath(), l.moveTo(0, a.ymin), l.lineTo(a.xmax, a.ymin), l.stroke(), l.beginPath(), l.moveTo(0, s), l.lineTo(a.xmax, s), l.stroke(), l.beginPath(), l.moveTo(0, o), l.lineTo(a.xmax, o), l.stroke();
  }, e._drawFog = function() {
    var n = this.map;
    if (!(n.getPitch() <= n.options.maxVisualPitch || !n.options.fog)) {
      var s = 30, o = n.getDevicePixelRatio(), a = this.context, l = n.getContainerExtent(), h = (n.height - n._getVisualHeight(75)) * o;
      h < 0 && (h = 0);
      var u = l.ymin * o, c = Math.ceil(u - h), f = n.options.fogColor.join(), d = a.createLinearGradient(0, h, 0, u + s), p = 1 - s / (c + s);
      d.addColorStop(0, "rgba(" + f + ", 0)"), d.addColorStop(0.3, "rgba(" + f + ", 0.3)"), d.addColorStop(p, "rgba(" + f + ", 1)"), d.addColorStop(1, "rgba(" + f + ", 0)"), a.beginPath(), a.fillStyle = d, a.fillRect(0, h, Math.ceil(l.getWidth()) * o, Math.ceil(c + s));
    }
  }, e._debugSky = function() {
    var n = this.map;
    if (!n)
      return this;
    var s = n.getContainerExtent().ymin;
    if (s <= 0)
      return this;
    var o = this.context;
    return o.strokeStyle = "red", o.strokeRect(0, 0, n.width, s), this;
  }, e._getAllLayerToRender = function() {
    return this.map._getLayers();
  }, e.clearCanvas = function() {
    this.canvas && Ct.clearRect(this.context, 0, 0, this.canvas.width, this.canvas.height);
  }, e._updateCanvasSize = function() {
    if (!this.canvas || this._containerIsCanvas)
      return !1;
    var n = this.map, s = n.getSize(), o = this.canvas, a = n.getDevicePixelRatio(), l = cv(s, a), h = l.width, u = l.height, c = l.cssWidth, f = l.cssHeight;
    return o.style && (o.style.width !== c || o.style.height !== f) && (o.style.width = c, o.style.height = f), h === o.width && u === o.height ? !1 : (o.height = u, o.width = h, this.topLayer.width = o.width, this.topLayer.height = o.height, !0);
  }, e.createCanvas = function() {
    this.topLayer = ve("canvas"), this.topCtx = this.topLayer.getContext("2d"), this._containerIsCanvas ? this.canvas = this.map._containerDOM : (this.canvas = ve("canvas"), this._updateCanvasSize(), this.map._panels.canvasContainer.appendChild(this.canvas)), this.context = this.canvas.getContext("2d");
  }, e._updateDomPosition = function(n) {
    this._checkPositionTime === void 0 && (this._checkPositionTime = -1 / 0);
    var s = Math.abs(n - this._checkPositionTime);
    return s >= 500 && (Ed(this.map._containerDOM), this._checkPositionTime = Math.min(n, this._checkPositionTime)), this;
  }, e._handleResizeEventList = function(n) {
    if (!this._resizeEventList)
      return this;
    var s = this._resizeEventList.length;
    if (s === 0)
      return this;
    if (this._resizeTime && n - this._resizeTime < 60)
      return this;
    var o = this._resizeEventList[s - 1].contentRect;
    return this.map._containerDomContentRect = o, this._resizeEventList = [], this._checkSize(o), this._resizeCount = this._resizeCount || 0, this.renderFrame((this._frameTimestamp || 0) + ++this._resizeCount / 100), this._resizeTime = n, this;
  }, e._checkSize = function() {
    this.map && this.map.checkSize();
  }, e._setCheckSizeInterval = function(n) {
    var s = this;
    Ce.resizeObserver ? (this._resizeObserver && this._resizeObserver.disconnect(), this.map && (this._resizeObserver = new ResizeObserver(function(o) {
      !s.map || s.map.isRemoved() ? s._resizeObserver.disconnect() : o.length && (s._resizeEventList = s._resizeEventList || [], s._resizeEventList.push(o[0]));
    }), this._resizeObserver.observe(this.map._containerDOM))) : (clearInterval(this._resizeInterval), this._checkSizeInterval = n, this._resizeInterval = setInterval(function() {
      !s.map || s.map.isRemoved() ? clearInterval(s._resizeInterval) : s._checkSize();
    }, this._checkSizeInterval));
  }, e._registerEvents = function() {
    var n = this, s = this.map;
    s.options.checkSize && !tr && typeof window < "u" && this._setCheckSizeInterval(s.options.checkSizeInterval), Ce.mobile || s.on("_mousemove", this._onMapMouseMove, this), s.on("_dragrotatestart _dragrotating _dragrotateend _movestart _moving _moveend _zoomstart", function(o) {
      n._eventParam = o;
    }), s.on("_zooming", function(o) {
      s.getPitch() || (n._zoomMatrix = o.matrix.container), n._eventParam = o;
    }), s.on("_zoomend", function(o) {
      n._eventParam = o, delete n._zoomMatrix;
    }), s.on("_spatialreferencechange", function() {
      n._spatialRefChanged = !0;
    }), Ce.webgl && typeof document < "u" && (bi.on(Wm, this._thisDocDPRChange, this), bi.on(Zm, this._thisDocVisibilitychange, this), bi.on(Xm, this._thisDocDragStart, this), bi.on(qm, this._thisDocDragEnd, this));
  }, e._onMapMouseMove = function(n) {
    var s = this, o = this.map;
    o.isInteracting() || !o.options.hitDetect || (this._hitDetectFrame && Kh(this._hitDetectFrame), this._hitDetectFrame = Cs(function() {
      s.hitDetect(n.containerPoint);
    }));
  }, e._getCanvasLayers = function() {
    return this.map._getLayers(function(n) {
      return n.isCanvasRender();
    });
  }, e.addTopElement = function(n) {
    this._tops || (this._tops = []), this._tops.push(n);
  }, e.removeTopElement = function(n) {
    if (this._tops) {
      var s = this._tops.indexOf(n);
      s >= 0 && this._tops.splice(s, 1);
    }
  }, e.getTopElements = function() {
    return this._tops || [];
  }, e.drawTops = function() {
    this.topCtx.clearRect(0, 0, this.topLayer.width, this.topLayer.height);
    var n = fR;
    n.clear(), this.map.fire("drawtopstart"), this.map.fire("drawtops");
    for (var s = this.getTopElements(), o = !1, a = this.map.getDevicePixelRatio(), l = [], h = 0; h < s.length; h++) {
      var u = s[h];
      if (u.needCollision && u.needCollision()) {
        var c = u.getRenderBBOX(a);
        if (c)
          if (n.collides(c)) {
            var f = u.target && u.target._geometry;
            f && l.indexOf(f) === -1 && (l.push(f), f.fire("handlecollision"));
            continue;
          } else
            n.insertBox(c);
      }
      u.render(this.topCtx) && (o = !0);
    }
    o && this.context.drawImage(this.topLayer, 0, 0), this.map.fire("drawtopsend");
  }, t;
}(zA);
xe.registerRenderer("canvas", NA);
xe.mergeOptions({
  fog: !1,
  fogColor: [233, 233, 233]
});
var zs = /* @__PURE__ */ Object.freeze({
  ResourceCache: Bo,
  CanvasRenderer: Ll,
  ImageGLRenderable: jv,
  MapRenderer: zA,
  MapCanvasRenderer: NA,
  Renderable: Cv,
  ImageLayerCanvasRenderer: Vv,
  ImageLayerGLRenderer: EA,
  TileLayerCanvasRenderer: zd,
  TileLayerGLRenderer: Wv,
  CanvasTileLayerCanvasRenderer: IA,
  CanvasTileLayerGLRenderer: DA,
  QuadStencil: lR,
  OverlayLayerCanvasRenderer: FA,
  VectorLayerCanvasRenderer: LA,
  CanvasLayerRenderer: Uv
}), Nd = {
  _getRenderPoints: function() {
    return [[this._getCenter2DPoint(this.getMap().getGLRes())], null];
  }
};
xn.include(Nd);
as.include(Nd);
Pi.include(Nd);
Ko.include(Nd);
Fo.include({
  _getRenderPoints: function(t) {
    var e = this.getMap(), r = e.getGLRes();
    if (t === "vertex") {
      for (var n = this._trimRing(this.getShell()), s = [], o = 0, a = n.length; o < a; o++)
        s.push(e.coordToPointAtRes(n[o], r));
      return [s, null];
    } else {
      var l = e.coordToPointAtRes(this.getCenter(), r);
      return [[l], null];
    }
  }
});
var HA = {
  _getRenderPoints: function(t) {
    var e = this.getMap(), r = e.getGLRes(), n, s = null;
    if (t === "point")
      n = this._getPath2DPoints(this._getPrjCoordinates(), !1, r), n && n.length > 0 && Array.isArray(n[0]) && (n = n[0].concat(n[1]));
    else if (t === "vertex")
      if (n = this._getPath2DPoints(this._getPrjCoordinates(), !1, r), s = [], n && n.length > 0 && Array.isArray(n[0])) {
        for (var o = 0, a = n.length; o < a; o++)
          for (var l = 0, h = n[o].length; l < h; l++)
            l === 0 ? s.push([n[o][l], n[o][l + 1]]) : s.push([n[o][l - 1], n[o][l]]);
        n = n[0].concat(n[1]);
      } else
        for (var u = 0, c = n.length; u < c; u++)
          u === 0 ? s.push([n[u], n[u + 1]]) : s.push([n[u - 1], n[u]]);
    else if (t === "line") {
      n = [], s = [];
      var f = this._getPath2DPoints(this._getPrjCoordinates(), !1, r), d = f.length > 0 && Array.isArray(f[0]);
      if (d)
        for (var p, g = 1, m = f.length; g < m; g++) {
          p = f[g], this instanceof vn && p.length > 0 && !p[0].equals(p[p.length - 1]) && p.push(p[0]);
          for (var v = 1, _ = p.length; v < _; v++)
            n.push(p[v].add(p[v - 1])._multi(0.5)), s.push([p[v - 1], p[v]]);
        }
      else {
        this instanceof vn && f.length > 0 && !f[0].equals(f[f.length - 1]) && f.push(f[0]);
        for (var y = 1, x = f.length; y < x; y++)
          n.push(f[y].add(f[y - 1])._multi(0.5)), s.push([f[y - 1], f[y]]);
      }
    } else if (t === "vertex-first") {
      var w = this._getPrjCoordinates(), b = w.length, T = b ? e._prjToPointAtRes(w[0], r) : null;
      n = b ? [T] : [], s = b ? [[T, w[1] ? e._prjToPointAtRes(w[1], r) : T]] : [];
    } else if (t === "vertex-last") {
      var A = this._getPrjCoordinates(), M = A.length, S = M ? e._prjToPointAtRes(A[M - 1], r) : null;
      n = M ? [S] : [];
      var P = M > 1 ? M - 2 : M - 1;
      s = M ? [[A[P] ? e._prjToPointAtRes(A[P], r) : S, S]] : [];
    } else {
      var C = this.getCenter();
      if (!C)
        n = [];
      else {
        var k = this._getProjection().project(C);
        n = [e._prjToPointAtRes(k, r)];
      }
    }
    return [n, s];
  }
};
Tn.include(HA);
vn.include(HA);
var da = {
  within: !1,
  center: [0, 0]
};
function BA(i) {
  if (!i || !i._containerBbox)
    da.within = !1;
  else {
    da.within = !1;
    var t = i._containerBbox, e = t.minx, r = t.miny, n = t.maxx, s = t.maxy, o = Math.abs(n - e), a = Math.abs(s - r);
    o <= 1 && a <= 1 && (da.within = !0, da.center[0] = (e + n) / 2, da.center[1] = (r + s) / 2), delete i._containerBbox;
  }
  return da;
}
nn.include({
  _redrawWhenPitch: function() {
    return !1;
  },
  _redrawWhenRotate: function() {
    return !1;
  },
  _getRenderBBOX: function(t, e) {
    return t.isHitTesting ? null : (iu(sl), kd(e, sl), sl);
  }
});
function jA() {
  var i = this._getPrjShell(), t = Jo();
  kd(i, t);
  var e = t[0], r = t[1], n = t[2], s = t[3];
  return new dn(e, r, n, s);
}
function GA() {
  var i = this._getPrjShell();
  if (!i || !Array.isArray(i))
    return [];
  var t = this._getProjection(), e = this.getCoordinates() || {};
  return i.map(function(r) {
    var n = t.unproject(r);
    return n.z = e.z || 0, n;
  });
}
var Zv = {
  _redrawWhenPitch: function() {
    return !0;
  },
  _redrawWhenRotate: function() {
    return this instanceof as || this instanceof Ko;
  },
  _computeRotatedPrjExtent: jA,
  getRotatedShell: GA,
  _paintAsPath: function() {
    if (this.isRotated())
      return !0;
    var t = this.getMap(), e = this._getAltitude();
    return e > 0 || t.getPitch() || this instanceof as && t.getBearing();
  },
  _getPaintParams: function() {
    var t = this.getMap();
    if (this._paintAsPath())
      return vn.prototype._getPaintParams.call(this, !0);
    var e = this._getPrjCoordinates(), r = t._prjToPointAtRes(e, t.getGLRes()), n = this._getRenderSize(r);
    return [r].concat(n);
  },
  _paintOn: function() {
    return this._paintAsPath() ? Ct.polygon.apply(Ct, arguments) : Ct.ellipse.apply(Ct, arguments);
  },
  _getRenderSize: function(t) {
    var e = this.getMap(), r = e.getGLRes(), n = this._getPrjExtent(), s = e._prjToPointAtRes(n.getMin(), r), o = e._prjToPointAtRes(n.getMax(), r);
    return [Math.abs(o.x - s.x) / 2, Math.abs(o.y - t.y), Math.abs(t.y - s.y)];
  }
};
as.include(Zv);
Pi.include(Zv);
Fo.include({
  _getPaintParams: function() {
    var t = this.getMap(), e = this._getPrjShell(), r = this._getPath2DPoints(e, !1, t.getGLRes());
    return [r];
  },
  _paintOn: Ct.polygon,
  _computeRotatedPrjExtent: jA,
  getRotatedShell: GA
});
Ko.include(Zv, {
  _redrawWhenPitch: function() {
    return !0;
  },
  _getPaintParams: function() {
    if (this._paintAsPath())
      return vn.prototype._getPaintParams.call(this, !0);
    var t = this.getMap(), e = t._prjToPointAtRes(this._getPrjCoordinates(), t.getGLRes()), r = this._getRenderSize(e);
    return [e, r[0], [this.getStartAngle(), this.getEndAngle()]];
  },
  _paintOn: function() {
    if (this._paintAsPath())
      return Ct.polygon.apply(Ct, arguments);
    var t = this.getMap().getBearing(), e = arguments;
    return t && (e[3] = e[3].slice(0), e[3][0] += t, e[3][1] += t), Ct.sector.apply(Ct, e);
  }
});
Fd.include({
  _paintAsPath: function() {
    return !0;
  }
});
Tn.include({
  arrowStyles: {
    classic: [3, 4]
  },
  _getArrowShape: function(t, e, r, n, s) {
    if (!t || !e || t.equals(e))
      return null;
    s || (s = 0);
    var o = r * n[0], a = r * n[1] + s, l = o / 2 + s, h;
    e.nextCtrlPoint || e.prevCtrlPoint ? e.prevCtrlPoint ? h = e.sub(new Y(e.prevCtrlPoint)) : h = e.sub(new Y(e.nextCtrlPoint)) : h = e.sub(t), h._unit();
    var u = e.sub(h.multi(a));
    h._perp();
    var c = u.add(h.multi(l));
    h._multi(-1);
    var f = u.add(h.multi(l));
    return [c, e, f, c];
  },
  _getPaintParams: function() {
    var t = this._getPrjCoordinates(), e = this._getPath2DPoints(t, !1, this.getMap().getGLRes());
    return [e];
  },
  _paintOn: function(t, e, r, n, s) {
    var o = BA(this._painter);
    return o.within ? Ct.pixelRect(t, o.center, r, n) : this.options.smoothness ? Ct.paintSmoothLine(t, e, r, this.options.smoothness, !1, this._animIdx, this._animTailRatio) : Ct.path(t, e, r, null, s), this._paintArrow(t, e, r), this._getRenderBBOX(t, e);
  },
  _getArrowPlacement: function() {
    return this.options.arrowPlacement;
  },
  _getArrowStyle: function() {
    var t = this.options.arrowStyle;
    return t ? Array.isArray(t) ? t : this.arrowStyles[t] : null;
  },
  _getArrows: function(t, e, r) {
    var n = this._getArrowStyle();
    if (!n || t.length < 2)
      return [];
    for (var s = t.length > 0 && Array.isArray(t[0]), o = s ? t : [t], a = this._getArrowPlacement(), l = [], h = this.getMap(), u = h.coordToContainerPoint(this.getFirstCoordinate()), c = h.coordToContainerPoint(this.getLastCoordinate()), f = o.length - 1; f >= 0; f--) {
      if (a === "vertex-first" || a === "vertex-firstlast" && o[f][0].closeTo(u, 0.01)) {
        var d = this._getArrowShape(o[f][1], o[f][0], e, n, r);
        d && l.push(d);
      }
      if (a === "vertex-last" || a === "vertex-firstlast" && o[f][o[f].length - 1].closeTo(c, 0.01)) {
        var p = this._getArrowShape(o[f][o[f].length - 2], o[f][o[f].length - 1], e, n, r);
        p && l.push(p);
      } else a === "point" && this._getArrowPoints(l, o[f], e, n, r);
    }
    return l;
  },
  _getArrowPoints: function(t, e, r, n, s) {
    for (var o = 0, a = e.length - 1; o < a; o++) {
      var l = this._getArrowShape(e[o], e[o + 1], r, n, s);
      l && t.push(l);
    }
  },
  _paintArrow: function(t, e, r) {
    var n = this._getInternalSymbol().lineWidth;
    (!Ut(n) || n < 3) && (n = 3);
    var s = this._getArrows(e, n);
    if (s.length) {
      t.setLineDash && t.setLineDash([]);
      for (var o = s.length - 1; o >= 0; o--)
        t.fillStyle = t.strokeStyle, Ct.polygon(t, s[o], r, r);
    }
  }
});
vn.include({
  _getPaintParams: function(t) {
    var e = this.getMap().getGLRes(), r = this._getPrjShell(), n = this._getPath2DPoints(r, t, e), s = n.length > 0 && Array.isArray(n[0]);
    s && (n = [[n[0]], [n[1]]]);
    var o = this._getPrjHoles(), a = [];
    if (o && o.length > 0) {
      for (var l = this._simplified, h = 0; h < o.length; h++) {
        var u = this._getPath2DPoints(o[h], t, e);
        Array.isArray(u) && s ? Array.isArray(u[0]) ? (n[0].push(u[0]), n[1].push(u[1])) : n[0].push(u) : a.push(u);
      }
      l && (this._simplified = l);
    }
    return s || (n = [n], Ui(n, a)), [n];
  },
  _paintOn: function(t, e, r, n, s) {
    var o = BA(this._painter);
    return o.within ? Ct.pixelRect(t, o.center, r, n) : Ct.polygon(t, e, r, n, s, this.options.smoothness), this._getRenderBBOX(t, e);
  }
});
xe.VERSION = d3;
var VA = {
  Actor: Id
};
const dR = xe, pR = Pn, UA = Symbol("map-injection");
let $A = "";
function gR(i) {
  $A = i;
}
function mR({ url: i, method: t, data: e }) {
  return new Promise((r, n) => {
    let s = null;
    e ? s = { ...e } : s = {};
    const o = {
      method: t,
      headers: {
        "Content-Type": "application/json"
      }
    };
    t === "POST" && s && (o.body = JSON.stringify(s)), fetch(`${$A}${i}`, o).then((a) => a.json()).then((a) => {
      r(a);
    }).catch((a) => {
      n(a);
    });
  });
}
const vR = { class: "w-full h-full relative" }, yR = /* @__PURE__ */ KP("div", {
  id: "homemap",
  class: "w-full h-full relative"
}, null, -1), mG = {
  __name: "VMap",
  props: {
    server: String
  },
  setup(i) {
    const t = i, e = ZP();
    return ww(() => {
      gR(t.server);
      const r = new dR("homemap", {
        center: [118.846825, 32.046534],
        zoom: 14
      });
      e.value = r;
    }), XP(UA, e), (r, n) => (qP(), YP("div", vR, [
      yR,
      JP(r.$slots, "default")
    ]));
  }
};
function Xv() {
  let i = null;
  const t = QP(UA);
  let e;
  ww(() => {
    !i && (t != null && t.value) && (i = $y(t.value), e && e(i));
  }), Tw(
    () => t == null ? void 0 : t.value,
    (n, s) => {
      !s && n && !i && (i = $y(n), e && e(i));
    }
  );
  function r(n) {
    e = n;
  }
  return {
    onMapMounted: r
  };
}
const vG = {
  name: "VTileLayer",
  props: {
    id: String,
    options: {
      type: Object,
      default: () => ({})
    }
  },
  setup(i) {
    const { onMapMounted: t } = Xv();
    let e;
    return t((r) => {
      e = new pR(i.id, i.options), e.addTo(r);
    }), sv(() => {
      e.remove();
    }), () => null;
  }
};
var WA = { exports: {} };
(function(i, t) {
  (function(e, r) {
    i.exports = r();
  })(Hh, function() {
    function e(E, V) {
      this.id = fe++, this.type = E, this.data = V;
    }
    function r(E) {
      if (E.length === 0) return [];
      var V = E.charAt(0), q = E.charAt(E.length - 1);
      if (1 < E.length && V === q && (V === '"' || V === "'")) return ['"' + E.substr(1, E.length - 2).replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"'];
      if (V = /\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(E)) return r(E.substr(
        0,
        V.index
      )).concat(r(V[1])).concat(r(E.substr(V.index + V[0].length)));
      if (V = E.split("."), V.length === 1) return ['"' + E.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"'];
      for (E = [], q = 0; q < V.length; ++q) E = E.concat(r(V[q]));
      return E;
    }
    function n(E) {
      return "[" + r(E).join("][") + "]";
    }
    function s(E, V) {
      if (typeof E == "function") return new e(0, E);
      if (typeof E == "number" || typeof E == "boolean") return new e(5, E);
      if (Array.isArray(E)) return new e(6, E.map(function(q, ut) {
        return s(q);
      }));
      if (E instanceof e) return E;
    }
    function o() {
      var E = { "": 0 }, V = [""];
      return { id: function(q) {
        var ut = E[q];
        return ut || (ut = E[q] = V.length, V.push(q), ut);
      }, str: function(q) {
        return V[q];
      } };
    }
    function a(E, V, q) {
      function ut() {
        var kt = window.innerWidth, Pt = window.innerHeight;
        E !== document.body && (Pt = E.getBoundingClientRect(), kt = Pt.right - Pt.left, Pt = Pt.bottom - Pt.top), ht.width = q * kt, ht.height = q * Pt, Kt(ht.style, { width: kt + "px", height: Pt + "px" });
      }
      var ht = document.createElement("canvas");
      Kt(ht.style, { border: 0, margin: 0, padding: 0, top: 0, left: 0 }), E.appendChild(ht), E === document.body && (ht.style.position = "absolute", Kt(E.style, { margin: 0, padding: 0 }));
      var gt;
      return E !== document.body && typeof ResizeObserver == "function" ? (gt = new ResizeObserver(function() {
        setTimeout(ut);
      }), gt.observe(E)) : window.addEventListener("resize", ut, !1), ut(), { canvas: ht, onDestroy: function() {
        gt ? gt.disconnect() : window.removeEventListener("resize", ut), E.removeChild(ht);
      } };
    }
    function l(E, V) {
      function q(ut) {
        try {
          return E.getContext(ut, V);
        } catch {
          return null;
        }
      }
      return q("webgl") || q("experimental-webgl") || q("webgl-experimental");
    }
    function h(E) {
      return typeof E == "string" ? E.split() : E;
    }
    function u(E) {
      return typeof E == "string" ? document.querySelector(E) : E;
    }
    function c(E) {
      var V = E || {}, q, ut, ht, gt;
      E = {};
      var kt = [], Pt = [], zt = typeof window > "u" ? 1 : window.devicePixelRatio, St = !1, Vt = function(ct) {
      }, tt = function() {
      };
      if (typeof V == "string" ? q = document.querySelector(V) : typeof V == "object" && (typeof V.nodeName == "string" && typeof V.appendChild == "function" && typeof V.getBoundingClientRect == "function" ? q = V : typeof V.drawArrays == "function" || typeof V.drawElements == "function" ? (gt = V, ht = gt.canvas) : ("gl" in V ? gt = V.gl : "canvas" in V ? ht = u(V.canvas) : "container" in V && (ut = u(V.container)), "attributes" in V && (E = V.attributes), "extensions" in V && (kt = h(V.extensions)), "optionalExtensions" in V && (Pt = h(V.optionalExtensions)), "onDone" in V && (Vt = V.onDone), "profile" in V && (St = !!V.profile), "pixelRatio" in V && (zt = +V.pixelRatio))), q && (q.nodeName.toLowerCase() === "canvas" ? ht = q : ut = q), !gt) {
        if (!ht) {
          if (q = a(ut || document.body, Vt, zt), !q) return null;
          ht = q.canvas, tt = q.onDestroy;
        }
        E.premultipliedAlpha === void 0 && (E.premultipliedAlpha = !0), gt = l(ht, E);
      }
      return gt ? { gl: gt, canvas: ht, container: ut, extensions: kt, optionalExtensions: Pt, pixelRatio: zt, profile: St, onDone: Vt, onDestroy: tt } : (tt(), Vt("webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org"), null);
    }
    function f(E, V) {
      function q(kt) {
        kt = kt.toLowerCase();
        var Pt;
        try {
          Pt = ut[kt] = E.getExtension(kt);
        } catch {
        }
        return !!Pt;
      }
      for (var ut = {}, ht = 0; ht < V.extensions.length; ++ht) {
        var gt = V.extensions[ht];
        if (!q(gt)) return V.onDestroy(), V.onDone('"' + gt + '" extension is not supported by the current WebGL context, try upgrading your system or a different browser'), null;
      }
      return V.optionalExtensions.forEach(q), { extensions: ut, restore: function() {
        Object.keys(ut).forEach(function(kt) {
          if (ut[kt] && !q(kt)) throw Error("(regl): error restoring extension " + kt);
        });
      } };
    }
    function d(E, V) {
      for (var q = Array(E), ut = 0; ut < E; ++ut) q[ut] = V(ut);
      return q;
    }
    function p(E) {
      var V, q;
      return V = (65535 < E) << 4, E >>>= V, q = (255 < E) << 3, E >>>= q, V |= q, q = (15 < E) << 2, E >>>= q, V |= q, q = (3 < E) << 1, V | q | E >>> q >> 1;
    }
    function g() {
      function E(ut) {
        t: {
          for (var ht = 16; 268435456 >= ht; ht *= 16) if (ut <= ht) {
            ut = ht;
            break t;
          }
          ut = 0;
        }
        return ht = q[p(ut) >> 2], 0 < ht.length ? ht.pop() : new ArrayBuffer(ut);
      }
      function V(ut) {
        q[p(ut.byteLength) >> 2].push(ut);
      }
      var q = d(8, function() {
        return [];
      });
      return { alloc: E, free: V, allocType: function(ut, ht) {
        var gt = null;
        switch (ut) {
          case 5120:
            gt = new Int8Array(E(ht), 0, ht);
            break;
          case 5121:
            gt = new Uint8Array(E(ht), 0, ht);
            break;
          case 5122:
            gt = new Int16Array(E(2 * ht), 0, ht);
            break;
          case 5123:
            gt = new Uint16Array(E(2 * ht), 0, ht);
            break;
          case 5124:
            gt = new Int32Array(E(4 * ht), 0, ht);
            break;
          case 5125:
            gt = new Uint32Array(E(4 * ht), 0, ht);
            break;
          case 5126:
            gt = new Float32Array(E(4 * ht), 0, ht);
            break;
          default:
            return null;
        }
        return gt.length !== ht ? gt.subarray(0, ht) : gt;
      }, freeType: function(ut) {
        V(ut.buffer);
      } };
    }
    function m(E) {
      return !!E && typeof E == "object" && Array.isArray(E.shape) && Array.isArray(E.stride) && typeof E.offset == "number" && E.shape.length === E.stride.length && (Array.isArray(E.data) || Ke(E.data));
    }
    function v(E, V, q, ut, ht, gt) {
      for (var kt = 0; kt < V; ++kt) for (var Pt = E[kt], zt = 0; zt < q; ++zt) for (var St = Pt[zt], Vt = 0; Vt < ut; ++Vt) ht[gt++] = St[Vt];
    }
    function _(E, V, q, ut, ht) {
      for (var gt = 1, kt = q + 1; kt < V.length; ++kt) gt *= V[kt];
      var Pt = V[q];
      if (V.length - q === 4) {
        var zt = V[q + 1], St = V[q + 2];
        for (V = V[q + 3], kt = 0; kt < Pt; ++kt) v(
          E[kt],
          zt,
          St,
          V,
          ut,
          ht
        ), ht += gt;
      } else for (kt = 0; kt < Pt; ++kt) _(E[kt], V, q + 1, ut, ht), ht += gt;
    }
    function y(E) {
      return bn[Object.prototype.toString.call(E)] | 0;
    }
    function x(E, V) {
      for (var q = 0; q < V.length; ++q) E[q] = V[q];
    }
    function w(E, V, q, ut, ht, gt, kt) {
      for (var Pt = 0, zt = 0; zt < q; ++zt) for (var St = 0; St < ut; ++St) E[Pt++] = V[ht * zt + gt * St + kt];
    }
    function b(E, V, q, ut) {
      function ht(tt) {
        this.id = zt++, this.buffer = E.createBuffer(), this.type = tt, this.usage = 35044, this.byteLength = 0, this.dimension = 1, this.dtype = 5121, this.persistentData = null, q.profile && (this.stats = { size: 0 });
      }
      function gt(tt, ct, _t) {
        tt.byteLength = ct.byteLength, E.bufferData(tt.type, ct, _t);
      }
      function kt(tt, ct, _t, bt, at, vt) {
        if (tt.usage = _t, Array.isArray(ct)) {
          if (tt.dtype = bt || 5126, 0 < ct.length) if (Array.isArray(ct[0])) {
            at = be(ct);
            for (var Z = bt = 1; Z < at.length; ++Z) bt *= at[Z];
            tt.dimension = bt, ct = $e(ct, at, tt.dtype), gt(tt, ct, _t), vt ? tt.persistentData = ct : oe.freeType(ct);
          } else typeof ct[0] == "number" ? (tt.dimension = at, at = oe.allocType(tt.dtype, ct.length), x(at, ct), gt(tt, at, _t), vt ? tt.persistentData = at : oe.freeType(at)) : Ke(ct[0]) && (tt.dimension = ct[0].length, tt.dtype = bt || y(ct[0]) || 5126, ct = $e(ct, [ct.length, ct[0].length], tt.dtype), gt(tt, ct, _t), vt ? tt.persistentData = ct : oe.freeType(ct));
        } else if (Ke(ct)) tt.dtype = bt || y(ct), tt.dimension = at, gt(tt, ct, _t), vt && (tt.persistentData = new Uint8Array(new Uint8Array(ct.buffer)));
        else if (m(ct)) {
          at = ct.shape;
          var Mt = ct.stride, Z = ct.offset, mt = 0, xt = 0, ce = 0, Xe = 0;
          at.length === 1 ? (mt = at[0], xt = 1, ce = Mt[0], Xe = 0) : at.length === 2 && (mt = at[0], xt = at[1], ce = Mt[0], Xe = Mt[1]), tt.dtype = bt || y(ct.data) || 5126, tt.dimension = xt, at = oe.allocType(tt.dtype, mt * xt), w(at, ct.data, mt, xt, ce, Xe, Z), gt(tt, at, _t), vt ? tt.persistentData = at : oe.freeType(at);
        } else ct instanceof ArrayBuffer && (tt.dtype = 5121, tt.dimension = at, gt(
          tt,
          ct,
          _t
        ), vt && (tt.persistentData = new Uint8Array(new Uint8Array(ct))));
      }
      function Pt(tt) {
        V.bufferCount--, ut(tt), E.deleteBuffer(tt.buffer), tt.buffer = null, delete St[tt.id];
      }
      var zt = 0, St = {};
      ht.prototype.bind = function() {
        E.bindBuffer(this.type, this.buffer);
      }, ht.prototype.destroy = function() {
        Pt(this);
      };
      var Vt = [];
      return q.profile && (V.getTotalBufferSize = function() {
        var tt = 0;
        return Object.keys(St).forEach(function(ct) {
          tt += St[ct].stats.size;
        }), tt;
      }), { create: function(tt, ct, _t, bt) {
        function at(Z) {
          var Mt = 35044, mt = null, xt = 0, ce = 0, Xe = vt && vt.dimension || 1;
          return Array.isArray(Z) || Ke(Z) || m(Z) || Z instanceof ArrayBuffer ? mt = Z : typeof Z == "number" ? xt = Z | 0 : Z && ("data" in Z && (mt = Z.data), "usage" in Z && (Mt = On[Z.usage]), "type" in Z && (ce = wn[Z.type]), "dimension" in Z && (Xe = Z.dimension | 0), "length" in Z && (xt = Z.length | 0)), vt.bind(), mt ? kt(vt, mt, Mt, ce, Xe, bt) : (xt && E.bufferData(vt.type, xt, Mt), vt.dtype = ce || 5121, vt.usage = Mt, vt.dimension = Xe, vt.byteLength = xt), q.profile && (vt.stats.size = vt.byteLength * Ee[vt.dtype]), at;
        }
        V.bufferCount++;
        var vt = new ht(ct);
        return St[vt.id] = vt, _t || at(tt), at._reglType = "buffer", at._buffer = vt, at.subdata = function(Z, Mt) {
          var mt = (Mt || 0) | 0, xt;
          if (vt.bind(), Ke(Z) || Z instanceof ArrayBuffer) E.bufferSubData(vt.type, mt, Z);
          else if (Array.isArray(Z)) {
            if (0 < Z.length) if (typeof Z[0] == "number") {
              var ce = oe.allocType(vt.dtype, Z.length);
              x(ce, Z), E.bufferSubData(vt.type, mt, ce), oe.freeType(ce);
            } else (Array.isArray(Z[0]) || Ke(Z[0])) && (xt = be(Z), ce = $e(Z, xt, vt.dtype), E.bufferSubData(vt.type, mt, ce), oe.freeType(ce));
          } else if (m(Z)) {
            xt = Z.shape;
            var Xe = Z.stride, cn = ce = 0, je = 0, yt = 0;
            xt.length === 1 ? (ce = xt[0], cn = 1, je = Xe[0], yt = 0) : xt.length === 2 && (ce = xt[0], cn = xt[1], je = Xe[0], yt = Xe[1]), xt = Array.isArray(Z.data) ? vt.dtype : y(Z.data), xt = oe.allocType(xt, ce * cn), w(xt, Z.data, ce, cn, je, yt, Z.offset), E.bufferSubData(vt.type, mt, xt), oe.freeType(xt);
          }
          return at;
        }, q.profile && (at.stats = vt.stats), at.destroy = function() {
          Pt(vt);
        }, at;
      }, createStream: function(tt, ct) {
        var _t = Vt.pop();
        return _t || (_t = new ht(tt)), _t.bind(), kt(_t, ct, 35040, 0, 1, !1), _t;
      }, destroyStream: function(tt) {
        Vt.push(tt);
      }, clear: function() {
        Ye(St).forEach(Pt), Vt.forEach(Pt);
      }, getBuffer: function(tt) {
        return tt && tt._buffer instanceof ht ? tt._buffer : null;
      }, restore: function() {
        Ye(St).forEach(function(tt) {
          tt.buffer = E.createBuffer(), E.bindBuffer(tt.type, tt.buffer), E.bufferData(tt.type, tt.persistentData || tt.byteLength, tt.usage);
        });
      }, _initBuffer: kt };
    }
    function T(E, V, q, ut) {
      function ht(tt) {
        this.id = zt++, Pt[this.id] = this, this.buffer = tt, this.primType = 4, this.type = this.vertCount = 0;
      }
      function gt(tt, ct, _t, bt, at, vt, Z) {
        tt.buffer.bind();
        var Mt;
        if (ct ? ((Mt = Z) || Ke(ct) && (!m(ct) || Ke(ct.data)) || (Mt = V.oes_element_index_uint ? 5125 : 5123), q._initBuffer(tt.buffer, ct, _t, Mt, 3)) : (E.bufferData(34963, vt, _t), tt.buffer.dtype = Mt || 5121, tt.buffer.usage = _t, tt.buffer.dimension = 3, tt.buffer.byteLength = vt), Mt = Z, !Z) {
          switch (tt.buffer.dtype) {
            case 5121:
            case 5120:
              Mt = 5121;
              break;
            case 5123:
            case 5122:
              Mt = 5123;
              break;
            case 5125:
            case 5124:
              Mt = 5125;
          }
          tt.buffer.dtype = Mt;
        }
        tt.type = Mt, ct = at, 0 > ct && (ct = tt.buffer.byteLength, Mt === 5123 ? ct >>= 1 : Mt === 5125 && (ct >>= 2)), tt.vertCount = ct, ct = bt, 0 > bt && (ct = 4, bt = tt.buffer.dimension, bt === 1 && (ct = 0), bt === 2 && (ct = 1), bt === 3 && (ct = 4)), tt.primType = ct;
      }
      function kt(tt) {
        ut.elementsCount--, delete Pt[tt.id], tt.buffer.destroy(), tt.buffer = null;
      }
      var Pt = {}, zt = 0, St = { uint8: 5121, uint16: 5123 };
      V.oes_element_index_uint && (St.uint32 = 5125), ht.prototype.bind = function() {
        this.buffer.bind();
      };
      var Vt = [];
      return { create: function(tt, ct) {
        function _t(vt) {
          if (vt) if (typeof vt == "number") bt(vt), at.primType = 4, at.vertCount = vt | 0, at.type = 5121;
          else {
            var Z = null, Mt = 35044, mt = -1, xt = -1, ce = 0, Xe = 0;
            Array.isArray(vt) || Ke(vt) || m(vt) ? Z = vt : ("data" in vt && (Z = vt.data), "usage" in vt && (Mt = On[vt.usage]), "primitive" in vt && (mt = Ze[vt.primitive]), "count" in vt && (xt = vt.count | 0), "type" in vt && (Xe = St[vt.type]), "length" in vt ? ce = vt.length | 0 : (ce = xt, Xe === 5123 || Xe === 5122 ? ce *= 2 : (Xe === 5125 || Xe === 5124) && (ce *= 4))), gt(at, Z, Mt, mt, xt, ce, Xe);
          }
          else bt(), at.primType = 4, at.vertCount = 0, at.type = 5121;
          return _t;
        }
        var bt = q.create(
          null,
          34963,
          !0
        ), at = new ht(bt._buffer);
        return ut.elementsCount++, _t(tt), _t._reglType = "elements", _t._elements = at, _t.subdata = function(vt, Z) {
          return bt.subdata(vt, Z), _t;
        }, _t.destroy = function() {
          kt(at);
        }, _t;
      }, createStream: function(tt) {
        var ct = Vt.pop();
        return ct || (ct = new ht(q.create(null, 34963, !0, !1)._buffer)), gt(ct, tt, 35040, -1, -1, 0, 0), ct;
      }, destroyStream: function(tt) {
        Vt.push(tt);
      }, getElements: function(tt) {
        return typeof tt == "function" && tt._elements instanceof ht ? tt._elements : null;
      }, clear: function() {
        Ye(Pt).forEach(kt);
      } };
    }
    function A(E) {
      for (var V = oe.allocType(
        5123,
        E.length
      ), q = 0; q < E.length; ++q) if (isNaN(E[q])) V[q] = 65535;
      else if (E[q] === 1 / 0) V[q] = 31744;
      else if (E[q] === -1 / 0) V[q] = 64512;
      else {
        yn[0] = E[q];
        var gt = Cr[0], ut = gt >>> 31 << 15, ht = (gt << 1 >>> 24) - 127, gt = gt >> 13 & 1023;
        V[q] = -24 > ht ? ut : -14 > ht ? ut + (gt + 1024 >> -14 - ht) : 15 < ht ? ut + 31744 : ut + (ht + 15 << 10) + gt;
      }
      return V;
    }
    function M(E) {
      return Array.isArray(E) || Ke(E);
    }
    function S(E) {
      return "[object " + E + "]";
    }
    function P(E) {
      return Array.isArray(E) && (E.length === 0 || typeof E[0] == "number");
    }
    function C(E) {
      return !!(Array.isArray(E) && E.length !== 0 && M(E[0]));
    }
    function k(E) {
      return Object.prototype.toString.call(E);
    }
    function O(E) {
      if (!E) return !1;
      var V = k(E);
      return 0 <= jr.indexOf(V) ? !0 : P(E) || C(E) || m(E);
    }
    function R(E, V) {
      E.type === 36193 ? (E.data = A(V), oe.freeType(V)) : E.data = V;
    }
    function I(E, V, q, ut, ht, gt) {
      if (E = typeof un[E] < "u" ? un[E] : Ve[E] * Rr[V], gt && (E *= 6), ht) {
        for (ut = 0; 1 <= q; ) ut += E * q * q, q /= 2;
        return ut;
      }
      return E * q * ut;
    }
    function D(E, V, q, ut, ht, gt, kt) {
      function Pt() {
        this.format = this.internalformat = 6408, this.type = 5121, this.flipY = this.premultiplyAlpha = this.compressed = !1, this.unpackAlignment = 1, this.colorSpace = 37444, this.channels = this.height = this.width = 0;
      }
      function zt(L, ft) {
        L.internalformat = ft.internalformat, L.format = ft.format, L.type = ft.type, L.compressed = ft.compressed, L.premultiplyAlpha = ft.premultiplyAlpha, L.flipY = ft.flipY, L.unpackAlignment = ft.unpackAlignment, L.colorSpace = ft.colorSpace, L.width = ft.width, L.height = ft.height, L.channels = ft.channels;
      }
      function St(L, ft) {
        if (typeof ft == "object" && ft) {
          "premultiplyAlpha" in ft && (L.premultiplyAlpha = ft.premultiplyAlpha), "flipY" in ft && (L.flipY = ft.flipY), "alignment" in ft && (L.unpackAlignment = ft.alignment), "colorSpace" in ft && (L.colorSpace = fn[ft.colorSpace]), "type" in ft && (L.type = ke[ft.type]);
          var X = L.width, Et = L.height, It = L.channels, Ae = !1;
          "shape" in ft ? (X = ft.shape[0], Et = ft.shape[1], ft.shape.length === 3 && (It = ft.shape[2], Ae = !0)) : ("radius" in ft && (X = Et = ft.radius), "width" in ft && (X = ft.width), "height" in ft && (Et = ft.height), "channels" in ft && (It = ft.channels, Ae = !0)), L.width = X | 0, L.height = Et | 0, L.channels = It | 0, X = !1, "format" in ft && (X = ft.format, Et = L.internalformat = Ue[X], L.format = _e[Et], X in ke && !("type" in ft) && (L.type = ke[X]), X in Zn && (L.compressed = !0), X = !0), !Ae && X ? L.channels = Ve[L.format] : Ae && !X && L.channels !== an[L.format] && (L.format = L.internalformat = an[L.channels]);
        }
      }
      function Vt(L) {
        E.pixelStorei(37440, L.flipY), E.pixelStorei(37441, L.premultiplyAlpha), E.pixelStorei(37443, L.colorSpace), E.pixelStorei(3317, L.unpackAlignment);
      }
      function tt() {
        Pt.call(this), this.yOffset = this.xOffset = 0, this.data = null, this.needsFree = !1, this.element = null, this.needsCopy = !1;
      }
      function ct(L, ft) {
        var X = null;
        if (O(ft) ? X = ft : ft && (St(L, ft), "x" in ft && (L.xOffset = ft.x | 0), "y" in ft && (L.yOffset = ft.y | 0), O(ft.data) && (X = ft.data)), ft.copy) {
          var Et = ht.viewportWidth, It = ht.viewportHeight;
          L.width = L.width || Et - L.xOffset, L.height = L.height || It - L.yOffset, L.needsCopy = !0;
        } else if (!X) L.width = L.width || 1, L.height = L.height || 1, L.channels = L.channels || 4;
        else if (Ke(X)) L.channels = L.channels || 4, L.data = X, "type" in ft || L.type !== 5121 || (L.type = bn[Object.prototype.toString.call(X)] | 0);
        else if (P(X)) {
          switch (L.channels = L.channels || 4, Et = X, It = Et.length, L.type) {
            case 5121:
            case 5123:
            case 5125:
            case 5126:
              It = oe.allocType(L.type, It), It.set(Et), L.data = It;
              break;
            case 36193:
              L.data = A(Et);
          }
          L.alignment = 1, L.needsFree = !0;
        } else if (m(X)) {
          Et = X.data, Array.isArray(Et) || L.type !== 5121 || (L.type = bn[Object.prototype.toString.call(Et)] | 0);
          var It = X.shape, Ae = X.stride, Qt, Yt, le, Ie;
          It.length === 3 ? (le = It[2], Ie = Ae[2]) : Ie = le = 1, Qt = It[0], Yt = It[1], It = Ae[0], Ae = Ae[1], L.alignment = 1, L.width = Qt, L.height = Yt, L.channels = le, L.format = L.internalformat = an[le], L.needsFree = !0, Qt = Ie, X = X.offset, le = L.width, Ie = L.height, Yt = L.channels;
          for (var F = oe.allocType(L.type === 36193 ? 5126 : L.type, le * Ie * Yt), B = 0, J = 0; J < Ie; ++J) for (var nt = 0; nt < le; ++nt) for (var ot = 0; ot < Yt; ++ot) F[B++] = Et[It * nt + Ae * J + Qt * ot + X];
          R(L, F);
        } else if (k(X) === Qn || k(X) === Kr || k(X) === Br) k(X) === Qn || k(X) === Kr ? L.element = X : L.element = X.canvas, L.width = L.element.width, L.height = L.element.height, L.channels = 4;
        else if (k(X) === An) L.element = X, L.width = X.width, L.height = X.height, L.channels = 4;
        else if (k(X) === Ri) L.element = X, L.width = X.naturalWidth, L.height = X.naturalHeight, L.channels = 4;
        else if (k(X) === yr) L.element = X, L.width = X.videoWidth, L.height = X.videoHeight, L.channels = 4;
        else if (C(X)) {
          for (Et = L.width || X[0].length, It = L.height || X.length, Ae = L.channels, Ae = M(X[0][0]) ? Ae || X[0][0].length : Ae || 1, Qt = We.shape(X), le = 1, Ie = 0; Ie < Qt.length; ++Ie) le *= Qt[Ie];
          le = oe.allocType(L.type === 36193 ? 5126 : L.type, le), We.flatten(X, Qt, "", le), R(L, le), L.alignment = 1, L.width = Et, L.height = It, L.channels = Ae, L.format = L.internalformat = an[Ae], L.needsFree = !0;
        }
      }
      function _t(L, ft, X, Et, It) {
        var Ae = L.element, Qt = L.data, Yt = L.internalformat, le = L.format, Ie = L.type, F = L.width, B = L.height;
        Vt(L), Ae ? E.texSubImage2D(ft, It, X, Et, le, Ie, Ae) : L.compressed ? E.compressedTexSubImage2D(ft, It, X, Et, Yt, F, B, Qt) : L.needsCopy ? (ut(), E.copyTexSubImage2D(
          ft,
          It,
          X,
          Et,
          L.xOffset,
          L.yOffset,
          F,
          B
        )) : E.texSubImage2D(ft, It, X, Et, F, B, le, Ie, Qt);
      }
      function bt() {
        return Xn.pop() || new tt();
      }
      function at(L) {
        L.needsFree && oe.freeType(L.data), tt.call(L), Xn.push(L);
      }
      function vt() {
        Pt.call(this), this.genMipmaps = !1, this.mipmapHint = 4352, this.mipmask = 0, this.images = Array(16);
      }
      function Z(L, ft, X) {
        var Et = L.images[0] = bt();
        L.mipmask = 1, Et.width = L.width = ft, Et.height = L.height = X, Et.channels = L.channels = 4;
      }
      function Mt(L, ft) {
        var X = null;
        if (O(ft)) X = L.images[0] = bt(), zt(X, L), ct(X, ft), L.mipmask = 1;
        else if (St(L, ft), Array.isArray(ft.mipmap)) for (var Et = ft.mipmap, It = 0; It < Et.length; ++It) X = L.images[It] = bt(), zt(X, L), X.width >>= It, X.height >>= It, ct(X, Et[It]), L.mipmask |= 1 << It;
        else X = L.images[0] = bt(), zt(X, L), ct(X, ft), L.mipmask = 1;
        zt(L, L.images[0]);
      }
      function mt(L, ft) {
        for (var X = L.images, Et = 0; Et < X.length && X[Et]; ++Et) {
          var It = X[Et], Ae = ft, Qt = Et, Yt = It.element, le = It.data, Ie = It.internalformat, F = It.format, B = It.type, J = It.width, nt = It.height;
          Vt(It), Yt ? E.texImage2D(Ae, Qt, F, F, B, Yt) : It.compressed ? E.compressedTexImage2D(Ae, Qt, Ie, Math.max(1, J), Math.max(1, nt), 0, le) : It.needsCopy ? (ut(), E.copyTexImage2D(
            Ae,
            Qt,
            F,
            It.xOffset,
            It.yOffset,
            J,
            nt,
            0
          )) : E.texImage2D(Ae, Qt, F, J, nt, 0, F, B, le || null);
        }
      }
      function xt() {
        var L = mi.pop() || new vt();
        Pt.call(L);
        for (var ft = L.mipmask = 0; 16 > ft; ++ft) L.images[ft] = null;
        return L;
      }
      function ce(L) {
        for (var ft = L.images, X = 0; X < ft.length; ++X) ft[X] && at(ft[X]), ft[X] = null;
        mi.push(L);
      }
      function Xe() {
        this.magFilter = this.minFilter = 9728, this.wrapT = this.wrapS = 33071, this.anisotropic = 1, this.genMipmaps = !1, this.mipmapHint = 4352;
      }
      function cn(L, ft) {
        "min" in ft && (L.minFilter = ze[ft.min], 0 <= vr.indexOf(L.minFilter) && !("faces" in ft) && (L.genMipmaps = !0)), "mag" in ft && (L.magFilter = de[ft.mag]);
        var X = L.wrapS, Et = L.wrapT;
        if ("wrap" in ft) {
          var It = ft.wrap;
          typeof It == "string" ? X = Et = Fe[It] : Array.isArray(It) && (X = Fe[It[0]], Et = Fe[It[1]]);
        } else "wrapS" in ft && (X = Fe[ft.wrapS]), "wrapT" in ft && (Et = Fe[ft.wrapT]);
        if (L.wrapS = X, L.wrapT = Et, "anisotropic" in ft && (L.anisotropic = ft.anisotropic), "mipmap" in ft) {
          switch (X = !1, typeof ft.mipmap) {
            case "string":
              L.mipmapHint = pe[ft.mipmap], X = L.genMipmaps = !0;
              break;
            case "boolean":
              X = L.genMipmaps = ft.mipmap;
              break;
            case "object":
              L.genMipmaps = !1, X = !0;
          }
          !X || "min" in ft || (L.minFilter = 9984);
        }
      }
      function je(L, ft) {
        E.texParameteri(ft, 10241, L.minFilter), E.texParameteri(ft, 10240, L.magFilter), E.texParameteri(ft, 10242, L.wrapS), E.texParameteri(ft, 10243, L.wrapT), V.ext_texture_filter_anisotropic && E.texParameteri(ft, 34046, L.anisotropic), L.genMipmaps && (E.hint(33170, L.mipmapHint), E.generateMipmap(ft));
      }
      function yt(L) {
        Pt.call(this), this.mipmask = 0, this.internalformat = 6408, this.id = ti++, this.refCount = 1, this.target = L, this.texture = E.createTexture(), this.unit = -1, this.bindCount = 0, this.texInfo = new Xe(), kt.profile && (this.stats = { size: 0 });
      }
      function ye(L) {
        E.activeTexture(33984), E.bindTexture(L.target, L.texture);
      }
      function ee() {
        var L = qn[0];
        L ? E.bindTexture(L.target, L.texture) : E.bindTexture(3553, null);
      }
      function Lt(L) {
        var ft = L.texture, X = L.unit, Et = L.target;
        0 <= X && (E.activeTexture(33984 + X), E.bindTexture(Et, null), qn[X] = null), E.deleteTexture(ft), L.texture = null, L.params = null, L.pixels = null, L.refCount = 0, delete Mn[L.id], gt.textureCount--;
      }
      var pe = { "don't care": 4352, "dont care": 4352, nice: 4354, fast: 4353 }, Fe = { repeat: 10497, clamp: 33071, mirror: 33648 }, de = {
        nearest: 9728,
        linear: 9729
      }, ze = Kt({ mipmap: 9987, "nearest mipmap nearest": 9984, "linear mipmap nearest": 9985, "nearest mipmap linear": 9986, "linear mipmap linear": 9987 }, de), fn = { none: 0, browser: 37444 }, ke = { uint8: 5121, rgba4: 32819, rgb565: 33635, "rgb5 a1": 32820 }, Ue = { alpha: 6406, luminance: 6409, "luminance alpha": 6410, rgb: 6407, rgba: 6408, rgba4: 32854, "rgb5 a1": 32855, rgb565: 36194 }, Zn = {};
      V.ext_srgb && (Ue.srgb = 35904, Ue.srgba = 35906), V.oes_texture_float && (ke.float32 = ke.float = 5126), V.oes_texture_half_float && (ke.float16 = ke["half float"] = 36193), V.webgl_depth_texture && (Kt(Ue, { depth: 6402, "depth stencil": 34041 }), Kt(ke, { uint16: 5123, uint32: 5125, "depth stencil": 34042 })), V.webgl_compressed_texture_s3tc && Kt(Zn, { "rgb s3tc dxt1": 33776, "rgba s3tc dxt1": 33777, "rgba s3tc dxt3": 33778, "rgba s3tc dxt5": 33779 }), V.webgl_compressed_texture_atc && Kt(Zn, { "rgb atc": 35986, "rgba atc explicit alpha": 35987, "rgba atc interpolated alpha": 34798 }), V.webgl_compressed_texture_pvrtc && Kt(Zn, { "rgb pvrtc 4bppv1": 35840, "rgb pvrtc 2bppv1": 35841, "rgba pvrtc 4bppv1": 35842, "rgba pvrtc 2bppv1": 35843 }), V.webgl_compressed_texture_etc1 && (Zn["rgb etc1"] = 36196);
      var _r = Array.prototype.slice.call(E.getParameter(34467));
      Object.keys(Zn).forEach(function(L) {
        var ft = Zn[L];
        0 <= _r.indexOf(ft) && (Ue[L] = ft);
      });
      var Pr = Object.keys(Ue);
      q.textureFormats = Pr;
      var cr = [];
      Object.keys(Ue).forEach(function(L) {
        cr[Ue[L]] = L;
      });
      var Vr = [];
      Object.keys(ke).forEach(function(L) {
        Vr[ke[L]] = L;
      });
      var Te = [];
      Object.keys(de).forEach(function(L) {
        Te[de[L]] = L;
      });
      var Le = [];
      Object.keys(ze).forEach(function(L) {
        Le[ze[L]] = L;
      });
      var rn = [];
      Object.keys(Fe).forEach(function(L) {
        rn[Fe[L]] = L;
      });
      var _e = Pr.reduce(function(L, ft) {
        var X = Ue[ft];
        return X === 6409 || X === 6406 || X === 6409 || X === 6410 || X === 6402 || X === 34041 || V.ext_srgb && (X === 35904 || X === 35906) ? L[X] = X : X === 32855 || 0 <= ft.indexOf("rgba") ? L[X] = 6408 : L[X] = 6407, L;
      }, {}), Xn = [], mi = [], ti = 0, Mn = {}, Dr = q.maxTextureUnits, qn = Array(Dr).map(function() {
        return null;
      });
      return Kt(yt.prototype, { bind: function() {
        this.bindCount += 1;
        var L = this.unit;
        if (0 > L) {
          for (var ft = 0; ft < Dr; ++ft) {
            var X = qn[ft];
            if (X) {
              if (0 < X.bindCount) continue;
              X.unit = -1;
            }
            qn[ft] = this, L = ft;
            break;
          }
          kt.profile && gt.maxTextureUnits < L + 1 && (gt.maxTextureUnits = L + 1), this.unit = L, E.activeTexture(33984 + L), E.bindTexture(this.target, this.texture);
        }
        return L;
      }, unbind: function() {
        --this.bindCount;
      }, decRef: function() {
        0 >= --this.refCount && Lt(this);
      } }), kt.profile && (gt.getTotalTextureSize = function() {
        var L = 0;
        return Object.keys(Mn).forEach(function(ft) {
          L += Mn[ft].stats.size;
        }), L;
      }), { create2D: function(L, ft) {
        function X(It, Ae) {
          var Qt = Et.texInfo;
          Xe.call(Qt);
          var Yt = xt();
          return typeof It == "number" ? typeof Ae == "number" ? Z(Yt, It | 0, Ae | 0) : Z(Yt, It | 0, It | 0) : It ? (cn(Qt, It), Mt(Yt, It)) : Z(Yt, 1, 1), Qt.genMipmaps && (Yt.mipmask = (Math.max(
            Yt.width,
            Yt.height
          ) << 1) - 1), Et.mipmask = Yt.mipmask, zt(Et, Yt), Et.internalformat = Yt.internalformat, X.width = Yt.width, X.height = Yt.height, ye(Et), mt(Yt, 3553), je(Qt, 3553), ee(), ce(Yt), kt.profile && (Et.stats.size = I(Et.internalformat, Et.type, Yt.width, Yt.height, Qt.genMipmaps, !1)), X.format = cr[Et.internalformat], X.type = Vr[Et.type], X.mag = Te[Qt.magFilter], X.min = Le[Qt.minFilter], X.wrapS = rn[Qt.wrapS], X.wrapT = rn[Qt.wrapT], X;
        }
        var Et = new yt(3553);
        return Mn[Et.id] = Et, gt.textureCount++, X(L, ft), X.subimage = function(It, Ae, Qt, Yt) {
          Ae |= 0, Qt |= 0, Yt |= 0;
          var le = bt();
          return zt(le, Et), le.width = 0, le.height = 0, ct(le, It), le.width = le.width || (Et.width >> Yt) - Ae, le.height = le.height || (Et.height >> Yt) - Qt, ye(Et), _t(le, 3553, Ae, Qt, Yt), ee(), at(le), X;
        }, X.resize = function(It, Ae) {
          var Qt = It | 0, Yt = Ae | 0 || Qt;
          if (Qt === Et.width && Yt === Et.height) return X;
          X.width = Et.width = Qt, X.height = Et.height = Yt, ye(Et);
          for (var le = 0; Et.mipmask >> le; ++le) {
            var Ie = Qt >> le, F = Yt >> le;
            if (!Ie || !F) break;
            E.texImage2D(3553, le, Et.format, Ie, F, 0, Et.format, Et.type, null);
          }
          return ee(), kt.profile && (Et.stats.size = I(Et.internalformat, Et.type, Qt, Yt, !1, !1)), X;
        }, X._reglType = "texture2d", X._texture = Et, kt.profile && (X.stats = Et.stats), X.destroy = function() {
          Et.decRef();
        }, X;
      }, createCube: function(L, ft, X, Et, It, Ae) {
        function Qt(Ie, F, B, J, nt, ot) {
          var rt, et = Yt.texInfo;
          for (Xe.call(et), rt = 0; 6 > rt; ++rt) le[rt] = xt();
          if (typeof Ie == "number" || !Ie) for (Ie = Ie | 0 || 1, rt = 0; 6 > rt; ++rt) Z(le[rt], Ie, Ie);
          else if (typeof Ie == "object") if (F) Mt(le[0], Ie), Mt(le[1], F), Mt(le[2], B), Mt(le[3], J), Mt(le[4], nt), Mt(le[5], ot);
          else if (cn(et, Ie), St(Yt, Ie), "faces" in Ie) for (Ie = Ie.faces, rt = 0; 6 > rt; ++rt) zt(le[rt], Yt), Mt(le[rt], Ie[rt]);
          else for (rt = 0; 6 > rt; ++rt) Mt(le[rt], Ie);
          for (zt(Yt, le[0]), Yt.mipmask = et.genMipmaps ? (Math.max(le[0].width, le[0].height) << 1) - 1 : le[0].mipmask, Yt.internalformat = le[0].internalformat, Qt.width = le[0].width, Qt.height = le[0].height, ye(Yt), rt = 0; 6 > rt; ++rt) mt(le[rt], 34069 + rt);
          for (je(et, 34067), ee(), kt.profile && (Yt.stats.size = I(Yt.internalformat, Yt.type, Qt.width, Qt.height, et.genMipmaps, !0)), Qt.format = cr[Yt.internalformat], Qt.type = Vr[Yt.type], Qt.mag = Te[et.magFilter], Qt.min = Le[et.minFilter], Qt.wrapS = rn[et.wrapS], Qt.wrapT = rn[et.wrapT], rt = 0; 6 > rt; ++rt) ce(le[rt]);
          return Qt;
        }
        var Yt = new yt(34067);
        Mn[Yt.id] = Yt, gt.cubeCount++;
        var le = Array(6);
        return Qt(L, ft, X, Et, It, Ae), Qt.subimage = function(Ie, F, B, J, nt) {
          B |= 0, J |= 0, nt |= 0;
          var ot = bt();
          return zt(ot, Yt), ot.width = 0, ot.height = 0, ct(ot, F), ot.width = ot.width || (Yt.width >> nt) - B, ot.height = ot.height || (Yt.height >> nt) - J, ye(Yt), _t(ot, 34069 + Ie, B, J, nt), ee(), at(ot), Qt;
        }, Qt.resize = function(Ie) {
          if (Ie |= 0, Ie !== Yt.width) {
            Qt.width = Yt.width = Ie, Qt.height = Yt.height = Ie, ye(Yt);
            for (var F = 0; 6 > F; ++F) for (var B = 0; Yt.mipmask >> B; ++B) E.texImage2D(34069 + F, B, Yt.format, Ie >> B, Ie >> B, 0, Yt.format, Yt.type, null);
            return ee(), kt.profile && (Yt.stats.size = I(Yt.internalformat, Yt.type, Qt.width, Qt.height, !1, !0)), Qt;
          }
        }, Qt._reglType = "textureCube", Qt._texture = Yt, kt.profile && (Qt.stats = Yt.stats), Qt.destroy = function() {
          Yt.decRef();
        }, Qt;
      }, clear: function() {
        for (var L = 0; L < Dr; ++L) E.activeTexture(33984 + L), E.bindTexture(3553, null), qn[L] = null;
        Ye(Mn).forEach(Lt), gt.cubeCount = 0, gt.textureCount = 0;
      }, getTexture: function(L) {
        return null;
      }, restore: function() {
        for (var L = 0; L < Dr; ++L) {
          var ft = qn[L];
          ft && (ft.bindCount = 0, ft.unit = -1, qn[L] = null);
        }
        Ye(Mn).forEach(function(X) {
          X.texture = E.createTexture(), E.bindTexture(X.target, X.texture);
          for (var Et = 0; 32 > Et; ++Et) if (X.mipmask & 1 << Et) if (X.target === 3553) E.texImage2D(
            3553,
            Et,
            X.internalformat,
            X.width >> Et,
            X.height >> Et,
            0,
            X.internalformat,
            X.type,
            null
          );
          else for (var It = 0; 6 > It; ++It) E.texImage2D(34069 + It, Et, X.internalformat, X.width >> Et, X.height >> Et, 0, X.internalformat, X.type, null);
          je(X.texInfo, X.target);
        });
      }, refresh: function() {
        for (var L = 0; L < Dr; ++L) {
          var ft = qn[L];
          ft && (ft.bindCount = 0, ft.unit = -1, qn[L] = null), E.activeTexture(33984 + L), E.bindTexture(3553, null), E.bindTexture(34067, null);
        }
      } };
    }
    function z(E, V, q, ut, ht, gt) {
      function kt(yt, ye, ee) {
        this.target = yt, this.texture = ye, this.renderbuffer = ee;
        var Lt = yt = 0;
        ye ? (yt = ye.width, Lt = ye.height) : ee && (yt = ee.width, Lt = ee.height), this.width = yt, this.height = Lt;
      }
      function Pt(yt) {
        yt && (yt.texture && yt.texture._texture.decRef(), yt.renderbuffer && yt.renderbuffer._renderbuffer.decRef());
      }
      function zt(yt, ye, ee) {
        yt && (yt.texture ? yt.texture._texture.refCount += 1 : yt.renderbuffer._renderbuffer.refCount += 1);
      }
      function St(yt, ye) {
        ye && (ye.texture ? E.framebufferTexture2D(36160, yt, ye.target, ye.texture._texture.texture, 0) : E.framebufferRenderbuffer(36160, yt, 36161, ye.renderbuffer._renderbuffer.renderbuffer));
      }
      function Vt(yt) {
        var ye = 3553, ee = null, Lt = null, pe = yt;
        return typeof yt == "object" && (pe = yt.data, "target" in yt && (ye = yt.target | 0)), yt = pe._reglType, yt === "texture2d" || yt === "textureCube" ? ee = pe : yt === "renderbuffer" && (Lt = pe, ye = 36161), new kt(ye, ee, Lt);
      }
      function tt(yt, ye, ee, Lt, pe) {
        return ee ? (yt = ut.create2D({ width: yt, height: ye, format: Lt, type: pe }), yt._texture.refCount = 0, new kt(3553, yt, null)) : (yt = ht.create({ width: yt, height: ye, format: Lt }), yt._renderbuffer.refCount = 0, new kt(36161, null, yt));
      }
      function ct(yt) {
        return yt && (yt.texture || yt.renderbuffer);
      }
      function _t(yt, ye, ee) {
        yt && (yt.texture ? yt.texture.resize(ye, ee) : yt.renderbuffer && yt.renderbuffer.resize(ye, ee), yt.width = ye, yt.height = ee);
      }
      function bt() {
        this.id = cn++, je[this.id] = this, this.framebuffer = E.createFramebuffer(), this.height = this.width = 0, this.colorAttachments = [], this.depthStencilAttachment = this.stencilAttachment = this.depthAttachment = null;
      }
      function at(yt) {
        yt.colorAttachments.forEach(Pt), Pt(yt.depthAttachment), Pt(yt.stencilAttachment), Pt(yt.depthStencilAttachment);
      }
      function vt(yt) {
        E.deleteFramebuffer(yt.framebuffer), yt.framebuffer = null, gt.framebufferCount--, delete je[yt.id];
      }
      function Z(yt, ye) {
        var ee;
        E.bindFramebuffer(
          36160,
          yt.framebuffer
        );
        var Lt = yt.colorAttachments;
        for (ee = 0; ee < Lt.length; ++ee) St(36064 + ee, Lt[ee]);
        for (ee = Lt.length; ee < q.maxColorAttachments; ++ee) E.framebufferTexture2D(36160, 36064 + ee, 3553, null, 0);
        E.framebufferTexture2D(36160, 33306, 3553, null, 0), E.framebufferTexture2D(36160, 36096, 3553, null, 0), E.framebufferTexture2D(36160, 36128, 3553, null, 0), St(36096, yt.depthAttachment), St(36128, yt.stencilAttachment), St(33306, yt.depthStencilAttachment), ye || (E.checkFramebufferStatus(36160), E.isContextLost()), E.bindFramebuffer(36160, mt.next ? mt.next.framebuffer : null), mt.cur = mt.next, ye || E.getError();
      }
      function Mt(yt, ye) {
        function ee(pe, Fe) {
          var de, ze = 0, fn = 0, ke = !0, Ue = !0;
          de = null;
          var Zn = !0, _r = "rgba", Pr = "uint8", cr = 1, Vr = null, Te = null, Le = null, rn = !1;
          if (typeof pe == "number") ze = pe | 0, fn = Fe | 0 || ze;
          else if (pe) {
            var _e = pe;
            "shape" in _e ? (fn = _e.shape, ze = fn[0], fn = fn[1]) : ("radius" in _e && (ze = fn = _e.radius), "width" in _e && (ze = _e.width), "height" in _e && (fn = _e.height)), ("color" in _e || "colors" in _e) && (de = _e.color || _e.colors), de || ("colorCount" in _e && (cr = _e.colorCount | 0), "colorTexture" in _e && (Zn = !!_e.colorTexture, _r = "rgba4"), "colorType" in _e && (Pr = _e.colorType, !Zn) && (Pr === "half float" || Pr === "float16" ? _r = "rgba16f" : (Pr === "float" || Pr === "float32") && (_r = "rgba32f")), "colorFormat" in _e && (_r = _e.colorFormat, 0 <= xt.indexOf(_r) ? Zn = !0 : 0 <= ce.indexOf(_r) && (Zn = !1))), ("depthTexture" in _e || "depthStencilTexture" in _e) && (rn = !(!_e.depthTexture && !_e.depthStencilTexture)), "depth" in _e && (typeof _e.depth == "boolean" ? ke = _e.depth : (Vr = _e.depth, Ue = !1)), "stencil" in _e && (typeof _e.stencil == "boolean" ? Ue = _e.stencil : (Te = _e.stencil, ke = !1)), "depthStencil" in _e && (typeof _e.depthStencil == "boolean" ? ke = Ue = _e.depthStencil : (Le = _e.depthStencil, Ue = ke = !1));
          } else ze = fn = 1;
          var Xn = null, mi = null, ti = null, Mn = null;
          if (Array.isArray(de)) Xn = de.map(Vt);
          else if (de) Xn = [Vt(de)];
          else for (Xn = Array(cr), de = 0; de < cr; ++de) Xn[de] = tt(ze, fn, Zn, _r, Pr);
          for (ze = ze || Xn[0].width, fn = fn || Xn[0].height, Vr ? mi = Vt(Vr) : ke && !Ue && (mi = tt(ze, fn, rn, "depth", "uint32")), Te ? ti = Vt(Te) : Ue && !ke && (ti = tt(ze, fn, !1, "stencil", "uint8")), Le ? Mn = Vt(Le) : !Vr && !Te && Ue && ke && (Mn = tt(ze, fn, rn, "depth stencil", "depth stencil")), ke = null, de = 0; de < Xn.length; ++de) zt(Xn[de]), Xn[de] && Xn[de].texture && (Ue = hs[Xn[de].texture._texture.format] * Gr[Xn[de].texture._texture.type], ke === null && (ke = Ue));
          return zt(mi), zt(ti), zt(Mn), at(Lt), Lt.width = ze, Lt.height = fn, Lt.colorAttachments = Xn, Lt.depthAttachment = mi, Lt.stencilAttachment = ti, Lt.depthStencilAttachment = Mn, ee.color = Xn.map(ct), ee.depth = ct(mi), ee.stencil = ct(ti), ee.depthStencil = ct(Mn), ee.width = Lt.width, ee.height = Lt.height, Z(Lt, _e && _e.ignoreStatusCheck), ee;
        }
        var Lt = new bt();
        return gt.framebufferCount++, ee(yt, ye), Kt(ee, { resize: function(pe, Fe) {
          var de = Math.max(pe | 0, 1), ze = Math.max(Fe | 0 || de, 1);
          if (de === Lt.width && ze === Lt.height) return ee;
          for (var fn = Lt.colorAttachments, ke = 0; ke < fn.length; ++ke) _t(
            fn[ke],
            de,
            ze
          );
          return _t(Lt.depthAttachment, de, ze), _t(Lt.stencilAttachment, de, ze), _t(Lt.depthStencilAttachment, de, ze), Lt.width = ee.width = de, Lt.height = ee.height = ze, Z(Lt), ee;
        }, blit: function(pe, Fe, de) {
          E.bindFramebuffer(36008, pe._framebuffer.framebuffer), E.bindFramebuffer(36009, Lt.framebuffer), Fe || (Fe = 16384), E.blitFramebuffer(0, 0, pe.width, pe.height, 0, 0, Lt.width, Lt.height, Fe, de === "linear" ? 9729 : 9728), E.bindFramebuffer(36008, null), E.bindFramebuffer(36009, null);
        }, _reglType: "framebuffer", _framebuffer: Lt, destroy: function() {
          vt(Lt), at(Lt);
        }, use: function(pe) {
          mt.setFBO(
            { framebuffer: ee },
            pe
          );
        } });
      }
      var mt = { cur: null, next: null, dirty: !1, setFBO: null }, xt = ["rgba"], ce = ["rgba4", "rgb565", "rgb5 a1"];
      V.ext_srgb && ce.push("srgba"), V.ext_color_buffer_half_float && ce.push("rgba16f", "rgb16f"), V.webgl_color_buffer_float && ce.push("rgba32f");
      var Xe = ["uint8"];
      V.oes_texture_half_float && Xe.push("half float", "float16"), V.oes_texture_float && Xe.push("float", "float32");
      var cn = 0, je = {};
      return Kt(mt, {
        getFramebuffer: function(yt) {
          return typeof yt == "function" && yt._reglType === "framebuffer" && (yt = yt._framebuffer, yt instanceof bt) ? yt : null;
        },
        create: Mt,
        createCube: function(yt) {
          function ye(Lt) {
            var pe, Fe = { color: null }, de = 0, ze = null;
            pe = "rgba";
            var fn = "uint8", ke = 1;
            if (typeof Lt == "number" ? de = Lt | 0 : Lt ? ("shape" in Lt ? de = Lt.shape[0] : ("radius" in Lt && (de = Lt.radius | 0), "width" in Lt ? de = Lt.width | 0 : "height" in Lt && (de = Lt.height | 0)), ("color" in Lt || "colors" in Lt) && (ze = Lt.color || Lt.colors), ze || ("colorCount" in Lt && (ke = Lt.colorCount | 0), "colorType" in Lt && (fn = Lt.colorType), "colorFormat" in Lt && (pe = Lt.colorFormat)), "depth" in Lt && (Fe.depth = Lt.depth), "stencil" in Lt && (Fe.stencil = Lt.stencil), "depthStencil" in Lt && (Fe.depthStencil = Lt.depthStencil)) : de = 1, ze) if (Array.isArray(ze)) for (Lt = [], pe = 0; pe < ze.length; ++pe) Lt[pe] = ze[pe];
            else Lt = [ze];
            else for (Lt = Array(ke), ze = { radius: de, format: pe, type: fn }, pe = 0; pe < ke; ++pe) Lt[pe] = ut.createCube(ze);
            for (Fe.color = Array(Lt.length), pe = 0; pe < Lt.length; ++pe) ke = Lt[pe], de = de || ke.width, Fe.color[pe] = { target: 34069, data: Lt[pe] };
            for (pe = 0; 6 > pe; ++pe) {
              for (ke = 0; ke < Lt.length; ++ke) Fe.color[ke].target = 34069 + pe;
              0 < pe && (Fe.depth = ee[0].depth, Fe.stencil = ee[0].stencil, Fe.depthStencil = ee[0].depthStencil), ee[pe] ? ee[pe](Fe) : ee[pe] = Mt(Fe);
            }
            return Kt(ye, {
              width: de,
              height: de,
              color: Lt
            });
          }
          var ee = Array(6);
          return ye(yt), Kt(ye, { faces: ee, resize: function(Lt) {
            var pe = Lt | 0;
            if (pe === ye.width) return ye;
            var Fe = ye.color;
            for (Lt = 0; Lt < Fe.length; ++Lt) Fe[Lt].resize(pe);
            for (Lt = 0; 6 > Lt; ++Lt) ee[Lt].resize(pe);
            return ye.width = ye.height = pe, ye;
          }, _reglType: "framebufferCube", destroy: function() {
            ee.forEach(function(Lt) {
              Lt.destroy();
            });
          } });
        },
        clear: function() {
          Ye(je).forEach(vt);
        },
        restore: function() {
          mt.cur = null, mt.next = null, mt.dirty = !0, Ye(je).forEach(function(yt) {
            yt.framebuffer = E.createFramebuffer(), Z(yt);
          });
        }
      });
    }
    function H() {
      this.w = this.z = this.y = this.x = this.state = 0, this.buffer = null, this.size = 0, this.normalized = !1, this.type = 5126, this.divisor = this.stride = this.offset = 0;
    }
    function G(E, V, q, ut, ht, gt, kt) {
      function Pt(Z) {
        if (Z !== vt.currentVAO) {
          var Mt = V.oes_vertex_array_object;
          Z ? Mt.bindVertexArrayOES(Z.vao) : Mt.bindVertexArrayOES(null), vt.currentVAO = Z;
        }
      }
      function zt(Z) {
        if (Z !== vt.currentVAO) {
          if (Z) Z.bindAttrs();
          else {
            for (var Mt = V.angle_instanced_arrays, mt = 0; mt < _t.length; ++mt) {
              var xt = _t[mt];
              xt.buffer ? (E.enableVertexAttribArray(mt), xt.buffer.bind(), E.vertexAttribPointer(
                mt,
                xt.size,
                xt.type,
                xt.normalized,
                xt.stride,
                xt.offfset
              ), Mt && xt.divisor && Mt.vertexAttribDivisorANGLE(mt, xt.divisor)) : (E.disableVertexAttribArray(mt), E.vertexAttrib4f(mt, xt.x, xt.y, xt.z, xt.w));
            }
            kt.elements ? E.bindBuffer(34963, kt.elements.buffer.buffer) : E.bindBuffer(34963, null);
          }
          vt.currentVAO = Z;
        }
      }
      function St() {
        Ye(at).forEach(function(Z) {
          Z.destroy();
        });
      }
      function Vt() {
        this.id = ++bt, this.attributes = [], this.elements = null, this.ownsElements = !1, this.offset = this.count = 0, this.instances = -1, this.primitive = 4;
        var Z = V.oes_vertex_array_object;
        this.vao = Z ? Z.createVertexArrayOES() : null, at[this.id] = this, this.buffers = [];
      }
      function tt() {
        V.oes_vertex_array_object && Ye(at).forEach(function(Z) {
          Z.refresh();
        });
      }
      var ct = q.maxAttributes, _t = Array(ct);
      for (q = 0; q < ct; ++q) _t[q] = new H();
      var bt = 0, at = {}, vt = { Record: H, scope: {}, state: _t, currentVAO: null, targetVAO: null, restore: V.oes_vertex_array_object ? tt : function() {
      }, createVAO: function(Z) {
        function Mt(xt) {
          var ce;
          Array.isArray(xt) ? (ce = xt, mt.elements && mt.ownsElements && mt.elements.destroy(), mt.elements = null, mt.ownsElements = !1, mt.offset = 0, mt.count = 0, mt.instances = -1, mt.primitive = 4) : (xt.elements ? (ce = xt.elements, mt.ownsElements ? (typeof ce == "function" && ce._reglType === "elements" ? mt.elements.destroy() : mt.elements(ce), mt.ownsElements = !1) : gt.getElements(xt.elements) ? (mt.elements = xt.elements, mt.ownsElements = !1) : (mt.elements = gt.create(xt.elements), mt.ownsElements = !0)) : (mt.elements = null, mt.ownsElements = !1), ce = xt.attributes, mt.offset = 0, mt.count = -1, mt.instances = -1, mt.primitive = 4, mt.elements && (mt.count = mt.elements._elements.vertCount, mt.primitive = mt.elements._elements.primType), "offset" in xt && (mt.offset = xt.offset | 0), "count" in xt && (mt.count = xt.count | 0), "instances" in xt && (mt.instances = xt.instances | 0), "primitive" in xt && (mt.primitive = Ze[xt.primitive])), xt = {};
          var Xe = mt.attributes;
          Xe.length = ce.length;
          for (var cn = 0; cn < ce.length; ++cn) {
            var je = ce[cn], yt = Xe[cn] = new H(), ye = je.data || je;
            if (Array.isArray(ye) || Ke(ye) || m(ye)) {
              var ee;
              mt.buffers[cn] && (ee = mt.buffers[cn], Ke(ye) && ee._buffer.byteLength >= ye.byteLength ? ee.subdata(ye) : (ee.destroy(), mt.buffers[cn] = null)), mt.buffers[cn] || (ee = mt.buffers[cn] = ht.create(je, 34962, !1, !0)), yt.buffer = ht.getBuffer(ee), yt.size = yt.buffer.dimension | 0, yt.normalized = !1, yt.type = yt.buffer.dtype, yt.offset = 0, yt.stride = 0, yt.divisor = 0, yt.state = 1, xt[cn] = 1;
            } else ht.getBuffer(je) ? (yt.buffer = ht.getBuffer(je), yt.size = yt.buffer.dimension | 0, yt.normalized = !1, yt.type = yt.buffer.dtype, yt.offset = 0, yt.stride = 0, yt.divisor = 0, yt.state = 1) : ht.getBuffer(je.buffer) ? (yt.buffer = ht.getBuffer(je.buffer), yt.size = (+je.size || yt.buffer.dimension) | 0, yt.normalized = !!je.normalized || !1, yt.type = "type" in je ? wn[je.type] : yt.buffer.dtype, yt.offset = (je.offset || 0) | 0, yt.stride = (je.stride || 0) | 0, yt.divisor = (je.divisor || 0) | 0, yt.state = 1) : "x" in je && (yt.x = +je.x || 0, yt.y = +je.y || 0, yt.z = +je.z || 0, yt.w = +je.w || 0, yt.state = 2);
          }
          for (ee = 0; ee < mt.buffers.length; ++ee) !xt[ee] && mt.buffers[ee] && (mt.buffers[ee].destroy(), mt.buffers[ee] = null);
          return mt.refresh(), Mt;
        }
        var mt = new Vt();
        return ut.vaoCount += 1, Mt.destroy = function() {
          for (var xt = 0; xt < mt.buffers.length; ++xt) mt.buffers[xt] && mt.buffers[xt].destroy();
          mt.buffers.length = 0, mt.ownsElements && (mt.elements.destroy(), mt.elements = null, mt.ownsElements = !1), mt.destroy();
        }, Mt._vao = mt, Mt._reglType = "vao", Mt(Z);
      }, getVAO: function(Z) {
        return typeof Z == "function" && Z._vao ? Z._vao : null;
      }, destroyBuffer: function(Z) {
        for (var Mt = 0; Mt < _t.length; ++Mt) {
          var mt = _t[Mt];
          mt.buffer === Z && (E.disableVertexAttribArray(Mt), mt.buffer = null);
        }
      }, setVAO: V.oes_vertex_array_object ? Pt : zt, clear: V.oes_vertex_array_object ? St : function() {
      } };
      return Vt.prototype.bindAttrs = function() {
        for (var Z = V.angle_instanced_arrays, Mt = this.attributes, mt = 0; mt < Mt.length; ++mt) {
          var xt = Mt[mt];
          xt.buffer ? (E.enableVertexAttribArray(mt), E.bindBuffer(34962, xt.buffer.buffer), E.vertexAttribPointer(mt, xt.size, xt.type, xt.normalized, xt.stride, xt.offset), Z && xt.divisor && Z.vertexAttribDivisorANGLE(mt, xt.divisor)) : (E.disableVertexAttribArray(mt), E.vertexAttrib4f(mt, xt.x, xt.y, xt.z, xt.w));
        }
        for (Z = Mt.length; Z < ct; ++Z) E.disableVertexAttribArray(Z);
        (Z = gt.getElements(this.elements)) ? E.bindBuffer(34963, Z.buffer.buffer) : E.bindBuffer(34963, null);
      }, Vt.prototype.refresh = function() {
        var Z = V.oes_vertex_array_object;
        Z && (Z.bindVertexArrayOES(this.vao), this.bindAttrs(), vt.currentVAO = null, Z.bindVertexArrayOES(null));
      }, Vt.prototype.destroy = function() {
        if (this.vao) {
          var Z = V.oes_vertex_array_object;
          this === vt.currentVAO && (vt.currentVAO = null, Z.bindVertexArrayOES(null)), Z.deleteVertexArrayOES(this.vao), this.vao = null;
        }
        this.ownsElements && (this.elements.destroy(), this.elements = null, this.ownsElements = !1), at[this.id] && (delete at[this.id], --ut.vaoCount);
      }, vt;
    }
    function $(E, V, q, ut) {
      function ht(bt, at, vt, Z) {
        this.name = bt, this.id = at, this.location = vt, this.info = Z;
      }
      function gt(bt, at) {
        for (var vt = 0; vt < bt.length; ++vt) if (bt[vt].id === at.id) {
          bt[vt].location = at.location;
          return;
        }
        bt.push(at);
      }
      function kt(bt, at, vt) {
        vt = bt === 35632 ? St : Vt;
        var Z = vt[at];
        if (!Z) {
          var Mt = V.str(at), Z = E.createShader(bt);
          E.shaderSource(Z, Mt), E.compileShader(Z), vt[at] = Z;
        }
        return Z;
      }
      function Pt(bt, at) {
        this.id = _t++, this.fragId = bt, this.vertId = at, this.program = null, this.uniforms = [], this.attributes = [], this.refCount = 1, ut.profile && (this.stats = { uniformsCount: 0, attributesCount: 0 });
      }
      function zt(bt, at, vt) {
        var Z;
        Z = kt(35632, bt.fragId);
        var Mt = kt(35633, bt.vertId);
        if (at = bt.program = E.createProgram(), E.attachShader(at, Z), E.attachShader(at, Mt), vt) for (Z = 0; Z < vt.length; ++Z) Mt = vt[Z], E.bindAttribLocation(at, Mt[0], Mt[1]);
        E.linkProgram(at), Mt = E.getProgramParameter(at, 35718), ut.profile && (bt.stats.uniformsCount = Mt);
        var mt = bt.uniforms;
        for (Z = 0; Z < Mt; ++Z) if (vt = E.getActiveUniform(at, Z)) {
          if (1 < vt.size) for (var xt = 0; xt < vt.size; ++xt) {
            var ce = vt.name.replace("[0]", "[" + xt + "]");
            gt(mt, new ht(ce, V.id(ce), E.getUniformLocation(at, ce), vt));
          }
          xt = vt.name, 1 < vt.size && (xt = xt.replace("[0]", "")), gt(mt, new ht(xt, V.id(xt), E.getUniformLocation(at, xt), vt));
        }
        for (Mt = E.getProgramParameter(at, 35721), ut.profile && (bt.stats.attributesCount = Mt), bt = bt.attributes, Z = 0; Z < Mt; ++Z) (vt = E.getActiveAttrib(at, Z)) && gt(bt, new ht(vt.name, V.id(vt.name), E.getAttribLocation(at, vt.name), vt));
      }
      var St = {}, Vt = {}, tt = {}, ct = [], _t = 0;
      return ut.profile && (q.getMaxUniformsCount = function() {
        var bt = 0;
        return ct.forEach(function(at) {
          at.stats.uniformsCount > bt && (bt = at.stats.uniformsCount);
        }), bt;
      }, q.getMaxAttributesCount = function() {
        var bt = 0;
        return ct.forEach(function(at) {
          at.stats.attributesCount > bt && (bt = at.stats.attributesCount);
        }), bt;
      }), { clear: function() {
        var bt = E.deleteShader.bind(E);
        Ye(St).forEach(bt), St = {}, Ye(Vt).forEach(bt), Vt = {}, ct.forEach(function(at) {
          E.deleteProgram(at.program);
        }), ct.length = 0, tt = {}, q.shaderCount = 0;
      }, program: function(bt, at, vt, Z) {
        var Mt = tt[at];
        Mt || (Mt = tt[at] = {});
        var mt = Mt[bt];
        if (mt && (mt.refCount++, !Z)) return mt;
        var xt = new Pt(at, bt);
        return q.shaderCount++, zt(xt, vt, Z), mt || (Mt[bt] = xt), ct.push(xt), Kt(xt, { destroy: function() {
          if (xt.refCount--, 0 >= xt.refCount) {
            E.deleteProgram(xt.program);
            var ce = ct.indexOf(xt);
            ct.splice(ce, 1), q.shaderCount--;
          }
          0 >= Mt[xt.vertId].refCount && (E.deleteShader(Vt[xt.vertId]), delete Vt[xt.vertId], delete tt[xt.fragId][xt.vertId]), Object.keys(tt[xt.fragId]).length || (E.deleteShader(St[xt.fragId]), delete St[xt.fragId], delete tt[xt.fragId]);
        } });
      }, restore: function() {
        St = {}, Vt = {};
        for (var bt = 0; bt < ct.length; ++bt) zt(ct[bt], null, ct[bt].attributes.map(function(at) {
          return [
            at.location,
            at.name
          ];
        }));
      }, shader: kt, frag: -1, vert: -1 };
    }
    function K(E, V, q, ut, ht, gt, kt) {
      function Pt(St) {
        var Vt;
        Vt = V.next === null ? 5121 : V.next.colorAttachments[0].texture._texture.type;
        var tt = 0, ct = 0, _t = ut.framebufferWidth, bt = ut.framebufferHeight, at = null;
        return Ke(St) ? at = St : St && (tt = St.x | 0, ct = St.y | 0, _t = (St.width || ut.framebufferWidth - tt) | 0, bt = (St.height || ut.framebufferHeight - ct) | 0, at = St.data || null), q(), St = _t * bt * 4, at || (Vt === 5121 ? at = new Uint8Array(St) : Vt === 5126 && (at = at || new Float32Array(St))), E.pixelStorei(3333, 4), E.readPixels(tt, ct, _t, bt, 6408, Vt, at), at;
      }
      function zt(St) {
        var Vt;
        return V.setFBO({ framebuffer: St.framebuffer }, function() {
          Vt = Pt(St);
        }), Vt;
      }
      return function(St) {
        return St && "framebuffer" in St ? zt(St) : Pt(St);
      };
    }
    function dt(E) {
      return Array.prototype.slice.call(E);
    }
    function it(E) {
      return dt(E).join("");
    }
    function st() {
      function E() {
        var Pt = [], zt = [];
        return Kt(function() {
          Pt.push.apply(Pt, dt(arguments));
        }, { def: function() {
          var St = "v" + q++;
          return zt.push(St), 0 < arguments.length && (Pt.push(St, "="), Pt.push.apply(Pt, dt(arguments)), Pt.push(";")), St;
        }, toString: function() {
          return it([
            0 < zt.length ? "var " + zt.join(",") + ";" : "",
            it(Pt)
          ]);
        } });
      }
      function V() {
        function Pt(ct, _t) {
          St(ct, _t, "=", zt.def(ct, _t), ";");
        }
        var zt = E(), St = E(), Vt = zt.toString, tt = St.toString;
        return Kt(function() {
          zt.apply(zt, dt(arguments));
        }, { def: zt.def, entry: zt, exit: St, save: Pt, set: function(ct, _t, bt) {
          Pt(ct, _t), zt(ct, _t, "=", bt, ";");
        }, toString: function() {
          return Vt() + tt();
        } });
      }
      var q = 0, ut = [], ht = [], gt = E(), kt = {};
      return { global: gt, link: function(Pt) {
        for (var zt = 0; zt < ht.length; ++zt) if (ht[zt] === Pt) return ut[zt];
        return zt = "g" + q++, ut.push(zt), ht.push(Pt), zt;
      }, block: E, proc: function(Pt, zt) {
        function St() {
          var _t = "a" + Vt.length;
          return Vt.push(_t), _t;
        }
        var Vt = [];
        zt = zt || 0;
        for (var tt = 0; tt < zt; ++tt) St();
        var tt = V(), ct = tt.toString;
        return kt[Pt] = Kt(tt, { arg: St, toString: function() {
          return it(["function(", Vt.join(), "){", ct(), "}"]);
        } });
      }, scope: V, cond: function() {
        var Pt = it(arguments), zt = V(), St = V(), Vt = zt.toString, tt = St.toString;
        return Kt(zt, { then: function() {
          return zt.apply(zt, dt(arguments)), this;
        }, else: function() {
          return St.apply(St, dt(arguments)), this;
        }, toString: function() {
          var ct = tt();
          return ct && (ct = "else{" + ct + "}"), it(["if(", Pt, "){", Vt(), "}", ct]);
        } });
      }, compile: function() {
        var Pt = ['"use strict";', gt, "return {"];
        Object.keys(kt).forEach(function(St) {
          Pt.push('"', St, '":', kt[St].toString(), ",");
        }), Pt.push("}");
        var zt = it(Pt).replace(/;/g, `;
`).replace(/}/g, `}
`).replace(/{/g, `{
`);
        return Function.apply(null, ut.concat(zt)).apply(null, ht);
      } };
    }
    function pt(E) {
      return Array.isArray(E) || Ke(E) || m(E);
    }
    function Ht(E) {
      return E.sort(function(V, q) {
        return V === "viewport" ? -1 : q === "viewport" ? 1 : V < q ? -1 : 1;
      });
    }
    function Rt(E, V, q, ut) {
      this.thisDep = E, this.contextDep = V, this.propDep = q, this.append = ut;
    }
    function Tt(E) {
      return E && !(E.thisDep || E.contextDep || E.propDep);
    }
    function $t(E) {
      return new Rt(!1, !1, !1, E);
    }
    function Wt(E, V) {
      var q = E.type;
      if (q === 0) return q = E.data.length, new Rt(!0, 1 <= q, 2 <= q, V);
      if (q === 4) return q = E.data, new Rt(q.thisDep, q.contextDep, q.propDep, V);
      if (q === 5) return new Rt(!1, !1, !1, V);
      if (q === 6) {
        for (var ut = q = !1, ht = !1, gt = 0; gt < E.data.length; ++gt) {
          var kt = E.data[gt];
          kt.type === 1 ? ht = !0 : kt.type === 2 ? ut = !0 : kt.type === 3 ? q = !0 : kt.type === 0 ? (q = !0, kt = kt.data, 1 <= kt && (ut = !0), 2 <= kt && (ht = !0)) : kt.type === 4 && (q = q || kt.data.thisDep, ut = ut || kt.data.contextDep, ht = ht || kt.data.propDep);
        }
        return new Rt(q, ut, ht, V);
      }
      return new Rt(q === 3, q === 2, q === 1, V);
    }
    function re(E, V, q, ut, ht, gt, kt, Pt, zt, St, Vt, tt, ct, _t, bt) {
      function at(F) {
        return F.replace(".", "_");
      }
      function vt(F, B, J) {
        var nt = at(F);
        It.push(F), Et[nt] = X[nt] = !!J, Ae[nt] = B;
      }
      function Z(F, B, J) {
        var nt = at(F);
        It.push(F), Array.isArray(J) ? (X[nt] = J.slice(), Et[nt] = J.slice()) : X[nt] = Et[nt] = J, Qt[nt] = B;
      }
      function Mt() {
        var F = st(), B = F.link, J = F.global;
        F.id = Ie++, F.batchId = "0";
        var nt = B(Yt), ot = F.shared = { props: "a0" };
        Object.keys(Yt).forEach(function(j) {
          ot[j] = J.def(nt, ".", j);
        });
        var rt = F.next = {}, et = F.current = {};
        Object.keys(Qt).forEach(function(j) {
          Array.isArray(X[j]) && (rt[j] = J.def(ot.next, ".", j), et[j] = J.def(ot.current, ".", j));
        });
        var Q = F.constants = {};
        Object.keys(le).forEach(function(j) {
          Q[j] = J.def(JSON.stringify(le[j]));
        }), F.invoke = function(j, U) {
          switch (U.type) {
            case 0:
              var wt = ["this", ot.context, ot.props, F.batchId];
              return j.def(B(U.data), ".call(", wt.slice(0, Math.max(U.data.length + 1, 4)), ")");
            case 1:
              return j.def(ot.props, U.data);
            case 2:
              return j.def(ot.context, U.data);
            case 3:
              return j.def("this", U.data);
            case 4:
              return U.data.append(F, j), U.data.ref;
            case 5:
              return U.data.toString();
            case 6:
              return U.data.map(function(At) {
                return F.invoke(j, At);
              });
          }
        }, F.attribCache = {};
        var N = {};
        return F.scopeAttrib = function(j) {
          if (j = V.id(j), j in N) return N[j];
          var U = St.scope[j];
          return U || (U = St.scope[j] = new Mn()), N[j] = B(U);
        }, F;
      }
      function mt(F) {
        var B = F.static;
        F = F.dynamic;
        var J;
        if ("profile" in B) {
          var nt = !!B.profile;
          J = $t(function(rt, et) {
            return nt;
          }), J.enable = nt;
        } else if ("profile" in F) {
          var ot = F.profile;
          J = Wt(ot, function(rt, et) {
            return rt.invoke(et, ot);
          });
        }
        return J;
      }
      function xt(F, B) {
        var J = F.static, nt = F.dynamic;
        if ("framebuffer" in J) {
          var ot = J.framebuffer;
          return ot ? (ot = Pt.getFramebuffer(ot), $t(function(et, Q) {
            var N = et.link(ot), j = et.shared;
            return Q.set(j.framebuffer, ".next", N), j = j.context, Q.set(j, ".framebufferWidth", N + ".width"), Q.set(j, ".framebufferHeight", N + ".height"), N;
          })) : $t(function(et, Q) {
            var N = et.shared;
            return Q.set(N.framebuffer, ".next", "null"), N = N.context, Q.set(N, ".framebufferWidth", N + ".drawingBufferWidth"), Q.set(N, ".framebufferHeight", N + ".drawingBufferHeight"), "null";
          });
        }
        if ("framebuffer" in nt) {
          var rt = nt.framebuffer;
          return Wt(rt, function(et, Q) {
            var U = et.invoke(Q, rt), N = et.shared, j = N.framebuffer, U = Q.def(j, ".getFramebuffer(", U, ")");
            return Q.set(j, ".next", U), N = N.context, Q.set(N, ".framebufferWidth", U + "?" + U + ".width:" + N + ".drawingBufferWidth"), Q.set(N, ".framebufferHeight", U + "?" + U + ".height:" + N + ".drawingBufferHeight"), U;
          });
        }
        return null;
      }
      function ce(F, B, J) {
        function nt(Q) {
          if (Q in ot) {
            var N = ot[Q];
            Q = !0;
            var j = N.x | 0, U = N.y | 0, wt, At;
            return "width" in N ? wt = N.width | 0 : Q = !1, "height" in N ? At = N.height | 0 : Q = !1, new Rt(!Q && B && B.thisDep, !Q && B && B.contextDep, !Q && B && B.propDep, function(Dt, Nt) {
              var Bt = Dt.shared.context, Gt = wt;
              "width" in N || (Gt = Nt.def(Bt, ".", "framebufferWidth", "-", j));
              var se = At;
              return "height" in N || (se = Nt.def(Bt, ".", "framebufferHeight", "-", U)), [j, U, Gt, se];
            });
          }
          if (Q in rt) {
            var Zt = rt[Q];
            return Q = Wt(Zt, function(Dt, Nt) {
              var Me = Dt.invoke(Nt, Zt), Bt = Dt.shared.context, Gt = Nt.def(Me, ".x|0"), se = Nt.def(Me, ".y|0"), te = Nt.def('"width" in ', Me, "?", Me, ".width|0:", "(", Bt, ".", "framebufferWidth", "-", Gt, ")"), Me = Nt.def('"height" in ', Me, "?", Me, ".height|0:", "(", Bt, ".", "framebufferHeight", "-", se, ")");
              return [Gt, se, te, Me];
            }), B && (Q.thisDep = Q.thisDep || B.thisDep, Q.contextDep = Q.contextDep || B.contextDep, Q.propDep = Q.propDep || B.propDep), Q;
          }
          return B ? new Rt(B.thisDep, B.contextDep, B.propDep, function(Dt, Nt) {
            var Bt = Dt.shared.context;
            return [0, 0, Nt.def(Bt, ".", "framebufferWidth"), Nt.def(Bt, ".", "framebufferHeight")];
          }) : null;
        }
        var ot = F.static, rt = F.dynamic;
        if (F = nt("viewport")) {
          var et = F;
          F = new Rt(F.thisDep, F.contextDep, F.propDep, function(Q, N) {
            var j = et.append(Q, N), U = Q.shared.context;
            return N.set(U, ".viewportWidth", j[2]), N.set(U, ".viewportHeight", j[3]), j;
          });
        }
        return { viewport: F, scissor_box: nt("scissor.box") };
      }
      function Xe(F, B) {
        var J = F.static;
        if (typeof J.frag == "string" && typeof J.vert == "string") {
          if (0 < Object.keys(B.dynamic).length) return null;
          var J = B.static, nt = Object.keys(J);
          if (0 < nt.length && typeof J[nt[0]] == "number") {
            for (var ot = [], rt = 0; rt < nt.length; ++rt) ot.push([J[nt[rt]] | 0, nt[rt]]);
            return ot;
          }
        }
        return null;
      }
      function cn(F, B, J) {
        function nt(j) {
          if (j in ot) {
            var U = V.id(ot[j]);
            return j = $t(function() {
              return U;
            }), j.id = U, j;
          }
          if (j in rt) {
            var wt = rt[j];
            return Wt(wt, function(At, Zt) {
              var Dt = At.invoke(Zt, wt);
              return Zt.def(At.shared.strings, ".id(", Dt, ")");
            });
          }
          return null;
        }
        var ot = F.static, rt = F.dynamic, et = nt("frag"), Q = nt("vert"), N = null;
        return Tt(et) && Tt(Q) ? (N = Vt.program(Q.id, et.id, null, J), F = $t(function(j, U) {
          return j.link(N);
        })) : F = new Rt(et && et.thisDep || Q && Q.thisDep, et && et.contextDep || Q && Q.contextDep, et && et.propDep || Q && Q.propDep, function(j, U) {
          var wt = j.shared.shader, At;
          At = et ? et.append(j, U) : U.def(wt, ".", "frag");
          var Zt;
          return Zt = Q ? Q.append(j, U) : U.def(wt, ".", "vert"), U.def(wt + ".program(" + Zt + "," + At + ")");
        }), { frag: et, vert: Q, progVar: F, program: N };
      }
      function je(F, B) {
        function J(Dt, Nt) {
          if (Dt in nt) {
            var Bt = nt[Dt] | 0;
            return Nt ? rt.offset = Bt : rt.instances = Bt, $t(function(se, te) {
              return Nt && (se.OFFSET = Bt), Bt;
            });
          }
          if (Dt in ot) {
            var Gt = ot[Dt];
            return Wt(Gt, function(se, te) {
              var Me = se.invoke(te, Gt);
              return Nt && (se.OFFSET = Me), Me;
            });
          }
          if (Nt) {
            if (N) return $t(function(se, te) {
              return se.OFFSET = 0;
            });
            if (et) return new Rt(Q.thisDep, Q.contextDep, Q.propDep, function(se, te) {
              return te.def(se.shared.vao + ".currentVAO?" + se.shared.vao + ".currentVAO.offset:0");
            });
          } else if (et) return new Rt(Q.thisDep, Q.contextDep, Q.propDep, function(se, te) {
            return te.def(se.shared.vao + ".currentVAO?" + se.shared.vao + ".currentVAO.instances:-1");
          });
          return null;
        }
        var nt = F.static, ot = F.dynamic, rt = {}, et = !1, Q = function() {
          if ("vao" in nt) {
            var Dt = nt.vao;
            return Dt !== null && St.getVAO(Dt) === null && (Dt = St.createVAO(Dt)), et = !0, rt.vao = Dt, $t(function(Bt) {
              var Gt = St.getVAO(Dt);
              return Gt ? Bt.link(Gt) : "null";
            });
          }
          if ("vao" in ot) {
            et = !0;
            var Nt = ot.vao;
            return Wt(Nt, function(Bt, Gt) {
              var se = Bt.invoke(Gt, Nt);
              return Gt.def(Bt.shared.vao + ".getVAO(" + se + ")");
            });
          }
          return null;
        }(), N = !1, j = function() {
          if ("elements" in nt) {
            var Dt = nt.elements;
            if (rt.elements = Dt, pt(Dt)) {
              var Nt = rt.elements = gt.create(Dt, !0), Dt = gt.getElements(Nt);
              N = !0;
            } else Dt && (Dt = gt.getElements(Dt), N = !0);
            return Nt = $t(function(Gt, se) {
              if (Dt) {
                var te = Gt.link(Dt);
                return Gt.ELEMENTS = te;
              }
              return Gt.ELEMENTS = null;
            }), Nt.value = Dt, Nt;
          }
          if ("elements" in ot) {
            N = !0;
            var Bt = ot.elements;
            return Wt(Bt, function(Gt, se) {
              var te = Gt.shared, xr = te.isBufferArgs, te = te.elements, Gl = Gt.invoke(se, Bt), Me = se.def("null"), xr = se.def(xr, "(", Gl, ")"), Gl = Gt.cond(xr).then(Me, "=", te, ".createStream(", Gl, ");").else(Me, "=", te, ".getElements(", Gl, ");");
              return se.entry(Gl), se.exit(Gt.cond(xr).then(te, ".destroyStream(", Me, ");")), Gt.ELEMENTS = Me;
            });
          }
          return et ? new Rt(
            Q.thisDep,
            Q.contextDep,
            Q.propDep,
            function(Gt, se) {
              return se.def(Gt.shared.vao + ".currentVAO?" + Gt.shared.elements + ".getElements(" + Gt.shared.vao + ".currentVAO.elements):null");
            }
          ) : null;
        }(), U = J("offset", !0), wt = function() {
          if ("primitive" in nt) {
            var Dt = nt.primitive;
            return rt.primitive = Dt, $t(function(Bt, Gt) {
              return Ze[Dt];
            });
          }
          if ("primitive" in ot) {
            var Nt = ot.primitive;
            return Wt(Nt, function(Bt, Gt) {
              var se = Bt.constants.primTypes, te = Bt.invoke(Gt, Nt);
              return Gt.def(se, "[", te, "]");
            });
          }
          return N ? Tt(j) ? j.value ? $t(function(Bt, Gt) {
            return Gt.def(Bt.ELEMENTS, ".primType");
          }) : $t(function() {
            return 4;
          }) : new Rt(j.thisDep, j.contextDep, j.propDep, function(Bt, Gt) {
            var se = Bt.ELEMENTS;
            return Gt.def(se, "?", se, ".primType:", 4);
          }) : et ? new Rt(Q.thisDep, Q.contextDep, Q.propDep, function(Bt, Gt) {
            return Gt.def(Bt.shared.vao + ".currentVAO?" + Bt.shared.vao + ".currentVAO.primitive:4");
          }) : null;
        }(), At = function() {
          if ("count" in nt) {
            var Dt = nt.count | 0;
            return rt.count = Dt, $t(function() {
              return Dt;
            });
          }
          if ("count" in ot) {
            var Nt = ot.count;
            return Wt(Nt, function(Bt, Gt) {
              return Bt.invoke(Gt, Nt);
            });
          }
          return N ? Tt(j) ? j ? U ? new Rt(U.thisDep, U.contextDep, U.propDep, function(Bt, Gt) {
            return Gt.def(
              Bt.ELEMENTS,
              ".vertCount-",
              Bt.OFFSET
            );
          }) : $t(function(Bt, Gt) {
            return Gt.def(Bt.ELEMENTS, ".vertCount");
          }) : $t(function() {
            return -1;
          }) : new Rt(j.thisDep || U.thisDep, j.contextDep || U.contextDep, j.propDep || U.propDep, function(Bt, Gt) {
            var se = Bt.ELEMENTS;
            return Bt.OFFSET ? Gt.def(se, "?", se, ".vertCount-", Bt.OFFSET, ":-1") : Gt.def(se, "?", se, ".vertCount:-1");
          }) : et ? new Rt(Q.thisDep, Q.contextDep, Q.propDep, function(Bt, Gt) {
            return Gt.def(Bt.shared.vao, ".currentVAO?", Bt.shared.vao, ".currentVAO.count:-1");
          }) : null;
        }(), Zt = J("instances", !1);
        return {
          elements: j,
          primitive: wt,
          count: At,
          instances: Zt,
          offset: U,
          vao: Q,
          vaoActive: et,
          elementsActive: N,
          static: rt
        };
      }
      function yt(F, B) {
        var J = F.static, nt = F.dynamic, ot = {};
        return It.forEach(function(rt) {
          function et(N, j) {
            if (rt in J) {
              var U = N(J[rt]);
              ot[Q] = $t(function() {
                return U;
              });
            } else if (rt in nt) {
              var wt = nt[rt];
              ot[Q] = Wt(wt, function(At, Zt) {
                return j(At, Zt, At.invoke(Zt, wt));
              });
            }
          }
          var Q = at(rt);
          switch (rt) {
            case "cull.enable":
            case "blend.enable":
            case "dither":
            case "stencil.enable":
            case "depth.enable":
            case "scissor.enable":
            case "polygonOffset.enable":
            case "sample.alpha":
            case "sample.enable":
            case "depth.mask":
              return et(
                function(N) {
                  return N;
                },
                function(N, j, U) {
                  return U;
                }
              );
            case "depth.func":
              return et(function(N) {
                return Ir[N];
              }, function(N, j, U) {
                return j.def(N.constants.compareFuncs, "[", U, "]");
              });
            case "depth.range":
              return et(function(N) {
                return N;
              }, function(N, j, U) {
                return N = j.def("+", U, "[0]"), j = j.def("+", U, "[1]"), [N, j];
              });
            case "blend.func":
              return et(function(N) {
                return [rr["srcRGB" in N ? N.srcRGB : N.src], rr["dstRGB" in N ? N.dstRGB : N.dst], rr["srcAlpha" in N ? N.srcAlpha : N.src], rr["dstAlpha" in N ? N.dstAlpha : N.dst]];
              }, function(N, j, U) {
                function wt(Nt, Bt) {
                  return j.def(
                    '"',
                    Nt,
                    Bt,
                    '" in ',
                    U,
                    "?",
                    U,
                    ".",
                    Nt,
                    Bt,
                    ":",
                    U,
                    ".",
                    Nt
                  );
                }
                N = N.constants.blendFuncs;
                var At = wt("src", "RGB"), Dt = wt("dst", "RGB"), At = j.def(N, "[", At, "]"), Zt = j.def(N, "[", wt("src", "Alpha"), "]"), Dt = j.def(N, "[", Dt, "]");
                return N = j.def(N, "[", wt("dst", "Alpha"), "]"), [At, Dt, Zt, N];
              });
            case "blend.equation":
              return et(function(N) {
                if (typeof N == "string") return [Dr[N], Dr[N]];
                if (typeof N == "object") return [Dr[N.rgb], Dr[N.alpha]];
              }, function(N, j, U) {
                var wt = N.constants.blendEquations, At = j.def(), Zt = j.def();
                return N = N.cond("typeof ", U, '==="string"'), N.then(
                  At,
                  "=",
                  Zt,
                  "=",
                  wt,
                  "[",
                  U,
                  "];"
                ), N.else(At, "=", wt, "[", U, ".rgb];", Zt, "=", wt, "[", U, ".alpha];"), j(N), [At, Zt];
              });
            case "blend.color":
              return et(function(N) {
                return d(4, function(j) {
                  return +N[j];
                });
              }, function(N, j, U) {
                return d(4, function(wt) {
                  return j.def("+", U, "[", wt, "]");
                });
              });
            case "stencil.mask":
              return et(function(N) {
                return N | 0;
              }, function(N, j, U) {
                return j.def(U, "|0");
              });
            case "stencil.func":
              return et(function(N) {
                return [Ir[N.cmp || "keep"], N.ref || 0, "mask" in N ? N.mask : -1];
              }, function(N, j, U) {
                N = j.def(
                  '"cmp" in ',
                  U,
                  "?",
                  N.constants.compareFuncs,
                  "[",
                  U,
                  ".cmp]",
                  ":",
                  7680
                );
                var wt = j.def(U, ".ref|0");
                return j = j.def('"mask" in ', U, "?", U, ".mask|0:-1"), [N, wt, j];
              });
            case "stencil.opFront":
            case "stencil.opBack":
              return et(function(N) {
                return [rt === "stencil.opBack" ? 1029 : 1028, _o[N.fail || "keep"], _o[N.zfail || "keep"], _o[N.zpass || "keep"]];
              }, function(N, j, U) {
                function wt(Zt) {
                  return j.def('"', Zt, '" in ', U, "?", At, "[", U, ".", Zt, "]:", 7680);
                }
                var At = N.constants.stencilOps;
                return [rt === "stencil.opBack" ? 1029 : 1028, wt("fail"), wt("zfail"), wt("zpass")];
              });
            case "polygonOffset.offset":
              return et(function(N) {
                return [N.factor | 0, N.units | 0];
              }, function(N, j, U) {
                return N = j.def(U, ".factor|0"), j = j.def(U, ".units|0"), [N, j];
              });
            case "cull.face":
              return et(function(N) {
                var j = 0;
                return N === "front" ? j = 1028 : N === "back" && (j = 1029), j;
              }, function(N, j, U) {
                return j.def(U, '==="front"?', 1028, ":", 1029);
              });
            case "lineWidth":
              return et(function(N) {
                return N;
              }, function(N, j, U) {
                return U;
              });
            case "frontFace":
              return et(function(N) {
                return xo[N];
              }, function(N, j, U) {
                return j.def(U + '==="cw"?2304:2305');
              });
            case "colorMask":
              return et(
                function(N) {
                  return N.map(function(j) {
                    return !!j;
                  });
                },
                function(N, j, U) {
                  return d(4, function(wt) {
                    return "!!" + U + "[" + wt + "]";
                  });
                }
              );
            case "sample.coverage":
              return et(function(N) {
                return ["value" in N ? N.value : 1, !!N.invert];
              }, function(N, j, U) {
                return N = j.def('"value" in ', U, "?+", U, ".value:1"), j = j.def("!!", U, ".invert"), [N, j];
              });
          }
        }), ot;
      }
      function ye(F, B) {
        var J = F.static, nt = F.dynamic, ot = {};
        return Object.keys(J).forEach(function(rt) {
          var et = J[rt], Q;
          if (typeof et == "number" || typeof et == "boolean") Q = $t(function() {
            return et;
          });
          else if (typeof et == "function") {
            var N = et._reglType;
            N === "texture2d" || N === "textureCube" ? Q = $t(function(j) {
              return j.link(et);
            }) : (N === "framebuffer" || N === "framebufferCube") && (Q = $t(function(j) {
              return j.link(et.color[0]);
            }));
          } else M(et) && (Q = $t(function(j) {
            return j.global.def("[", d(et.length, function(U) {
              return et[U];
            }), "]");
          }));
          Q.value = et, ot[rt] = Q;
        }), Object.keys(nt).forEach(function(rt) {
          var et = nt[rt];
          ot[rt] = Wt(et, function(Q, N) {
            return Q.invoke(N, et);
          });
        }), ot;
      }
      function ee(F, B) {
        var J = F.static, nt = F.dynamic, ot = {};
        return Object.keys(J).forEach(function(rt) {
          var et = J[rt], Q = V.id(rt), N = new Mn();
          if (pt(et)) N.state = 1, N.buffer = ht.getBuffer(ht.create(et, 34962, !1, !0)), N.type = 0;
          else {
            var j = ht.getBuffer(et);
            if (j) N.state = 1, N.buffer = j, N.type = 0;
            else if ("constant" in et) {
              var U = et.constant;
              N.buffer = "null", N.state = 2, typeof U == "number" ? N.x = U : Qr.forEach(function(Bt, Gt) {
                Gt < U.length && (N[Bt] = U[Gt]);
              });
            } else {
              var j = pt(et.buffer) ? ht.getBuffer(ht.create(et.buffer, 34962, !1, !0)) : ht.getBuffer(et.buffer), wt = et.offset | 0, At = et.stride | 0, Zt = et.size | 0, Dt = !!et.normalized, Nt = 0;
              "type" in et && (Nt = wn[et.type]), et = et.divisor | 0, N.buffer = j, N.state = 1, N.size = Zt, N.normalized = Dt, N.type = Nt || j.dtype, N.offset = wt, N.stride = At, N.divisor = et;
            }
          }
          ot[rt] = $t(function(Bt, Gt) {
            var se = Bt.attribCache;
            if (Q in se) return se[Q];
            var te = { isStream: !1 };
            return Object.keys(N).forEach(function(Me) {
              te[Me] = N[Me];
            }), N.buffer && (te.buffer = Bt.link(N.buffer), te.type = te.type || te.buffer + ".dtype"), se[Q] = te;
          });
        }), Object.keys(nt).forEach(function(rt) {
          var et = nt[rt];
          ot[rt] = Wt(et, function(Q, N) {
            function j(se) {
              N(Dt[se], "=", U, ".", se, "|0;");
            }
            var U = Q.invoke(N, et), Zt = Q.shared, wt = Q.constants, At = Zt.isBufferArgs, Zt = Zt.buffer, Dt = { isStream: N.def(!1) }, Nt = new Mn();
            Nt.state = 1, Object.keys(Nt).forEach(function(se) {
              Dt[se] = N.def("" + Nt[se]);
            });
            var Bt = Dt.buffer, Gt = Dt.type;
            return N(
              "if(",
              At,
              "(",
              U,
              ")){",
              Dt.isStream,
              "=true;",
              Bt,
              "=",
              Zt,
              ".createStream(",
              34962,
              ",",
              U,
              ");",
              Gt,
              "=",
              Bt,
              ".dtype;",
              "}else{",
              Bt,
              "=",
              Zt,
              ".getBuffer(",
              U,
              ");",
              "if(",
              Bt,
              "){",
              Gt,
              "=",
              Bt,
              ".dtype;",
              '}else if("constant" in ',
              U,
              "){",
              Dt.state,
              "=",
              2,
              ";",
              "if(typeof " + U + '.constant === "number"){',
              Dt[Qr[0]],
              "=",
              U,
              ".constant;",
              Qr.slice(1).map(function(se) {
                return Dt[se];
              }).join("="),
              "=0;",
              "}else{",
              Qr.map(function(se, te) {
                return Dt[se] + "=" + U + ".constant.length>" + te + "?" + U + ".constant[" + te + "]:0;";
              }).join(""),
              "}}else{",
              "if(",
              At,
              "(",
              U,
              ".buffer)){",
              Bt,
              "=",
              Zt,
              ".createStream(",
              34962,
              ",",
              U,
              ".buffer);",
              "}else{",
              Bt,
              "=",
              Zt,
              ".getBuffer(",
              U,
              ".buffer);",
              "}",
              Gt,
              '="type" in ',
              U,
              "?",
              wt.glTypes,
              "[",
              U,
              ".type]:",
              Bt,
              ".dtype;",
              Dt.normalized,
              "=!!",
              U,
              ".normalized;"
            ), j("size"), j("offset"), j("stride"), j("divisor"), N("}}"), N.exit("if(", Dt.isStream, "){", Zt, ".destroyStream(", Bt, ");", "}"), Dt;
          });
        }), ot;
      }
      function Lt(F) {
        var B = F.static, J = F.dynamic, nt = {};
        return Object.keys(B).forEach(function(ot) {
          var rt = B[ot];
          nt[ot] = $t(function(et, Q) {
            return typeof rt == "number" || typeof rt == "boolean" ? "" + rt : et.link(rt);
          });
        }), Object.keys(J).forEach(function(ot) {
          var rt = J[ot];
          nt[ot] = Wt(rt, function(et, Q) {
            return et.invoke(Q, rt);
          });
        }), nt;
      }
      function pe(F, B, J, nt, ot) {
        function rt(Nt) {
          var Bt = Q[Nt];
          Bt && (j[Nt] = Bt);
        }
        var et = Xe(F, B), At = xt(F), Q = ce(F, At), N = je(F), j = yt(F), U = cn(F, ot, et);
        rt("viewport"), rt(at("scissor.box"));
        var wt = 0 < Object.keys(j).length, At = { framebuffer: At, draw: N, shader: U, state: j, dirty: wt, scopeVAO: null, drawVAO: null, useVAO: !1, attributes: {} };
        if (At.profile = mt(F), At.uniforms = ye(J), At.drawVAO = At.scopeVAO = N.vao, !At.drawVAO && U.program && !et && q.angle_instanced_arrays && N.static.elements) {
          var Zt = !0;
          if (F = U.program.attributes.map(function(Nt) {
            return Nt = B.static[Nt], Zt = Zt && !!Nt, Nt;
          }), Zt && 0 < F.length) {
            var Dt = St.getVAO(St.createVAO({ attributes: F, elements: N.static.elements }));
            At.drawVAO = new Rt(null, null, null, function(Nt, Bt) {
              return Nt.link(Dt);
            }), At.useVAO = !0;
          }
        }
        return et ? At.useVAO = !0 : At.attributes = ee(B), At.context = Lt(nt), At;
      }
      function Fe(F, B, J) {
        var nt = F.shared.context, ot = F.scope();
        Object.keys(J).forEach(function(rt) {
          B.save(nt, "." + rt);
          var et = J[rt].append(F, B);
          Array.isArray(et) ? ot(nt, ".", rt, "=[", et.join(), "];") : ot(nt, ".", rt, "=", et, ";");
        }), B(ot);
      }
      function de(F, B, J, nt) {
        var Q = F.shared, ot = Q.gl, rt = Q.framebuffer, et;
        L && (et = B.def(Q.extensions, ".webgl_draw_buffers"));
        var N = F.constants, Q = N.drawBuffer, N = N.backBuffer;
        F = J ? J.append(F, B) : B.def(rt, ".next"), nt || B("if(", F, "!==", rt, ".cur){"), B("if(", F, "){", ot, ".bindFramebuffer(", 36160, ",", F, ".framebuffer);"), L && B(et, ".drawBuffersWEBGL(", Q, "[", F, ".colorAttachments.length]);"), B("}else{", ot, ".bindFramebuffer(", 36160, ",null);"), L && B(et, ".drawBuffersWEBGL(", N, ");"), B("}", rt, ".cur=", F, ";"), nt || B("}");
      }
      function ze(F, B, J) {
        var nt = F.shared, ot = nt.gl, rt = F.current, et = F.next, Q = nt.current, N = nt.next, j = F.cond(Q, ".dirty");
        It.forEach(function(U) {
          if (U = at(U), !(U in J.state)) {
            var wt, At;
            if (U in et) {
              wt = et[U], At = rt[U];
              var Zt = d(X[U].length, function(Dt) {
                return j.def(wt, "[", Dt, "]");
              });
              j(F.cond(Zt.map(function(Dt, Nt) {
                return Dt + "!==" + At + "[" + Nt + "]";
              }).join("||")).then(ot, ".", Qt[U], "(", Zt, ");", Zt.map(function(Dt, Nt) {
                return At + "[" + Nt + "]=" + Dt;
              }).join(";"), ";"));
            } else wt = j.def(N, ".", U), Zt = F.cond(
              wt,
              "!==",
              Q,
              ".",
              U
            ), j(Zt), U in Ae ? Zt(F.cond(wt).then(ot, ".enable(", Ae[U], ");").else(ot, ".disable(", Ae[U], ");"), Q, ".", U, "=", wt, ";") : Zt(ot, ".", Qt[U], "(", wt, ");", Q, ".", U, "=", wt, ";");
          }
        }), Object.keys(J.state).length === 0 && j(Q, ".dirty=false;"), B(j);
      }
      function fn(F, B, J, nt) {
        var ot = F.shared, rt = F.current, et = ot.current, Q = ot.gl;
        Ht(Object.keys(J)).forEach(function(N) {
          var j = J[N];
          if (!nt || nt(j)) {
            var U = j.append(F, B);
            if (Ae[N]) {
              var wt = Ae[N];
              Tt(j) ? U ? B(Q, ".enable(", wt, ");") : B(Q, ".disable(", wt, ");") : B(F.cond(U).then(Q, ".enable(", wt, ");").else(
                Q,
                ".disable(",
                wt,
                ");"
              )), B(et, ".", N, "=", U, ";");
            } else if (M(U)) {
              var At = rt[N];
              B(Q, ".", Qt[N], "(", U, ");", U.map(function(Zt, Dt) {
                return At + "[" + Dt + "]=" + Zt;
              }).join(";"), ";");
            } else B(Q, ".", Qt[N], "(", U, ");", et, ".", N, "=", U, ";");
          }
        });
      }
      function ke(F, B) {
        qn && (F.instancing = B.def(F.shared.extensions, ".angle_instanced_arrays"));
      }
      function Ue(F, B, J, nt, ot) {
        function rt() {
          return typeof performance > "u" ? "Date.now()" : "performance.now()";
        }
        function et(Nt) {
          Zt = B.def(), Nt(Zt, "=", rt(), ";"), typeof ot == "string" ? Nt(U, ".count+=", ot, ";") : Nt(U, ".count++;"), _t && (nt ? (Dt = B.def(), Nt(Dt, "=", At, ".getNumPendingQueries();")) : Nt(At, ".beginQuery(", U, ");"));
        }
        function Q(Nt) {
          Nt(U, ".cpuTime+=", rt(), "-", Zt, ";"), _t && (nt ? Nt(At, ".pushScopeStats(", Dt, ",", At, ".getNumPendingQueries(),", U, ");") : Nt(At, ".endQuery();"));
        }
        function N(Nt) {
          var Bt = B.def(wt, ".profile");
          B(wt, ".profile=", Nt, ";"), B.exit(wt, ".profile=", Bt, ";");
        }
        var j = F.shared, U = F.stats, wt = j.current, At = j.timer;
        J = J.profile;
        var Zt, Dt;
        if (J) {
          if (Tt(J)) {
            J.enable ? (et(B), Q(B.exit), N("true")) : N("false");
            return;
          }
          J = J.append(F, B), N(J);
        } else J = B.def(wt, ".profile");
        j = F.block(), et(j), B("if(", J, "){", j, "}"), F = F.block(), Q(F), B.exit("if(", J, "){", F, "}");
      }
      function Zn(F, B, J, nt, ot) {
        function rt(N) {
          switch (N) {
            case 35664:
            case 35667:
            case 35671:
              return 2;
            case 35665:
            case 35668:
            case 35672:
              return 3;
            case 35666:
            case 35669:
            case 35673:
              return 4;
            default:
              return 1;
          }
        }
        function et(N, j, U) {
          function wt() {
            B(Zt, ".enableVertexAttribArray(", Dt, ");");
            var te = U.type, Me;
            Me = U.size ? B.def(U.size, "||", j) : j, B(
              Zt,
              ".bindBuffer(",
              34962,
              ",",
              Bt,
              ".buffer);",
              Zt,
              ".vertexAttribPointer(",
              [Dt, Me, te, U.normalized, U.stride, U.offset],
              ");",
              Nt,
              ".type=",
              te,
              ";",
              Nt,
              ".size=",
              Me,
              ";",
              se.map(function(xr) {
                return Nt + "." + xr + "=" + U[xr] + ";";
              }).join("")
            ), qn && (te = U.divisor, B("if(", Nt, ".divisor!==", te, "){", F.instancing, ".vertexAttribDivisorANGLE(", [Dt, te], ");", Nt, ".divisor=", te, ";}"));
          }
          function At() {
            B("if(", Nt, ".buffer){", Zt, ".disableVertexAttribArray(", Dt, ");", Nt, ".buffer=null;", "}if(", Qr.map(function(te, Me) {
              return Nt + "." + te + "!==" + Gt[Me];
            }).join("||"), "){", Zt, ".vertexAttrib4f(", Dt, ",", Gt, ");", Qr.map(function(te, Me) {
              return Nt + "." + te + "=" + Gt[Me] + ";";
            }).join(""), "}");
          }
          var Zt = Q.gl, Dt = B.def(N, ".location"), Nt = B.def(Q.attributes, "[", Dt, "]");
          N = U.state;
          var Bt = U.buffer, Gt = [U.x, U.y, U.z, U.w], se = ["buffer", "normalized", "offset", "stride"];
          N === 1 ? wt() : N === 2 ? At() : (B("if(", N, "===", 1, "){"), wt(), B("}else{"), At(), B("}"));
        }
        var Q = F.shared;
        nt.forEach(function(N) {
          var j = N.name, U = J.attributes[j], wt;
          if (U) {
            if (!ot(U)) return;
            wt = U.append(F, B);
          } else {
            if (!ot(jl)) return;
            var At = F.scopeAttrib(j);
            wt = {}, Object.keys(new Mn()).forEach(function(Zt) {
              wt[Zt] = B.def(At, ".", Zt);
            });
          }
          et(F.link(N), rt(N.info.type), wt);
        });
      }
      function _r(F, B, J, nt, ot, rt) {
        for (var et = F.shared, Q = et.gl, N = {}, j, U = 0; U < nt.length; ++U) {
          var Bt = nt[U], wt = Bt.name, At = Bt.info.type, Zt = Bt.info.size, Dt = J.uniforms[wt];
          if (1 < Zt) {
            if (!Dt) continue;
            var Nt = wt.replace("[0]", "");
            if (N[Nt]) continue;
            N[Nt] = 1;
          }
          var Bt = F.link(Bt) + ".location", Gt;
          if (Dt) {
            if (!ot(Dt)) continue;
            if (Tt(Dt)) {
              if (wt = Dt.value, At === 35678 || At === 35680) At = F.link(wt._texture || wt.color[0]._texture), B(Q, ".uniform1i(", Bt, ",", At + ".bind());"), B.exit(At, ".unbind();");
              else if (At === 35674 || At === 35675 || At === 35676) Zt = F.global.def("new Float32Array([" + Array.prototype.slice.call(wt) + "])"), wt = 2, At === 35675 ? wt = 3 : At === 35676 && (wt = 4), B(Q, ".uniformMatrix", wt, "fv(", Bt, ",false,", Zt, ");");
              else {
                switch (At) {
                  case 5126:
                    j = "1f";
                    break;
                  case 35664:
                    j = "2f";
                    break;
                  case 35665:
                    j = "3f";
                    break;
                  case 35666:
                    j = "4f";
                    break;
                  case 35670:
                    j = "1i";
                    break;
                  case 5124:
                    j = "1i";
                    break;
                  case 35671:
                    j = "2i";
                    break;
                  case 35667:
                    j = "2i";
                    break;
                  case 35672:
                    j = "3i";
                    break;
                  case 35668:
                    j = "3i";
                    break;
                  case 35673:
                    j = "4i";
                    break;
                  case 35669:
                    j = "4i";
                }
                1 < Zt ? (j += "v", wt = F.global.def("[" + Array.prototype.slice.call(wt) + "]")) : wt = M(wt) ? Array.prototype.slice.call(wt) : wt, B(Q, ".uniform", j, "(", Bt, ",", wt, ");");
              }
              continue;
            } else Gt = Dt.append(F, B);
          } else {
            if (!ot(jl)) continue;
            Gt = B.def(et.uniforms, "[", V.id(wt), "]");
          }
          switch (At === 35678 ? B("if(", Gt, "&&", Gt, '._reglType==="framebuffer"){', Gt, "=", Gt, ".color[0];", "}") : At === 35680 && B("if(", Gt, "&&", Gt, '._reglType==="framebufferCube"){', Gt, "=", Gt, ".color[0];", "}"), wt = 1, At) {
            case 35678:
            case 35680:
              At = B.def(Gt, "._texture"), B(Q, ".uniform1i(", Bt, ",", At, ".bind());"), B.exit(At, ".unbind();");
              continue;
            case 5124:
            case 35670:
              j = "1i";
              break;
            case 35667:
            case 35671:
              j = "2i", wt = 2;
              break;
            case 35668:
            case 35672:
              j = "3i", wt = 3;
              break;
            case 35669:
            case 35673:
              j = "4i", wt = 4;
              break;
            case 5126:
              j = "1f";
              break;
            case 35664:
              j = "2f", wt = 2;
              break;
            case 35665:
              j = "3f", wt = 3;
              break;
            case 35666:
              j = "4f", wt = 4;
              break;
            case 35674:
              j = "Matrix2fv";
              break;
            case 35675:
              j = "Matrix3fv";
              break;
            case 35676:
              j = "Matrix4fv";
          }
          if (j.indexOf("Matrix") === -1 && 1 < Zt && (j += "v", wt = 1), j.charAt(0) === "M") {
            B(Q, ".uniform", j, "(", Bt, ",");
            var Bt = Math.pow(At - 35674 + 2, 2), se = F.global.def("new Float32Array(", Bt, ")");
            Array.isArray(Gt) ? B("false,(", d(Bt, function(xr) {
              return se + "[" + xr + "]=" + Gt[xr];
            }), ",", se, ")") : B(
              "false,(Array.isArray(",
              Gt,
              ")||",
              Gt,
              " instanceof Float32Array)?",
              Gt,
              ":(",
              d(Bt, function(xr) {
                return se + "[" + xr + "]=" + Gt + "[" + xr + "]";
              }),
              ",",
              se,
              ")"
            ), B(");");
          } else {
            if (1 < wt) {
              for (var At = [], te = [], Zt = 0; Zt < wt; ++Zt) Array.isArray(Gt) ? te.push(Gt[Zt]) : te.push(B.def(Gt + "[" + Zt + "]")), rt && At.push(B.def());
              rt && B("if(!", F.batchId, "||", At.map(function(Me, xr) {
                return Me + "!==" + te[xr];
              }).join("||"), "){", At.map(function(Me, xr) {
                return Me + "=" + te[xr] + ";";
              }).join("")), B(Q, ".uniform", j, "(", Bt, ",", te.join(","), ");");
            } else rt && (At = B.def(), B("if(!", F.batchId, "||", At, "!==", Gt, "){", At, "=", Gt, ";")), B(Q, ".uniform", j, "(", Bt, ",", Gt, ");");
            rt && B("}");
          }
        }
      }
      function Pr(F, B, J, nt) {
        function ot(te) {
          var Me = U[te];
          return Me ? Me.contextDep && nt.contextDynamic || Me.propDep ? Me.append(F, J) : Me.append(F, B) : B.def(j, ".", te);
        }
        function rt() {
          function te() {
            J(Bt, ".drawElementsInstancedANGLE(", [At, Dt, Gt, Zt + "<<((" + Gt + "-5121)>>1)", Nt], ");");
          }
          function Me() {
            J(Bt, ".drawArraysInstancedANGLE(", [At, Zt, Dt, Nt], ");");
          }
          wt && wt !== "null" ? se ? te() : (J("if(", wt, "){"), te(), J("}else{"), Me(), J("}")) : Me();
        }
        function et() {
          function te() {
            J(N + ".drawElements(" + [At, Dt, Gt, Zt + "<<((" + Gt + "-5121)>>1)"] + ");");
          }
          function Me() {
            J(N + ".drawArrays(" + [At, Zt, Dt] + ");");
          }
          wt && wt !== "null" ? se ? te() : (J("if(", wt, "){"), te(), J("}else{"), Me(), J("}")) : Me();
        }
        var Q = F.shared, N = Q.gl, j = Q.draw, U = nt.draw, wt = function() {
          var te = U.elements, Me = B;
          return te ? ((te.contextDep && nt.contextDynamic || te.propDep) && (Me = J), te = te.append(F, Me), U.elementsActive && Me("if(" + te + ")" + N + ".bindBuffer(34963," + te + ".buffer.buffer);")) : (te = Me.def(), Me(te, "=", j, ".", "elements", ";", "if(", te, "){", N, ".bindBuffer(", 34963, ",", te, ".buffer.buffer);}", "else if(", Q.vao, ".currentVAO){", te, "=", F.shared.elements + ".getElements(" + Q.vao, ".currentVAO.elements);", ft ? "" : "if(" + te + ")" + N + ".bindBuffer(34963," + te + ".buffer.buffer);", "}")), te;
        }(), At = ot("primitive"), Zt = ot("offset"), Dt = function() {
          var te = U.count, Me = B;
          return te ? ((te.contextDep && nt.contextDynamic || te.propDep) && (Me = J), te = te.append(F, Me)) : te = Me.def(j, ".", "count"), te;
        }();
        if (typeof Dt == "number") {
          if (Dt === 0) return;
        } else J("if(", Dt, "){"), J.exit("}");
        var Nt, Bt;
        qn && (Nt = ot("instances"), Bt = F.instancing);
        var Gt = wt + ".type", se = U.elements && Tt(U.elements) && !U.vaoActive;
        qn && (typeof Nt != "number" || 0 <= Nt) ? typeof Nt == "string" ? (J("if(", Nt, ">0){"), rt(), J(
          "}else if(",
          Nt,
          "<0){"
        ), et(), J("}")) : rt() : et();
      }
      function cr(F, B, J, nt, ot) {
        return B = Mt(), ot = B.proc("body", ot), qn && (B.instancing = ot.def(B.shared.extensions, ".angle_instanced_arrays")), F(B, ot, J, nt), B.compile().body;
      }
      function Vr(F, B, J, nt) {
        ke(F, B), J.useVAO ? J.drawVAO ? B(F.shared.vao, ".setVAO(", J.drawVAO.append(F, B), ");") : B(F.shared.vao, ".setVAO(", F.shared.vao, ".targetVAO);") : (B(F.shared.vao, ".setVAO(null);"), Zn(F, B, J, nt.attributes, function() {
          return !0;
        })), _r(F, B, J, nt.uniforms, function() {
          return !0;
        }, !1), Pr(F, B, B, J);
      }
      function Te(F, B) {
        var J = F.proc(
          "draw",
          1
        );
        ke(F, J), Fe(F, J, B.context), de(F, J, B.framebuffer), ze(F, J, B), fn(F, J, B.state), Ue(F, J, B, !1, !0);
        var nt = B.shader.progVar.append(F, J);
        if (J(F.shared.gl, ".useProgram(", nt, ".program);"), B.shader.program) Vr(F, J, B, B.shader.program);
        else {
          J(F.shared.vao, ".setVAO(null);");
          var ot = F.global.def("{}"), rt = J.def(nt, ".id"), et = J.def(ot, "[", rt, "]");
          J(F.cond(et).then(et, ".call(this,a0);").else(et, "=", ot, "[", rt, "]=", F.link(function(Q) {
            return cr(Vr, F, B, Q, 1);
          }), "(", nt, ");", et, ".call(this,a0);"));
        }
        0 < Object.keys(B.state).length && J(
          F.shared.current,
          ".dirty=true;"
        ), F.shared.vao && J(F.shared.vao, ".setVAO(null);");
      }
      function Le(F, B, J, nt) {
        function ot() {
          return !0;
        }
        F.batchId = "a1", ke(F, B), Zn(F, B, J, nt.attributes, ot), _r(F, B, J, nt.uniforms, ot, !1), Pr(F, B, B, J);
      }
      function rn(F, B, J, nt) {
        function ot(wt) {
          return wt.contextDep && et || wt.propDep;
        }
        function rt(wt) {
          return !ot(wt);
        }
        ke(F, B);
        var et = J.contextDep, Q = B.def(), N = B.def();
        F.shared.props = N, F.batchId = Q;
        var j = F.scope(), U = F.scope();
        B(j.entry, "for(", Q, "=0;", Q, "<", "a1", ";++", Q, "){", N, "=", "a0", "[", Q, "];", U, "}", j.exit), J.needsContext && Fe(F, U, J.context), J.needsFramebuffer && de(F, U, J.framebuffer), fn(F, U, J.state, ot), J.profile && ot(J.profile) && Ue(F, U, J, !1, !0), nt ? (J.useVAO ? J.drawVAO ? ot(J.drawVAO) ? U(F.shared.vao, ".setVAO(", J.drawVAO.append(F, U), ");") : j(F.shared.vao, ".setVAO(", J.drawVAO.append(F, j), ");") : j(F.shared.vao, ".setVAO(", F.shared.vao, ".targetVAO);") : (j(F.shared.vao, ".setVAO(null);"), Zn(F, j, J, nt.attributes, rt), Zn(F, U, J, nt.attributes, ot)), _r(F, j, J, nt.uniforms, rt, !1), _r(F, U, J, nt.uniforms, ot, !0), Pr(F, j, U, J)) : (B = F.global.def("{}"), nt = J.shader.progVar.append(F, U), N = U.def(
          nt,
          ".id"
        ), j = U.def(B, "[", N, "]"), U(F.shared.gl, ".useProgram(", nt, ".program);", "if(!", j, "){", j, "=", B, "[", N, "]=", F.link(function(wt) {
          return cr(Le, F, J, wt, 2);
        }), "(", nt, ");}", j, ".call(this,a0[", Q, "],", Q, ");"));
      }
      function _e(F, B) {
        function J(j) {
          return j.contextDep && ot || j.propDep;
        }
        var nt = F.proc("batch", 2);
        F.batchId = "0", ke(F, nt);
        var ot = !1, rt = !0;
        Object.keys(B.context).forEach(function(j) {
          ot = ot || B.context[j].propDep;
        }), ot || (Fe(F, nt, B.context), rt = !1);
        var et = B.framebuffer, Q = !1;
        if (et ? (et.propDep ? ot = Q = !0 : et.contextDep && ot && (Q = !0), Q || de(F, nt, et)) : de(
          F,
          nt,
          null
        ), B.state.viewport && B.state.viewport.propDep && (ot = !0), ze(F, nt, B), fn(F, nt, B.state, function(j) {
          return !J(j);
        }), B.profile && J(B.profile) || Ue(F, nt, B, !1, "a1"), B.contextDep = ot, B.needsContext = rt, B.needsFramebuffer = Q, rt = B.shader.progVar, rt.contextDep && ot || rt.propDep) rn(F, nt, B, null);
        else if (rt = rt.append(F, nt), nt(F.shared.gl, ".useProgram(", rt, ".program);"), B.shader.program) rn(F, nt, B, B.shader.program);
        else {
          nt(F.shared.vao, ".setVAO(null);");
          var et = F.global.def("{}"), Q = nt.def(rt, ".id"), N = nt.def(et, "[", Q, "]");
          nt(F.cond(N).then(
            N,
            ".call(this,a0,a1);"
          ).else(N, "=", et, "[", Q, "]=", F.link(function(wt) {
            return cr(rn, F, B, wt, 2);
          }), "(", rt, ");", N, ".call(this,a0,a1);"));
        }
        0 < Object.keys(B.state).length && nt(F.shared.current, ".dirty=true;"), F.shared.vao && nt(F.shared.vao, ".setVAO(null);");
      }
      function Xn(F, B) {
        function J(et) {
          var Q = B.shader[et];
          Q && nt.set(ot.shader, "." + et, Q.append(F, nt));
        }
        var nt = F.proc("scope", 3);
        F.batchId = "a2";
        var ot = F.shared, rt = ot.current;
        Fe(F, nt, B.context), B.framebuffer && B.framebuffer.append(F, nt), Ht(Object.keys(B.state)).forEach(function(et) {
          var Q = B.state[et].append(F, nt);
          M(Q) ? Q.forEach(function(N, j) {
            nt.set(F.next[et], "[" + j + "]", N);
          }) : nt.set(ot.next, "." + et, Q);
        }), Ue(F, nt, B, !0, !0), ["elements", "offset", "count", "instances", "primitive"].forEach(function(et) {
          var Q = B.draw[et];
          Q && nt.set(ot.draw, "." + et, "" + Q.append(F, nt));
        }), Object.keys(B.uniforms).forEach(function(et) {
          var Q = B.uniforms[et].append(F, nt);
          Array.isArray(Q) && (Q = "[" + Q.join() + "]"), nt.set(ot.uniforms, "[" + V.id(et) + "]", Q);
        }), Object.keys(B.attributes).forEach(function(et) {
          var Q = B.attributes[et].append(F, nt), N = F.scopeAttrib(et);
          Object.keys(new Mn()).forEach(function(j) {
            nt.set(N, "." + j, Q[j]);
          });
        }), B.scopeVAO && nt.set(ot.vao, ".targetVAO", B.scopeVAO.append(F, nt)), J("vert"), J("frag"), 0 < Object.keys(B.state).length && (nt(rt, ".dirty=true;"), nt.exit(rt, ".dirty=true;")), nt("a1(", F.shared.context, ",a0,", F.batchId, ");");
      }
      function mi(F) {
        if (typeof F == "object" && !M(F)) {
          for (var B = Object.keys(F), J = 0; J < B.length; ++J) if (Xt.isDynamic(F[B[J]])) return !0;
          return !1;
        }
      }
      function ti(F, B, J) {
        function nt(wt, At) {
          et.forEach(function(Zt) {
            var Dt = ot[Zt];
            Xt.isDynamic(Dt) && (Dt = wt.invoke(
              At,
              Dt
            ), At(U, ".", Zt, "=", Dt, ";"));
          });
        }
        var ot = B.static[J];
        if (ot && mi(ot)) {
          var rt = F.global, et = Object.keys(ot), Q = !1, N = !1, j = !1, U = F.global.def("{}");
          et.forEach(function(wt) {
            var At = ot[wt];
            if (Xt.isDynamic(At)) typeof At == "function" && (At = ot[wt] = Xt.unbox(At)), wt = Wt(At, null), Q = Q || wt.thisDep, j = j || wt.propDep, N = N || wt.contextDep;
            else {
              switch (rt(U, ".", wt, "="), typeof At) {
                case "number":
                  rt(At);
                  break;
                case "string":
                  rt('"', At, '"');
                  break;
                case "object":
                  Array.isArray(At) && rt("[", At.join(), "]");
                  break;
                default:
                  rt(F.link(At));
              }
              rt(";");
            }
          }), B.dynamic[J] = new Xt.DynamicVariable(
            4,
            { thisDep: Q, contextDep: N, propDep: j, ref: U, append: nt }
          ), delete B.static[J];
        }
      }
      var Mn = St.Record, Dr = { add: 32774, subtract: 32778, "reverse subtract": 32779 };
      q.ext_blend_minmax && (Dr.min = 32775, Dr.max = 32776);
      var qn = q.angle_instanced_arrays, L = q.webgl_draw_buffers, ft = q.oes_vertex_array_object, X = { dirty: !0, profile: bt.profile }, Et = {}, It = [], Ae = {}, Qt = {};
      vt("dither", 3024), vt("blend.enable", 3042), Z("blend.color", "blendColor", [0, 0, 0, 0]), Z("blend.equation", "blendEquationSeparate", [32774, 32774]), Z(
        "blend.func",
        "blendFuncSeparate",
        [1, 0, 1, 0]
      ), vt("depth.enable", 2929, !0), Z("depth.func", "depthFunc", 513), Z("depth.range", "depthRange", [0, 1]), Z("depth.mask", "depthMask", !0), Z("colorMask", "colorMask", [!0, !0, !0, !0]), vt("cull.enable", 2884), Z("cull.face", "cullFace", 1029), Z("frontFace", "frontFace", 2305), Z("lineWidth", "lineWidth", 1), vt("polygonOffset.enable", 32823), Z("polygonOffset.offset", "polygonOffset", [0, 0]), vt("sample.alpha", 32926), vt("sample.enable", 32928), Z("sample.coverage", "sampleCoverage", [1, !1]), vt("stencil.enable", 2960), Z(
        "stencil.mask",
        "stencilMask",
        -1
      ), Z("stencil.func", "stencilFunc", [519, 0, -1]), Z("stencil.opFront", "stencilOpSeparate", [1028, 7680, 7680, 7680]), Z("stencil.opBack", "stencilOpSeparate", [1029, 7680, 7680, 7680]), vt("scissor.enable", 3089), Z("scissor.box", "scissor", [0, 0, E.drawingBufferWidth, E.drawingBufferHeight]), Z("viewport", "viewport", [0, 0, E.drawingBufferWidth, E.drawingBufferHeight]);
      var Yt = {
        gl: E,
        context: ct,
        strings: V,
        next: Et,
        current: X,
        draw: tt,
        elements: gt,
        buffer: ht,
        shader: Vt,
        attributes: St.state,
        vao: St,
        uniforms: zt,
        framebuffer: Pt,
        extensions: q,
        timer: _t,
        isBufferArgs: pt
      }, le = { primTypes: Ze, compareFuncs: Ir, blendFuncs: rr, blendEquations: Dr, stencilOps: _o, glTypes: wn, orientationType: xo };
      L && (le.backBuffer = [1029], le.drawBuffer = d(ut.maxDrawbuffers, function(F) {
        return F === 0 ? [0] : d(F, function(B) {
          return 36064 + B;
        });
      }));
      var Ie = 0;
      return { next: Et, current: X, procs: function() {
        var F = Mt(), B = F.proc("poll"), J = F.proc("refresh"), nt = F.block();
        B(nt), J(nt);
        var ot = F.shared, rt = ot.gl, et = ot.next, Q = ot.current;
        nt(Q, ".dirty=false;"), de(F, B), de(F, J, null, !0);
        var N;
        qn && (N = F.link(qn)), q.oes_vertex_array_object && J(F.link(q.oes_vertex_array_object), ".bindVertexArrayOES(null);");
        for (var j = 0; j < ut.maxAttributes; ++j) {
          var U = J.def(ot.attributes, "[", j, "]"), wt = F.cond(U, ".buffer");
          wt.then(rt, ".enableVertexAttribArray(", j, ");", rt, ".bindBuffer(", 34962, ",", U, ".buffer.buffer);", rt, ".vertexAttribPointer(", j, ",", U, ".size,", U, ".type,", U, ".normalized,", U, ".stride,", U, ".offset);").else(rt, ".disableVertexAttribArray(", j, ");", rt, ".vertexAttrib4f(", j, ",", U, ".x,", U, ".y,", U, ".z,", U, ".w);", U, ".buffer=null;"), J(wt), qn && J(
            N,
            ".vertexAttribDivisorANGLE(",
            j,
            ",",
            U,
            ".divisor);"
          );
        }
        return J(F.shared.vao, ".currentVAO=null;", F.shared.vao, ".setVAO(", F.shared.vao, ".targetVAO);"), Object.keys(Ae).forEach(function(At) {
          var Zt = Ae[At], Dt = nt.def(et, ".", At), Nt = F.block();
          Nt("if(", Dt, "){", rt, ".enable(", Zt, ")}else{", rt, ".disable(", Zt, ")}", Q, ".", At, "=", Dt, ";"), J(Nt), B("if(", Dt, "!==", Q, ".", At, "){", Nt, "}");
        }), Object.keys(Qt).forEach(function(At) {
          var Zt = Qt[At], Dt = X[At], Nt, Bt, Gt = F.block();
          Gt(rt, ".", Zt, "("), M(Dt) ? (Zt = Dt.length, Nt = F.global.def(et, ".", At), Bt = F.global.def(Q, ".", At), Gt(
            d(Zt, function(se) {
              return Nt + "[" + se + "]";
            }),
            ");",
            d(Zt, function(se) {
              return Bt + "[" + se + "]=" + Nt + "[" + se + "];";
            }).join("")
          ), B("if(", d(Zt, function(se) {
            return Nt + "[" + se + "]!==" + Bt + "[" + se + "]";
          }).join("||"), "){", Gt, "}")) : (Nt = nt.def(et, ".", At), Bt = nt.def(Q, ".", At), Gt(Nt, ");", Q, ".", At, "=", Nt, ";"), B("if(", Nt, "!==", Bt, "){", Gt, "}")), J(Gt);
        }), F.compile();
      }(), compile: function(F, B, J, nt, ot) {
        var rt = Mt();
        rt.stats = rt.link(ot), Object.keys(B.static).forEach(function(Q) {
          ti(rt, B, Q);
        }), qi.forEach(function(Q) {
          ti(rt, F, Q);
        });
        var et = pe(F, B, J, nt, rt);
        return Te(rt, et), Xn(rt, et), _e(rt, et), Kt(rt.compile(), { destroy: function() {
          et.shader.program.destroy();
        } });
      } };
    }
    function ie(E, V) {
      for (var q = 0; q < E.length; ++q) if (E[q] === V) return q;
      return -1;
    }
    var Kt = function(E, V) {
      for (var q = Object.keys(V), ut = 0; ut < q.length; ++ut) E[q[ut]] = V[q[ut]];
      return E;
    }, fe = 0, Xt = { DynamicVariable: e, define: function(E, V) {
      return new e(E, n(V + ""));
    }, isDynamic: function(E) {
      return typeof E == "function" && !E._reglType || E instanceof e;
    }, unbox: s, accessor: n }, Re = { next: typeof requestAnimationFrame == "function" ? function(E) {
      return requestAnimationFrame(E);
    } : function(E) {
      return setTimeout(E, 16);
    }, cancel: typeof cancelAnimationFrame == "function" ? function(E) {
      return cancelAnimationFrame(E);
    } : clearTimeout }, Oe = typeof performance < "u" && performance.now ? function() {
      return performance.now();
    } : function() {
      return +/* @__PURE__ */ new Date();
    }, oe = g();
    oe.zero = g();
    var nr = function(E, V) {
      var q = 1;
      V.ext_texture_filter_anisotropic && (q = E.getParameter(34047));
      var ut = 1, ht = 1;
      V.webgl_draw_buffers && (ut = E.getParameter(34852), ht = E.getParameter(36063));
      var gt = !!V.oes_texture_float;
      if (gt) {
        gt = E.createTexture(), E.bindTexture(3553, gt), E.texImage2D(3553, 0, 6408, 1, 1, 0, 6408, 5126, null);
        var kt = E.createFramebuffer();
        if (E.bindFramebuffer(36160, kt), E.framebufferTexture2D(36160, 36064, 3553, gt, 0), E.bindTexture(3553, null), E.checkFramebufferStatus(36160) !== 36053) gt = !1;
        else {
          E.viewport(0, 0, 1, 1), E.clearColor(1, 0, 0, 1), E.clear(16384);
          var Pt = oe.allocType(5126, 4);
          E.readPixels(0, 0, 1, 1, 6408, 5126, Pt), E.getError() ? gt = !1 : (E.deleteFramebuffer(kt), E.deleteTexture(gt), gt = Pt[0] === 1), oe.freeType(Pt);
        }
      }
      return Pt = !0, typeof navigator < "u" && (/MSIE/.test(navigator.userAgent) || /Trident\//.test(navigator.appVersion) || /Edge/.test(navigator.userAgent)) || (Pt = E.createTexture(), kt = oe.allocType(5121, 36), E.activeTexture(33984), E.bindTexture(34067, Pt), E.texImage2D(34069, 0, 6408, 3, 3, 0, 6408, 5121, kt), oe.freeType(kt), E.bindTexture(34067, null), E.deleteTexture(Pt), Pt = !E.getError()), {
        colorBits: [E.getParameter(3410), E.getParameter(3411), E.getParameter(3412), E.getParameter(3413)],
        depthBits: E.getParameter(3414),
        stencilBits: E.getParameter(3415),
        subpixelBits: E.getParameter(3408),
        extensions: Object.keys(V).filter(function(zt) {
          return !!V[zt];
        }),
        maxAnisotropic: q,
        maxDrawbuffers: ut,
        maxColorAttachments: ht,
        pointSizeDims: E.getParameter(33901),
        lineWidthDims: E.getParameter(33902),
        maxViewportDims: E.getParameter(3386),
        maxCombinedTextureUnits: E.getParameter(35661),
        maxCubeMapSize: E.getParameter(34076),
        maxRenderbufferSize: E.getParameter(34024),
        maxTextureUnits: E.getParameter(34930),
        maxTextureSize: E.getParameter(3379),
        maxAttributes: E.getParameter(34921),
        maxVertexUniforms: E.getParameter(36347),
        maxVertexTextureUnits: E.getParameter(35660),
        maxVaryingVectors: E.getParameter(36348),
        maxFragmentUniforms: E.getParameter(36349),
        glsl: E.getParameter(35724),
        renderer: E.getParameter(7937),
        vendor: E.getParameter(7936),
        version: E.getParameter(7938),
        readFloat: gt,
        npotTextureCube: Pt
      };
    }, Ke = function(E) {
      return E instanceof Uint8Array || E instanceof Uint16Array || E instanceof Uint32Array || E instanceof Int8Array || E instanceof Int16Array || E instanceof Int32Array || E instanceof Float32Array || E instanceof Float64Array || E instanceof Uint8ClampedArray;
    }, Ye = function(E) {
      return Object.keys(E).map(function(V) {
        return E[V];
      });
    }, We = { shape: function(E) {
      for (var V = []; E.length; E = E[0]) V.push(E.length);
      return V;
    }, flatten: function(E, V, q, ut) {
      var ht = 1;
      if (V.length) for (var gt = 0; gt < V.length; ++gt) ht *= V[gt];
      else ht = 0;
      switch (q = ut || oe.allocType(q, ht), V.length) {
        case 0:
          break;
        case 1:
          for (ut = V[0], V = 0; V < ut; ++V) q[V] = E[V];
          break;
        case 2:
          for (ut = V[0], V = V[1], gt = ht = 0; gt < ut; ++gt) for (var kt = E[gt], Pt = 0; Pt < V; ++Pt) q[ht++] = kt[Pt];
          break;
        case 3:
          v(E, V[0], V[1], V[2], q, 0);
          break;
        default:
          _(E, V, 0, q, 0);
      }
      return q;
    } }, bn = {
      "[object Int8Array]": 5120,
      "[object Int16Array]": 5122,
      "[object Int32Array]": 5124,
      "[object Uint8Array]": 5121,
      "[object Uint8ClampedArray]": 5121,
      "[object Uint16Array]": 5123,
      "[object Uint32Array]": 5125,
      "[object Float32Array]": 5126,
      "[object Float64Array]": 5121,
      "[object ArrayBuffer]": 5121
    }, wn = { int8: 5120, int16: 5122, int32: 5124, uint8: 5121, uint16: 5123, uint32: 5125, float: 5126, float32: 5126 }, On = { dynamic: 35048, stream: 35040, static: 35044 }, $e = We.flatten, be = We.shape, Ee = [];
    Ee[5120] = 1, Ee[5122] = 2, Ee[5124] = 4, Ee[5121] = 1, Ee[5123] = 2, Ee[5125] = 4, Ee[5126] = 4;
    var Ze = {
      points: 0,
      point: 0,
      lines: 1,
      line: 1,
      triangles: 4,
      triangle: 4,
      "line loop": 2,
      "line strip": 3,
      "triangle strip": 5,
      "triangle fan": 6
    }, yn = new Float32Array(1), Cr = new Uint32Array(yn.buffer), vr = [9984, 9986, 9985, 9987], an = [0, 6409, 6410, 6407, 6408], Ve = {};
    Ve[6409] = Ve[6406] = Ve[6402] = 1, Ve[34041] = Ve[6410] = 2, Ve[6407] = Ve[35904] = 3, Ve[6408] = Ve[35906] = 4;
    var Qn = S("HTMLCanvasElement"), Kr = S("OffscreenCanvas"), Br = S("CanvasRenderingContext2D"), An = S("ImageBitmap"), Ri = S("HTMLImageElement"), yr = S("HTMLVideoElement"), jr = Object.keys(bn).concat([Qn, Kr, Br, An, Ri, yr]), Rr = [];
    Rr[5121] = 1, Rr[5126] = 4, Rr[36193] = 2, Rr[5123] = 2, Rr[5125] = 4;
    var un = [];
    un[32854] = 2, un[32855] = 2, un[36194] = 2, un[34041] = 4, un[33776] = 0.5, un[33777] = 0.5, un[33778] = 1, un[33779] = 1, un[35986] = 0.5, un[35987] = 1, un[34798] = 1, un[35840] = 0.5, un[35841] = 0.25, un[35842] = 0.5, un[35843] = 0.25, un[36196] = 0.5;
    var Wn = [];
    Wn[32854] = 2, Wn[32855] = 2, Wn[36194] = 2, Wn[33189] = 2, Wn[36168] = 1, Wn[34041] = 4, Wn[35056] = 4, Wn[35907] = 4, Wn[34836] = 16, Wn[34842] = 8, Wn[34843] = 6;
    var yo = function(E, V, q, ut, ht) {
      function gt(tt) {
        this.id = St++, this.refCount = 1, this.renderbuffer = tt, this.format = 32854, this.height = this.width = 0, ht.profile && (this.stats = { size: 0 });
      }
      function kt(tt) {
        var ct = tt.renderbuffer;
        E.bindRenderbuffer(36161, null), E.deleteRenderbuffer(ct), tt.renderbuffer = null, tt.refCount = 0, delete Vt[tt.id], ut.renderbufferCount--;
      }
      var Pt = { rgba4: 32854, rgba8: 32856, rgb565: 36194, "rgb5 a1": 32855, depth: 33189, stencil: 36168, "depth stencil": 34041, "depth24 stencil8": 35056 };
      V.ext_srgb && (Pt.srgba = 35907), V.ext_color_buffer_half_float && (Pt.rgba16f = 34842, Pt.rgb16f = 34843), V.webgl_color_buffer_float && (Pt.rgba32f = 34836);
      var zt = [];
      Object.keys(Pt).forEach(function(tt) {
        zt[Pt[tt]] = tt;
      });
      var St = 0, Vt = {};
      return gt.prototype.decRef = function() {
        0 >= --this.refCount && kt(this);
      }, ht.profile && (ut.getTotalRenderbufferSize = function() {
        var tt = 0;
        return Object.keys(Vt).forEach(function(ct) {
          tt += Vt[ct].stats.size;
        }), tt;
      }), { create: function(tt, ct) {
        function _t(at, vt) {
          var Z = 0, Mt = 0, mt = 32854, xt = 0;
          if (typeof at == "object" && at ? ("shape" in at ? (Mt = at.shape, Z = Mt[0] | 0, Mt = Mt[1] | 0) : ("radius" in at && (Z = Mt = at.radius | 0), "width" in at && (Z = at.width | 0), "height" in at && (Mt = at.height | 0)), "format" in at && (mt = Pt[at.format]), "samples" in at && (xt = at.samples)) : typeof at == "number" ? (Z = at | 0, Mt = typeof vt == "number" ? vt | 0 : Z) : at || (Z = Mt = 1), Z !== bt.width || Mt !== bt.height || mt !== bt.format) return _t.width = bt.width = Z, _t.height = bt.height = Mt, _t.samples = xt, bt.format = mt, bt.samples = xt, E.bindRenderbuffer(36161, bt.renderbuffer), xt && E.renderbufferStorageMultisample ? E.renderbufferStorageMultisample(36161, xt, mt, Z, Mt) : E.renderbufferStorage(36161, mt, Z, Mt), ht.profile && (bt.stats.size = Wn[bt.format] * bt.width * bt.height), _t.format = zt[bt.format], _t;
        }
        var bt = new gt(E.createRenderbuffer());
        return Vt[bt.id] = bt, ut.renderbufferCount++, _t(tt, ct), _t.resize = function(at, vt) {
          var Z = at | 0, Mt = vt | 0 || Z;
          if (Z === bt.width && Mt === bt.height) return _t;
          _t.width = bt.width = Z, _t.height = bt.height = Mt;
          var mt = _t.samples;
          return E.bindRenderbuffer(36161, bt.renderbuffer), mt && E.renderbufferStorageMultisample ? E.renderbufferStorageMultisample(36161, mt, bt.format, Z, Mt) : E.renderbufferStorage(36161, bt.format, Z, Mt), ht.profile && (bt.stats.size = Wn[bt.format] * bt.width * bt.height), _t;
        }, _t._reglType = "renderbuffer", _t._renderbuffer = bt, ht.profile && (_t.stats = bt.stats), _t.destroy = function() {
          bt.decRef();
        }, _t;
      }, clear: function() {
        Ye(Vt).forEach(kt);
      }, restore: function() {
        Ye(Vt).forEach(function(tt) {
          tt.renderbuffer = E.createRenderbuffer(), E.bindRenderbuffer(36161, tt.renderbuffer), tt.samples && E.renderbufferStorageMultisample ? E.renderbufferStorageMultisample(36161, tt.samples, tt.format, tt.width, tt.height) : E.renderbufferStorage(36161, tt.format, tt.width, tt.height);
        }), E.bindRenderbuffer(36161, null);
      } };
    }, hs = [];
    hs[6408] = 4, hs[6407] = 3;
    var Gr = [];
    Gr[5121] = 1, Gr[5126] = 4, Gr[36193] = 2;
    var Qr = ["x", "y", "z", "w"], qi = "blend.func blend.equation stencil.func stencil.opFront stencil.opBack sample.coverage viewport scissor.box polygonOffset.offset".split(" "), rr = {
      0: 0,
      1: 1,
      zero: 0,
      one: 1,
      "src color": 768,
      "one minus src color": 769,
      "src alpha": 770,
      "one minus src alpha": 771,
      "dst color": 774,
      "one minus dst color": 775,
      "dst alpha": 772,
      "one minus dst alpha": 773,
      "constant color": 32769,
      "one minus constant color": 32770,
      "constant alpha": 32771,
      "one minus constant alpha": 32772,
      "src alpha saturate": 776
    }, Ir = { never: 512, less: 513, "<": 513, equal: 514, "=": 514, "==": 514, "===": 514, lequal: 515, "<=": 515, greater: 516, ">": 516, notequal: 517, "!=": 517, "!==": 517, gequal: 518, ">=": 518, always: 519 }, _o = {
      0: 0,
      zero: 0,
      keep: 7680,
      replace: 7681,
      increment: 7682,
      decrement: 7683,
      "increment wrap": 34055,
      "decrement wrap": 34056,
      invert: 5386
    }, xo = { cw: 2304, ccw: 2305 }, jl = new Rt(!1, !1, !1, function() {
    }), Hs = function(E, V) {
      function q() {
        this.endQueryIndex = this.startQueryIndex = -1, this.sum = 0, this.stats = null;
      }
      function ut(Vt, tt, ct) {
        var _t = kt.pop() || new q();
        _t.startQueryIndex = Vt, _t.endQueryIndex = tt, _t.sum = 0, _t.stats = ct, Pt.push(_t);
      }
      if (!V.ext_disjoint_timer_query) return null;
      var ht = [], gt = [], kt = [], Pt = [], zt = [], St = [];
      return { beginQuery: function(Vt) {
        var tt = ht.pop() || V.ext_disjoint_timer_query.createQueryEXT();
        V.ext_disjoint_timer_query.beginQueryEXT(35007, tt), gt.push(tt), ut(gt.length - 1, gt.length, Vt);
      }, endQuery: function() {
        V.ext_disjoint_timer_query.endQueryEXT(35007);
      }, pushScopeStats: ut, update: function() {
        var Vt, tt;
        if (Vt = gt.length, Vt !== 0) {
          St.length = Math.max(St.length, Vt + 1), zt.length = Math.max(zt.length, Vt + 1), zt[0] = 0;
          var ct = St[0] = 0;
          for (tt = Vt = 0; tt < gt.length; ++tt) {
            var _t = gt[tt];
            V.ext_disjoint_timer_query.getQueryObjectEXT(_t, 34919) ? (ct += V.ext_disjoint_timer_query.getQueryObjectEXT(_t, 34918), ht.push(_t)) : gt[Vt++] = _t, zt[tt + 1] = ct, St[tt + 1] = Vt;
          }
          for (gt.length = Vt, tt = Vt = 0; tt < Pt.length; ++tt) {
            var ct = Pt[tt], bt = ct.startQueryIndex, _t = ct.endQueryIndex;
            ct.sum += zt[_t] - zt[bt], bt = St[bt], _t = St[_t], _t === bt ? (ct.stats.gpuTime += ct.sum / 1e6, kt.push(ct)) : (ct.startQueryIndex = bt, ct.endQueryIndex = _t, Pt[Vt++] = ct);
          }
          Pt.length = Vt;
        }
      }, getNumPendingQueries: function() {
        return gt.length;
      }, clear: function() {
        ht.push.apply(ht, gt);
        for (var Vt = 0; Vt < ht.length; Vt++) V.ext_disjoint_timer_query.deleteQueryEXT(ht[Vt]);
        gt.length = 0, ht.length = 0;
      }, restore: function() {
        gt.length = 0, ht.length = 0;
      } };
    };
    return function(E) {
      function V() {
        if (Ue.length === 0) Mt && Mt.update(), cr = null;
        else {
          cr = Re.next(V), Vt();
          for (var Te = Ue.length - 1; 0 <= Te; --Te) {
            var Le = Ue[Te];
            Le && Le(ce, null, 0);
          }
          _t.flush(), Mt && Mt.update();
        }
      }
      function q() {
        !cr && 0 < Ue.length && (cr = Re.next(V));
      }
      function ut() {
        cr && (Re.cancel(V), cr = null);
      }
      function ht(Te) {
        Te.preventDefault(), ut(), Zn.forEach(function(Le) {
          Le();
        });
      }
      function gt(Te) {
        _t.getError(), at.restore(), ee.restore(), je.restore(), Lt.restore(), pe.restore(), Fe.restore(), ye.restore(), Mt && Mt.restore(), de.procs.refresh(), q(), _r.forEach(function(Le) {
          Le();
        });
      }
      function kt(Te) {
        function Le(X, Et) {
          var It = {}, Ae = {};
          return Object.keys(X).forEach(function(Qt) {
            var Yt = X[Qt];
            if (Xt.isDynamic(Yt)) Ae[Qt] = Xt.unbox(Yt, Qt);
            else {
              if (Et && Array.isArray(Yt)) {
                for (var le = 0; le < Yt.length; ++le) if (Xt.isDynamic(Yt[le])) {
                  Ae[Qt] = Xt.unbox(Yt, Qt);
                  return;
                }
              }
              It[Qt] = Yt;
            }
          }), { dynamic: Ae, static: It };
        }
        function rn(X) {
          for (; ft.length < X; ) ft.push(null);
          return ft;
        }
        var _e = Le(Te.context || {}, !0), Xn = Le(Te.uniforms || {}, !0), mi = Le(Te.attributes || {}, !1);
        Te = Le(function(X) {
          function Et(Ae) {
            if (Ae in It) {
              var Qt = It[Ae];
              delete It[Ae], Object.keys(Qt).forEach(function(Yt) {
                It[Ae + "." + Yt] = Qt[Yt];
              });
            }
          }
          var It = Kt({}, X);
          return delete It.uniforms, delete It.attributes, delete It.context, delete It.vao, "stencil" in It && It.stencil.op && (It.stencil.opBack = It.stencil.opFront = It.stencil.op, delete It.stencil.op), Et("blend"), Et("depth"), Et("cull"), Et("stencil"), Et("polygonOffset"), Et("scissor"), Et("sample"), "vao" in X && (It.vao = X.vao), It;
        }(Te), !1);
        var ti = { gpuTime: 0, cpuTime: 0, count: 0 }, Mn = de.compile(Te, mi, Xn, _e, ti), Dr = Mn.draw, qn = Mn.batch, L = Mn.scope, ft = [];
        return Kt(function(X, Et) {
          var It;
          if (typeof X == "function") return L.call(this, null, X, 0);
          if (typeof Et == "function") if (typeof X == "number") for (It = 0; It < X; ++It) L.call(this, null, Et, It);
          else if (Array.isArray(X)) for (It = 0; It < X.length; ++It) L.call(this, X[It], Et, It);
          else return L.call(this, X, Et, 0);
          else if (typeof X == "number") {
            if (0 < X) return qn.call(this, rn(X | 0), X | 0);
          } else if (Array.isArray(X)) {
            if (X.length) return qn.call(this, X, X.length);
          } else return Dr.call(this, X);
        }, { stats: ti, destroy: function() {
          Mn.destroy();
        } });
      }
      function Pt(Te, Le) {
        var rn = 0;
        de.procs.poll();
        var _e = Le.color;
        _e && (_t.clearColor(+_e[0] || 0, +_e[1] || 0, +_e[2] || 0, +_e[3] || 0), rn |= 16384), "depth" in Le && (_t.clearDepth(+Le.depth), rn |= 256), "stencil" in Le && (_t.clearStencil(Le.stencil | 0), rn |= 1024), _t.clear(rn);
      }
      function zt(Te) {
        return Ue.push(Te), q(), { cancel: function() {
          function Le() {
            var _e = ie(Ue, Le);
            Ue[_e] = Ue[Ue.length - 1], --Ue.length, 0 >= Ue.length && ut();
          }
          var rn = ie(Ue, Te);
          Ue[rn] = Le;
        } };
      }
      function St() {
        var Te = fn.viewport, Le = fn.scissor_box;
        Te[0] = Te[1] = Le[0] = Le[1] = 0, ce.viewportWidth = ce.framebufferWidth = ce.drawingBufferWidth = Te[2] = Le[2] = _t.drawingBufferWidth, ce.viewportHeight = ce.framebufferHeight = ce.drawingBufferHeight = Te[3] = Le[3] = _t.drawingBufferHeight;
      }
      function Vt() {
        ce.tick += 1, ce.time = ct(), St(), de.procs.poll();
      }
      function tt() {
        Lt.refresh(), St(), de.procs.refresh(), Mt && Mt.update();
      }
      function ct() {
        return (Oe() - mt) / 1e3;
      }
      if (E = c(E), !E) return null;
      var _t = E.gl, bt = _t.getContextAttributes();
      _t.isContextLost();
      var at = f(_t, E);
      if (!at) return null;
      var ze = o(), vt = { vaoCount: 0, bufferCount: 0, elementsCount: 0, framebufferCount: 0, shaderCount: 0, textureCount: 0, cubeCount: 0, renderbufferCount: 0, maxTextureUnits: 0 }, Z = at.extensions, Mt = Hs(_t, Z), mt = Oe(), Xe = _t.drawingBufferWidth, xt = _t.drawingBufferHeight, ce = {
        tick: 0,
        time: 0,
        viewportWidth: Xe,
        viewportHeight: xt,
        framebufferWidth: Xe,
        framebufferHeight: xt,
        drawingBufferWidth: Xe,
        drawingBufferHeight: xt,
        pixelRatio: E.pixelRatio
      }, Xe = { elements: null, primitive: 4, count: -1, offset: 0, instances: -1 }, cn = nr(_t, Z), je = b(_t, vt, E, function(Te) {
        return ye.destroyBuffer(Te);
      }), yt = T(_t, Z, je, vt), ye = G(_t, Z, cn, vt, je, yt, Xe), ee = $(_t, ze, vt, E), Lt = D(_t, Z, cn, function() {
        de.procs.poll();
      }, ce, vt, E), pe = yo(_t, Z, cn, vt, E), Fe = z(_t, Z, cn, Lt, pe, vt), de = re(_t, ze, Z, cn, je, yt, Lt, Fe, {}, ye, ee, Xe, ce, Mt, E), ze = K(_t, Fe, de.procs.poll, ce), fn = de.next, ke = _t.canvas, Ue = [], Zn = [], _r = [], Pr = [E.onDestroy], cr = null;
      ke && (ke.addEventListener("webglcontextlost", ht, !1), ke.addEventListener("webglcontextrestored", gt, !1));
      var Vr = Fe.setFBO = kt({ framebuffer: Xt.define.call(null, 1, "framebuffer") });
      return tt(), bt = Kt(kt, {
        clear: function(Te) {
          if ("framebuffer" in Te) if (Te.framebuffer && Te.framebuffer_reglType === "framebufferCube") for (var Le = 0; 6 > Le; ++Le) Vr(Kt({ framebuffer: Te.framebuffer.faces[Le] }, Te), Pt);
          else Vr(Te, Pt);
          else Pt(null, Te);
        },
        prop: Xt.define.bind(null, 1),
        context: Xt.define.bind(null, 2),
        this: Xt.define.bind(null, 3),
        draw: kt({}),
        buffer: function(Te) {
          return je.create(Te, 34962, !1, !1);
        },
        elements: function(Te) {
          return yt.create(Te, !1);
        },
        texture: Lt.create2D,
        cube: Lt.createCube,
        renderbuffer: pe.create,
        framebuffer: Fe.create,
        framebufferCube: Fe.createCube,
        vao: ye.createVAO,
        attributes: bt,
        frame: zt,
        on: function(Te, Le) {
          var rn;
          switch (Te) {
            case "frame":
              return zt(Le);
            case "lost":
              rn = Zn;
              break;
            case "restore":
              rn = _r;
              break;
            case "destroy":
              rn = Pr;
          }
          return rn.push(Le), { cancel: function() {
            for (var _e = 0; _e < rn.length; ++_e) if (rn[_e] === Le) {
              rn[_e] = rn[rn.length - 1], rn.pop();
              break;
            }
          } };
        },
        limits: cn,
        hasExtension: function(Te) {
          return 0 <= cn.extensions.indexOf(Te.toLowerCase());
        },
        read: ze,
        destroy: function() {
          Ue.length = 0, ut(), ke && (ke.removeEventListener("webglcontextlost", ht), ke.removeEventListener(
            "webglcontextrestored",
            gt
          )), ee.clear(), Fe.clear(), pe.clear(), ye.clear(), Lt.clear(), yt.clear(), je.clear(), Mt && Mt.clear(), Pr.forEach(function(Te) {
            Te();
          });
        },
        _gl: _t,
        _refresh: tt,
        poll: function() {
          Vt(), Mt && Mt.update();
        },
        now: ct,
        stats: vt,
        blit: Fe.blit
      }), E.onDone(null, bt), bt;
    };
  });
})(WA);
var ZA = WA.exports;
const zu = /* @__PURE__ */ Fs(ZA);
var li = 1e-6, di = typeof Float32Array < "u" ? Float32Array : Array;
function _R(i, t, e, r, n) {
  return i[0] = t, i[1] = e, i[2] = r, i[3] = n, i;
}
function xR(i, t) {
  var e = Math.sin(t), r = Math.cos(t);
  return i[0] = r, i[1] = e, i[2] = -e, i[3] = r, i;
}
function bR() {
  var i = new di(9);
  return di != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[5] = 0, i[6] = 0, i[7] = 0), i[0] = 1, i[4] = 1, i[8] = 1, i;
}
function au(i, t) {
  return i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[4], i[4] = t[5], i[5] = t[6], i[6] = t[8], i[7] = t[9], i[8] = t[10], i;
}
function qv(i, t) {
  var e = Math.sin(t), r = Math.cos(t);
  return i[0] = r, i[1] = e, i[2] = 0, i[3] = -e, i[4] = r, i[5] = 0, i[6] = 0, i[7] = 0, i[8] = 1, i;
}
function wR() {
  var i = new di(16);
  return di != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0), i[0] = 1, i[5] = 1, i[10] = 1, i[15] = 1, i;
}
function Hi(i, t) {
  return i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i;
}
function pn(i) {
  return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
}
function XA(i, t) {
  if (i === t) {
    var e = t[1], r = t[2], n = t[3], s = t[6], o = t[7], a = t[11];
    i[1] = t[4], i[2] = t[8], i[3] = t[12], i[4] = e, i[6] = t[9], i[7] = t[13], i[8] = r, i[9] = s, i[11] = t[14], i[12] = n, i[13] = o, i[14] = a;
  } else
    i[0] = t[0], i[1] = t[4], i[2] = t[8], i[3] = t[12], i[4] = t[1], i[5] = t[5], i[6] = t[9], i[7] = t[13], i[8] = t[2], i[9] = t[6], i[10] = t[10], i[11] = t[14], i[12] = t[3], i[13] = t[7], i[14] = t[11], i[15] = t[15];
  return i;
}
function Is(i, t) {
  var e = t[0], r = t[1], n = t[2], s = t[3], o = t[4], a = t[5], l = t[6], h = t[7], u = t[8], c = t[9], f = t[10], d = t[11], p = t[12], g = t[13], m = t[14], v = t[15], _ = e * a - r * o, y = e * l - n * o, x = e * h - s * o, w = r * l - n * a, b = r * h - s * a, T = n * h - s * l, A = u * g - c * p, M = u * m - f * p, S = u * v - d * p, P = c * m - f * g, C = c * v - d * g, k = f * v - d * m, O = _ * k - y * C + x * P + w * S - b * M + T * A;
  return O ? (O = 1 / O, i[0] = (a * k - l * C + h * P) * O, i[1] = (n * C - r * k - s * P) * O, i[2] = (g * T - m * b + v * w) * O, i[3] = (f * b - c * T - d * w) * O, i[4] = (l * S - o * k - h * M) * O, i[5] = (e * k - n * S + s * M) * O, i[6] = (m * x - p * T - v * y) * O, i[7] = (u * T - f * x + d * y) * O, i[8] = (o * C - a * S + h * A) * O, i[9] = (r * S - e * C - s * A) * O, i[10] = (p * b - g * x + v * _) * O, i[11] = (c * x - u * b - d * _) * O, i[12] = (a * M - o * P - l * A) * O, i[13] = (e * P - r * M + n * A) * O, i[14] = (g * y - p * w - m * _) * O, i[15] = (u * w - c * y + f * _) * O, i) : null;
}
function Jt(i, t, e) {
  var r = t[0], n = t[1], s = t[2], o = t[3], a = t[4], l = t[5], h = t[6], u = t[7], c = t[8], f = t[9], d = t[10], p = t[11], g = t[12], m = t[13], v = t[14], _ = t[15], y = e[0], x = e[1], w = e[2], b = e[3];
  return i[0] = y * r + x * a + w * c + b * g, i[1] = y * n + x * l + w * f + b * m, i[2] = y * s + x * h + w * d + b * v, i[3] = y * o + x * u + w * p + b * _, y = e[4], x = e[5], w = e[6], b = e[7], i[4] = y * r + x * a + w * c + b * g, i[5] = y * n + x * l + w * f + b * m, i[6] = y * s + x * h + w * d + b * v, i[7] = y * o + x * u + w * p + b * _, y = e[8], x = e[9], w = e[10], b = e[11], i[8] = y * r + x * a + w * c + b * g, i[9] = y * n + x * l + w * f + b * m, i[10] = y * s + x * h + w * d + b * v, i[11] = y * o + x * u + w * p + b * _, y = e[12], x = e[13], w = e[14], b = e[15], i[12] = y * r + x * a + w * c + b * g, i[13] = y * n + x * l + w * f + b * m, i[14] = y * s + x * h + w * d + b * v, i[15] = y * o + x * u + w * p + b * _, i;
}
function ss(i, t, e) {
  var r = e[0], n = e[1], s = e[2], o = void 0, a = void 0, l = void 0, h = void 0, u = void 0, c = void 0, f = void 0, d = void 0, p = void 0, g = void 0, m = void 0, v = void 0;
  return t === i ? (i[12] = t[0] * r + t[4] * n + t[8] * s + t[12], i[13] = t[1] * r + t[5] * n + t[9] * s + t[13], i[14] = t[2] * r + t[6] * n + t[10] * s + t[14], i[15] = t[3] * r + t[7] * n + t[11] * s + t[15]) : (o = t[0], a = t[1], l = t[2], h = t[3], u = t[4], c = t[5], f = t[6], d = t[7], p = t[8], g = t[9], m = t[10], v = t[11], i[0] = o, i[1] = a, i[2] = l, i[3] = h, i[4] = u, i[5] = c, i[6] = f, i[7] = d, i[8] = p, i[9] = g, i[10] = m, i[11] = v, i[12] = o * r + u * n + p * s + t[12], i[13] = a * r + c * n + g * s + t[13], i[14] = l * r + f * n + m * s + t[14], i[15] = h * r + d * n + v * s + t[15]), i;
}
function os(i, t, e) {
  var r = e[0], n = e[1], s = e[2];
  return i[0] = t[0] * r, i[1] = t[1] * r, i[2] = t[2] * r, i[3] = t[3] * r, i[4] = t[4] * n, i[5] = t[5] * n, i[6] = t[6] * n, i[7] = t[7] * n, i[8] = t[8] * s, i[9] = t[9] * s, i[10] = t[10] * s, i[11] = t[11] * s, i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i;
}
function TR(i, t, e, r) {
  var n = r[0], s = r[1], o = r[2], a = Math.sqrt(n * n + s * s + o * o), l = void 0, h = void 0, u = void 0, c = void 0, f = void 0, d = void 0, p = void 0, g = void 0, m = void 0, v = void 0, _ = void 0, y = void 0, x = void 0, w = void 0, b = void 0, T = void 0, A = void 0, M = void 0, S = void 0, P = void 0, C = void 0, k = void 0, O = void 0, R = void 0;
  return a < li ? null : (a = 1 / a, n *= a, s *= a, o *= a, l = Math.sin(e), h = Math.cos(e), u = 1 - h, c = t[0], f = t[1], d = t[2], p = t[3], g = t[4], m = t[5], v = t[6], _ = t[7], y = t[8], x = t[9], w = t[10], b = t[11], T = n * n * u + h, A = s * n * u + o * l, M = o * n * u - s * l, S = n * s * u - o * l, P = s * s * u + h, C = o * s * u + n * l, k = n * o * u + s * l, O = s * o * u - n * l, R = o * o * u + h, i[0] = c * T + g * A + y * M, i[1] = f * T + m * A + x * M, i[2] = d * T + v * A + w * M, i[3] = p * T + _ * A + b * M, i[4] = c * S + g * P + y * C, i[5] = f * S + m * P + x * C, i[6] = d * S + v * P + w * C, i[7] = p * S + _ * P + b * C, i[8] = c * k + g * O + y * R, i[9] = f * k + m * O + x * R, i[10] = d * k + v * O + w * R, i[11] = p * k + _ * O + b * R, t !== i && (i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i);
}
function Bh(i, t) {
  return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = t[0], i[13] = t[1], i[14] = t[2], i[15] = 1, i;
}
function $o(i, t) {
  return i[0] = t[0], i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = t[1], i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = t[2], i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
}
function AR(i, t, e) {
  var r = e[0], n = e[1], s = e[2], o = Math.sqrt(r * r + n * n + s * s), a = void 0, l = void 0, h = void 0;
  return o < li ? null : (o = 1 / o, r *= o, n *= o, s *= o, a = Math.sin(t), l = Math.cos(t), h = 1 - l, i[0] = r * r * h + l, i[1] = n * r * h + s * a, i[2] = s * r * h - n * a, i[3] = 0, i[4] = r * n * h - s * a, i[5] = n * n * h + l, i[6] = s * n * h + r * a, i[7] = 0, i[8] = r * s * h + n * a, i[9] = n * s * h - r * a, i[10] = s * s * h + l, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i);
}
function Yv(i, t, e) {
  var r = t[0], n = t[1], s = t[2], o = t[3], a = r + r, l = n + n, h = s + s, u = r * a, c = r * l, f = r * h, d = n * l, p = n * h, g = s * h, m = o * a, v = o * l, _ = o * h;
  return i[0] = 1 - (d + g), i[1] = c + _, i[2] = f - v, i[3] = 0, i[4] = c - _, i[5] = 1 - (u + g), i[6] = p + m, i[7] = 0, i[8] = f + v, i[9] = p - m, i[10] = 1 - (u + d), i[11] = 0, i[12] = e[0], i[13] = e[1], i[14] = e[2], i[15] = 1, i;
}
function MR(i, t) {
  return i[0] = t[12], i[1] = t[13], i[2] = t[14], i;
}
function SR(i, t) {
  var e = t[0], r = t[1], n = t[2], s = t[4], o = t[5], a = t[6], l = t[8], h = t[9], u = t[10];
  return i[0] = Math.sqrt(e * e + r * r + n * n), i[1] = Math.sqrt(s * s + o * o + a * a), i[2] = Math.sqrt(l * l + h * h + u * u), i;
}
function CR(i, t) {
  var e = t[0] + t[5] + t[10], r = 0;
  return e > 0 ? (r = Math.sqrt(e + 1) * 2, i[3] = 0.25 * r, i[0] = (t[6] - t[9]) / r, i[1] = (t[8] - t[2]) / r, i[2] = (t[1] - t[4]) / r) : t[0] > t[5] && t[0] > t[10] ? (r = Math.sqrt(1 + t[0] - t[5] - t[10]) * 2, i[3] = (t[6] - t[9]) / r, i[0] = 0.25 * r, i[1] = (t[1] + t[4]) / r, i[2] = (t[8] + t[2]) / r) : t[5] > t[10] ? (r = Math.sqrt(1 + t[5] - t[0] - t[10]) * 2, i[3] = (t[8] - t[2]) / r, i[0] = (t[1] + t[4]) / r, i[1] = 0.25 * r, i[2] = (t[6] + t[9]) / r) : (r = Math.sqrt(1 + t[10] - t[0] - t[5]) * 2, i[3] = (t[1] - t[4]) / r, i[0] = (t[8] + t[2]) / r, i[1] = (t[6] + t[9]) / r, i[2] = 0.25 * r), i;
}
function Nl(i, t, e, r) {
  var n = t[0], s = t[1], o = t[2], a = t[3], l = n + n, h = s + s, u = o + o, c = n * l, f = n * h, d = n * u, p = s * h, g = s * u, m = o * u, v = a * l, _ = a * h, y = a * u, x = r[0], w = r[1], b = r[2];
  return i[0] = (1 - (p + m)) * x, i[1] = (f + y) * x, i[2] = (d - _) * x, i[3] = 0, i[4] = (f - y) * w, i[5] = (1 - (c + m)) * w, i[6] = (g + v) * w, i[7] = 0, i[8] = (d + _) * b, i[9] = (g - v) * b, i[10] = (1 - (c + p)) * b, i[11] = 0, i[12] = e[0], i[13] = e[1], i[14] = e[2], i[15] = 1, i;
}
function qA(i, t) {
  var e = t[0], r = t[1], n = t[2], s = t[3], o = e + e, a = r + r, l = n + n, h = e * o, u = r * o, c = r * a, f = n * o, d = n * a, p = n * l, g = s * o, m = s * a, v = s * l;
  return i[0] = 1 - c - p, i[1] = u + v, i[2] = f - m, i[3] = 0, i[4] = u - v, i[5] = 1 - h - p, i[6] = d + g, i[7] = 0, i[8] = f + m, i[9] = d - g, i[10] = 1 - h - c, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
}
function PR(i, t, e, r, n) {
  var s = 1 / Math.tan(t / 2), o = void 0;
  return i[0] = s / e, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = s, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = -1, i[12] = 0, i[13] = 0, i[15] = 0, n !== 1 / 0 ? (o = 1 / (r - n), i[10] = (n + r) * o, i[14] = 2 * n * r * o) : (i[10] = -1, i[14] = -2 * r), i;
}
function ER(i, t, e, r, n, s, o) {
  var a = 1 / (t - e), l = 1 / (r - n), h = 1 / (s - o);
  return i[0] = -2 * a, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = -2 * l, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 2 * h, i[11] = 0, i[12] = (t + e) * a, i[13] = (n + r) * l, i[14] = (o + s) * h, i[15] = 1, i;
}
function Eo(i, t, e, r) {
  var n = void 0, s = void 0, o = void 0, a = void 0, l = void 0, h = void 0, u = void 0, c = void 0, f = void 0, d = void 0, p = t[0], g = t[1], m = t[2], v = r[0], _ = r[1], y = r[2], x = e[0], w = e[1], b = e[2];
  return Math.abs(p - x) < li && Math.abs(g - w) < li && Math.abs(m - b) < li ? pn(i) : (u = p - x, c = g - w, f = m - b, d = 1 / Math.sqrt(u * u + c * c + f * f), u *= d, c *= d, f *= d, n = _ * f - y * c, s = y * u - v * f, o = v * c - _ * u, d = Math.sqrt(n * n + s * s + o * o), d ? (d = 1 / d, n *= d, s *= d, o *= d) : (n = 0, s = 0, o = 0), a = c * o - f * s, l = f * n - u * o, h = u * s - c * n, d = Math.sqrt(a * a + l * l + h * h), d ? (d = 1 / d, a *= d, l *= d, h *= d) : (a = 0, l = 0, h = 0), i[0] = n, i[1] = a, i[2] = u, i[3] = 0, i[4] = s, i[5] = l, i[6] = c, i[7] = 0, i[8] = o, i[9] = h, i[10] = f, i[11] = 0, i[12] = -(n * p + s * g + o * m), i[13] = -(a * p + l * g + h * m), i[14] = -(u * p + c * g + f * m), i[15] = 1, i);
}
function yf(i, t) {
  return i[0] === t[0] && i[1] === t[1] && i[2] === t[2] && i[3] === t[3] && i[4] === t[4] && i[5] === t[5] && i[6] === t[6] && i[7] === t[7] && i[8] === t[8] && i[9] === t[9] && i[10] === t[10] && i[11] === t[11] && i[12] === t[12] && i[13] === t[13] && i[14] === t[14] && i[15] === t[15];
}
var OR = Jt;
function YA() {
  var i = new di(3);
  return di != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0), i;
}
function qa(i) {
  var t = i[0], e = i[1], r = i[2];
  return Math.sqrt(t * t + e * e + r * r);
}
function E_(i, t, e) {
  var r = new di(3);
  return r[0] = i, r[1] = t, r[2] = e, r;
}
function Jn(i, t) {
  return i[0] = t[0], i[1] = t[1], i[2] = t[2], i;
}
function ne(i, t, e, r) {
  return i[0] = t, i[1] = e, i[2] = r, i;
}
function qr(i, t, e) {
  return i[0] = t[0] + e[0], i[1] = t[1] + e[1], i[2] = t[2] + e[2], i;
}
function kR(i, t, e) {
  return i[0] = t[0] - e[0], i[1] = t[1] - e[1], i[2] = t[2] - e[2], i;
}
function Jv(i, t, e) {
  return i[0] = t[0] * e[0], i[1] = t[1] * e[1], i[2] = t[2] * e[2], i;
}
function go(i, t, e) {
  return i[0] = t[0] * e, i[1] = t[1] * e, i[2] = t[2] * e, i;
}
function O_(i, t, e, r) {
  return i[0] = t[0] + e[0] * r, i[1] = t[1] + e[1] * r, i[2] = t[2] + e[2] * r, i;
}
function RR(i, t) {
  var e = t[0] - i[0], r = t[1] - i[1], n = t[2] - i[2];
  return Math.sqrt(e * e + r * r + n * n);
}
function mo(i, t) {
  var e = t[0], r = t[1], n = t[2], s = e * e + r * r + n * n;
  return s > 0 && (s = 1 / Math.sqrt(s), i[0] = t[0] * s, i[1] = t[1] * s, i[2] = t[2] * s), i;
}
function lu(i, t) {
  return i[0] * t[0] + i[1] * t[1] + i[2] * t[2];
}
function hi(i, t, e) {
  var r = t[0], n = t[1], s = t[2], o = e[0], a = e[1], l = e[2];
  return i[0] = n * l - s * a, i[1] = s * o - r * l, i[2] = r * a - n * o, i;
}
function fl(i, t, e) {
  var r = t[0], n = t[1], s = t[2], o = e[3] * r + e[7] * n + e[11] * s + e[15];
  return o = o || 1, i[0] = (e[0] * r + e[4] * n + e[8] * s + e[12]) / o, i[1] = (e[1] * r + e[5] * n + e[9] * s + e[13]) / o, i[2] = (e[2] * r + e[6] * n + e[10] * s + e[14]) / o, i;
}
function dl(i, t) {
  var e = i[0], r = i[1], n = i[2], s = t[0], o = t[1], a = t[2];
  return Math.abs(e - s) <= li * Math.max(1, Math.abs(e), Math.abs(s)) && Math.abs(r - o) <= li * Math.max(1, Math.abs(r), Math.abs(o)) && Math.abs(n - a) <= li * Math.max(1, Math.abs(n), Math.abs(a));
}
var Ti = kR, Ya = RR, IR = qa;
(function() {
  var i = YA();
  return function(t, e, r, n, s, o) {
    var a = void 0, l = void 0;
    for (e || (e = 3), r || (r = 0), n ? l = Math.min(n * e + r, t.length) : l = t.length, a = r; a < l; a += e)
      i[0] = t[a], i[1] = t[a + 1], i[2] = t[a + 2], s(i, i, o), t[a] = i[0], t[a + 1] = i[1], t[a + 2] = i[2];
    return t;
  };
})();
function DR() {
  var i = new di(4);
  return di != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0, i[3] = 0), i;
}
function nd(i, t) {
  return i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i;
}
function Sr(i, t, e, r, n) {
  return i[0] = t, i[1] = e, i[2] = r, i[3] = n, i;
}
function FR(i, t, e) {
  return i[0] = t[0] / e[0], i[1] = t[1] / e[1], i[2] = t[2] / e[2], i[3] = t[3] / e[3], i;
}
function Sl(i, t, e) {
  return i[0] = t[0] * e, i[1] = t[1] * e, i[2] = t[2] * e, i[3] = t[3] * e, i;
}
function LR(i, t) {
  var e = t[0], r = t[1], n = t[2], s = t[3], o = e * e + r * r + n * n + s * s;
  return o > 0 && (o = 1 / Math.sqrt(o), i[0] = e * o, i[1] = r * o, i[2] = n * o, i[3] = s * o), i;
}
function ho(i, t, e) {
  var r = t[0], n = t[1], s = t[2], o = t[3];
  return i[0] = e[0] * r + e[4] * n + e[8] * s + e[12] * o, i[1] = e[1] * r + e[5] * n + e[9] * s + e[13] * o, i[2] = e[2] * r + e[6] * n + e[10] * s + e[14] * o, i[3] = e[3] * r + e[7] * n + e[11] * s + e[15] * o, i;
}
function zR(i, t) {
  return i[0] === t[0] && i[1] === t[1] && i[2] === t[2] && i[3] === t[3];
}
function NR(i, t) {
  var e = i[0], r = i[1], n = i[2], s = i[3], o = t[0], a = t[1], l = t[2], h = t[3];
  return Math.abs(e - o) <= li * Math.max(1, Math.abs(e), Math.abs(o)) && Math.abs(r - a) <= li * Math.max(1, Math.abs(r), Math.abs(a)) && Math.abs(n - l) <= li * Math.max(1, Math.abs(n), Math.abs(l)) && Math.abs(s - h) <= li * Math.max(1, Math.abs(s), Math.abs(h));
}
(function() {
  var i = DR();
  return function(t, e, r, n, s, o) {
    var a = void 0, l = void 0;
    for (e || (e = 4), r || (r = 0), n ? l = Math.min(n * e + r, t.length) : l = t.length, a = r; a < l; a += e)
      i[0] = t[a], i[1] = t[a + 1], i[2] = t[a + 2], i[3] = t[a + 3], s(i, i, o), t[a] = i[0], t[a + 1] = i[1], t[a + 2] = i[2], t[a + 3] = i[3];
    return t;
  };
})();
function k_() {
  var i = new di(4);
  return di != Float32Array && (i[0] = 0, i[1] = 0, i[2] = 0), i[3] = 1, i;
}
function Kv(i) {
  return i[0] = 0, i[1] = 0, i[2] = 0, i[3] = 1, i;
}
function JA(i, t, e) {
  e = e * 0.5;
  var r = Math.sin(e);
  return i[0] = r * t[0], i[1] = r * t[1], i[2] = r * t[2], i[3] = Math.cos(e), i;
}
function _f(i, t, e, r) {
  var n = t[0], s = t[1], o = t[2], a = t[3], l = e[0], h = e[1], u = e[2], c = e[3], f = void 0, d = void 0, p = void 0, g = void 0, m = void 0;
  return d = n * l + s * h + o * u + a * c, d < 0 && (d = -d, l = -l, h = -h, u = -u, c = -c), 1 - d > li ? (f = Math.acos(d), p = Math.sin(f), g = Math.sin((1 - r) * f) / p, m = Math.sin(r * f) / p) : (g = 1 - r, m = r), i[0] = g * n + m * l, i[1] = g * s + m * h, i[2] = g * o + m * u, i[3] = g * a + m * c, i;
}
function KA(i, t) {
  var e = t[0] + t[4] + t[8], r = void 0;
  if (e > 0)
    r = Math.sqrt(e + 1), i[3] = 0.5 * r, r = 0.5 / r, i[0] = (t[5] - t[7]) * r, i[1] = (t[6] - t[2]) * r, i[2] = (t[1] - t[3]) * r;
  else {
    var n = 0;
    t[4] > t[0] && (n = 1), t[8] > t[n * 3 + n] && (n = 2);
    var s = (n + 1) % 3, o = (n + 2) % 3;
    r = Math.sqrt(t[n * 3 + n] - t[s * 3 + s] - t[o * 3 + o] + 1), i[n] = 0.5 * r, r = 0.5 / r, i[3] = (t[s * 3 + o] - t[o * 3 + s]) * r, i[s] = (t[s * 3 + n] + t[n * 3 + s]) * r, i[o] = (t[o * 3 + n] + t[n * 3 + o]) * r;
  }
  return i;
}
function Qo(i, t, e, r) {
  var n = 0.5 * Math.PI / 180;
  t *= n, e *= n, r *= n;
  var s = Math.sin(t), o = Math.cos(t), a = Math.sin(e), l = Math.cos(e), h = Math.sin(r), u = Math.cos(r);
  return i[0] = s * l * u - o * a * h, i[1] = o * a * u + s * l * h, i[2] = o * l * h - s * a * u, i[3] = o * l * u + s * a * h, i;
}
var QA = nd, tM = Sl, Qv = LR, HR = NR;
(function() {
  var i = YA(), t = E_(1, 0, 0), e = E_(0, 1, 0);
  return function(r, n, s) {
    var o = lu(n, s);
    return o < -0.999999 ? (hi(i, t, n), IR(i) < 1e-6 && hi(i, e, n), mo(i, i), JA(r, i, Math.PI), r) : o > 0.999999 ? (r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 1, r) : (hi(i, n, s), r[0] = i[0], r[1] = i[1], r[2] = i[2], r[3] = 1 + o, Qv(r, r));
  };
})();
(function() {
  var i = k_(), t = k_();
  return function(e, r, n, s, o, a) {
    return _f(i, r, o, a), _f(t, n, s, a), _f(e, i, t, 2 * a * (1 - a)), e;
  };
})();
(function() {
  var i = bR();
  return function(t, e, r, n) {
    return i[0] = r[0], i[3] = r[1], i[6] = r[2], i[1] = n[0], i[4] = n[1], i[7] = n[2], i[2] = -e[0], i[5] = -e[1], i[8] = -e[2], Qv(t, KA(t, i));
  };
})();
function BR() {
  var i = new di(2);
  return di != Float32Array && (i[0] = 0, i[1] = 0), i;
}
function R_(i, t) {
  return i[0] = t[0], i[1] = t[1], i;
}
function we(i, t, e) {
  return i[0] = t, i[1] = e, i;
}
function I_(i, t, e) {
  return i[0] = t[0] + e[0], i[1] = t[1] + e[1], i;
}
function or(i, t, e) {
  return i[0] = t[0] * e[0], i[1] = t[1] * e[1], i;
}
function ui(i, t, e) {
  return i[0] = t[0] * e, i[1] = t[1] * e, i;
}
function fc(i, t) {
  var e = t[0] - i[0], r = t[1] - i[1];
  return Math.sqrt(e * e + r * r);
}
function Bi(i, t, e) {
  var r = t[0], n = t[1];
  return i[0] = e[0] * r + e[2] * n, i[1] = e[1] * r + e[3] * n, i;
}
function jR(i, t, e, r) {
  var n = t[0] - e[0], s = t[1] - e[1], o = Math.sin(r), a = Math.cos(r);
  return i[0] = n * a - s * o + e[0], i[1] = n * o + s * a + e[1], i;
}
var dc = or;
(function() {
  var i = BR();
  return function(t, e, r, n, s, o) {
    var a = void 0, l = void 0;
    for (e || (e = 2), r || (r = 0), n ? l = Math.min(n * e + r, t.length) : l = t.length, a = r; a < l; a += e)
      i[0] = t[a], i[1] = t[a + 1], s(i, i, o), t[a] = i[0], t[a + 1] = i[1];
    return t;
  };
})();
/*!
 * @maptalks/gltf-loader v0.97.2
 * LICENSE : UNLICENSED
 * (c) 2016-2024 maptalks.org
 */
let GR = 0;
function eM(i) {
  return i == null;
}
function Sn(i) {
  return !eM(i);
}
function nM(i) {
  return !eM(i) && (typeof i == "string" || i.constructor !== null && i.constructor === String);
}
function rd(i) {
  for (let t = 1; t < arguments.length; t++) {
    const e = arguments[t];
    for (const r in e) i[r] = e[r];
  }
  return i;
}
function ty(i) {
  switch (i) {
    case 5120:
      return Int8Array;
    case 5121:
      return Uint8Array;
    case 5122:
      return Int16Array;
    case 5123:
      return Uint16Array;
    case 5124:
      return Int32Array;
    case 5125:
      return Uint32Array;
    case 5126:
      return Float32Array;
  }
  throw new Error("unsupported bufferView's component type: " + i);
}
function i0(i) {
  return i.indexOf("data:") === 0 && i.indexOf("base64,") > 0;
}
function s0(i) {
  const t = function(n) {
    return typeof self < "u" ? self.atob(n) : window.atob(n);
  }(i.substring(i.indexOf(",") + 1)), e = t.length, r = new Uint8Array(e);
  for (let n = 0; n < e; n++) r[n] = t.charCodeAt(n);
  return r.buffer;
}
const VR = [], UR = [], $R = [], WR = [0, 0, 0], ZR = Kv([]), XR = [1, 1, 1];
function rM(i, t, e, r, n, s, o) {
  const a = ty(o);
  if ((n === 0 || n === r * a.BYTES_PER_ELEMENT) && s % a.BYTES_PER_ELEMENT == 0) {
    const h = new a(t, s, e * r);
    return i.set(h), i;
  }
  n === 0 && (n = r * a.BYTES_PER_ELEMENT);
  const l = new Uint8Array(r * a.BYTES_PER_ELEMENT);
  for (let h = 0; h < e; h++) {
    let u = null;
    const c = new Uint8Array(t, n * h + s, r * a.BYTES_PER_ELEMENT);
    l.set(c), u = new a(l.buffer, 0, r);
    for (let f = 0; f < r; f++) i[h * r + f] = u[f];
  }
  return i;
}
const qR = typeof TextDecoder < "u" ? new TextDecoder("utf-8") : null;
function D_(i, t, e) {
  const r = new Uint8Array(i, t, e);
  return qR.decode(r);
}
const Ts = { get: function(i, t = {}, e) {
  t || (t = {});
  const r = new AbortController(), n = r.signal, s = rd({}, t);
  s.signal = n, s.method || (s.method = "GET"), s.referrerPolicy = s.referrerPolicy || "origin", typeof window > "u" || s.referrer || (s.referrer = window.location.href), e && (i = e(i));
  const o = fetch(i, s).then((a) => {
    const l = this._parseResponse(a, t.responseType);
    return l.message ? l : l.then((h) => t.responseType === "arraybuffer" ? { data: h, cacheControl: a.headers.get("Cache-Control"), expires: a.headers.get("Expires"), contentType: a.headers.get("Content-Type") } : h).catch((h) => {
      if (!h.code || h.code !== DOMException.ABORT_ERR) throw h;
    });
  }).catch((a) => {
    if (!a.code || a.code !== DOMException.ABORT_ERR) throw a;
  });
  return o.xhr = r, o;
}, _parseResponse: (i, t) => i.status !== 200 ? { status: i.status, statusText: i.statusText, message: `incorrect http request with status code(${i.status}): ${i.statusText}` } : t === "arraybuffer" ? i.arrayBuffer() : t === "json" ? i.json() : i.text(), getArrayBuffer: (i, t = {}, e) => (t || (t = {}), t.responseType = "arraybuffer", Ts.get(i, t, e)), getJSON: function(i, t = {}, e) {
  return t && t.jsonp ? Ts.jsonp(i) : ((t = t || {}).responseType = "json", Ts.get(i, t, e));
} };
Ts.jsonp = function(i) {
  const t = "_maptalks_jsonp_" + GR++;
  i.match(/\?/) ? i += "&callback=" + t : i += "?callback=" + t;
  let e = document.createElement("script");
  return e.type = "text/javascript", e.src = i, new Promise((r) => {
    window[t] = function(n) {
      document.getElementsByTagName("head")[0].removeChild(e), e = null, delete window[t], r(n);
    }, document.getElementsByTagName("head")[0].appendChild(e);
  });
};
let iM = class {
  constructor(t, e, r, n, s) {
    this._requestImage = t, this.decoders = e, this._supportedFormats = r, this.images = {}, this._imgRequests = {}, this._fetchOptions = n || {}, this._urlModifier = s;
  }
  requestImageFromBufferURI(t, e, r) {
    if (this.buffers[t.id]) {
      const o = this.buffers[t.id], a = this._createDataView(e, o);
      return this.getImageByBuffer(a, r);
    }
    if (this._imgRequests[t.id]) return this._imgRequests[t.id].then(() => {
      const o = this.buffers[t.id], a = this._createDataView(e, o);
      return this.getImageByBuffer(a, r);
    });
    if (i0(t.uri)) {
      const o = this.buffers[t.id] = s0(t.uri), a = this._createDataView(e, o);
      return this.getImageByBuffer(a, r);
    }
    let n;
    const s = t.uri.indexOf("blob:") >= 0;
    return n = t.uri.indexOf("://") > 0 || s ? t.uri : this.rootPath + "/" + t.uri, this._imgRequests[t.id] = Ts.getArrayBuffer(n, this._fetchOptions, this._urlModifier).then((o) => {
      const a = this.buffers[t.id] = o.data, l = this._createDataView(e, a);
      return this.getImageByBuffer(l, r);
    });
  }
  getImageByBuffer(t, e) {
    if (this.images[e.id]) return Promise.resolve(this.images[e.id]);
    const r = this.decoders;
    return r[e.mimeType] ? r[e.mimeType](t, { supportedFormats: this._supportedFormats }) : e.mimeType === "image/crn" || e.mimeType === "image/ktx2" || e.mimeType === "image/cttf" ? (console.warn("missing transcoder for " + e.mimeType, ", visit https://maptalks.com/docs/transcoders for details"), Promise.resolve(null)) : this._getImageInfo(e.id, t);
  }
  requestExternalImage(t) {
    if (this.images[t.id]) return Promise.resolve(this.images[t.id]);
    const e = t.uri.indexOf("data:image/") === 0 ? t.uri : this.rootPath + "/" + t.uri;
    return this._imgRequests[t.id] ? this._imgRequests[t.id].then(() => this.images[t.id]) : this._imgRequests[t.id] = this._getImageInfo(t.id, e);
  }
  _getImageInfo(t, e) {
    return new Promise((r, n) => {
      let s = e;
      this._urlModifier && (s = this._urlModifier(e)), this._requestImage(s, this._fetchOptions, (o, a) => {
        o ? n(o) : (URL.revokeObjectURL(e), this.images[t] = a, r(this.images[t]));
      });
    });
  }
};
const F_ = ["SCALAR", 1, "VEC2", 2, "VEC3", 3, "VEC4", 4, "MAT2", 4, "MAT3", 9, "MAT4", 16], pa = [];
let ey = class {
  constructor(t, e, r, n, s) {
    this.rootPath = t, this.gltf = e, this._enableInterleave = !1, this.glbBuffer = r, this.buffers = {}, this.requests = {}, this.accessors = {}, this._compareAccessor(), this._fetchOptions = n, this._urlModifier = s;
  }
  _requestData(t, e) {
    const r = this.gltf, n = r.accessors[e];
    if (n.bufferView === void 0) return this.accessors[n.id] = this._toBufferData(t, e, null, 0), Promise.resolve(this.accessors[n.id]);
    if (n && this.accessors[n.id]) return Promise.resolve(this.accessors[n.id]);
    const s = r.bufferViews[n.bufferView];
    return this._requestBufferOfBufferView(s).then((o) => {
      const { buffer: a, byteOffset: l } = o;
      return this.accessors[n.id] = this._toBufferData(t, e, a, l);
    });
  }
  _requestBufferOfBufferView(t) {
    const e = this.gltf.buffers[t.buffer];
    if (this.buffers[e.id]) {
      const r = this.buffers[e.id];
      return Promise.resolve({ buffer: r, byteOffset: 0 });
    }
    if (this.requests[e.id]) return this.requests[e.id].then(() => {
      const r = this.buffers[e.id];
      return Promise.resolve({ buffer: r, byteOffset: 0 });
    });
    if (t.buffer !== "binary_glTF" && t.buffer !== "KHR_binary_glTF" && e.uri) {
      if (i0(e.uri)) {
        const s = this.buffers[e.id] = s0(e.uri);
        return Promise.resolve({ buffer: s, byteOffset: 0 });
      }
      let r;
      const n = e.uri.indexOf("blob:") >= 0;
      return r = e.uri.indexOf("://") > 0 || n ? e.uri : this.rootPath + "/" + e.uri, this.requests[e.id] = Ts.getArrayBuffer(r, this._fetchOptions, !n && this._urlModifier).then((s) => (n && URL.revokeObjectURL(r), { buffer: this.buffers[e.id] = s.data, byteOffset: 0 }));
    }
    return Promise.resolve({ buffer: this.glbBuffer.buffer, byteOffset: this.glbBuffer.byteOffset });
  }
  _toBufferData(t, e, r, n = 0) {
    const s = this.gltf, o = s.accessors[e], a = o.bufferView !== void 0 ? s.bufferViews[o.bufferView] : {}, l = (a.byteOffset || 0) + n, h = this._getTypeItemSize(o.type), u = ty(o.componentType), c = a.byteStride || 0, f = { array: void 0, name: t, accessorName: e, byteLength: o.count * h * u.BYTES_PER_ELEMENT, componentType: o.componentType, count: o.count, type: o.type, itemSize: h, max: o.max, min: o.min, extensions: o.extensions };
    if (o.min && (f.min = o.min), o.max && (f.max = o.max), r) if (this._enableInterleave) f.byteStride = c, f.byteOffset = l + (o.byteOffset || 0), !c || c === h * u.BYTES_PER_ELEMENT || t === "indices" || t === "input" || t === "output" || t.indexOf("morph") >= 0 ? (f.array = this._typedArray(r, o.count, h, l + (o.byteOffset || 0), u), f.array.buffer.byteLength === f.byteLength && (f.byteOffset = 0)) : f.array = new Uint8Array(r, l, a.byteLength);
    else if (o.interleaved) {
      f.byteStride = 0, f.byteOffset = 0;
      const d = new u(o.count * h);
      if (f.array = rM(d, r, o.count, h, c, l + (o.byteOffset || 0), o.componentType), f.extensions && f.extensions.WEB3D_quantized_attributes && h > 2) {
        const p = new Float32Array(f.array.length), { decodeMatrix: g } = f.extensions.WEB3D_quantized_attributes;
        for (let m = 0; m < f.array.length; m += h) {
          pa[0] = f.array[m], pa[1] = f.array[m + 1], pa[2] = f.array[m + 2], pa[3] = 1;
          const v = ho(pa, pa, g);
          p[m] = v[0], p[m + 1] = v[1], p[m + 2] = v[2];
        }
        f.componentType = 5126, f.array = p;
      }
    } else f.byteStride = 0, f.array = this._typedArray(r, o.count, h, l + (o.byteOffset || 0), u), f.byteOffset = f.array.byteOffset;
    else {
      f.array = new u(o.count);
      const d = f.min || f.max;
      d && (f.array[0] = d[0], f.array[1] = d[1], f.array[2] = d[2]);
    }
    return f;
  }
  _compareAccessor() {
    const t = this.gltf.accessors;
    if (Array.isArray(t)) for (let e = 0; e < t.length; e++) for (let r = 0; r < t.length; r++) e !== r && t[e].bufferView === t[r].bufferView && (t[e].interleaved = t[r].interleaved = !0);
    else for (const e in t) for (const r in t) e !== r && t[e].bufferView === t[r].bufferView && (t[e].interleaved = t[r].interleaved = !0);
  }
  _typedArray(t, e, r, n, s) {
    return n % s.BYTES_PER_ELEMENT != 0 && (t = t.slice(n, n + e * r * s.BYTES_PER_ELEMENT), n = 0), new s(t, n, r * e);
  }
  _getTypeItemSize(t) {
    const e = F_.indexOf(t);
    return F_[e + 1];
  }
  requestKHRTechniquesWebgl(t) {
    const { shaders: e } = t, r = e.map((n) => {
      if (n.bufferView !== void 0) {
        const s = this.gltf.bufferViews[n.bufferView], { byteLength: o } = s;
        return this._requestBufferOfBufferView(s).then((a) => {
          const { buffer: l, byteOffset: h } = a, u = D_(l, h + (s.byteOffset || 0), o);
          return n.content = u, n;
        });
      }
      if (n.uri) {
        if (i0(n.uri)) {
          const s = s0(n.uri), o = D_(s, 0, s.byteLength);
          return n.content = o, Promise.resolve(n);
        }
        {
          const s = this.rootPath + "/" + n.uri;
          return Ts.get(s, this._fetchOptions, this._urlModifier).then((o) => (n.content = o, n));
        }
      }
      return Promise.resolve(n);
    });
    return Promise.all(r).then(() => t);
  }
}, YR = class extends iM {
  constructor(t, e, r, n, s, o, a, l) {
    super(n, s, o, a, l), this.rootPath = t, this.gltf = e, this.requests = {}, this.buffers = {}, this.glbBuffer = r, this.accessor = new ey(t, e, r, a, l);
  }
  iterate(t, e) {
    const r = this.gltf[e];
    if (!r) return;
    let n = 0;
    for (const s in r) t(s, r[s], n++);
  }
  createNode(t) {
    const e = {};
    if (Sn(t.name) && (e.name = t.name), Sn(t.children) && (e.children = t.children), Sn(t.jointName) && (e.jointName = t.jointName), Sn(t.matrix) && (e.matrix = t.matrix), Sn(t.rotation) && (e.rotation = t.rotation), Sn(t.scale) && (e.scale = t.scale), Sn(t.translation) && (e.translation = t.translation), Sn(t.extras) && (e.extras = t.extras), Sn(t.meshes) && (e.mesh = t.meshes[0]), e.translation || e.rotation || e.scale) {
      const r = function(n, s) {
        if (s.matrix) return s.matrix;
        if (s.translation || s.scale || s.rotation) {
          const o = Bh(VR, s.translation || WR), a = qA(UR, s.rotation || ZR), l = $o($R, s.scale || XR);
          return Jt(l, a, l), Jt(n, o, l);
        }
        return pn(n);
      }([], e);
      delete e.translation, delete e.rotation, delete e.scale, e.matrix = r;
    }
    return e;
  }
  _loadMaterials(t) {
    const e = {};
    for (const r in t) {
      const n = t[r];
      let s, o;
      n.instanceTechnique && n.instanceTechnique.values ? (s = n.instanceTechnique, o = s.values.diffuse) : (s = n, o = s.values.tex || s.values.diffuseTex || s.values.diffuse);
      const a = { baseColorTexture: { index: o } };
      n.name && (a.name = n.name), n.extensions && (a.extensions = n.extensions), n.extras && (a.extras = n.extras), e[r] = a;
    }
    return e;
  }
  _loadImage(t) {
    if (t.bufferView || t.extensions && (t.extensions.KHR_binary_glTF || t.extensions.binary_glTF)) {
      const e = t.bufferView ? t : t.extensions.KHR_binary_glTF || t.extensions.binary_glTF;
      t.extensions && (t.mimeType = e.mimeType, t.width = e.width, t.height = e.height);
      const r = this.gltf.bufferViews[e.bufferView], n = (r.byteOffset || 0) + this.glbBuffer.byteOffset, s = r.byteLength, o = this.buffers[e.bufferView] = new Uint8Array(this.glbBuffer.buffer, n, s);
      return this.getImageByBuffer(o, t);
    }
    return this.requestExternalImage(t);
  }
  _getTexture(t) {
    const e = this.gltf.textures[t];
    if (!e) return null;
    const r = this.gltf.images[e.source];
    return this._loadImage(r).then((n) => {
      const s = this.gltf.samplers[e.sampler];
      return { image: { array: n.data, width: n.width, height: n.height, index: e.source, mimeType: r.mimeType, name: r.name, extras: r.extras }, sampler: s };
    });
  }
  getBaseColorTexture(t) {
    const e = this.gltf.materials[t];
    let r, n;
    if (e.instanceTechnique && e.instanceTechnique.values ? (r = e.instanceTechnique, n = r.values.diffuse) : (r = e, n = r.values.tex || r.values.diffuseTex || r.values.diffuse), n === void 0 || this.gltf.textures === void 0) return null;
    const s = this.gltf.textures[n];
    if (!s) return null;
    const o = this.gltf.samplers[s.sampler];
    return { format: s.format || 6408, internalFormat: s.internalFormat || 6408, type: s.type || 5121, sampler: o, source: this.gltf.images[s.source] };
  }
  getMaterial() {
    return null;
  }
  getAnimations() {
    return null;
  }
}, JR = class extends iM {
  constructor(t, e, r, n, s, o, a, l) {
    super(n, s, o, a, l), this.rootPath = t, this.gltf = e, this.glbBuffer = r, this.buffers = {}, this.requests = {}, this.accessor = new ey(t, e, r, a, l);
  }
  iterate(t, e) {
    const r = this.gltf[e];
    if (r) for (let n = 0; n < r.length; n++) t(n, r[n], n);
  }
  createNode(t) {
    const e = {};
    return rd(e, t), !Sn(t.weights) && this.gltf.meshes && Sn(e.mesh) ? e.weights = this.gltf.meshes[e.mesh].weights : t.weights && (e.weights = t.weights), e;
  }
  _getTexture(t) {
    const e = this.gltf.textures[t];
    if (!e) return null;
    let r = e.source;
    if (e.extensions && e.extensions.EXT_texture_webp && (r = e.extensions.EXT_texture_webp.source), !Sn(r)) return null;
    const n = this.gltf.images[r];
    return this._loadImage(n).then((s) => {
      if (!s) return null;
      const o = { image: { array: s.data, mipmap: s.mipmap, width: s.width, height: s.height, index: e.source, mimeType: n.mimeType, name: n.name, extensions: n.extensions, extras: n.extras } };
      rd(o, e);
      const a = Sn(e.sampler) ? this.gltf.samplers[e.sampler] : void 0;
      return a && (o.sampler = a, o.sampler.magFilter = a.magFilter || 9729, o.sampler.minFilter = a.minFilter || 9729, o.sampler.wrapS = a.wrapS || 10497, o.sampler.wrapT = a.wrapT || 10497), s.format && (o.format = s.format), o;
    });
  }
  _loadImage(t) {
    if (!Sn(t.bufferView)) return this.requestExternalImage(t);
    {
      const e = this.gltf.bufferViews[t.bufferView], r = this.gltf.buffers[e.buffer];
      if (r.uri) return this.requestImageFromBufferURI(r, e, t);
      if (this.glbBuffer) return this._requestFromGlbBuffer(e, t);
    }
    return null;
  }
  _requestFromGlbBuffer(t, e) {
    const r = this._createDataView(t, this.glbBuffer.buffer, this.glbBuffer.byteOffset);
    return this.getImageByBuffer(r, e);
  }
  _createDataView(t, e, r) {
    r = r || 0;
    const n = (t.byteOffset || 0) + r, s = t.byteLength;
    return new Uint8Array(e, n, s);
  }
  _transformArrayBufferToBase64(t, e) {
    const r = new Array(t.byteLength);
    for (let n = 0; n < t.byteLength; n++) r[n] = String.fromCharCode(t[n]);
    return r.join(""), "data:" + (e = e || "image/png") + ";base64," + function(n) {
      return typeof self < "u" ? self.btoa(n) : window.btoa(n);
    }(unescape(encodeURIComponent(r)));
  }
  getAnimations(t) {
    const e = [];
    return t.forEach((r) => {
      e.push(this.getSamplers(r.samplers));
    }), Promise.all(e).then((r) => {
      for (let n = 0; n < r.length; n++) t[n].samplers = r[n];
      return t;
    });
  }
  getSamplers(t) {
    const e = [];
    for (let r = 0; r < t.length; r++) (Sn(t[r].input) || Sn(t[r].output)) && (e.push(this.accessor._requestData("input", t[r].input)), e.push(this.accessor._requestData("output", t[r].output)));
    return Promise.all(e).then((r) => {
      for (let n = 0; n < r.length / 2; n++) t[n].input = r[2 * n], t[n].output = r[2 * n + 1], t[n].interpolation || (t[n].interpolation = "LINEAR");
      return t;
    });
  }
};
const L_ = typeof TextDecoder < "u" ? new TextDecoder("utf-8") : null, KR = 1313821514, QR = 5130562;
let tI = class o0 {
  static read(t, e = 0, r = 0) {
    r || (r = t.byteLength);
    const n = new DataView(t, e, r), s = n.getUint32(4, !0);
    if (s === 1) return o0.readV1(n, e);
    if (s === 2) return o0.readV2(t, e);
    throw new Error("Unsupported glb version : " + s);
  }
  static readV1(t, e) {
    const r = t.getUint32(8, !0), n = t.getUint32(12, !0);
    if (r !== t.byteLength) throw new Error("Length in GLB header is inconsistent with glb's byte length.");
    const s = z_(t.buffer, 20 + e, n);
    return { json: JSON.parse(s), glbBuffer: { byteOffset: 20 + e + n, buffer: t.buffer, byteLength: r } };
  }
  static readV2(t, e) {
    let r, n, s;
    const o = new DataView(t, e + 12);
    let a = 0;
    for (; a < o.byteLength; ) {
      const l = o.getUint32(a, !0);
      a += 4;
      const h = o.getUint32(a, !0);
      if (a += 4, h === KR) r = z_(t, e + 12 + a, l);
      else if (h === QR) {
        s = e + 12 + a, n = l;
        break;
      }
      a += l;
    }
    return { json: JSON.parse(r), glbBuffer: { byteOffset: s, buffer: t, byteLength: n } };
  }
};
function z_(i, t, e) {
  if (L_) {
    const r = new Uint8Array(i, t, e);
    return L_.decode(r);
  }
  return function(r) {
    const n = r.length;
    let s = "";
    for (let o = 0; o < n; ) {
      let a = r[o++];
      if (128 & a) {
        let l = eI[a >> 3 & 7];
        if (!(64 & a) || !l || o + l > n) return null;
        for (a &= 63 >> l; l > 0; l -= 1) {
          const h = r[o++];
          if ((192 & h) != 128) return null;
          a = a << 6 | 63 & h;
        }
      }
      s += String.fromCharCode(a);
    }
    return s;
  }(new Uint8Array(i, t, e));
}
const eI = [1, 1, 1, 1, 2, 2, 3, 0], eg = [0, 0, 0], ng = [0, 0, 0, 1], rg = [1, 1, 1], ig = { TRANSLATION: [0, 0, 0], ROTATION: [0, 0, 0, 1], SCALE: [1, 1, 1] }, ga = { PREVIOUS: null, NEXT: null, PREINDEX: null, NEXTINDEX: null, INTERPOLATION: null }, N_ = { _getTRSW(i, t, e, r, n, s, o, a) {
  const l = Sn(i) ? t.animations : [t.animations[0]], h = {};
  for (let u = 0; u < l.length; u++) {
    const c = l[u], f = c.name || u;
    if (Sn(i) && f !== i) continue;
    const d = c.channelsMap[e];
    if (d) for (let p = 0; p < d.length; p++) {
      const g = d[p];
      g.target.path === "translation" ? (this._getAnimateData(n, c.samplers[g.sampler], r, 1), h.translation = Jn(eg, n)) : g.target.path === "rotation" ? (this._getQuaternion(s, c.samplers[g.sampler], r, 1), h.rotation = QA(ng, s)) : g.target.path === "scale" ? (this._getAnimateData(o, c.samplers[g.sampler], r, 1), h.scale = Jn(rg, o)) : g.target.path === "weights" && a && (this._getAnimateData(a, c.samplers[g.sampler], r, a.length), h.weights = a);
    }
  }
  return h;
}, _getAnimateData(i, t, e, r) {
  switch (t.interpolation) {
    case "LINEAR": {
      const n = this._getPreNext(ga, t, e, 1 * r);
      n && (i = function(s, o, a, l) {
        for (let h = 0; h < s.length; h++) s[h] = o[h] + l * (a[h] - o[h]);
        return s;
      }(i, n.PREVIOUS, n.NEXT, n.INTERPOLATION));
      break;
    }
    case "STEP": {
      const n = this._getPreNext(ga, t, e, 1 * r);
      n && (i = function(s, o) {
        for (let a = 0; a < s.length; a++) s[a] = o[a];
        return s;
      }(i, ...n.PREVIOUS));
      break;
    }
    case "CUBICSPLINE": {
      const n = this._getPreNext(ga, t, e, 3 * r);
      n && (i = this._getCubicSpline(i, n, t.input.array, 3 * r));
      break;
    }
  }
  return i;
}, _getQuaternion(i, t, e) {
  switch (t.interpolation) {
    case "LINEAR": {
      const r = this._getPreNext(ga, t, e, 1);
      r && _f(i, r.PREVIOUS, r.NEXT, r.INTERPOLATION);
      break;
    }
    case "STEP": {
      const r = this._getPreNext(ga, t, e, 1);
      r && (i = Sr(i, ...r.PREVIOUS));
      break;
    }
    case "CUBICSPLINE": {
      const r = this._getPreNext(ga, t, e, 3);
      if (r) {
        for (let n = 0; n < r.PREVIOUS.length; n++) r.PREVIOUS[n] = Math.acos(r.PREVIOUS[n]), r.NEXT[n] = Math.acos(r.NEXT[n]);
        i = this._getCubicSpline(i, r, t.input.array, 3);
        for (let n = 0; n < i.length; n++) i[n] = Math.cos(i[n]);
      }
      break;
    }
  }
  return i;
}, _search(i, t) {
  const e = i.length;
  let r, n, s, o = 0, a = e - 1, l = Math.floor((o + a) / 2);
  for (; o <= e - 1 && a >= 0; ) {
    if (o === a) return null;
    if (i[l] <= t && t <= i[l + 1]) {
      const h = i[l];
      return r = l, n = l + 1, s = (t - h) / (i[l + 1] - h), { preIndx: r, nextIndex: n, interpolation: s };
    }
    t < i[l] ? (a = l, l = Math.floor((o + a) / 2)) : i[l + 1] < t && (o = l, l = Math.floor((o + a) / 2));
  }
  return null;
}, _getPreNext(i, t, e, r) {
  const n = t.input.array, s = t.output.array, o = t.output.itemSize;
  (e < n[0] || e > n[n.length - 1]) && (e = Math.max(n[0], Math.min(n[n.length - 1], e))), e === n[n.length - 1] && (e = n[0]);
  const a = this._search(n, e);
  if (!a || !a.nextIndex) return null;
  const { preIndx: l, nextIndex: h, interpolation: u } = a;
  i.PREINDEX = l, i.NEXTINDEX = h, i.INTERPOLATION = u;
  const c = o * r;
  return i.PREVIOUS = s.subarray(i.PREINDEX * c, (i.PREINDEX + 1) * c), i.NEXT = s.subarray(i.NEXTINDEX * c, (i.NEXTINDEX + 1) * c), i;
}, _getCubicSpline(i, t, e, r) {
  const n = t.INTERPOLATION, s = e[t.PREINDEX], o = e[t.NEXTINDEX];
  for (let a = 0; a < 3; a++) {
    const l = t.PREVIOUS[r + a], h = (o - s) * t.PREVIOUS[2 * r + a], u = t.NEXT[3 + a], c = (o - s) * t.NEXT[a], f = (2 * Math.pow(n, 3) - 3 * Math.pow(n, 2) + 1) * l + (Math.pow(n, 3) - 2 * Math.pow(n, 2) + n) * h + (2 * -Math.pow(n, 3) + 3 * Math.pow(n, 2)) * u + (Math.pow(n, 3) - Math.pow(n, 2)) * c;
    i[a] = f;
  }
  return i;
}, getAnimationClip(i, t, e, r) {
  const n = i.nodes[t] && i.nodes[t].weights;
  return ne(eg, ...ig.TRANSLATION), Sr(ng, ...ig.ROTATION), ne(rg, ...ig.SCALE), this._getTRSW(r, i, t, e, eg, ng, rg, n);
}, getTimeSpan(i) {
  if (!i.animations) return null;
  if (i.timeSpan) return i.timeSpan;
  const t = i.animations;
  return i.timeSpan = {}, t.forEach((e, r) => {
    let n = -1 / 0, s = 1 / 0;
    const o = e.channels;
    for (let l = 0; l < o.length; l++) {
      const h = o[l], u = e.samplers[h.sampler].input.array;
      u[u.length - 1] > n && (n = u[u.length - 1]), u[0] < s && (s = u[0]);
    }
    const a = e.name || r;
    i.timeSpan[a] = { max: n, min: s };
  }), i.timeSpan;
}, getTimeSpanByName(i, t) {
  const e = this.getTimeSpan(i);
  return e ? Sn(t) ? e[t] : e[Object.keys(e)[0]] : null;
} };
let sM = !1;
if (typeof OffscreenCanvas < "u") {
  let i;
  try {
    i = new OffscreenCanvas(2, 2).getContext("2d");
  } catch {
  }
  i && typeof createImageBitmap < "u" && (sM = !0);
}
const pc = typeof document > "u" ? null : document.createElement("canvas");
let bs = class {
  constructor(t, e, r) {
    if (this.options = r || {}, this.options.decoders || (this.options.decoders = {}), this._fetchOptions = this.options.fetchOptions || {}, e.buffer instanceof ArrayBuffer) {
      const { json: n, glbBuffer: s } = tI.read(e.buffer, e.byteOffset, e.byteLength);
      this._init(t, n, s);
    } else this._init(t, e);
    this._accessor = new ey(this.rootPath, this.gltf, this.glbBuffer, this._fetchOptions, this.options.urlModifier), this._checkExtensions();
  }
  _checkExtensions() {
    const t = this.gltf.extensionsRequired;
    if (t) {
      if (t.indexOf("KHR_draco_mesh_compression") >= 0 && !this.options.decoders.draco) throw new Error("KHR_draco_mesh_compression is required but @maptalks/transcoders.draco is not loaded");
      if (t.indexOf("KHR_texture_basisu") >= 0 && !this.options.decoders.ktx2) throw new Error("KHR_texture_basisu is required but @maptalks/transcoders.ktx2 is not loaded");
    }
  }
  _loadExtensions() {
    const t = this.gltf.extensions;
    return t && t.KHR_techniques_webgl ? this._accessor.requestKHRTechniquesWebgl(t.KHR_techniques_webgl).then((e) => (t.KHR_techniques_webgl = e, t)) : Promise.resolve(t);
  }
  load(t) {
    t = t || {};
    const e = this._loadScene(t), r = this._loadAnimations(), n = this._loadTextures(), s = this._loadExtensions();
    return Promise.all([e, r, n, s]).then((o) => (o[0].animations = o[1], o[0].textures = o[2], o[0].extensions = o[3], o[0].transferables = this.transferables || [], this.createChannelsMap(o[0]), o[0]));
  }
  createChannelsMap(t) {
    const e = t.animations;
    if (e) for (let r = 0; r < e.length; r++) {
      const n = e[r];
      n.channelsMap = {};
      for (let s = 0; s < n.channels.length; s++) {
        const o = n.channels[s];
        n.channelsMap[o.target.node] || (n.channelsMap[o.target.node] = []), n.channelsMap[o.target.node].push(o);
      }
    }
  }
  getExternalResources() {
    const t = [];
    if (this.gltf) {
      const { buffers: e, images: r } = this.gltf;
      for (let n = 0; n < e.length; n++) e[n].uri && e[n].uri.indexOf("data:application/octet-stream;base64") < 0 && t.push({ type: "buffer", uri: e[n].uri });
      for (let n = 0; n < r.length; n++) r[n].uri && r[n].uri.indexOf("data:image/") < 0 && t.push({ type: "image", uri: r[n].uri });
    }
    return t;
  }
  static getAnimationClip(t, e, r, n) {
    return N_.getAnimationClip(t, e, r, n);
  }
  static getAnimationTimeSpan(t, e) {
    return N_.getTimeSpanByName(t, e);
  }
  static getTypedArrayCtor(t) {
    return ty(t);
  }
  static readInterleavedArray(t, e, r, n, s, o, a) {
    return rM(t, e, r, n, s, o, a);
  }
  _init(t, e, r) {
    this.gltf = e, this.glbBuffer = r, this.version = e.asset ? +e.asset.version : 1, this.rootPath = t, this.buffers = {}, this.requests = {}, this.options.requestImage = sM ? rI.bind(this) : this.options.requestImage || nI, this.options.transferable && (this.transferables = []), this.version === 2 ? (this.adapter = new JR(t, e, r, this.options.requestImage, this.options.decoders || {}, this.options.supportedFormats || {}, this._fetchOptions, this.options.urlModifier), this.adapter.iterate((n, s, o) => {
      s.id = "buffer_" + o;
    }, "buffers"), this.adapter.iterate((n, s, o) => {
      s.id = "image_" + o;
    }, "images"), this.adapter.iterate((n, s, o) => {
      s.id = "accessor_" + o;
    }, "accessors")) : (this.adapter = new YR(t, e, r, this.options.requestImage, this.options.decoders || {}, this.options.supportedFormats || {}, this._fetchOptions, this.options.urlModifier), this.adapter.iterate((n, s, o) => {
      s.id = "accessor_" + o;
    }, "accessors"), this.adapter.iterate((n, s, o) => {
      s.id = "image_" + o;
    }, "images"));
  }
  _parseNodes(t, e) {
    if (t.children && t.children.length > 0) {
      if (r = t.children[0], !(typeof r == "number" && isFinite(r) || nM(t.children[0]))) return t;
      const n = t.children.map((s) => {
        const o = e[s];
        return o.nodeIndex = s, this._parseNodes(o, e);
      });
      t.children = n;
    }
    var r;
    return t;
  }
  _loadScene(t) {
    return this._loadNodes(t).then((e) => {
      const r = this.scenes = [];
      let n;
      for (const o in e) e[o] = this._parseNodes(e[o], e), e[o].nodeIndex = Number(o) ? Number(o) : o;
      this.adapter.iterate((o, a, l) => {
        const h = {};
        a.name && (h.name = a.name), a.nodes && (h.nodes = a.nodes.map((u) => e[u])), this.gltf.scene === o && (n = l), r.push(h);
      }, "scenes");
      const s = { textures: this.gltf.textures, asset: this.gltf.asset, scene: n, scenes: r, nodes: e, meshes: this.meshes, materials: this.gltf.materials, skins: this.skins, extensionsRequired: this.gltf.extensionsRequired, extensionsUsed: this.gltf.extensionsUsed };
      if (this.gltf.extensions && (s.extensions = this.gltf.extensions), this.version === 1) {
        const o = this.adapter._loadMaterials(this.gltf.materials);
        s.materials = o;
      }
      return delete this.gltf.buffers, s.json = this.gltf, s;
    });
  }
  _loadNodes(t) {
    return this._loadMeshes(t).then(() => {
      const e = this.nodes = {};
      return this.adapter.iterate((r, n) => {
        const s = this.adapter.createNode(n, this.meshes, this.skins);
        e[r] = s;
      }, "nodes"), e;
    });
  }
  _loadSkins() {
    this.skins = [];
    const t = [];
    return this.adapter.iterate((e, r, n) => {
      t.push(this._loadSkin(r).then((s) => {
        s.index = n, this.skins.push(s);
      }));
    }, "skins"), t;
  }
  _loadSkin(t) {
    const e = t.inverseBindMatrices;
    return this.adapter.accessor._requestData("inverseBindMatrices", e).then((r) => (t.inverseBindMatrices = r, r && r.buffer && this.transferables && this.transferables.indexOf(r.buffer) < 0 && this.transferables.push(r.buffer), t));
  }
  _loadAnimations() {
    const t = this.gltf.animations;
    return Sn(t) ? this.adapter.getAnimations(t) : null;
  }
  _loadMeshes(t) {
    this.meshes = {};
    let e = [];
    return this.adapter.iterate((r, n, s) => {
      e.push(this._loadMesh(n, t).then((o) => {
        o.index = s, this.meshes[r] = o;
      }));
    }, "meshes"), e = e.concat(this._loadSkins()), Promise.all(e);
  }
  _loadMesh(t, e) {
    const r = t.primitives.map((n) => this._loadPrimitive(n, e)).filter((n) => !!n);
    return Promise.all(r).then((n) => {
      const s = {};
      return rd(s, t), s.primitives = n, s;
    });
  }
  _loadTextures() {
    const t = this.gltf.textures;
    if (!t) return null;
    const e = [];
    for (const r in t) e.push(this.adapter._getTexture(r));
    return Promise.all(e).then((r) => {
      if (this.transferables) for (let n = 0; n < r.length; n++) {
        const s = r[n].image.array;
        if (r[n] && s) {
          let o;
          o = s instanceof ImageBitmap ? s : s.buffer, o && this.transferables.indexOf(o) < 0 && this.transferables.push(o);
        }
      }
      if (!Array.isArray(t)) {
        const n = {}, s = Object.keys(t);
        for (let o = 0; o < r.length; o++) r[o] && (n[s[o]] = r[o]);
        return n;
      }
      return r;
    });
  }
  _loadPrimitive(t, e) {
    let r;
    const n = [], s = t.extensions;
    if (Sn(t.targets)) for (let o = 0; o < t.targets.length; o++) {
      const a = t.targets[o];
      for (const l in a) {
        const h = this.adapter.accessor._requestData(`morphTargets_${l}_${o}`, a[l]);
        h && n.push(h);
      }
    }
    if (s && s.KHR_draco_mesh_compression) {
      if (!this.options.decoders.draco && (!this.gltf.extensionsRequired || !this.gltf.extensionsRequired.indexOf("KHR_draco_mesh_compression") < 0)) return null;
      const o = this.options.decoders.draco, { bufferView: a, attributes: l } = s.KHR_draco_mesh_compression, h = this.gltf.bufferViews[a], u = this._accessor._requestBufferOfBufferView(h).then((c) => {
        const { buffer: f, byteOffset: d } = c;
        let { byteOffset: p } = h;
        const g = h.byteLength;
        p || (p = 0);
        const m = new DataView(f, d + p, g), v = { attributes: l, useUniqueIDs: !1, skipAttributeTransform: e.skipAttributeTransform };
        return o(m, v).then((_) => {
          const y = Object.values(_.attributes);
          return _.indices && y.push(_.indices), y;
        });
      });
      n.push(u), r = Promise.all(n);
    } else {
      const o = t.attributes;
      for (const a in o) {
        const l = this.adapter.accessor._requestData(a, o[a]);
        l && n.push(l);
      }
      if (Sn(t.indices)) {
        const a = this.adapter.accessor._requestData("indices", t.indices);
        a && n.push(a);
      }
      r = Promise.all(n);
    }
    return r.then((o) => {
      if (s && s.KHR_draco_mesh_compression) {
        const u = t.targets ? t.targets.length : 0;
        o[u] = o[u].concat(o.slice(0, u)), o = o[u];
      }
      let a, l;
      const h = { attributes: o.reduce((u, c) => {
        if (c.name === "indices") a = c;
        else if (c.name.indexOf("morphTargets_") > -1) l = l || {}, l[c.name.slice(13)] = c;
        else {
          if (!(c.name !== "POSITION" || c.min && c.max)) {
            const f = [1 / 0, 1 / 0, 1 / 0], d = [-1 / 0, -1 / 0, -1 / 0], { itemSize: p, array: g } = c, m = g.length / p;
            for (let v = 0; v < m; v++) for (let _ = 0; _ < p; _++) {
              const y = v * p + _;
              g[y] < f[_] && (f[_] = g[y]), g[y] > d[_] && (d[_] = g[y]);
            }
            if (c.quantization) {
              const v = c.quantization, _ = v.range / (1 << v.quantizationBits), y = v.minValues;
              go(f, f, _), qr(f, f, y), go(d, d, _), qr(d, d, y);
            }
            c.min = f, c.max = d;
          }
          u[c.name] = c;
        }
        return this.transferables && c.array.buffer && this.transferables.indexOf(c.array.buffer) < 0 && this.transferables.push(c.array.buffer), u;
      }, {}), material: t.material };
      return a && (h.indices = a), l && (h.morphTargets = l), h.mode = Sn(t.mode) ? t.mode : 4, Sn(t.extras) && (h.extras = t.extras), h;
    });
  }
};
function nI(i, t, e) {
  const r = new Image();
  r.crossOrigin = "", r.onload = () => {
    if (!pc) return void e(new Error("There is no canvas to draw image!"));
    pc.width = r.width, pc.height = r.height;
    const n = pc.getContext("2d", { willReadFrequently: !0 });
    n.drawImage(r, 0, 0, r.width, r.height);
    const s = n.getImageData(0, 0, r.width, r.height), o = { width: r.width, height: r.height, data: new Uint8Array(s.data) };
    e(null, o);
  }, r.onerror = function(n) {
    e(n);
  }, r.src = i;
}
const sg = [], ma = [];
let jh, a0;
function rI(i, t, e) {
  jh || (jh = new OffscreenCanvas(2, 2), a0 = jh.getContext("2d", { willReadFrequently: !0 }));
  let r = null;
  if (nM(i)) this.options.urlModifier && (i = this.options.urlModifier(i)), sg.push([i, t, e, this]), function n() {
    if (!sg.length || ma.length > 10) return;
    const s = sg.shift(), [o, a, l, h] = s;
    ma.push(s), fetch(o, a).then((u) => u.arrayBuffer()).then((u) => {
      const c = new Blob([new Uint8Array(u)]);
      return createImageBitmap(c);
    }).then(H_.bind(h)).then((u) => {
      l.call(h, null, u);
      const c = ma.indexOf(s);
      ma.splice(c, 1), n();
    }).catch((u) => {
      console.warn(u), l.call(h, u);
      const c = ma.indexOf(s);
      ma.splice(c, 1), n();
    });
  }();
  else {
    const n = new Blob([i]);
    r = createImageBitmap(n), r.then(H_.bind(this)).then((s) => {
      e(null, s);
    }).catch((s) => {
      console.warn(s), e(s);
    });
  }
}
function H_(i) {
  let { width: t, height: e } = i;
  B_(t) || (t = j_(t)), B_(e) || (e = j_(e));
  const r = this.options.maxTextureSize;
  r && (t = Math.min(r, t), e = Math.min(r, e)), jh.width = t, jh.height = e, a0.drawImage(i, 0, 0, t, e), i.close();
  const n = a0.getImageData(0, 0, t, e);
  return { width: t, height: e, data: new Uint8Array(n.data) };
}
function B_(i) {
  return (i & i - 1) == 0 && i !== 0;
}
function j_(i) {
  return Math.pow(2, Math.floor(Math.log(i) / Math.LN2));
}
/*!
 * Contains code from google filament
 * https://github.com/google/filament/
 * License Apache-2.0
 */
const iI = 8, sI = [], oI = [], G_ = [], aI = [];
function oM(i, t, e) {
  const r = hi(oI, t, e), n = lI(sI, e[0], e[1], e[2], ...r, ...t);
  i = KA(i, n), i = Qv(i, i), i = hI(i);
  const o = 1 / ((1 << 2 * iI - 1) - 1);
  if (i[3] < o) {
    i[3] = o;
    const h = Math.sqrt(1 - o * o);
    i[0] *= h, i[1] *= h, i[2] *= h;
  }
  const a = e[3] > 0 ? hi(G_, e, t) : hi(G_, t, e), l = hi(aI, e, t);
  return lu(l, a) < 0 && tM(i, i, -1), i;
}
function lI(i, t, e, r, n, s, o, a, l, h) {
  return i[0] = t, i[1] = e, i[2] = r, i[3] = n, i[4] = s, i[5] = o, i[6] = a, i[7] = l, i[8] = h, i;
}
function hI(i) {
  return i[3] < 0 ? tM(i, i, -1) : i;
}
const uI = [];
function aM(i, t, e) {
  const r = e || [];
  r.setLength && r.setLength(i.length);
  const n = uI;
  n.length < i.length / 3 && (n.length = i.length / 3), n.fill(0, 0, i.length / 3);
  const s = t.length === void 0 ? t : t.length;
  for (let o = 0; o < s / 3; o++)
    t.length === void 0 ? $_(i, o * 3, o * 3 + 1, o * 3 + 2, r, n) : $_(i, t[o * 3], t[o * 3 + 1], t[o * 3 + 2], r, n);
  for (let o = 0; o < r.length; o += 3) {
    const a = n[o / 3];
    if (a === 0) {
      r[o] = 0, r[o + 1] = 0, r[o + 2] = 0;
      continue;
    }
    r[o] /= a, r[o + 1] /= a, r[o + 2] /= a;
  }
  return r;
}
const cI = [], fI = [], dI = [], V_ = [], og = [], U_ = [], Yi = [];
function $_(i, t, e, r, n, s) {
  ne(V_, i[t * 3], i[t * 3 + 1], i[t * 3 + 2]), ne(og, i[e * 3], i[e * 3 + 1], i[e * 3 + 2]), ne(U_, i[r * 3], i[r * 3 + 1], i[r * 3 + 2]);
  const o = Ti(cI, U_, og), a = Ti(fI, V_, og), l = hi(dI, o, a);
  mo(Yi, l), n[t * 3] = n[t * 3] || 0, n[e * 3] = n[e * 3] || 0, n[r * 3] = n[r * 3] || 0, n[t * 3 + 1] = n[t * 3 + 1] || 0, n[e * 3 + 1] = n[e * 3 + 1] || 0, n[r * 3 + 1] = n[r * 3 + 1] || 0, n[t * 3 + 2] = n[t * 3 + 2] || 0, n[e * 3 + 2] = n[e * 3 + 2] || 0, n[r * 3 + 2] = n[r * 3 + 2] || 0, n[t * 3] += Yi[0], n[e * 3] += Yi[0], n[r * 3] += Yi[0], n[t * 3 + 1] += Yi[1], n[e * 3 + 1] += Yi[1], n[r * 3 + 1] += Yi[1], n[t * 3 + 2] += Yi[2], n[e * 3 + 2] += Yi[2], n[r * 3 + 2] += Yi[2], s[t] += 1, s[e] += 1, s[r] += 1;
}
/*!
 * Contains code from THREE.JS
 * https://github.com/mrdoob/three.js/
 * License MIT
 * 
 * Generate tangents per vertex.
 */
function lM(i, t, e, r, n) {
  const s = i.length / 3, o = n || new Array(4 * s), a = [], l = [];
  for (let S = 0; S < s; S++)
    a[S] = [0, 0, 0], l[S] = [0, 0, 0];
  const h = [0, 0, 0], u = [0, 0, 0], c = [0, 0, 0], f = [0, 0], d = [0, 0], p = [0, 0], g = [0, 0, 0], m = [0, 0, 0];
  function v(S, P, C) {
    gc(h, i, S * 3), gc(u, i, P * 3), gc(c, i, C * 3), ag(f, e, S * 2), ag(d, e, P * 2), ag(p, e, C * 2);
    const k = u[0] - h[0], O = c[0] - h[0], R = u[1] - h[1], I = c[1] - h[1], D = u[2] - h[2], z = c[2] - h[2], H = d[0] - f[0], G = p[0] - f[0], $ = d[1] - f[1], K = p[1] - f[1], dt = 1 / (H * K - G * $);
    ne(
      g,
      (K * k - $ * O) * dt,
      (K * R - $ * I) * dt,
      (K * D - $ * z) * dt
    ), ne(
      m,
      (H * O - G * k) * dt,
      (H * I - G * R) * dt,
      (H * z - G * D) * dt
    ), qr(a[S], a[S], g), qr(a[P], a[P], g), qr(a[C], a[C], g), qr(l[S], l[S], m), qr(l[P], l[P], m), qr(l[C], l[C], m);
  }
  for (let S = 0, P = r.length; S < P; S += 3)
    v(
      r[S + 0],
      r[S + 1],
      r[S + 2]
    );
  const _ = [], y = [], x = [], w = [];
  let b, T, A;
  function M(S) {
    gc(x, t, S * 3), Jn(w, x), T = a[S], Jn(_, T), Ti(_, _, go(x, x, lu(x, T))), mo(_, _), hi(y, w, T), A = lu(y, l[S]), b = A < 0 ? -1 : 1, o[S * 4] = _[0], o[S * 4 + 1] = _[1], o[S * 4 + 2] = _[2], o[S * 4 + 3] = b;
  }
  for (let S = 0, P = r.length; S < P; S += 3)
    M(r[S + 0]), M(r[S + 1]), M(r[S + 2]);
  return o;
}
function gc(i, t, e) {
  return i[0] = t[e], i[1] = t[e + 1], i[2] = t[e + 2], i;
}
function ag(i, t, e) {
  return i[0] = t[e], i[1] = t[e + 1], i;
}
/*!
 * @maptalks/reshader.gl v0.97.4
 * LICENSE : UNLICENSED
 * (c) 2016-2024 maptalks.com
 */
function hM(i) {
  return !ri(i) && (typeof i == "string" || i.constructor !== null && i.constructor === String);
}
function ri(i) {
  return i == null;
}
function Oo(i) {
  return !ri(i);
}
function Ei(i) {
  return !ri(i) && (typeof i == "function" || i.constructor !== null && i.constructor === Function);
}
const pI = typeof Object.assign == "function";
function $n(i) {
  if (pI) Object.assign.apply(Object, arguments);
  else for (let t = 1; t < arguments.length; t++) {
    const e = arguments[t];
    for (const r in e) i[r] = e[r];
  }
  return i;
}
function uM(i) {
  for (let t = 1; t < arguments.length; t++) {
    const e = arguments[t];
    for (const r in e) e[r] != null && (i[r] = e[r]);
  }
  return i;
}
function Ds(i) {
  return typeof i == "number" && !isNaN(i);
}
function xf(i, t, e) {
  return i * (1 - e) + t * e;
}
function zr(i) {
  return Array.isArray(i) || i instanceof Uint8Array || i instanceof Int8Array || i instanceof Uint16Array || i instanceof Int16Array || i instanceof Uint32Array || i instanceof Int32Array || i instanceof Uint8ClampedArray || i instanceof Float32Array || i instanceof Float64Array;
}
function cM(i) {
  return (i = Math.abs(i)) < 128 ? Int8Array : i < 32768 ? Int16Array : Float32Array;
}
function fM(i, t, e) {
  return Math.min(e, Math.max(t, i));
}
function Cl(i) {
  return i && i.hasExtension("oes_vertex_array_object");
}
function Vi(i, t) {
  return Object.prototype.hasOwnProperty.call(i, t);
}
function ny(i) {
  if (i.data) {
    if (i.data.BYTES_PER_ELEMENT) return i.data.length * i.data.BYTES_PER_ELEMENT;
    if (i.data.length) return 4 * i.data.length;
  } else {
    if (i.BYTES_PER_ELEMENT) return i.length * i.BYTES_PER_ELEMENT;
    if (i.length) return 4 * i.length;
    if (i.buffer && i.buffer.destroy) return i.buffer._buffer.byteLength;
  }
  return 0;
}
function dM(i) {
  return i.width * i.height * iy(i.format) * ry(i.type) * (i._reglType === "textureCube" ? 6 : 1);
}
function ry(i) {
  return i === "uint8" ? 1 : i === "uint16" || i === "float16" || i === "half float" ? 2 : i === "uint32" || i === "float" || i === "float32" ? 4 : 0;
}
function iy(i) {
  return i === "depth" || i === "alpha" || i === "luminance" ? 1 : i === "luminance alpha" || i === "depth stencil" ? 2 : i === "srgba" || i === "rgb5 a1" || i.substring(0, 4) === "rgba" ? 4 : i === "srgb" || i.substring(0, 3) === "rgb" ? 3 : 1;
}
function sy(i) {
  if (!i.componentType) return !1;
  const t = bs.getTypedArrayCtor(i.componentType);
  return i.byteStride > 0 && i.byteStride !== i.itemSize * t.BYTES_PER_ELEMENT;
}
function id(i) {
  return i && (i.stride > 0 || sy(i));
}
function l0(i) {
  let t = 0;
  const e = i && i.length || 0;
  if (!e) return t;
  let r;
  for (let n = 0; n < e; n++) r = i.charCodeAt(n), t = (t << 5) - t + r, t &= t;
  return t;
}
function zi(i) {
  return (i & i - 1) == 0 && i !== 0;
}
function mc(i) {
  return Math.pow(2, Math.floor(Math.log(i) / Math.LN2));
}
function bf(i, t, e) {
  if (zr(i)) return zi(i.width) && zi(i.height) ? i : function(a, l, h) {
    let u = l, c = h;
    zi(l) || (u = mc(l)), zi(h) || (c = mc(h));
    const f = new ImageData(new Uint8ClampedArray(a), l, h), d = document.createElement("canvas");
    d.width = l, d.height = h, d.getContext("2d").putImageData(f, 0, 0);
    const p = document.createElement("canvas");
    p.width = u, p.height = c, p.getContext("2d").drawImage(d, 0, 0, l, h, 0, 0, c, c), console.warn(`Texture's size is not power of two, resize from (${l}, ${h}) to (${u}, ${c})`);
    let g = document.getElementById("_debug_resize_canvas");
    return g || (g = document.createElement("canvas"), g.id = "_debug_resize_canvas", document.body.appendChild(g)), g.width = u, g.height = c, g.getContext("2d").drawImage(p, 0, 0), p;
  }(i, t, e);
  if (zi(i.width) && zi(i.height)) return i;
  e = i.height, zi(t = i.width) || (t = mc(t)), zi(e) || (e = mc(e));
  const r = document.createElement("canvas");
  r.width = t, r.height = e, r.getContext("2d").drawImage(i, 0, 0, t, e);
  const n = i.src, s = n.lastIndexOf("/") + 1, o = n.substring(s);
  return console.warn(`Texture(${o})'s size is not power of two, resize from (${i.width}, ${i.height}) to (${t}, ${e})`), r;
}
var pM = Object.freeze({
  __proto__: null,
  isString: hM,
  isNil: ri,
  defined: Oo,
  isFunction: Ei,
  extend: $n,
  extend1: uM,
  extend2: function(i) {
    for (let t = 1; t < arguments.length; t++) {
      const e = arguments[t];
      for (const r in e) i[r] === void 0 && (i[r] = e[r]);
    }
    return i;
  },
  isNumber: Ds,
  log2: function(i) {
    if (Math.log2) return Math.log2(i);
    const t = Math.log(i) * Math.LOG2E, e = Math.round(t);
    return Math.abs(e - t) < 1e-14 ? e : t;
  },
  normalize: function(i, t) {
    let e = 0;
    for (let r = 0, n = t.length; r < n; r++) e += t[r];
    for (let r = 0, n = t.length; r < n; r++) i[r] = t[r] / e;
    return i;
  },
  interpolate: xf,
  isArray: zr,
  lerp: function(i, t, e, r) {
    for (let n = 0; n < i.length; n++) i[n] = t[n] + r * (e[n] - t[n]);
    return i;
  },
  set: function(i, t) {
    for (let e = 0; e < i.length; e++) i[e] = t[e];
    return i;
  },
  getPosArrayType: cM,
  clamp: fM,
  isSupportVAO: Cl,
  hasOwn: Vi,
  getBufferSize: ny,
  getTexMemorySize: dM,
  getTextureByteWidth: ry,
  getTextureChannels: iy,
  isInStride: sy,
  isInterleaved: id,
  getSupportedFormats: function(i) {
    return {
      etc: !!i.getExtension("WEBGL_compressed_texture_etc"),
      etc1: !!i.getExtension("WEBGL_compressed_texture_etc1"),
      s3tc: !!i.getExtension("WEBGL_compressed_texture_s3tc"),
      pvrtc: !!i.getExtension("WEBGL_compressed_texture_pvrtc"),
      astc: !!i.getExtension("WEBGL_compressed_texture_astc"),
      bc7: !!i.getExtension("EXT_texture_compression_bptc")
    };
  },
  hashCode: l0,
  isPowerOfTwo: zi,
  resizeToPowerOfTwo: bf
});
const oy = (i) => class extends i {
  on(t, e) {
    return this._events || (this._events = {
      type: [e]
    }), this._events[t] = this._events[t] || [], this._events[t].push(e), this;
  }
  once(t, e) {
    return this.on(t, this._wrapOnce(t, e));
  }
  off(t, e) {
    return this._events && this._events[t] ? (this._events[t].splice(this._events[t].indexOf(e), 1), this) : this;
  }
  fire(t, e = {}) {
    if (!this._events || !this._events[t]) return this;
    e.target || (e.target = this);
    const r = this._events[t].slice(0);
    for (const n of r) n(e);
    return this;
  }
  _wrapOnce(t, e) {
    const r = this;
    let n = !1;
    return function s(o) {
      n || (n = !0, e(o), r.off(t, s));
    };
  }
}, pr = "__reshader_disposed";
var W_ = Object.freeze({
  __proto__: null,
  KEY_DISPOSED: pr,
  WEBGL_EXTENSIONS: ["ANGLE_instanced_arrays", "OES_element_index_uint", "OES_standard_derivatives"],
  WEBGL_OPTIONAL_EXTENSIONS: ["OES_vertex_array_object", "OES_texture_half_float", "OES_texture_half_float_linear", "OES_texture_float", "OES_texture_float_linear", "WEBGL_depth_texture", "EXT_shader_texture_lod", "EXT_texture_filter_anisotropic"]
}), gM = oy(class {
  constructor(i, t) {
    if (Ei(i)) {
      this._texture = i, i = this.config = {};
      for (const e in this._texture) Vi(this._texture, e) && (Ei(this._texture[e]) || (i[e] = this._texture[e]));
    } else if (this.config = i || {}, this.resLoader = t, !i.url && !i.promise || i.data) i.data && this._needPowerOf2() && (i.data instanceof Image ? i.data = bf(i.data) : i.hdr || !zr(i.data) || zi(i.width) && zi(i.height) || (i.data = bf(i.data, i.width, i.height)));
    else {
      this._loading = !0;
      const e = this;
      let r;
      if (i.promise) r = i.promise;
      else {
        let n;
        n = i.arrayBuffer ? t.getArrayBuffer : t.get, r = n.call(t, i.url);
      }
      i.data = t.getDefaultTexture(i.url), this.promise = r, r.then((n) => (delete this.promise, e._loading = !1, e.config && (n.data instanceof Image && this._needPowerOf2() && (n.data = bf(n.data)), e.onLoad(n), Array.isArray(n) || (n = [n]), e.fire("complete", {
        target: this,
        resources: n
      })), n)).catch((n) => {
        console.error("error when loading texture image.", n), e.fire("error", {
          target: this,
          error: n
        });
      });
    }
  }
  isReady() {
    return !this._loading;
  }
  set(i, t) {
    return this.config[i] = t, this.dirty = !0, this;
  }
  get(i) {
    return this.config[i];
  }
  getREGLTexture(i) {
    return this._texture || (this._texture = this.createREGLTexture(i), this.config.persistent || (this.config.data && (this.config.data instanceof ImageBitmap || (this.config.data = [])), this.config.faces && (this.config.faces = []), this.config.image && (this.config.image.array = []), this.config.mipmap && delete this.config.mipmap)), this.dirty && this._updateREGL(), this._texture;
  }
  getMemorySize() {
    if (!this.config) return 0;
    const { width: i, height: t, type: e, format: r } = this.config, n = ry(e || "uint8"), s = iy(r || "rgba");
    return this.config.faces ? i * t * n * s * 6 : i * t * n * s;
  }
  _updateREGL() {
    this._texture && !this._texture[pr] && this._texture(this.config), this.dirty = !1;
  }
  dispose() {
    this.config && this.config.url && (URL.revokeObjectURL(this.config.url), this.resLoader.disposeRes(this.config.url)), this.config && this.config.data instanceof ImageBitmap && (this.config.data.close(), this.config.data = []), this._texture && !this._texture[pr] && (this._texture._reshader_refCount && this._texture._reshader_refCount--, this._texture._reshader_refCount || (this._texture.destroy(), this._texture[pr] = !0, delete this._texture)), delete this.resLoader;
    const i = this.config && this.config.url;
    delete this.config, i && this.fire("disposed", {
      target: this,
      url: i
    });
  }
  _needPowerOf2() {
    const i = this.config;
    return i.wrap && i.wrap !== "clamp" || i.wrapS && i.wrapS !== "clamp" || i.wrapT && i.wrapT !== "clamp" || i.min && i.min !== "nearest" && i.min !== "linear";
  }
});
const gI = {};
let hn = class {
  constructor(t) {
    this.regl = t;
  }
  render(t, e, r, n) {
    t.setUniforms(e || gI), t.setFramebuffer(n);
    let s = 0;
    if (r) {
      const { opaques: o, transparents: a } = r.getSortedMeshes();
      s += t.draw(this.regl, o), s += t.draw(this.regl, a);
    } else s += t.draw(this.regl);
    return s;
  }
  clear(t) {
    this.regl.clear(t);
  }
};
const Z_ = [], X_ = pn([]), lg = {
  min: [],
  max: []
};
let Mh = class h0 {
  constructor(t, e) {
    this.min = t || [1 / 0, 1 / 0, 1 / 0], this.max = e || [-1 / 0, -1 / 0, -1 / 0], this.updateVertex();
  }
  static copy(t, e) {
    Jn(t.min, e.min), Jn(t.max, e.max);
    for (let r = 0; r < e.vertex.length; r++) Jn(t.vertex[r], e.vertex[r]);
    return t;
  }
  combine(t) {
    return t ? (Array.isArray(t) && (Jn(lg.min, t[0]), Jn(lg.max, t[1]), t = lg), t.min[0] < this.min[0] && (this.min[0] = t.min[0], this._dirty = !0), t.min[1] < this.min[1] && (this.min[1] = t.min[1], this._dirty = !0), t.min[2] < this.min[2] && (this.min[2] = t.min[2], this._dirty = !0), t.max[0] > this.max[0] && (this.max[0] = t.max[0], this._dirty = !0), t.max[1] > this.max[1] && (this.max[1] = t.max[1], this._dirty = !0), t.max[2] > this.max[2] && (this.max[2] = t.max[2], this._dirty = !0), this) : this;
  }
  dirty() {
    return this._dirty = !0, this;
  }
  getCenter() {
    return this.center || (this.center = [], this._dirty = !0), this._dirty && (qr(this.center, this.min, this.max), go(this.center, this.center, 0.5)), this._dirty = !1, this.center;
  }
  containPoint(t) {
    const e = this.min, r = this.max;
    return e[0] <= t[0] && e[1] <= t[1] && e[2] <= t[2] && r[0] >= t[0] && r[1] >= t[1] && r[2] >= t[2];
  }
  isFinite() {
    const t = this.min, e = this.max;
    return isFinite(t[0]) && isFinite(t[1]) && isFinite(t[2]) && isFinite(e[0]) && isFinite(e[1]) && isFinite(e[2]);
  }
  updateVertex() {
    if (!this.vertex) {
      this.vertex = [];
      for (let t = 0; t < 8; t++) this.vertex.push([]);
    }
    return this.vertex[0][0] = this.min[0], this.vertex[0][1] = this.min[1], this.vertex[0][2] = this.min[2], this.vertex[1][0] = this.min[0], this.vertex[1][1] = this.min[1], this.vertex[1][2] = this.max[2], this.vertex[2][0] = this.min[0], this.vertex[2][1] = this.max[1], this.vertex[2][2] = this.max[2], this.vertex[3][0] = this.min[0], this.vertex[3][1] = this.max[1], this.vertex[3][2] = this.min[2], this.vertex[4][0] = this.max[0], this.vertex[4][1] = this.min[1], this.vertex[4][2] = this.min[2], this.vertex[5][0] = this.max[0], this.vertex[5][1] = this.min[1], this.vertex[5][2] = this.max[2], this.vertex[6][0] = this.max[0], this.vertex[6][1] = this.max[1], this.vertex[6][2] = this.max[2], this.vertex[7][0] = this.max[0], this.vertex[7][1] = this.max[1], this.vertex[7][2] = this.min[2], this.vertex;
  }
  copy(t) {
    return t ? h0.copy(t, this) : new h0(this.min.slice(), this.max.slice());
  }
  equals(t) {
    if (!dl(this.min, t.min) || !dl(this.max, t.max)) return !1;
    const e = t.vertex;
    for (let r = 0; r < this.vertex.length; r++) if (!dl(e[r], this.vertex[r])) return !1;
    return !0;
  }
  transform(t, e) {
    if (t = t || X_, (e = e || X_)[1] || e[2] || e[4] || e[6] || e[8] || e[9]) {
      const r = this.vertex, n = Jt(Z_, e, t);
      for (let p = 0; p < r.length; p++) fl(this.vertex[p], this.vertex[p], n);
      const s = this.vertex.map((p) => p[0]), o = this.vertex.map((p) => p[1]), a = this.vertex.map((p) => p[2]), l = Math.min(...s), h = Math.max(...s), u = Math.min(...o), c = Math.max(...o), f = Math.min(...a), d = Math.max(...a);
      ne(this.min, l, u, f), ne(this.max, h, c, d);
    } else {
      const r = Jt(Z_, e, t);
      fl(this.min, this.min, r), fl(this.max, this.max, r);
    }
    return this;
  }
};
const mI = [], vI = {
  5120: "int8",
  5122: "int16",
  5124: "int32",
  5121: "uint8",
  5123: "uint16",
  5125: "uint32",
  5126: "float"
}, yI = {
  5120: 1,
  5122: 2,
  5124: 4,
  5121: 1,
  5123: 2,
  5125: 4,
  5126: 4
}, _I = {
  positionSize: 3,
  primitive: "triangles",
  positionAttribute: "aPosition",
  normalAttribute: "aNormal",
  uv0Attribute: "aTexCoord",
  uv1Attribute: "aTexCoord1",
  color0Attribute: "aColor0",
  tangentAttribute: "aTangent",
  pickingIdAttribute: "aPickingId",
  textureCoordMatrixAttribute: "aTextureCoordMatrix"
};
let xI = 1;
const fs = "_reshader_refCount";
let er = class {
  constructor(t, e, r, n) {
    this._version = 0, this.data = t, this.elements = e, this.desc = $n({}, _I, n);
    const s = this._getPosAttritute();
    this.data[this.desc.positionAttribute] = s, r || (this.elements ? r = q_(this.elements) : s && s.length ? r = s.length / this.desc.positionSize : s && s.interleavedArray ? r = s.interleavedArray.length / this.desc.positionSize : s && s.array && (r = s.array.length / this.desc.positionSize)), this.count = r, this.elements || (this.elements = r), this.properties = {}, this._buffers = {}, this._vao = {}, this.getVertexCount(), this._prepareData(!0), this.updateBoundingBox();
  }
  set version(t) {
    throw new Error("Geometry.version is read only.");
  }
  get version() {
    return this._version;
  }
  _getPosAttritute() {
    return this.data[this.desc.positionAttribute];
  }
  _prepareData(t) {
    if (!this.data) return;
    const e = this._buffers || {};
    for (const n in this.data) {
      const s = this.data[n];
      if (s) {
        if (s.buffer && s.buffer.destroy) {
          const o = s.buffer;
          o[fs] || (o[fs] = 0), t && o[fs]++;
        } else if (s && s.array) if (sy(s)) {
          let o = s.array.buffer.__id;
          o || (o = s.array.buffer.__id = xI++), this.data[n] = {
            buffer: o,
            offset: s.byteOffset,
            stride: s.byteStride,
            type: vI[s.componentType],
            size: s.itemSize,
            count: s.count,
            componentType: s.componentType
          }, e[o] || (e[o] = {
            data: s.array.buffer
          });
        } else this.data[n] = s.array;
      }
    }
    this._buffers = e;
    const r = this.elements;
    r && r.array && (this.elements = this.elements.array);
  }
  getAttrData(t) {
    const e = t.key, r = !this._reglData || !this._reglData[e];
    if (this._reglData || (this._reglData = {}), r) {
      const n = this._reglData[e] = {}, s = this.data, { positionAttribute: o, normalAttribute: a, uv0Attribute: l, uv1Attribute: h, tangentAttribute: u, color0Attribute: c, pickingIdAttribute: f, textureCoordMatrixAttribute: d } = this.desc;
      $n(n, this.data), n.aPosition = s[o], s[a] && (n.aNormal = s[a]), s[l] && (n.aTexCoord = s[l]), s[h] && (n.aTexCoord1 = s[h]), s[u] && (n.aTangent = s[u]), s[c] && (n.aColor0 = s[c]), s[f] && (n.aPickingId = s[f]), s[d] && (n.aTextureCoordMatrix = s[d]);
    }
    return this._reglData[e];
  }
  getREGLData(t, e, r) {
    this.getAttrData(e);
    const n = !this._reglData || !this._reglData[e.key];
    if (Cl(t) && !r) {
      const s = e && e.key || "default";
      if (!this._vao[s] || n || this._vao[s].dirty) {
        const o = this._reglData[e.key], a = this._vertexCount, l = [];
        for (let u = 0; u < e.length; u++) {
          const c = e[u].name, f = o[c] && o[c].buffer;
          if (f && f.destroy) l.push(o[c].stride !== void 0 ? o[c] : f);
          else {
            const d = o[c];
            if (!d) {
              l.push(this.desc.fillEmptyDataInMissingAttribute ? new Uint8Array(4 * a) : mI);
              continue;
            }
            const p = (d.data && zr(d.data) ? d.data.length : d.length) / a;
            d.data ? (d.dimension = p, l.push(d)) : l.push({
              data: d,
              dimension: p
            });
          }
        }
        const h = {
          attributes: l,
          primitive: this.getPrimitive()
        };
        if (this.elements && !Ds(this.elements)) if (this.elements.destroy) h.elements = this.elements;
        else {
          h.elements = {
            primitive: this.getPrimitive(),
            data: this.elements
          };
          const u = this.getElementsType(this.elements);
          u && (h.elements.type = u);
        }
        this._vao[s] ? this._vao[s].vao(h) : this._vao[s] = {
          vao: t.vao(h)
        };
      }
      return delete this._vao[s].dirty, this._vao[s];
    }
    return this._reglData[e.key];
  }
  _isAttrChanged(t) {
    if (t === this._activeAttributes) return !1;
    if (t.length !== this._activeAttributes.length) return !0;
    for (let e = 0; e < t.length; e++) if (t[e] !== this._activeAttributes[e]) return !0;
    return !1;
  }
  generateBuffers(t) {
    const e = this._buffers;
    for (const l in e) e[l].buffer || (e[l].buffer = t.buffer(e[l].data)), delete e[l].data;
    const r = this.desc.positionAttribute, n = this.desc.altitudeAttribute, s = this.data, o = this._vertexCount, a = {};
    for (const l in s) if (s[l]) {
      if (s[l].buffer === void 0 || s[l].buffer instanceof ArrayBuffer) {
        const h = s[l].data ? s[l] : {
          data: s[l]
        };
        h.dimension = (s[l].data ? s[l].data : s[l]).length / o;
        const u = t.buffer(h);
        u[fs] = 1, a[l] = {
          buffer: u
        }, l !== r && l !== n || (a[l].array = s[l]);
      } else s[l].buffer.destroy ? a[l] = s[l] : e[s[l].buffer] && (a[l] = $n({}, s[l]), a[l].buffer = e[s[l].buffer].buffer);
      (this.desc.static || l !== r) && delete s[l].array;
    }
    if (this.data = a, delete this._reglData, this.elements && !Ds(this.elements)) {
      const l = {
        primitive: this.getPrimitive(),
        data: this.elements
      }, h = this.getElementsType(this.elements);
      if (h && (l.type = h), !this.desc.static && !this.elements.destroy) {
        this.indices = new Uint16Array(this.elements.length);
        for (let c = 0; c < this.elements.length; c++) this.indices[c] = this.elements[c];
      }
      this.elements = this.elements.destroy ? this.elements : t.elements(l);
      const u = this.elements;
      u[fs] || (u[fs] = 0), u[fs]++;
    }
  }
  getVertexCount() {
    const { positionAttribute: t, positionSize: e, color0Attribute: r } = this.desc;
    let n = this.data[t];
    n.data && (n = n.data), n.array && (n = n.array), zr(n) ? this._vertexCount = Math.ceil(n.length / e) : n && n.count !== void 0 && (this._vertexCount = n.count);
    const s = r;
    if (this.data[s]) {
      const o = this.data[s].data || this.data[s].array || this.data[s];
      Array.isArray(o) ? this._color0Size = o.length / this._vertexCount : o && o.count ? this._color0Size = o.count / this._vertexCount : this.data[s].buffer && this.data[s].buffer.destroy && (this._color0Size = this.data[s].buffer._buffer.dimension);
    }
    return this._vertexCount;
  }
  getColor0Size() {
    return this._color0Size || 0;
  }
  addBuffer(t, e) {
    return this._buffers[t] = {
      data: e
    }, delete this._reglData, this._deleteVAO(), this;
  }
  updateBuffer(t, e) {
    if (!this._buffers[t]) throw new Error(`invalid buffer ${t} in geometry`);
    return this._buffers[t].buffer ? this._buffers[t].buffer.subdata(e) : this._buffers[t].data = e, delete this._reglData, this._deleteVAO(), this;
  }
  deleteData(t) {
    const e = this.data[t];
    return e ? (this._incrVersion(), e.buffer && e.buffer.destroy && e.buffer.destroy(), delete this.data[t], delete this._reglData, this._markVAODirty(), this) : this;
  }
  updateData(t, e) {
    const r = this.data[t];
    if (!r) return this;
    let n;
    return this._incrVersion(), this.data[t] = e, r.buffer && r.buffer.destroy && (n = r), t === this.desc.positionAttribute && this.updateBoundingBox(), this.getVertexCount(), n && (n.buffer(e), this.data[t] = n), this._prepareData(!1), this.desc.positionAttribute === t && (this._posDirty = !0), delete this._reglData, this;
  }
  updateSubData(t, e, r) {
    const n = this.data[t];
    if (!n) return this;
    let s;
    if (this._incrVersion(), n.buffer && n.buffer.destroy && (s = n), t === this.desc.positionAttribute && this._updateSubBoundingBox(e), s) {
      const o = yI[s.buffer._buffer.dtype];
      e.BYTES_PER_ELEMENT !== o && (e = new (function(a, l) {
        return a instanceof Uint8Array || a instanceof Uint16Array || a instanceof Uint32Array || a instanceof Uint8ClampedArray ? l === 1 ? Uint8Array : l === 2 ? Uint16Array : Uint32Array : a instanceof Int8Array || a instanceof Int16Array || a instanceof Int32Array ? l === 1 ? Int8Array : l === 2 ? Int16Array : Int32Array : a instanceof Float32Array || a instanceof Float64Array ? l === 4 ? Float32Array : Float64Array : null;
      }(e, o))(e)), s.buffer.subdata(e, r * o);
    } else {
      const o = this.data[t].data ? this.data[t].data : this.data[t];
      for (let a = 0; a < e.length; a++) o[r + a] = e[a];
    }
    return this._prepareData(!1), this.desc.positionAttribute === t && (this._posDirty = !0), delete this._reglData, this;
  }
  getPrimitive() {
    return this.desc.primitive;
  }
  getElements() {
    return this.elements;
  }
  setElements(t, e) {
    if (!t) throw new Error("elements data is invalid");
    this._incrVersion();
    const r = this.elements;
    return this.count = e === void 0 ? q_(t) : e, this.elements = t && t.destroy ? t : r.destroy ? r(t) : t, this._markVAODirty(!0), this;
  }
  deleteElements() {
    return this.elements && this.elements.length !== 0 ? (this._incrVersion(), this.elements && this.elements.destroy && !this.elements[pr] && (this.elements.destroy(), this.elements[pr] = 1), this.elements = [], this._markVAODirty(!0), this) : this;
  }
  _markVAODirty(t) {
    if (this._vao) {
      for (const e in this._vao) t ? this._vao[e].vao.destroy() : this._vao[e].dirty = !0;
      t && (this._vao = {});
    }
  }
  setDrawCount(t) {
    return this._incrVersion(), this.count1 = t, this;
  }
  getDrawCount() {
    return this.count1 >= 0 ? this.count1 : this.count;
  }
  setDrawOffset(t) {
    return this._incrVersion(), this.offset = t, this;
  }
  getDrawOffset() {
    return this.offset || 0;
  }
  dispose() {
    if (this._deleteVAO(), this._forEachBuffer((t) => {
      if (!t[pr]) {
        let e = t[fs];
        e && e--, e <= 0 ? (t[pr] = !0, t.destroy()) : t[fs] = e;
      }
    }), this.properties) {
      const t = this.properties.oldElementsBeforeHighlight;
      t && !t[pr] && t.destroy && (t.destroy(), t[pr] = !0), delete this.properties.oldElementsBeforeHighlight, delete this.properties.hasInvisible;
    }
    this.data = {}, this._buffers = {}, delete this._reglData, delete this._attributes, this.count = 0, this.elements = [], delete this._tempPosArray, this._disposed = !0;
  }
  isDisposed() {
    return !!this._disposed;
  }
  updateBoundingBox() {
    let t = this.boundingBox;
    t || (t = this.boundingBox = new Mh());
    let e, r, n = this.data[this.desc.positionAttribute];
    if (zr(n) || (n.data ? n = n.data : id(n) ? n = this._getAttributeData(this.desc.positionAttribute) : n.array && (e = n.min, r = n.max, n = n.array)), n && n.length) {
      const s = t.min, o = t.max;
      if (e && r) ne(s, ...e), ne(o, ...r);
      else {
        ne(s, n[0], n[1], n[2]), ne(o, n[0], n[1], n[2]);
        for (let a = 3; a < n.length; ) {
          const l = n[a++], h = n[a++], u = n[a++];
          l < s[0] && (s[0] = l), h < s[1] && (s[1] = h), u < s[2] && (s[2] = u), l > o[0] && (o[0] = l), h > o[1] && (o[1] = h), u > o[2] && (o[2] = u);
        }
      }
      t.updateVertex(), t.dirty();
    }
  }
  _updateSubBoundingBox(t) {
    const e = this.boundingBox, r = e.min, n = e.max, s = this.desc.positionSize;
    for (let o = 0; o < t.length; ) {
      const a = t[o++], l = t[o++];
      let h = 0;
      s === 3 && (h = t[o++]), a < r[0] && (r[0] = a), l < r[1] && (r[1] = l), h < r[2] && (r[2] = h), a > n[0] && (n[0] = a), l > n[1] && (n[1] = l), h > n[2] && (n[2] = h);
    }
    e.updateVertex(), e.dirty();
  }
  _getAttributeData(t) {
    const e = this.data[t] && this.data[t].array ? this.data[t].array : this.data[t], r = e.buffer;
    if (id(e)) {
      const n = this._buffers[r] ? this._buffers[r].data : e.array, { count: s, size: o, stride: a, offset: l, componentType: h } = e, u = bs.getTypedArrayCtor(h);
      if ((a === 0 || a === o * u.BYTES_PER_ELEMENT) && l % u.BYTES_PER_ELEMENT == 0) return new u(n, l, s * o);
      if (t === this.desc.positionAttribute) return !this._tempPosArray || this._tempPosArray && this._tempPosArray.length < o * s ? (this._tempPosArray = new u(o * s), bs.readInterleavedArray(this._tempPosArray, n, s, o, a, l, h)) : this._posDirty ? (this._posDirty = !1, bs.readInterleavedArray(this._tempPosArray, n, s, o, a, l, h)) : this._tempPosArray;
      {
        const c = new u(o * s);
        return bs.readInterleavedArray(c, n, s, o, a, l, h);
      }
    }
    return e;
  }
  createTangent(t = "aTangent") {
    this._incrVersion();
    const { normalAttribute: e, positionAttribute: r, uv0Attribute: n } = this.desc, s = this._getAttributeData(e), o = this._getAttributeData(r), a = lM(o, s, this.data[n], this.elements), l = this.data[t] = new Float32Array(a.length), h = [], u = [], c = [];
    for (let f = 0; f < a.length; f += 4) {
      const d = f / 4 * 3;
      ne(u, s[d], s[d + 1], s[d + 2]), Sr(h, a[f], a[f + 1], a[f + 2], a[f + 3]), oM(c, u, h), nd(l.subarray(f, f + 4), c);
    }
    delete this._reglData;
  }
  createNormal(t = "aNormal") {
    this._incrVersion();
    const e = this._getAttributeData(this.desc.positionAttribute);
    this.data[t] = aM(e.array || e, this.elements), delete this._reglData;
  }
  createBarycentric(t = "aBarycentric") {
    if (this.desc.primitive !== "triangles") throw new Error("Primitive must be triangles to create bary centric data");
    this._incrVersion();
    const e = new Uint8Array(3 * this._vertexCount);
    for (let r = 0, n = this.elements.length; r < n; ) for (let s = 0; s < 3; s++)
      e[3 * this.elements[r++] + s] = 1;
    this.data[t] = e, delete this._reglData;
  }
  buildUniqueVertex() {
    this._incrVersion();
    const t = this.data, e = this.elements;
    if (!zr(e)) throw new Error("elements must be array to build unique vertex.");
    const r = Object.keys(t), n = {};
    let s = t[this.desc.positionAttribute];
    if (s = s.length ? s : s.array, !zr(s)) throw new Error(this.desc.positionAttribute + " must be array to build unique vertex.");
    const o = this._vertexCount, a = e.length;
    for (let h = 0; h < r.length; h++) {
      const u = r[h], c = zr(t[u]) ? t[u] : t[u].array, f = c.length / o;
      if (!zr(c)) throw new Error(u + " must be array to build unique vertex.");
      n[u] = c, t[u] = new c.constructor(a * f);
    }
    let l = 0;
    for (let h = 0; h < a; h++) {
      const u = e[h];
      for (let c = 0; c < r.length; c++) {
        const f = r[c], d = t[f], p = n[f].length / o;
        for (let g = 0; g < p; g++) d[l * p + g] = n[f][u * p + g];
      }
      e[h] = l++;
    }
    s = this.data[this.desc.positionAttribute], this._vertexCount = Math.ceil(s.length / this.desc.positionSize), delete this._reglData;
  }
  getMemorySize() {
    let t = 0;
    for (const e in this.data) Vi(this.data, e) && (t += ny(this.data[e]));
    if (this.elements) {
      const e = this.elements;
      e.destroy ? t += e._elements.buffer.byteLength : e.BYTES_PER_ELEMENT ? t += e.length * e.BYTES_PER_ELEMENT : e.length && (t += 4 * e.length);
    }
    return t;
  }
  _deleteVAO() {
    for (const t in this._vao) this._vao[t].vao.destroy();
    this._vao = {};
  }
  _forEachBuffer(t) {
    this.elements && this.elements.destroy && t(this.elements);
    for (const e in this.data) Vi(this.data, e) && this.data[e] && this.data[e].buffer && this.data[e].buffer.destroy && t(this.data[e].buffer);
    for (const e in this._buffers) Vi(this._buffers, e) && this._buffers[e] && this._buffers[e].buffer && this._buffers[e].buffer.destroy && t(this._buffers[e].buffer);
  }
  getElementsType(t) {
    return t instanceof Uint8Array ? "uint8" : t instanceof Uint16Array ? "uint16" : t instanceof Uint32Array ? "uint32" : void 0;
  }
  _incrVersion() {
    this._version++;
  }
};
function q_(i) {
  if (Ds(i)) return i;
  if (i.count !== void 0) return i.count;
  if (i.destroy) return i._elements.vertCount;
  if (i.length !== void 0) return i.length;
  if (i.data) return i.data.length;
  throw new Error("invalid elements length");
}
const bI = ["points", "lines", "line strip", "line loop", "triangles", "triangle strip", "triangle fan"];
function mM(i) {
  return bI[i];
}
const wI = {
  9729: "linear",
  9728: "nearest"
};
function TI(i) {
  return wI[i];
}
const AI = {
  9729: "linear",
  9728: "nearest",
  9984: "nearest mipmap nearest",
  9985: "linear mipmap nearest",
  9986: "nearest mipmap linear",
  9987: "linear mipmap linear"
};
function MI(i) {
  return AI[i];
}
const SI = {
  10497: "repeat",
  33071: "clamp",
  33648: "mirror"
};
function Y_(i) {
  return SI[i];
}
const vc = "__reshader_webgl_buffer", yc = "__reshader_webgl_tex";
function CI(i, t, e) {
  let r;
  if (zr(t) ? t.buffer && t.byteOffset !== void 0 && (r = t) : t.array && t.array.buffer && t.array.byteOffset !== void 0 && (r = t.array), !r) return null;
  const n = r.buffer, s = r.byteOffset;
  n[vc] || (n[vc] = {});
  let o = n[vc][s];
  if (!o) {
    const a = {};
    e && $n(a, e), a.data = r, o = i.buffer(a), n[vc][s] = o;
  }
  return o;
}
function PI(i, t) {
  const e = t.data;
  if (!e || !e.buffer) return i.texture(t);
  const r = e.buffer, n = e.byteOffset;
  r[yc] || (r[yc] = {});
  let s = r[yc][n];
  return s || (s = i.texture(t), r[yc][n] = s), s;
}
const EI = [], OI = [], va = [], kI = [], RI = [], II = [], J_ = ["a", "b", "c"];
let DI = class extends er {
  constructor(t, e, r, n) {
    super(t, e, r, {
      primitive: mM(1),
      positionAttribute: n.positionAttribute
    });
  }
  _getPosAttritute() {
    const t = this.data[this.desc.positionAttribute];
    if (!t) return null;
    const e = Math.pow(10, 4), r = Math.cos(Math.PI / 180 * 0.8), n = this.elements, s = t.length ? t : t.array, o = n.length ? n ? n.length : s.length / 3 : n, a = [0, 0, 0], l = new Array(3), h = {}, u = [], c = new FI();
    for (let f = 0; f < o; f += 3) {
      n.length ? (a[0] = n[f], a[1] = n[f + 1], a[2] = n[f + 2]) : (a[0] = f, a[1] = f + 1, a[2] = f + 2), c.a = this._getPos(kI, s, a[0]), c.b = this._getPos(RI, s, a[1]), c.c = this._getPos(II, s, a[2]);
      const d = c.getNormal(), p = c.a, g = c.b, m = c.c;
      if (l[0] = `${Math.round(p[0] * e)},${Math.round(p[1] * e)},${Math.round(p[2] * e)}`, l[1] = `${Math.round(g[0] * e)},${Math.round(g[1] * e)},${Math.round(g[2] * e)}`, l[2] = `${Math.round(m[0] * e)},${Math.round(m[1] * e)},${Math.round(m[2] * e)}`, l[0] !== l[1] && l[1] !== l[2] && l[2] !== l[0]) for (let v = 0; v < 3; v++) this._calEdgeData(v, a, c, h, l, r, d, u);
    }
    for (const f in h) if (h[f]) {
      const { index0: d, index1: p } = h[f];
      u.push(s[3 * d], s[3 * d + 1], s[3 * d + 2]), u.push(s[3 * p], s[3 * p + 1], s[3 * p + 2]);
    }
    return this.elements = this._createElements(u), u;
  }
  _getPos(t, e, r) {
    return ne(t, e[3 * r], e[3 * r + 1], e[3 * r + 2]);
  }
  _calEdgeData(t, e, r, n, s, o, a, l) {
    const h = (t + 1) % 3, u = s[t], c = s[h], f = r[J_[t]], d = r[J_[h]], p = `${u}_${c}`, g = `${c}_${u}`;
    g in n && n[g] ? (lu(a, n[g].normal) <= o && (l.push(f[0], f[1], f[2]), l.push(d[0], d[1], d[2])), n[g] = null) : p in n || (n[p] = {
      index0: e[t],
      index1: e[h],
      normal: Jn([], a)
    });
  }
  _createElements(t) {
    const e = [], r = t.length / 3;
    for (let n = 0; n < r; n++) e.push(n);
    return e;
  }
}, FI = class {
  constructor(t = [0, 0, 0], e = [0, 0, 0], r = [0, 0, 0]) {
    this.a = t, this.b = e, this.c = r;
  }
  getNormal() {
    const t = Ti(EI, this.a, this.b), e = Ti(OI, this.a, this.c);
    hi(va, t, e);
    const r = qa(va);
    return ne(va, va[0] / r, va[1] / r, va[2] / r);
  }
};
var Nr = oy(class {
  constructor(i = {}, t) {
    this._version = 0, this.uniforms = uM({}, t || {}, i);
    for (const e in i) {
      const r = Object.getOwnPropertyDescriptor(i, e).get;
      r && Object.defineProperty(this.uniforms, e, {
        get: r
      });
    }
    this._reglUniforms = {}, this.refCount = 0, this._bindedOnTextureComplete = this._onTextureComplete.bind(this), this._genUniformKeys(), this._checkTextures();
  }
  set version(i) {
    throw new Error("Material.version is read only.");
  }
  get version() {
    return this._version;
  }
  set doubleSided(i) {
    this._doubleSided = i;
  }
  get doubleSided() {
    return this._doubleSided;
  }
  isReady() {
    return this._loadingCount <= 0;
  }
  set(i, t) {
    const e = ri(this.uniforms[i]) && !ri(t) || !ri(this.uniforms[i]) && ri(t);
    if (this.uniforms[i] && this.isTexture(i) && this.uniforms[i].dispose(), ri(t)) ri(this.uniforms[i]) || delete this.uniforms[i];
    else if (this.uniforms[i] = t, this._reglUniforms) {
      const r = Object.getOwnPropertyDescriptor(this._reglUniforms, i);
      r && !r.get && (this._dirtyProps = this._dirtyProps || [], this._dirtyProps.push(i), this._reglUniforms[i] = t);
    }
    return this.isTexture(i) && this._checkTextures(), e && (this._genUniformKeys(), this._incrVersion()), this;
  }
  _getDirtyProps() {
    return this._dirtyProps;
  }
  _clearDirtyProps() {
    this._dirtyProps = null;
  }
  get(i) {
    return this.uniforms[i];
  }
  isDirty() {
    return this._uniformVer !== this.version;
  }
  appendDefines(i) {
    const t = this.uniforms;
    return t && (t.jointTexture && (i.HAS_SKIN = 1), t.morphWeights1 && (i.HAS_MORPH = 1), (t.khr_offset || t.khr_rotation || t.khr_scale) && (i.HAS_KHR_TEXTURE_TRANSFORM = 1)), i;
  }
  hasSkinAnimation() {
    return this.uniforms && this.uniforms.jointTexture && this.uniforms.skinAnimation;
  }
  getUniforms(i) {
    if (this._reglUniforms && !this.isDirty()) return this._reglUniforms;
    const t = this.uniforms, e = {};
    for (const r in t) this.isTexture(r) ? Object.defineProperty(e, r, {
      enumerable: !0,
      configurable: !0,
      get: function() {
        return t[r].getREGLTexture(i);
      }
    }) : Object.getOwnPropertyDescriptor(t, r).get ? Object.defineProperty(e, r, {
      enumerable: !0,
      configurable: !0,
      get: function() {
        return t[r];
      }
    }) : e[r] = t[r];
    return this._reglUniforms = e, this._uniformVer = this.version, e;
  }
  isTexture(i) {
    return this.uniforms[i] instanceof gM;
  }
  dispose() {
    for (const i in this.uniforms) {
      const t = this.uniforms[i];
      t && (t.dispose ? t.dispose() : t.destroy && !t[pr] && (t.destroy(), t[pr] = !0));
    }
    delete this.uniforms, delete this._reglUniforms, this._disposed = !0;
  }
  isDisposed() {
    return !!this._disposed;
  }
  _checkTextures() {
    this._loadingCount = 0;
    for (const i in this.uniforms) if (this.isTexture(i)) {
      const t = this.uniforms[i];
      t.isReady() || (this._loadingCount++, t.on("complete", this._bindedOnTextureComplete));
    }
  }
  _onTextureComplete() {
    this._loadingCount--, this._incrVersion(), this._loadingCount <= 0 && (this._disposed || this.fire("complete"));
  }
  getUniformKeys() {
    return this._uniformKeys;
  }
  _genUniformKeys() {
    const i = [];
    for (const t in this.uniforms) Vi(this.uniforms, t) && !ri(this.uniforms[t]) && i.push(t);
    this._uniformKeys = i.join();
  }
  _incrVersion() {
    this._version++;
  }
  getMemorySize() {
    const i = this.uniforms;
    let t = 0;
    for (const e in i) this.isTexture(e) ? t += i[e].getMemorySize() : this.uniforms[e].destroy && (t += dM(this.uniforms[e]));
    return t;
  }
});
const K_ = {
  baseColorFactor: [1, 1, 1, 1],
  materialShininess: 32,
  environmentExposure: 1,
  specularStrength: 32,
  opacity: 1,
  extrusionOpacity: 0,
  extrusionOpacityRange: [0, 1.8],
  baseColorTexture: null,
  normalTexture: null,
  emissiveTexture: null,
  occlusionTexture: null,
  uvScale: [1, 1],
  uvOffset: [0, 0],
  alphaTest: 0
};
let ay = class vM extends Nr {
  constructor(t) {
    super(t, K_);
  }
  static convertFrom(t) {
    const e = {};
    for (const r in K_) e[r] = t.get(r);
    return new vM(e);
  }
  appendDefines(t, e) {
    super.appendDefines(t, e);
    const r = this.uniforms;
    return r.extrusionOpacity && (t.HAS_EXTRUSION_OPACITY = 1), e.data[e.desc.colorAttribute] && (t.HAS_COLOR = 1), e.data[e.desc.color0Attribute] && (t.HAS_COLOR0 = 1, t.COLOR0_SIZE = e.getColor0Size()), e.data[e.desc.tangentAttribute] ? t.HAS_TANGENT = 1 : e.data[e.desc.normalAttribute] && (t.HAS_NORMAL = 1), e.data[e.desc.uv0Attribute] && (r.baseColorTexture && (t.HAS_BASECOLOR_MAP = 1), r.occlusionTexture && e.data[e.desc.uv1Attribute] && (t.HAS_AO_MAP = 1), r.emissiveTexture && (t.HAS_EMISSIVE_MAP = 1), r.normalTexture && (t.HAS_NORMAL_MAP = 1), (t.HAS_BASECOLOR_MAP || t.HAS_AO_MAP || t.HAS_EMISSIVE_MAP || t.HAS_NORMAL_MAP) && (t.HAS_MAP = 1)), t;
  }
};
const LI = {
  diffuseFactor: [1, 1, 1, 1],
  specularFactor: [1, 1, 1],
  glossinessFactor: 1,
  diffuseTexture: null,
  specularGlossinessTexture: null,
  normalTexture: null,
  emissiveTexture: null,
  occlusionTexture: null
}, yM = (i) => class extends i {
  constructor(t) {
    super(t = $n({}, LI, t || {}));
  }
  appendDefines(t, e) {
    if (super.appendDefines(t, e), t.SHADING_MODEL_SPECULAR_GLOSSINESS = 1, !e.data[e.desc.uv0Attribute]) return t;
    const r = this.uniforms;
    return r.diffuseTexture && (t.HAS_DIFFUSE_MAP = 1), r.specularGlossinessTexture && (t.HAS_SPECULARGLOSSINESS_MAP = 1), (t.HAS_SPECULARGLOSSINESS_MAP || t.HAS_DIFFUSE_MAP) && (t.HAS_MAP = 1), t;
  }
};
let zI = class extends yM(ay) {
};
const Q_ = [];
let hg = 0, tn = class {
  constructor(t, e, r = {}) {
    this._version = 0, this._geometry = t, this._material = e, this.transparent = !!r.transparent, this.bloom = !!r.bloom, this.ssr = !!r.ssr, this.castShadow = ri(r.castShadow) || r.castShadow, this.picking = !!r.picking, this.disableVAO = !!r.disableVAO, this.uniforms = {}, this._localTransform = pn(new Array(16)), this._positionMatrix = pn(new Array(16)), this.properties = {}, this._dirtyUniforms = !0, this._dirtyGeometry = !0, Object.defineProperty(this, "uuid", {
      value: hg++
    }), hg > Number.MAX_VALUE - 10 && (hg = 0);
  }
  set material(t) {
    this._material !== t && this.setMaterial(t);
  }
  get material() {
    return this._material;
  }
  set version(t) {
    throw new Error("Mesh.version is read only.");
  }
  get version() {
    return this._version;
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(t) {
    this._geometry !== t && (this._incrVersion(), this._dirtyGeometry = !0), this._geometry = t;
  }
  set localTransform(t) {
    this._prevTMat || (this._prevTMat = []), Array.isArray(t) && !yf(this._prevTMat, t) && (this._incrVersion(), this._prevTMat = Hi(this._prevTMat, t)), this._localTransform = t;
  }
  get localTransform() {
    return this._localTransform;
  }
  set positionMatrix(t) {
    this._prevPMat || (this._prevPMat = []), Array.isArray(t) && !yf(this._prevPMat, t) && (this._incrVersion(), this._prevPMat = Hi(this._prevPMat, t)), this._positionMatrix = t;
  }
  get positionMatrix() {
    return this._positionMatrix;
  }
  get config() {
    return this._cfg || (this._cfg = {}), this._cfg.transparent = this.transparent, this._cfg.castShadow = this.castShadow, this._cfg.bloom = this.bloom, this._cfg.ssr = this.ssr, this._cfg.picking = this.picking, this._cfg;
  }
  get defines() {
    return this._getDefines();
  }
  set defines(t) {
    this.setDefines(t);
  }
  setMaterial(t) {
    return this._material = t, this._dirtyUniforms = !0, delete this._materialVer, this.dirtyDefines = !0, this;
  }
  setParent(t) {
    return this.parent = t, this;
  }
  setLocalTransform(t) {
    return this.localTransform = t, this;
  }
  setPositionMatrix(t) {
    this.positionMatrix = t;
  }
  setUniform(t, e) {
    return this.uniforms[t] === void 0 ? this._dirtyUniforms = !0 : (this._dirtyProps = this._dirtyProps || [], this._dirtyProps.push(t)), this.uniforms[t] = e, this;
  }
  getUniform(t) {
    return this.uniforms[t];
  }
  getDefines() {
    const t = {};
    return $n(t, this._getDefines()), this._material && this._geometry && this._material.appendDefines(t, this._geometry), t;
  }
  _getDefines() {
    this._defines || (this._defines = {});
    const t = this._geometry, e = t.data[t.desc.positionAttribute], r = t.data[t.desc.uv0Attribute], n = t.data[t.desc.normalAttribute];
    return e && e.quantization && (this._defines.HAS_DRACO_POSITION = 1), r && r.quantization && (this._defines.HAS_DRACO_TEXCOORD = 1), n && n.quantization && (this._defines.HAS_DRACO_NORMAL = 1), this._defines;
  }
  setDefines(t) {
    const e = this._bakDefines;
    return this._defines = t, this.dirtyDefines = this.dirtyDefines || !!e != !!t || !function(r, n) {
      if (!r && !n) return !0;
      const s = Object.getOwnPropertyNames(r), o = Object.getOwnPropertyNames(n);
      if (s.length !== o.length) return !1;
      for (let a = 0; a < s.length; a++) if (r[s[a]] !== n[s[a]]) return !1;
      return !0;
    }(e, t), this.dirtyDefines && (this._bakDefines = $n({}, t)), this;
  }
  hasSkinAnimation() {
    return this._material && this._material.hasSkinAnimation();
  }
  _getDefinesKey() {
    return this.dirtyDefines = !1, this._createDefinesKey(this.getDefines());
  }
  getCommandKey() {
    if (!this._commandKey || this.dirtyDefines || this._material && this._materialKeys !== this._material.getUniformKeys()) {
      let t = this._getDefinesKey();
      t += "_" + (Ds(this.getElements()) ? "count" : "elements"), t += "_" + +!!this.disableVAO, this._material && (t += "_" + +!!this._material.doubleSided), this._commandKey = t, this._material && (this._materialKeys = this._material.getUniformKeys());
    }
    return this._commandKey;
  }
  getUniforms(t) {
    if (this._dirtyUniforms || this._dirtyGeometry || this._material && this._materialVer !== this._material.version) {
      this._realUniforms = {}, this._getUniformsForDraco();
      const e = this.uniforms;
      for (const r in this.uniforms) Vi(this.uniforms, r) && (Object.getOwnPropertyDescriptor(e, r).get ? Object.defineProperty(this._realUniforms, r, {
        enumerable: !0,
        configurable: !0,
        get: function() {
          return e[r];
        }
      }) : this._realUniforms[r] = e[r]);
      if (this._material) {
        const r = this._material.getUniforms(t);
        for (const n in r) Vi(r, n) && !Vi(this._realUniforms, n) && (Object.getOwnPropertyDescriptor(r, n).get ? Object.defineProperty(this._realUniforms, n, {
          enumerable: !0,
          configurable: !0,
          get: function() {
            return r[n];
          }
        }) : this._realUniforms[n] === void 0 && (this._realUniforms[n] = r[n]));
      }
      this._dirtyUniforms = !1, this._dirtyGeometry = !1, this._materialVer = this._material && this._material.version, this._material && this._material._clearDirtyProps(), this._dirtyProps = null;
    } else if (this._dirtyProps || this._material && this._material._getDirtyProps()) {
      if (this._dirtyProps) for (const r of this._dirtyProps) this._realUniforms[r] = this.uniforms[r];
      const e = this._material && this._material._getDirtyProps();
      if (e) {
        const r = this._material.getUniforms(t);
        for (const n of e) this._realUniforms[n] = r[n];
        this._material._clearDirtyProps();
      }
      this._dirtyProps = null;
    }
    return this._realUniforms.modelMatrix = Ei(this._localTransform) ? this._localTransform() : this._localTransform, this._realUniforms.positionMatrix = Ei(this._positionMatrix) ? this._positionMatrix() : this._positionMatrix, this._realUniforms;
  }
  _getUniformsForDraco() {
    const t = this._geometry, e = t.data[t.desc.positionAttribute], r = t.data[t.desc.uv0Attribute], n = t.data[t.desc.normalAttribute];
    if (e && e.quantization) {
      const s = e.quantization, o = s.range / (1 << s.quantizationBits);
      this._realUniforms.minValues_pos = s.minValues, this._realUniforms.gltf_u_dec_position_normConstant = o;
    }
    if (r && r.quantization) {
      const s = r.quantization;
      this._realUniforms.minValues_tex = s.minValues, this._realUniforms.gltf_u_dec_texcoord_0_normConstant = s.range / (1 << s.quantizationBits);
    }
    n && n.quantization && (this._realUniforms.gltf_u_dec_normal_rangeConstant = (1 << n.quantization.quantizationBits) - 1);
  }
  getMaterial() {
    return this._material;
  }
  getElements() {
    return this._geometry.getElements();
  }
  _getREGLAttrData(t, e) {
    return this._geometry.getREGLData(t, e, this.disableVAO);
  }
  getREGLProps(t, e) {
    const r = this.getUniforms(t);
    return $n(r, this._getREGLAttrData(t, e)), Cl(t) && !this.disableVAO || (r.elements = this._geometry.getElements()), r.meshProperties = this.properties, r.meshConfig = this.config, r.count = this._geometry.getDrawCount(), r.offset = this._geometry.getDrawOffset(), r.primitive = this._geometry.getPrimitive(), r;
  }
  dispose() {
    return delete this._geometry, delete this._material, this.uniforms = {}, this;
  }
  isValid() {
    return this._geometry && !this._geometry.isDisposed() && (!this._material || !this._material.isDisposed());
  }
  getBoundingBox() {
    return this._bbox || this.updateBoundingBox(), Jt(Q_, this._localTransform, this._positionMatrix), yf(Q_, this._currentTransform) && this._geometry.boundingBox.equals(this._geoBox) || this.updateBoundingBox(), this._bboxArr;
  }
  updateBoundingBox() {
    const t = this._geometry.boundingBox;
    this._bbox || (this._bbox = new Mh()), this._bboxArr || (this._bboxArr = [[], []]), this._geoBox || (this._geoBox = new Mh()), Mh.copy(this._bbox, t), this._bbox.updateVertex(), this.constructor.name === "InstancedMesh" ? (this._bbox.transform(this._localTransform, this._positionMatrix), this._currentTransform = Jt(this._currentTransform || [], this._positionMatrix, this._localTransform)) : (this._bbox.transform(this._positionMatrix, this._localTransform), this._currentTransform = Jt(this._currentTransform || [], this._localTransform, this._positionMatrix)), Mh.copy(this._geoBox, t), Jn(this._bboxArr[0], this._bbox.min), Jn(this._bboxArr[1], this._bbox.max);
  }
  _createDefinesKey(t) {
    const e = [];
    for (const r in t) e.push(r, t[r]);
    return e.join(",");
  }
  _incrVersion() {
    this._version++;
  }
  getMemorySize() {
    return (this.geometry && this.geometry.getMemorySize() || 0) + (this.material && this.material.getMemorySize() || 0);
  }
};
tn.prototype.getWorldTransform = /* @__PURE__ */ function() {
  const i = [];
  return function() {
    const t = this.parent;
    return t ? Jt(i, t.getWorldTransform(), this._localTransform) : this._localTransform;
  };
}();
let _M = class extends tn {
  constructor(t, e, r, n, s = {}) {
    super(r, n, s), this._instanceCount = e, this.instancedData = t || {}, this._checkInstancedProp(), this._vao = {};
  }
  get instanceCount() {
    return this._instanceCount;
  }
  set instanceCount(t) {
    this._incrVersion(), this._instanceCount = t;
  }
  getMemorySize() {
    return super.getMemorySize() + this._getInstanceMemorySize();
  }
  _getInstanceMemorySize() {
    let t = 0;
    for (const e in this.instancedData) Vi(this.instancedData, e) && (t += ny(this.instancedData[e]));
    return t;
  }
  _checkInstancedProp() {
    for (const t in this.instancedData) if (this.geometry.data[t]) throw new Error(`Duplicate attribute ${t} defined in geometry and instanced data`);
  }
  _getREGLAttrData(t, e) {
    const r = this.geometry.getAttrData(e);
    if (Cl(t)) {
      const n = e.key;
      if (!this._vao[n] || this._vao[n].dirty) {
        const s = e.map((l) => l.name), o = [];
        for (let l = 0; l < s.length; l++) {
          const h = r[s[l]];
          o.push(h && h.buffer || this.instancedData[s[l]]);
        }
        const a = {
          attributes: o,
          primitive: this.geometry.getPrimitive()
        };
        this._vao[n] ? this._vao[n].vao(a) : this._vao[n] = {
          vao: t.vao(a)
        }, delete this._vao[n].dirty;
      }
      return this._vao[n];
    }
    return r;
  }
  getDefines() {
    const t = super.getDefines();
    return t.HAS_INSTANCE = 1, t;
  }
  getCommandKey(t) {
    return "i_" + super.getCommandKey(t);
  }
  updateInstancedData(t, e) {
    const r = this.instancedData[t];
    if (!r) return this;
    if (this._incrVersion(), this.instancedData[t] = e, r.buffer && r.buffer.destroy && r.buffer.destroy(), this._vao) for (const n in this._vao) this._vao[n].dirty = !0;
    return this;
  }
  generateInstancedBuffers(t) {
    const e = this.instancedData, r = {};
    for (const n in e) e[n] && (e[n].buffer !== void 0 && e[n].buffer.destroy ? (r[n] = e[n], r[n].divisor && (r[n].divisor = 1)) : r[n] = e[n].destroy ? {
      buffer: e[n],
      divisor: 1
    } : {
      buffer: t.buffer({
        data: e[n],
        dimension: e[n].length / this._instanceCount
      }),
      divisor: 1
    });
    return this.instancedData = r, this;
  }
  getREGLProps(t, e) {
    const r = super.getREGLProps(t, e);
    return Cl(t) || $n(r, this.instancedData), r.elements = this.geometry.getElements(), r.instances = this._instanceCount, r;
  }
  disposeInstanceData() {
    const t = this.instancedData;
    if (t) for (const e in t) t[e] && t[e].destroy && !t[e][pr] && (t[e][pr] = 1, t[e].destroy());
    this.instancedData = {};
    for (const e in this._vao) this._vao[e].vao.destroy();
    this._vao = {};
  }
  _getBytesPerElement(t) {
    switch (t) {
      case 5120:
      case 5121:
        return 1;
      case 5122:
      case 5123:
        return 2;
      case 5124:
      case 5125:
      case 5126:
        return 4;
    }
    throw new Error("unsupported data type: " + t);
  }
};
const wf = {
  getArrayBuffer: (i, t) => wf.get(i, {
    responseType: "arraybuffer"
  }, t),
  get: function(i, t, e) {
    const r = wf._getClient(e);
    if (r.open("GET", i, !0), t) {
      for (const n in t.headers) r.setRequestHeader(n, t.headers[n]);
      r.withCredentials = t.credentials === "include", t.responseType && (r.responseType = t.responseType);
    }
    return r.send(null), r;
  },
  _wrapCallback: function(i, t) {
    return function() {
      i.readyState === 4 && (i.status === 200 ? i.responseType === "arraybuffer" ? i.response.byteLength === 0 ? t(new Error("http status 200 returned without content.")) : t(null, {
        data: i.response,
        cacheControl: i.getResponseHeader("Cache-Control"),
        expires: i.getResponseHeader("Expires"),
        contentType: i.getResponseHeader("Content-Type")
      }) : t(null, i.responseText) : t(new Error(i.statusText + "," + i.status)));
    };
  },
  _getClient: function(i) {
    let t;
    try {
      t = new XMLHttpRequest();
    } catch {
      try {
        t = new ActiveXObject("Msxml2.XMLHTTP");
      } catch {
        try {
          t = new ActiveXObject("Microsoft.XMLHTTP");
        } catch {
        }
      }
    }
    return t.onreadystatechange = wf._wrapCallback(t, i), t;
  }
};
var Hd = oy(class {
  constructor(i, t) {
    this.defaultTexture = i, this.defaultCubeTexture = new Array(6), this.urlModifier = t, this.resources = {};
  }
  setURLModifier(i) {
    this.urlModifier = i;
  }
  get(i) {
    return Array.isArray(i) ? this._loadImages(i) : this._loadImage(i);
  }
  getArrayBuffer(i) {
    if (Array.isArray(i)) {
      const t = i.map((e) => this.getArrayBuffer(e));
      return Promise.all(t);
    }
    return new Promise((t, e) => {
      let r = i;
      this.urlModifier && (r = this.urlModifier(i)), wf.getArrayBuffer(r, (n, s) => {
        n ? e(n) : t({
          url: i,
          data: s
        });
      });
    });
  }
  disposeRes(i) {
    return Array.isArray(i) ? i.forEach((t) => this._disposeOne(t)) : this._disposeOne(i), this;
  }
  isLoading() {
    return this._count && this._count > 0;
  }
  getDefaultTexture(i) {
    return Array.isArray(i) ? this._getBlankTextures(i.length) : this.defaultTexture;
  }
  _disposeOne(i) {
    const t = this.resources;
    t[i] && (t[i].count--, t[i].count <= 0 && delete t[i]);
  }
  _loadImage(i) {
    const t = this.resources;
    return t[i] ? Promise.resolve({
      url: i,
      data: t[i].image
    }) : new Promise((e, r) => {
      const n = new Image();
      n.crossOrigin = "anonymous", n.onload = function() {
        t[i] = {
          image: n,
          count: 1
        }, e({
          url: i,
          data: n
        });
      }, n.onerror = function(s) {
        r(s);
      }, n.onabort = function() {
        r(`image(${i}) loading aborted.`);
      }, n.src = this.urlModifier ? this.urlModifier(i) : i;
    });
  }
  _loadImages(i) {
    const t = i.map((e) => this._loadImage(e, !0));
    return Promise.all(t);
  }
  _getBlankTextures(i) {
    const t = new Array(i);
    for (let e = 0; e < 6; e++) t.push(this.defaultTexture);
    return t;
  }
});
const tx = [], ex = [];
let NI = 0, ur = class {
  constructor(t) {
    this._id = NI++, this.sortedMeshes = {}, this.setMeshes(t), this._compareBinded = this._compare.bind(this), this.dirty();
  }
  setMeshes(t) {
    if (this.clear(), !t || Array.isArray(t) && !t.length || t === this.meshes) return this;
    t = Array.isArray(t) ? t : [t], this.meshes = [];
    for (let e = 0; e < t.length; e++) {
      const r = t[e];
      r && (r._scenes = r._scenes || {}, r._scenes[this._id] = 1, this.meshes.push(r));
    }
    return this.dirty(), this;
  }
  addMesh(t) {
    return !t || Array.isArray(t) && !t.length || (Array.isArray(t) ? t.forEach((e) => {
      e._scenes = e._scenes || {}, e._scenes[this._id] || (e._scenes[this._id] = 1, this.meshes.push(e), this.dirty());
    }) : (t._scenes = t._scenes || {}, t._scenes[this._id] || (t._scenes[this._id] = 1, this.meshes.push(t), this.dirty()))), this;
  }
  removeMesh(t) {
    if (!t || Array.isArray(t) && !t.length) return this;
    if (Array.isArray(t)) {
      let e = !1;
      for (let r = 0; r < t.length; r++) t[r]._scenes && t[r]._scenes[this._id] && (e = !0, this.dirty(), delete t[r]._scenes[this._id]);
      e && (this.meshes = this.meshes.filter((r) => t.indexOf(r) < 0));
    } else {
      if (!t._scenes || !t._scenes[this._id]) return this;
      const e = this.meshes.indexOf(t);
      e >= 0 && this.meshes.splice(e, 1), delete t._scenes[this._id], this.dirty();
    }
    return this;
  }
  getMeshes() {
    return this.meshes || [];
  }
  clear() {
    if (this.meshes) for (let t = 0; t < this.meshes.length; t++) delete this.meshes[t]._scenes[this._id];
    return this.meshes = [], this.sortedMeshes.opaques = [], this.sortedMeshes.transparents = [], this;
  }
  dirty() {
    return this._dirty = !0, this;
  }
  sortMeshes(t) {
    const e = this.meshes;
    this.sortFunction && e.sort(this.sortFunction);
    let r = this.sortedMeshes.transparents;
    if (this._dirty) {
      const n = this.sortedMeshes.opaques = [];
      r = this.sortedMeshes.transparents = [];
      for (let s = 0, o = e.length; s < o; s++) e[s].transparent ? r.push(e[s]) : n.push(e[s]);
    }
    t && r.length > 1 && (this._cameraPosition = t, r.sort(this._compareBinded), delete this._cameraPosition), this._dirty = !1;
  }
  getSortedMeshes() {
    return this._dirty && this.sortMeshes(), this.sortedMeshes || [];
  }
  _compare(t, e) {
    return fl(tx, t.geometry.boundingBox.getCenter(), t.localTransform), fl(ex, e.geometry.boundingBox.getCenter(), e.localTransform), Ya(ex, this._cameraPosition) - Ya(tx, this._cameraPosition);
  }
};
const _c = String.fromCharCode;
function HI(i, t, e, r) {
  if (i[3] > 0) {
    const n = Math.pow(2, i[3] - 128 - 8 + r);
    t[e + 0] = i[0] * n, t[e + 1] = i[1] * n, t[e + 2] = i[2] * n;
  } else t[e + 0] = 0, t[e + 1] = 0, t[e + 2] = 0;
  return t[e + 3] = 1, t;
}
function BI(i, t, e) {
  const r = i[t] / e, n = i[t + 1] / e, s = i[t + 2] / e;
  let o = fM(Math.max(Math.max(r, n), Math.max(s, 1e-6)), 0, 1);
  o = Math.ceil(255 * o) / 255, i[t] = Math.min(255, r / o * 255), i[t + 1] = Math.min(255, n / o * 255), i[t + 2] = Math.min(255, s / o * 255), i[t + 3] = Math.min(255, 255 * o);
}
function nx(i, t, e, r) {
  let n = 0, s = 0, o = r;
  for (; o > 0; ) if (i[s][0] = t[e++], i[s][1] = t[e++], i[s][2] = t[e++], i[s][3] = t[e++], i[s][0] === 1 && i[s][1] === 1 && i[s][2] === 1) {
    for (let h = i[s][3] << n >>> 0; h > 0; h--) (l = i[s])[0] = (a = i[s - 1])[0], l[1] = a[1], l[2] = a[2], l[3] = a[3], s++, o--;
    n += 8;
  } else s++, o--, n = 0;
  var a, l;
  return e;
}
function jI(i, t, e, r) {
  if (r < 8 | r > 32767) return nx(i, t, e, r);
  let n = t[e++];
  if (n !== 2) return nx(i, t, e - 1, r);
  if (i[0][1] = t[e++], i[0][2] = t[e++], n = t[e++], (i[0][2] << 8 >>> 0 | n) >>> 0 !== r) return null;
  for (let s = 0; s < 4; s++) for (let o = 0; o < r; ) {
    let a = t[e++];
    if (a > 128) {
      a = (127 & a) >>> 0;
      const l = t[e++];
      for (; a--; ) i[o++][s] = l;
    } else for (; a--; ) i[o++][s] = t[e++];
  }
  return e;
}
function GI(i, t = 0, e = 9) {
  const r = new Uint8Array(i), n = r.length;
  if (function(g, m, v) {
    let _ = "";
    for (let y = m; y < v; y++) _ += _c(g[y]);
    return _;
  }(r, 0, 2) !== "#?") return null;
  for (var s = 2; s < n && (_c(r[s]) !== `
` || _c(r[s + 1]) !== `
`); s++) ;
  if (s >= n) return null;
  s += 2;
  let o = "";
  for (; s < n; s++) {
    const g = _c(r[s]);
    if (g === `
`) break;
    o += g;
  }
  const a = o.split(" "), l = parseInt(a[1]), h = parseInt(a[3]);
  if (!h || !l) return null;
  let u = s + 1;
  const c = [];
  for (let g = 0; g < h; g++) {
    c[g] = [];
    for (let m = 0; m < 4; m++) c[g][m] = 0;
  }
  let f = 0;
  const d = new Array(h * l * 4);
  let p = 0;
  for (let g = 0; g < l; g++) {
    if (u = jI(c, r, u, h), !u) return null;
    for (let m = 0; m < h; m++) HI(c[m], d, p, t), f = Math.max(f, d[p], d[p + 1], d[p + 2], d[p + 3]), p += 4;
  }
  f = Math.min(f, e), p = 0;
  for (let g = 0; g < l; g++) for (let m = 0; m < h; m++) BI(d, p, f), p += 4;
  return {
    width: h,
    height: l,
    pixels: d,
    rgbmRange: f
  };
}
let Bd = class extends gM {
  onLoad({ data: t }) {
    const e = this.config;
    if (e) {
      if (e.hdr) {
        if (!(t = GI(t.data, 0, e.maxRange))) throw new Error("Invalid hdr data" + (e.url ? ":" + e.url : ""));
        this.rgbmRange = t.rgbmRange, e.data = t.pixels;
      } else e.data = t;
      e.width = e.width || t.width, e.height = e.height || t.height, this._updateREGL();
    }
  }
  createREGLTexture(t) {
    if (zr(this.config.data) || zr(this.config.mipmap)) {
      const e = PI(t, this.config);
      return e._reshader_refCount || (e._reshader_refCount = 0), e._reshader_refCount++, e;
    }
    return t.texture(this.config);
  }
}, jd = class extends er {
  constructor(t) {
    super({
      aPosition: new (cM(t = t || 0))([-1, -1, t, 1, -1, t, -1, 1, t, 1, 1, t]),
      aNormal: new Int8Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1])
    }, new Uint16Array([0, 1, 3, 3, 2, 0]));
  }
};
const u0 = {
  vsm_shadow_vert: `
uniform mat4 shadow_lightProjViewModelMatrix;
varying vec4 shadow_vLightSpacePos;
void shadow_computeShadowPars(vec4 position) {
    shadow_vLightSpacePos = shadow_lightProjViewModelMatrix * position;
}`,
  vsm_shadow_frag: `
uniform sampler2D shadow_shadowMap;
uniform float shadow_opacity;
uniform vec3 shadow_color;
#if defined(USE_ESM)
    uniform float esm_shadow_threshold;
#endif
varying vec4 shadow_vLightSpacePos;
#ifdef PACK_FLOAT
    #include <common_pack_float>
#endif
#if defined(USE_ESM)
float esm(vec3 projCoords, vec4 shadowTexel) {
    float compare = projCoords.z;
    float c = 120.0;
    #ifdef PACK_FLOAT
        float depth = common_decodeDepth(shadowTexel);
        if (depth >= 1.0 - 1E-6 || compare <= depth) {
            return 1.0;
        }
    #else
        float depth = shadowTexel.r;
    #endif
    depth = exp(-c * min(compare - depth, 0.05));
    return clamp(depth, esm_shadow_threshold, 1.0);
}
#endif
#if defined(USE_VSM)
float vsm_shadow_chebyshevUpperBound(vec3 projCoords, vec4 shadowTexel){
    vec2 moments = shadowTexel.rg;
    float distance = projCoords.z;
    if (distance >= 1.0 || distance <= moments.x)
        return 1.0 ;
    float variance = moments.y - (moments.x * moments.x);
    variance = max(variance, 0.00002);
    float d = distance - moments.x;
    float p_max = variance / (variance + d * d);
    return p_max;
}
#endif
float shadow_computeShadow_coeff(sampler2D shadowMap, vec3 projCoords) {
    vec2 uv = projCoords.xy;
    vec4 shadowTexel = texture2D(shadowMap, uv);
    #if defined(USE_ESM)
        float esm_coeff = esm(projCoords, shadowTexel);
        float coeff = esm_coeff * esm_coeff;
    #endif
    #if defined(USE_VSM)
        float vsm_coeff = vsm_shadow_chebyshevUpperBound(projCoords, shadowTexel);
        float coeff = vsm_coeff;
    #endif
    return 1.0 - (1.0 - coeff) * shadow_opacity;
}
float shadow_computeShadow() {
    vec3 projCoords = shadow_vLightSpacePos.xyz / shadow_vLightSpacePos.w;
    projCoords = projCoords * 0.5 + 0.5;
    if(projCoords.z >= 1.0 || projCoords.x < 0.0 || projCoords.x > 1.0 || projCoords.y < 0.0 || projCoords.y > 1.0) return 1.0;
    return shadow_computeShadow_coeff(shadow_shadowMap, projCoords);
}
vec3 shadow_blend(vec3 color, float coeff) {
    color = color * coeff + shadow_color * shadow_opacity * (1.0 - coeff);
    return color;
}`,
  fbo_picking_vert: `
#ifdef ENABLE_PICKING
#if HAS_PICKING_ID == 1
attribute float aPickingId;
#elif HAS_PICKING_ID == 2
uniform float uPickingId;
#endif
varying float vPickingId;
varying float vFbo_picking_viewZ;
varying float vFbo_picking_visible;
#endif
varying float vFbo_picking_fragDepth;
void fbo_picking_setData(float viewPosZ, bool visible) {
    #ifdef ENABLE_PICKING
    #if HAS_PICKING_ID == 1
       vPickingId = aPickingId;
    #elif HAS_PICKING_ID == 2
        vPickingId = uPickingId;
    #endif
        vFbo_picking_viewZ = viewPosZ;
    #endif
    vFbo_picking_visible = visible ? 1.0 : 0.0;
    vFbo_picking_fragDepth = viewPosZ + 1.0;
}`,
  common_pack_float: `const float COMMON_FLOAT_MAX =  1.70141184e38;
const float COMMON_FLOAT_MIN = 1.17549435e-38;
float common_packFloat(vec4 val){
    vec4 scl = floor(255.0 * val + 0.5);
    float sgn = (scl.a < 128.0) ? 1.0 : -1.0;
    float exn = mod(scl.a * 2.0, 256.0) + floor(scl.b / 128.0) - 127.0;
    float man = 1.0 +
        (scl.r / 8388608.0) +
        (scl.g / 32768.0) +
        mod(scl.b, 128.0) / 128.0;
    return sgn * man * pow(2.0, exn);
}
vec4 common_unpackFloat(highp float v) {
    highp float av = abs(v);
    if(av < COMMON_FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > COMMON_FLOAT_MAX) {
        return vec4(127.0, 128.0, 0.0, 0.0) / 255.0;
    } else if(v < -COMMON_FLOAT_MAX) {
        return vec4(255.0, 128.0, 0.0, 0.0) / 255.0;
    }
    highp vec4 c = vec4(0,0,0,0);
    highp float e = floor(log2(av));
    highp float m = av * pow(2.0, -e) - 1.0;
    c[1] = floor(128.0 * m);
    m -= c[1] / 128.0;
    c[2] = floor(32768.0 * m);
    m -= c[2] / 32768.0;
    c[3] = floor(8388608.0 * m);
    highp float ebias = e + 127.0;
    c[0] = floor(ebias / 2.0);
    ebias -= c[0] * 2.0;
    c[1] += floor(ebias) * 128.0;
    c[0] += 128.0 * step(0.0, -v);
    return c / 255.0;
}
vec4 common_encodeDepth(const in float depth) {
    float alpha = 1.0;
    vec4 pack = vec4(0.0);
    pack.a = alpha;
    const vec3 code = vec3(1.0, 255.0, 65025.0);
    pack.rgb = vec3(code * depth);
    pack.gb = fract(pack.gb);
    pack.rg -= pack.gb * (1.0 / 256.0);
    pack.b -= mod(pack.b, 4.0 / 255.0);
    return pack;
}
float common_decodeDepth(const in vec4 pack) {
    return pack.r + pack.g / 255.0;
}`,
  invert_matrix: `mat4 invert_matrix(mat4 matrix) {
    #if __VERSION__ == 300
        return inverse(matrix);
    #else
        vec4 vector1 = matrix[0], vector2 = matrix[1], vector3 = matrix[2], vector4 = matrix[3];
        float a00 = vector1.x, a01 = vector1.y, a02 = vector1.z, a03 = vector1.w;
        float a10 = vector2.x, a11 = vector2.y, a12 = vector2.z, a13 = vector2.w;
        float a20 = vector3.x, a21 = vector3.y, a22 = vector3.z, a23 = vector3.w;
        float a30 = vector4.x, a31 = vector4.y, a32 = vector4.z, a33 = vector4.w;
        float b00 = a00 * a11 - a01 * a10;
        float b01 = a00 * a12 - a02 * a10;
        float b02 = a00 * a13 - a03 * a10;
        float b03 = a01 * a12 - a02 * a11;
        float b04 = a01 * a13 - a03 * a11;
        float b05 = a02 * a13 - a03 * a12;
        float b06 = a20 * a31 - a21 * a30;
        float b07 = a20 * a32 - a22 * a30;
        float b08 = a20 * a33 - a23 * a30;
        float b09 = a21 * a32 - a22 * a31;
        float b10 = a21 * a33 - a23 * a31;
        float b11 = a22 * a33 - a23 * a32;
        float det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        det = 1.0 / det;
        mat4 m = mat4(
            (a11 * b11 - a12 * b10 + a13 * b09) * det,
            (a02 * b10 - a01 * b11 - a03 * b09) * det,
            (a31 * b05 - a32 * b04 + a33 * b03) * det,
            (a22 * b04 - a21 * b05 - a23 * b03) * det,
            (a12 * b08 - a10 * b11 - a13 * b07) * det,
            (a00 * b11 - a02 * b08 + a03 * b07) * det,
            (a32 * b02 - a30 * b05 - a33 * b01) * det,
            (a20 * b05 - a22 * b02 + a23 * b01) * det,
            (a10 * b10 - a11 * b08 + a13 * b06) * det,
            (a01 * b08 - a00 * b10 - a03 * b06) * det,
            (a30 * b04 - a31 * b02 + a33 * b00) * det,
            (a21 * b02 - a20 * b04 - a23 * b00) * det,
            (a11 * b07 - a10 * b09 - a12 * b06) * det,
            (a00 * b09 - a01 * b07 + a02 * b06) * det,
            (a31 * b01 - a30 * b03 - a32 * b00) * det,
            (a20 * b03 - a21 * b01 + a22 * b00) * det
        );
        return m;
    #endif
}
mat4 transpose_matrix(mat4 matrix) {
    #if __VERSION__ == 300
        return transpose(matrix);
    #else
        vec4 vector1 = matrix[0], vector2 = matrix[1], vector3 = matrix[2], vector4 = matrix[3];
        float a01 = vector1.y, a02 = vector1.z, a03 = vector1.w;
        float a12 = vector2.z, a13 = vector2.w;
        float a23 = vector3.w;
        mat4 m = mat4(
            vector1.x,
            vector2.x,
            vector3.x,
            vector4.x,
            a01,
            vector2.y,
            vector3.y,
            vector4.y,
            a02,
            a12,
            vector3.z,
            vector4.z,
            a03,
            a13,
            a23,
            vector4.w
        );
        return m;
    #endif
}`,
  get_output: `#include <invert_matrix>
#include <draco_decode_vert>
#ifdef HAS_INSTANCE
    #include <instance_vert>
    #ifdef HAS_INSTANCE_COLOR
        varying vec4 vInstanceColor;
    #endif
#endif
#ifdef HAS_SKIN
    uniform int skinAnimation;
    #include <skin_vert>
#endif
#include <mask_vert>
#ifdef HAS_MORPH
    attribute vec3 POSITION0;
    attribute vec3 POSITION1;
    attribute vec3 POSITION2;
    attribute vec3 POSITION3;
    attribute vec3 POSITION4;
    attribute vec3 POSITION5;
    attribute vec3 POSITION6;
    attribute vec3 POSITION7;
    #ifdef HAS_MORPHNORMALS
        attribute vec3 NORMAL0;
        attribute vec3 NORMAL1;
        attribute vec3 NORMAL2;
        attribute vec3 NORMAL3;
    #endif
    uniform vec4 morphWeights1;
    uniform vec4 morphWeights2;
#endif
#ifdef HAS_TERRAIN_ALTITUDE
attribute float aTerrainAltitude;
#endif
mat4 getPositionMatrix() {
    mat4 worldMatrix;
    #ifdef HAS_INSTANCE
        #ifdef HAS_INSTANCE_COLOR
            vInstanceColor = instance_getInstanceColor();
        #endif
        mat4 attributeMatrix = instance_getAttributeMatrix();
        #ifdef HAS_SKIN
            if (skinAnimation == 1) {
                worldMatrix = attributeMatrix * positionMatrix * skin_getSkinMatrix();
            } else {
                worldMatrix = attributeMatrix * positionMatrix;
            }
        #else
            worldMatrix = attributeMatrix * positionMatrix;
        #endif
    #else
        #ifdef HAS_SKIN
            if (skinAnimation == 1) {
                worldMatrix = skin_getSkinMatrix() * positionMatrix;
            } else {
                worldMatrix = positionMatrix;
            }
        #else
            worldMatrix = positionMatrix;
        #endif
    #endif
    return worldMatrix;
}
#ifdef HAS_MIN_ALTITUDE
uniform float minAltitude;
#endif
vec4 getPosition(vec3 aPosition) {
    vec3 position = decode_getPosition(aPosition);
    #ifdef HAS_MORPH
        vec4 POSITION = vec4(position + morphWeights1[0] * POSITION0 + morphWeights1[1] * POSITION1 + morphWeights1[2] * POSITION2 + morphWeights1[3] * POSITION3
        + morphWeights2[0] * POSITION4 + morphWeights2[1] * POSITION5 + morphWeights2[2] * POSITION6 + morphWeights2[3] * POSITION7
        , 1.0);
    #else
        vec4 POSITION = vec4(position, 1.0);
    #endif
    #ifdef HAS_TERRAIN_ALTITUDE
        POSITION.z += aTerrainAltitude * 100.0;
    #endif
    #ifdef HAS_MIN_ALTITUDE
        POSITION.z += minAltitude * 100.0;
    #endif
    return POSITION;
}
vec3 appendMorphNormal(vec3 NORMAL) {
    #ifdef HAS_MORPHNORMALS
        vec3 normal = NORMAL + morphWeights1[0] * NORMAL0 + morphWeights1[1] * NORMAL1 + morphWeights1[2] * NORMAL2 + morphWeights1[3] * NORMAL3;
    #else
        vec3 normal = NORMAL;
    #endif
    return normal;
}`,
  instance_vert: `attribute vec4 instance_vectorA;
attribute vec4 instance_vectorB;
attribute vec4 instance_vectorC;
#ifdef HAS_INSTANCE_TERRAIN_ALTITUDE
attribute float aTerrainAltitude;
uniform float terrainAltitudeScale;
#endif
mat4 instance_getAttributeMatrix() {
    mat4 mat =  mat4(
        instance_vectorA.x, instance_vectorB.x, instance_vectorC.x, 0.0,
        instance_vectorA.y, instance_vectorB.y, instance_vectorC.y, 0.0,
        instance_vectorA.z, instance_vectorB.z, instance_vectorC.z, 0.0,
        instance_vectorA.w, instance_vectorB.w, instance_vectorC.w, 1.0
    );
    #ifdef HAS_INSTANCE_TERRAIN_ALTITUDE
        mat4 terrainMat = mat4(
            1., 0., 0., 0.,
            0., 1., 0., 0.,
            0., 0., 1., 0.,
            0., 0., aTerrainAltitude * terrainAltitudeScale, 1.
        );
        mat = terrainMat * mat;
    #endif
    return mat;
}
#ifdef HAS_INSTANCE_COLOR
    attribute vec4 instance_color;
    vec4 instance_getInstanceColor() {
        return instance_color;
    }
#endif`,
  skin_vert: `attribute vec4 WEIGHTS_0;
attribute vec4 JOINTS_0;
uniform sampler2D jointTexture;
uniform vec2 jointTextureSize;
uniform float numJoints;
#define ROW0_U ((0.5 + 0.0) / 4.)
#define ROW1_U ((0.5 + 1.0) / 4.)
#define ROW2_U ((0.5 + 2.0) / 4.)
#define ROW3_U ((0.5 + 3.0) / 4.)
mat4 skin_getBoneMatrix(float jointNdx) {
    float v = (jointNdx + 0.5) / numJoints;
    return mat4(
        texture2D(jointTexture, vec2(ROW0_U, v)),
        texture2D(jointTexture, vec2(ROW1_U, v)),
        texture2D(jointTexture, vec2(ROW2_U, v)),
        texture2D(jointTexture, vec2(ROW3_U, v)));
}
mat4 skin_getSkinMatrix() {
        mat4 skinMatrix = skin_getBoneMatrix(JOINTS_0[0]) * WEIGHTS_0[0] +
                        skin_getBoneMatrix(JOINTS_0[1]) * WEIGHTS_0[1] +
                        skin_getBoneMatrix(JOINTS_0[2]) * WEIGHTS_0[2] +
                        skin_getBoneMatrix(JOINTS_0[3]) * WEIGHTS_0[3];
        return skinMatrix;
}`,
  heatmap_render_vert: `#ifdef HAS_HEATMAP
varying vec2 heatmap_vTexCoord;
void heatmap_compute(mat4 matrix, vec3 position) {
    vec4 pos = matrix * vec4(position.xy, 0., 1.);
    heatmap_vTexCoord = (1. + pos.xy / pos.w) / 2.;
}
#endif`,
  heatmap_render_frag: `#ifdef HAS_HEATMAP
uniform sampler2D heatmap_inputTexture;
uniform sampler2D heatmap_colorRamp;
uniform float heatmap_heatmapOpacity;
varying vec2 heatmap_vTexCoord;
vec4 heatmap_getColor(vec4 color) {
    float t = texture2D(heatmap_inputTexture, heatmap_vTexCoord).r;
    vec4 heatmapColor = texture2D(heatmap_colorRamp, vec2(t, 0.5)) * heatmap_heatmapOpacity;
    return color * (1.0 - heatmapColor.a) + heatmapColor * heatmapColor.a;
}
#endif`,
  line_extrusion_vert: `#ifdef IS_LINE_EXTRUSION
    #define ALTITUDE_SCALE 32767.0;
    #define EXTRUDE_SCALE 63.0;
    attribute vec2 aExtrude;
    #ifdef HAS_LINE_WIDTH
        attribute float aLineWidth;
    #else
        uniform float lineWidth;
    #endif
    #ifdef HAS_LINE_HEIGHT
        attribute float aLineHeight;
    #else
        uniform float lineHeight;
    #endif
    uniform float linePixelScale;
    vec3 getLineExtrudePosition(vec3 position) {
        #ifdef HAS_LINE_WIDTH
            float lineWidth = aLineWidth / 2.0;
        #endif
        #ifdef HAS_LINE_HEIGHT
            float lineHeight = aLineHeight / 10.0;
        #endif
        float halfwidth = lineWidth / 2.0;
        float outset = halfwidth;
        vec2 dist = outset * aExtrude / EXTRUDE_SCALE;
        position.z *= lineHeight / ALTITUDE_SCALE;
        return position + vec3(dist, 0.0) * linePixelScale;
    }
#endif`,
  gl2_vert: `#if __VERSION__ == 300
    #define texture2D texture
    #define varying out
    #define attribute in
#endif`,
  gl2_frag: `#if __VERSION__ == 300
    #define varying in
    #define gl_FragDepthEXT gl_FragDepth
    #define texture2D texture
    #define textureCube texture
    #define texture2DProj textureProj
    #define texture2DLodEXT textureLod
    #define texture2DProjLodEXT textureProjLod
    #define textureCubeLodEXT textureLod
    #define texture2DGradEXT textureGrad
    #define texture2DProjGradEXT textureProjGrad
    #define textureCubeGradEXT textureGrad
    #define texture2D texture
    out vec4 glFragColor;
#else
    vec4 glFragColor;
#endif`,
  hsv_frag: `
const mediump vec4 HSV_K0 = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
const mediump vec4 HSV_K1 = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
const mediump float HSV_E = 1.0e-10;
vec3 hsv_rgb2hsv(vec3 c) {
    vec4 K = HSV_K0;
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
    float d = q.x - min(q.w, q.y);
    float e = HSV_E;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}
vec3 hsv_hsv2rgb(vec3 c) {
    vec4 K = HSV_K1;
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
vec4 hsv_apply(vec4 c, vec3 hsvOffset) {
    vec3 hsv = hsv_rgb2hsv(c.rgb);
    hsv += hsv * hsvOffset;
    hsv = clamp(hsv, 0.0, 1.0);
    return vec4(hsv_hsv2rgb(hsv), c.a);
}
vec3 hsv_apply(vec3 c, vec3 hsvOffset) {
    vec3 hsv = hsv_rgb2hsv(c.rgb);
    hsv += hsv * hsvOffset;
    hsv = clamp(hsv, 0.0, 1.0);
    return hsv_hsv2rgb(hsv);
}
mat4 contrastMatrix(float contrast)
{
    float t = (1.0 - contrast) / 2.0;
    return mat4(
        contrast, 0., 0., 0.,
        0., contrast, 0., 0.,
        0., 0., contrast, 0.,
        t, t, t, 1
    );
}`,
  snow_frag: `#ifdef HAS_SNOW
    float lerp(float a, float b, float w) {
        return a + w * (b - a);
    }
    vec3 snow(vec4 sceneColor, vec3 normalColor, float height) {
        float snowIntense = normalColor.b;
        vec3 fixedC = vec3(1.0, 1.0, 1.0);
        if (height < 1.0) {
            float r = lerp(0.5, fixedC.x, snowIntense);
            float g = lerp(0.5, fixedC.y, snowIntense);
            float b = lerp(0.5, fixedC.z, snowIntense);
            return vec3(r, g, b);
        } else {
            float r = lerp(sceneColor.r, fixedC.x, snowIntense);
            float g = lerp(sceneColor.g, fixedC.y, snowIntense);
            float b = lerp(sceneColor.b, fixedC.z, snowIntense);
            return vec3(r, g, b);
        }
    }
#endif`,
  draco_decode_vert: `#if defined(HAS_TANGENT)
    attribute vec4 aTangent;
#elif defined(HAS_NORMAL)
    #ifdef HAS_DRACO_NORMAL
        attribute vec2 aNormal;
        uniform float gltf_u_dec_normal_rangeConstant;
    #else
        attribute vec3 aNormal;
    #endif
#endif
#ifdef HAS_DRACO_POSITION
    uniform float gltf_u_dec_position_normConstant;
    uniform vec3 minValues_pos;
    vec3 decodeDracoPosition(vec3 aPosition) {
        return minValues_pos + aPosition * gltf_u_dec_position_normConstant;
    }
#endif
#ifdef HAS_DRACO_TEXCOORD
    uniform vec2 minValues_tex;
    uniform float gltf_u_dec_texcoord_0_normConstant;
    vec2 decodeDracoTexcoord(vec2 aTexCoord) {
        return minValues_tex + aTexCoord * gltf_u_dec_texcoord_0_normConstant;
    }
#endif
#ifdef HAS_WEB3D_quantized_attributes_TEXCOORD
    uniform mat3 decodeMatrix;
#endif
#ifdef HAS_DRACO_NORMAL
    float czm_signNotZero(float value) {
        return value >= 0.0 ? 1.0 : -1.0;
    }
    vec2 czm_signNotZero(vec2 value) {
        return vec2(czm_signNotZero(value.x), czm_signNotZero(value.y));
    }
    vec3 decodeDracoNormal(vec2 encoded, float range)
    {
        if (encoded.x == 0.0 && encoded.y == 0.0) {
            return vec3(0.0, 0.0, 0.0);
        }
        encoded = encoded / range * 2.0 - 1.0;
        vec3 v = vec3(encoded.x, encoded.y, 1.0 - abs(encoded.x) - abs(encoded.y));
        if (v.z < 0.0) {
            v.xy = (1.0 - abs(v.yx)) * czm_signNotZero(v.xy);
        }
        return normalize(v);
    }
    vec3 decode_getNormal(vec2 aNormal) {
        return decodeDracoNormal(aNormal, gltf_u_dec_normal_rangeConstant).zxy;
    }
#endif
#ifdef HAS_COMPRESSED_INT16
    #ifdef HAS_COMPRESSED_INT16_POSITION
      uniform vec2 compressedPositionRange;
    #endif
    #ifdef HAS_COMPRESSED_INT16_TEXCOORD_0
      uniform vec2 compressedTexcoordRange_0;
    #endif
    #ifdef HAS_COMPRESSED_INT16_TEXCOORD_1
      uniform vec2 compressedTexcoordRange_1;
    #endif
    #ifdef HAS_COMPRESSED_INT16_NORMAL
      uniform vec2 compressedNormalRange;
    #endif
    #ifdef HAS_COMPRESSED_INT16_RATIO
      uniform float compressed_ratio;
    #endif
    float int16ToFloat32(float value, vec2 range) {
        float v = (value >= 32768.0) ? -(65536.0 - value) / 32768.0 : value / 32767.0;
        return (v + 1.0) * (range.y - range.x) / 2.0 + range.x;
    }
#endif
vec3 decode_getPosition(vec3 aPosition) {
    vec3 position = aPosition;
    #if defined(HAS_COMPRESSED_INT16) && defined(HAS_COMPRESSED_INT16_POSITION)
        float x = int16ToFloat32(aPosition.x, compressedPositionRange);
        float y = int16ToFloat32(aPosition.y, compressedPositionRange);
        float z = int16ToFloat32(aPosition.z, compressedPositionRange);
        #ifdef HAS_COMPRESSED_INT16_RATIO
          position = vec3(x / compressed_ratio, y / compressed_ratio, z);
        #else
          position = vec3(x, y, z);
        #endif
    #endif
    #ifdef HAS_DRACO_POSITION
        return decodeDracoPosition(position);
    #else
        return position;
    #endif
}
vec2 decode_getTexcoord(vec2 aTexCoord) {
    vec2 texcoord = aTexCoord;
    #if defined(HAS_COMPRESSED_INT16) && (defined(HAS_COMPRESSED_INT16_TEXCOORD_0) || defined(HAS_COMPRESSED_INT16_TEXCOORD_1))
        float x = int16ToFloat32(aTexCoord.x, compressedTexcoordRange_0);
        float y = int16ToFloat32(aTexCoord.y, compressedTexcoordRange_0);
        texcoord = vec2(x, y);
    #endif
    #ifdef HAS_DRACO_TEXCOORD
        return decodeDracoTexcoord(texcoord);
    #elif defined(HAS_WEB3D_quantized_attributes_TEXCOORD)
        vec3 web3dTexcoord = decodeMatrix * vec3(texcoord, 1.0);
        return vec2(web3dTexcoord.x, web3dTexcoord.y);
    #else
        return texcoord;
    #endif
}
vec3 decode_getNormal(vec3 aNormal) {
    #ifdef HAS_COMPRESSED_INT16_NORMAL
        aNormal.x = int16ToFloat32(aNormal.x, compressedNormalRange);
        aNormal.y = int16ToFloat32(aNormal.y, compressedNormalRange);
        aNormal.z = int16ToFloat32(aNormal.z, compressedNormalRange);
    #endif
    return aNormal;
}`,
  highlight_vert: `#if defined(HAS_HIGHLIGHT_COLOR)
    attribute vec4 aHighlightColor;
    varying vec4 vHighlightColor;
#endif
#if defined(HAS_HIGHLIGHT_OPACITY)
    attribute float aHighlightOpacity;
    varying float vHighlightOpacity;
#endif
void highlight_setVarying() {
    #if defined(HAS_HIGHLIGHT_COLOR)
        vHighlightColor = aHighlightColor / 255.0;
    #endif
    #if defined(HAS_HIGHLIGHT_OPACITY)
        vHighlightOpacity = aHighlightOpacity / 255.0;
    #endif
}`,
  highlight_frag: `#if defined(HAS_HIGHLIGHT_COLOR)
	varying vec4 vHighlightColor;
#endif
#if defined(HAS_HIGHLIGHT_OPACITY)
    varying float vHighlightOpacity;
#endif
vec4 highlight_blendColor(vec4 color) {
	vec4 outColor;
	#if defined(HAS_HIGHLIGHT_COLOR)
		color.rgb = color.rgb * (1.0 - vHighlightColor.a) + vHighlightColor.rgb * vHighlightColor.a;
		#ifndef HAS_HIGHLIGHT_COLOR_POINT
        	color.a = color.a * (1.0 - vHighlightColor.a) + vHighlightColor.a;
        #endif
        outColor = color;
	#else
		outColor = color;
	#endif
	#if defined(HAS_HIGHLIGHT_OPACITY)
		outColor *= vHighlightOpacity;
	#endif
	return outColor;
}`,
  mask_vert: `#ifdef HAS_MASK_EXTENT
    uniform vec4 mask_extent;
    uniform sampler2D mask_colorExtent;
    uniform sampler2D mask_modeExtent;
    uniform float mask_maskMode;
    uniform float mask_hasFlatOut;
    uniform mat4 viewMatrix;
    uniform float mask_heightRatio;
    uniform float mask_heightOffset;
    varying vec4 vWorldPosition;
    varying vec2 vUVInExtent;
    varying float vHeightRatio;
    varying float vHeightOffset;
    const float CLIPINSIDE_MODE = 0.2;
    const float FLATINSIDE_MODE = 0.3;
    const float FLATOUTSIDE_MODE = 0.4;
    const float ELEVATE_MODE = 0.7;
    float random (vec2 st) {
        return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123) * 0.1;
    }
    bool isInExtent(vec4 color) {
        return length(color.rgb) > 0.0;
    }
    float getFlatHeight(float maskMode, float flatHeight, float height) {
      if (maskMode <= ELEVATE_MODE && maskMode > 0.6) {
          return flatHeight + height;
      } else {
        return flatHeight;
      }
    }
    vec4 getNoErrorPosition(vec4 position, vec4 wPosition) {
      vec4 realPos = modelViewMatrix * position;      vec4 pos = viewMatrix * wPosition;      vec4 tempPos = viewMatrix * modelMatrix * position;      float deltaX = realPos.x - tempPos.x;
      float deltaY = realPos.y - tempPos.y;
      float deltaZ = realPos.z - tempPos.z;
      pos.x = pos.x + deltaX;
      pos.y = pos.y + deltaY;
      pos.z = pos.z + deltaZ;
      return pos;
    }
    vec4 getMaskPosition(vec4 position, mat4 modelMatrix) {
        vWorldPosition = modelMatrix * position;
        float w = mask_extent.z - mask_extent.x;
        float h = mask_extent.y - mask_extent.w;
        vec2 uvInExtent = vec2((vWorldPosition.x - mask_extent.x) / abs(w), 1.0 - (vWorldPosition.y - mask_extent.w) / h);
        vec4 extentColor = texture2D(mask_colorExtent, uvInExtent);
        vec3 maskOptionColor = texture2D(mask_modeExtent, uvInExtent).rgb;
        float maskMode = maskOptionColor.r;
        float flatHeight = maskOptionColor.g / mask_heightRatio + mask_heightOffset;
        float height = getFlatHeight(maskMode, flatHeight, vWorldPosition.z);
        vec4 wPosition = vec4(vWorldPosition.x, vWorldPosition.y, height, vWorldPosition.w);
        vUVInExtent = uvInExtent;
        vHeightRatio = mask_heightRatio;
        vHeightOffset = mask_heightOffset;
        if (maskMode <= FLATOUTSIDE_MODE && maskMode > FLATINSIDE_MODE) {
            return modelViewMatrix * position;;
        } else if (mask_hasFlatOut == 1.0) {
            return getNoErrorPosition(position, wPosition);
        }
        if (isInExtent(extentColor) == true && maskMode <= FLATINSIDE_MODE && maskMode > CLIPINSIDE_MODE) {
            return getNoErrorPosition(position, wPosition);
        } if (isInExtent(extentColor) == true && maskMode <= ELEVATE_MODE && maskMode > 0.6) {
            return getNoErrorPosition(position, wPosition);
        } else {
            return modelViewMatrix * position;
        }
    }
#endif`,
  mask_frag: `#ifdef HAS_MASK_EXTENT
    uniform sampler2D mask_colorExtent;
    uniform sampler2D mask_modeExtent;
    uniform float mask_hasClipOut;
    varying float vHeightRatio;
    varying float vHeightOffset;
    varying vec2 vUVInExtent;
    varying vec4 vWorldPosition;
    const float CLIPINSIDE_MODE = 0.1;
    const float CLIPOUTSIDE_MODE = 0.2;
    const float FLATINSIDE_MODE = 0.3;
    const float FLATOUTSIDE_MODE = 0.4;
    const float COLOR_MODE = 0.5;
    const float VIDEO_MODE = 0.6;
    bool isInExtent(vec4 color) {
        return length(color.rgb) > 0.0;
    }
    vec4 setMask(vec4 glFragColor) {
        vec4 extentColor = texture2D(mask_colorExtent, vUVInExtent);
        vec4 modeColor = texture2D(mask_modeExtent, vUVInExtent);
        float maskMode = modeColor.r;
        float minHeight = modeColor.b / vHeightRatio + vHeightOffset;
        float maxHeight = modeColor.a / vHeightRatio + vHeightOffset;
        if (maskMode > CLIPINSIDE_MODE && maskMode <= CLIPOUTSIDE_MODE) {
            if (minHeight == 0.0 && maxHeight == 0.0) {
                return glFragColor;
            } else if (vWorldPosition.z >= minHeight && vWorldPosition.z <= maxHeight) {
                return glFragColor;
            } else {
              discard;
            }
        } else if (mask_hasClipOut == 1.0) {
            discard;
        }
        if (isInExtent(extentColor) == true && maskMode <= CLIPINSIDE_MODE && maskMode > 0.0) {
            if (minHeight == 0.0 && maxHeight == 0.0) {
                discard;
            } else if (vWorldPosition.z >= minHeight && vWorldPosition.z <= maxHeight) {
                discard;
            } else {
              return glFragColor;
            }
        } else if (isInExtent(extentColor) == true && maskMode <= VIDEO_MODE && maskMode > FLATOUTSIDE_MODE) {
            if (minHeight == 0.0 && maxHeight == 0.0) {
                glFragColor = vec4(mix(extentColor.rgb, glFragColor.rgb, 1.0 - extentColor.a), glFragColor.a);
            } else if (vWorldPosition.z >= minHeight && vWorldPosition.z <= maxHeight) {
                glFragColor = vec4(mix(extentColor.rgb, glFragColor.rgb, 1.0 - extentColor.a), glFragColor.a);
            }
        }
        return glFragColor;
    }
#endif`,
  computeTexcoord_frag: `#ifdef HAS_KHR_TEXTURE_TRANSFORM
    uniform vec2 khr_offset;
    uniform float khr_rotation;
    uniform vec2 khr_scale;
    vec2 khr_tex_transformTexCoord(vec2 texCoords, vec2 offset, float rotation, vec2 scale) {
        rotation = -rotation;
        mat3 transform = mat3(
        cos(rotation) * scale.x, sin(rotation) * scale.x, 0.0, -sin(rotation) * scale.y, cos(rotation) * scale.y, 0.0, offset.x, offset.y, 1.0);
        vec2 transformedTexCoords = (transform * vec3(fract(texCoords), 1.0)).xy;
        return transformedTexCoords;
    }
#endif
varying highp vec2 vTexCoord;
#ifdef HAS_I3S_UVREGION
    varying vec4 vUvRegion;
#endif
vec2 computeTexCoord(vec2 texCoord) {
    #ifdef HAS_I3S_UVREGION
        vec2 atlasScale = vUvRegion.zw - vUvRegion.xy;
        vec2 uvAtlas = fract(texCoord) * atlasScale + vUvRegion.xy;
        return uvAtlas;
    #elif defined(HAS_KHR_TEXTURE_TRANSFORM)
        return khr_tex_transformTexCoord(texCoord, khr_offset, khr_rotation, khr_scale);
    #else
        return texCoord;
    #endif
}`,
  terrain_normal_frag: `#ifdef HAS_TERRAIN_NORMAL
    uniform sampler2D terrainHeightTexture;
    uniform vec2 terrainHeightMapResolution;
    uniform vec2 terrainResolution;
    uniform float terrainHeightScale;
    uniform float terrainTileResolution;
    uniform vec4 terrainUnpackFactors;
    float getHeight(vec2 uv) {
        vec4 color = texture2D(terrainHeightTexture, uv) * 255.0;
        color.a = -1.0;
        return dot(color, terrainUnpackFactors) / 4.0;
    }
    vec3 convertTerrainHeightToNormalMap(vec2 uv) {
        uv.y = 1.0 - uv.y;
        vec2 epsilon = 1.0 / terrainHeightMapResolution;
        float a = getHeight(uv + vec2(-epsilon.x, -epsilon.y));
        float b = getHeight(uv + vec2(0, -epsilon.y));
        float c = getHeight(uv + vec2(epsilon.x, -epsilon.y));
        float d = getHeight(uv + vec2(-epsilon.x, 0));
        float e = getHeight(uv + vec2(epsilon.x, 0));
        float f = getHeight(uv + vec2(-epsilon.x, epsilon.y));
        float g = getHeight(uv + vec2(0, epsilon.y));
        float h = getHeight(uv + vec2(epsilon.x, epsilon.y));
        vec2 dxy = vec2(
            (c + e + e + h) - (a + d + d + f),
            (f + g + g + h) - (a + b + b + c)
        );
        return normalize(vec3(dxy / epsilon, terrainResolution ));
    }
#endif`,
  vertex_color_vert: `#ifdef HAS_VERTEX_COLOR
attribute float aVertexColorType;
uniform vec4 vertexColorsOfType[VERTEX_TYPES_COUNT];
varying vec4 vertexColor_color;
void vertexColor_update() {
    vertexColor_color = vertexColorsOfType[int(aVertexColorType)];
}
#endif`,
  vertex_color_frag: `#ifdef HAS_VERTEX_COLOR
varying vec4 vertexColor_color;
vec4 vertexColor_get() {
	return vertexColor_color;
}
#endif`,
  excavate_vert: `#ifdef HAS_EXCAVATE_ANALYSIS
  uniform vec4 excavateExtent;
  varying vec2 vCoordinateTexcoord;
  varying float vHeight;
  float getWorldHeight() {
    vec4 wPosition = modelMatrix * getPosition(aPosition);
    return wPosition.z;
  }
  vec2 getCoordinateTexcoord() {
    mat4 localPositionMatrix = getPositionMatrix();
    vec4 wPosition = modelMatrix * localPositionMatrix * getPosition(aPosition);
    float x = (wPosition.x - excavateExtent.x) / (excavateExtent.z - excavateExtent.x);
    float y = (wPosition.y - excavateExtent.y) / (excavateExtent.w - excavateExtent.y);
    return vec2(x, y);
  }
#endif`,
  excavate_frag: `#ifdef HAS_EXCAVATE_ANALYSIS
  uniform sampler2D heightmap;
  uniform float excavateHeight;
  varying vec2 vCoordinateTexcoord;
  varying float vHeight;
  const vec2 range = vec2(-100.0, 1000.0);
  float decodeHeight(const in vec4 pack) {
      return pack.r + pack.g / 255.0;
  }
  vec4 excavateColor(vec4 fragColor) {
      float samplerHeight = decodeHeight(texture2D(heightmap, vCoordinateTexcoord));
      float realHeight = samplerHeight * (range.y - range.x) + range.x;
      if(realHeight < range.x || realHeight > range.y) {
          realHeight = 0.0;
      }
      if(vHeight > realHeight) {
          discard;
      }
      return fragColor;
  }
#endif`
};
var sd = {
  register(i, t) {
    if (u0[i]) throw new Error(`Key of ${i} is already registered in ShaderLib.`);
    u0[i] = t;
  },
  compile: (i) => xM(i)
};
const VI = /^[ \t]*#include +<([\w\d.]+)>/gm;
function xM(i) {
  return i.replace(VI, UI);
}
function UI(i, t) {
  const e = u0[t];
  if (!e) throw new Error("Can not resolve #include <" + t + ">");
  return xM(e);
}
const $I = "function", WI = "array";
let ZI = 0;
const xc = {};
let XI = class {
  constructor({ vert: t, frag: e, uniforms: r, defines: n, extraCommandProps: s }) {
    this.vert = t, this.frag = e;
    const o = ZI++;
    Object.defineProperty(this, "uid", {
      enumerable: !0,
      configurable: !1,
      get: () => o
    }), this.shaderDefines = n && $n({}, n) || {}, r = this.uniforms = (r || []).slice(), this.contextDesc = {};
    for (let a = 0, l = r.length; a < l; a++) {
      const h = r[a];
      if (hM(h)) if (h.indexOf("[") > 0) {
        const { name: u, len: c } = rx(h);
        this.contextDesc[u] = {
          name: u,
          type: "array",
          length: c
        };
      } else this.contextDesc[h] = null;
      else if (h.name.indexOf("[") > 0) {
        const { name: u, len: c } = rx(h.name);
        this.contextDesc[u] = {
          name: u,
          type: "array",
          length: c,
          fn: h.fn
        };
      } else this.contextDesc[h.name] = h;
    }
    this.extraCommandProps = s && $n({}, s) || {}, this.commands = {}, this._compileSource();
  }
  set shaderDefines(t) {
    this._shaderDefines = t, this.dkey = Object.keys(this._shaderDefines).join();
  }
  get shaderDefines() {
    return this._shaderDefines || {};
  }
  setDefines(t) {
    this.shaderDefines = t;
  }
  setFramebuffer(t) {
    return this.context.framebuffer = t, this;
  }
  appendDescUniforms(t, e) {
    const r = e, n = this.contextDesc;
    for (const s in n) if (n[s]) if (n[s].type === "array") {
      const o = s, a = n[s].length;
      let l = e[s];
      if (n[s].fn && (l = n[s].fn(null, e)), !l) continue;
      if (l.length !== a) throw new Error(`${o} uniform's length is not ${a}`);
      r[o] = r[o] || {};
      for (let h = 0; h < a; h++) r[o]["" + h] = l[h].getREGLTexture ? l[h].getREGLTexture(t) : l[h];
    } else n[s].type === "function" && (Object.getOwnPropertyDescriptor(r, s) || Object.defineProperty(r, s, {
      configurable: !1,
      enumerable: !0,
      get: function() {
        return n[s].fn(null, e);
      }
    }));
    return r;
  }
  setUniforms(t) {
    if (t.modelMatrix || t.positionMatrix) throw new Error("modelMatrix or positionMatrix is reserved uniform name for Mesh, please change to another name");
    return this.contextKeys = t ? Object.keys(t).join() : null, this.context = t, this;
  }
  getVersion(t, e) {
    return e.substring(0, 8) === "#version" ? "" : t.limits.version.indexOf("WebGL 2.0") === 0 && this.version === 300 ? `#version 300 es
` : `#version 100
`;
  }
  getActiveVars(t, e, r, n) {
    const s = n;
    if (xc[s]) return xc[s];
    const o = t._gl, a = o.createProgram(), l = o.createShader(35633);
    o.shaderSource(l, e), o.compileShader(l);
    const h = o.createShader(35632);
    o.shaderSource(h, r), o.compileShader(h), o.attachShader(a, h), o.attachShader(a, l), o.linkProgram(a);
    const u = o.getProgramParameter(a, 35721), c = [];
    for (let p = 0; p < u; ++p) {
      const g = o.getActiveAttrib(a, p);
      g && c.push({
        name: g.name,
        type: g.type
      });
    }
    const f = o.getProgramParameter(a, 35718), d = [];
    for (let p = 0; p < f; ++p) {
      const g = o.getActiveUniform(a, p);
      let m = g.name;
      g.name.indexOf("[") > 0 && (m = m.replace("[0]", "")), d.push(m);
    }
    return o.deleteProgram(a), o.deleteShader(l), o.deleteShader(h), xc[s] = {
      activeUniforms: d,
      activeAttributes: c
    }, xc[s];
  }
  createREGLCommand(t, e, r, n, s, o = {}) {
    const a = Cl(t) && !s, l = $n({}, this.shaderDefines || {}, e || {}), h = this._insertDefines(this.vert, l), u = this.getVersion(t, h) + h, c = this._insertDefines(this.frag, l), f = this.getVersion(t, c) + c, d = l0(u) + "_" + l0(f), { activeAttributes: p, activeUniforms: g } = this.getActiveVars(t, u, f, d), m = {};
    p.forEach((w, b) => {
      const T = w.name;
      m[T] = a ? b : t.prop(T);
    });
    const v = {};
    g.forEach((w) => {
      v[w] = t.prop(w);
    });
    const _ = this.contextDesc;
    for (const w in _) if (_[w] && _[w].type === $I) v[w] = _[w].fn;
    else if (_[w] && _[w].type === WI) {
      const b = _[w].name, T = _[w].length;
      for (let A = 0; A < T; A++) {
        const M = `${b}[${A}]`;
        v[M] = t.prop(M);
      }
    } else v[w] = t.prop(w);
    const y = {
      vert: u,
      frag: f,
      uniforms: v,
      attributes: m
    };
    a && (y.vao = t.prop("vao")), a && !n || !r || Ds(r) || (y.elements = t.prop("elements")), y.count = t.prop("count"), y.offset = t.prop("offset"), y.primitive = t.prop("primitive"), y.framebuffer = t.prop("framebuffer"), n && (y.instances = t.prop("instances")), $n(y, this.extraCommandProps, o);
    const x = t(y);
    return p.key = p.map((w) => w.name).join(), x.activeAttributes = p, x;
  }
  dispose() {
    for (const t in this.commands) {
      const e = this.commands[t];
      e && e.destroy && !e[pr] && (e[pr] = !0, e.destroy());
    }
    this.commands = {}, delete this.vert, delete this.frag;
  }
  _insertDefines(t, e) {
    const r = [];
    for (const n in e) Vi(e, n) && !Ei(e[n]) && r.push(`#define ${n} ${e[n]}
`);
    return r.join("") + t;
  }
  _compileSource() {
    this.vert = sd.compile(this.vert), this.frag = sd.compile(this.frag);
  }
};
function rx(i) {
  const t = i.indexOf("["), e = i.indexOf("]");
  return {
    name: i.substring(0, t),
    len: +i.substring(t + 1, e)
  };
}
let qe = class extends XI {
  draw(t, e) {
    if (!e || !e.length) return 0;
    const r = [];
    let n, s = 0;
    for (let o = 0, a = e.length; o < a; o++) {
      if (!e[o].isValid()) {
        o === a - 1 && n && r.length && n(r);
        continue;
      }
      if (!e[o].geometry.getDrawCount() || !this._runFilter(e[o])) {
        o === a - 1 && n && r.length && n(r);
        continue;
      }
      const l = this.getMeshCommand(t, e[o]);
      r.length && n !== l && (n(r), r.length = 0);
      const h = e[o].getREGLProps(t, l.activeAttributes);
      this._ensureContextDefines(h), h.shaderContext = this.context, this.appendDescUniforms(t, h), r.push(h), s++, o < a - 1 ? n = l : o === a - 1 && l(r);
    }
    return s;
  }
  _ensureContextDefines(t) {
    if (this.context && (t.contextKeys || (t.contextKeys = {}), t.contextKeys[this.uid] !== this.contextKeys)) {
      for (const e in this.context) e === "framebuffer" || Object.getOwnPropertyDescriptor(t, e) || Object.defineProperty(t, e, {
        configurable: !1,
        enumerable: !0,
        get: function() {
          return this.shaderContext[e];
        }
      });
      Object.getOwnPropertyDescriptor(t, "framebuffer") || Object.defineProperty(t, "framebuffer", {
        configurable: !1,
        enumerable: !0,
        get: function() {
          return this.targetFramebuffer || this.shaderContext && this.shaderContext.framebuffer;
        }
      }), t.contextKeys[this.uid] = this.contextKeys;
    }
  }
  _runFilter(t) {
    const e = this.filter;
    if (!e) return !0;
    if (Array.isArray(e)) {
      for (let r = 0; r < e.length; r++) if (!e[r](t)) return !1;
      return !0;
    }
    return e(t);
  }
  getMeshCommand(t, e) {
    this._cmdKeys || (this._cmdKeys = {});
    const r = this.dkey || "default";
    let n = this._cmdKeys[r];
    n || (n = this._cmdKeys[r] = {});
    const s = e.getCommandKey(t);
    n[s] || (n[s] = r + "_" + e.getCommandKey(t));
    const o = n[s];
    let a = this.commands[o];
    if (!a) {
      const l = e.getDefines(), h = e.getMaterial(), u = {};
      h && h.doubleSided && this.extraCommandProps && this.extraCommandProps.cull && (u.cull = {
        enable: !1
      }), a = this.commands[o] = this.createREGLCommand(t, l, e.getElements(), e instanceof _M, e.disableVAO, u);
    }
    return a;
  }
};
var qI = `precision mediump float;
#include <gl2_frag>
uniform vec4 baseColorFactor;
uniform float materialShininess;
uniform float environmentExposure;
uniform float specularStrength;
uniform vec3 light0_viewDirection;
uniform vec3 ambientColor;
uniform vec4 light0_diffuse;
uniform vec3 lightSpecular;
uniform vec3 cameraPosition;
uniform float alphaTest;
#ifdef HAS_TOON
uniform float toons;
uniform float specularToons;
#endif
#ifdef HAS_TANGENT
varying vec4 vTangent;
#endif
#ifdef HAS_MAP
#include <computeTexcoord_frag>
#endif
varying vec3 vNormal;
varying vec3 vFragPos;
#ifdef HAS_INSTANCE_COLOR
varying vec4 vInstanceColor;
#endif
#ifdef HAS_BASECOLOR_MAP
uniform sampler2D baseColorTexture;
#endif
#ifdef HAS_EXTRUSION_OPACITY
uniform vec2 extrusionOpacityRange;
varying float vExtrusionOpacity;
#endif
#if defined(HAS_COLOR) || defined(HAS_COLOR0)
varying vec4 vColor;
#elif defined(IS_LINE_EXTRUSION)
uniform vec4 lineColor;
#else
uniform vec4 polygonFill;
#endif
#ifdef HAS_LAYER_OPACITY
uniform float layerOpacity;
#endif
#ifdef IS_LINE_EXTRUSION
uniform float lineOpacity;
#else
uniform float polygonOpacity;
#endif
#ifdef HAS_AO_MAP
uniform sampler2D occlusionTexture;
varying vec2 vTexCoord1;
#endif
#ifdef HAS_NORMAL_MAP
uniform sampler2D normalTexture;
#endif
#ifdef HAS_EMISSIVE_MAP
uniform sampler2D emissiveTexture;
#endif
#ifdef SHADING_MODEL_SPECULAR_GLOSSINESS
uniform vec4 diffuseFactor;
uniform vec3 specularFactor;
#ifdef HAS_DIFFUSE_MAP
uniform sampler2D diffuseTexture;
#endif
#ifdef HAS_SPECULARGLOSSINESS_MAP
uniform sampler2D specularGlossinessTexture;
#endif
#endif
#include <heatmap_render_frag>
#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
#include <vsm_shadow_frag>
#endif
#include <highlight_frag>
#include <mask_frag>
vec3 c() {
  
#if defined(HAS_NORMAL_MAP)
vec3 d = normalize(vNormal);
  vec3 e = texture2D(normalTexture, computeTexCoord(vTexCoord)).xyz * 2. - 1.;
#if defined(HAS_TANGENT)
vec3 t = normalize(vTangent.xyz);
  vec3 b = normalize(cross(d, t) * sign(vTangent.w));
  mat3 f = mat3(t, b, d);
  return normalize(f * e);
#else
return normalize(e);
#endif
#else
return normalize(vNormal);
#endif
}
vec4 h(const in vec4 i) {
  return vec4(i.r < .0031308 ? i.r * 12.92 : 1.055 * pow(i.r, 1. / 2.4) - .055, i.g < .0031308 ? i.g * 12.92 : 1.055 * pow(i.g, 1. / 2.4) - .055, i.b < .0031308 ? i.b * 12.92 : 1.055 * pow(i.b, 1. / 2.4) - .055, i.a);
}
vec4 j() {
  
#if defined(HAS_BASECOLOR_MAP)
return texture2D(baseColorTexture, computeTexCoord(vTexCoord));
#elif defined(HAS_DIFFUSE_MAP)
return texture2D(diffuseTexture, computeTexCoord(vTexCoord));
#elif defined(SHADING_MODEL_SPECULAR_GLOSSINESS)
return diffuseFactor;
#else
return baseColorFactor;
#endif
}
vec3 k() {
  
#if defined(HAS_SPECULARGLOSSINESS_MAP)
return texture2D(specularGlossinessTexture, computeTexCoord(vTexCoord)).rgb;
#elif defined(SHADING_MODEL_SPECULAR_GLOSSINESS)
return specularFactor;
#else
return vec3(1.);
#endif
}
void main() {
  vec4 l = j();
  vec3 m = environmentExposure * ambientColor * l.rgb;
#ifdef HAS_INSTANCE_COLOR
m *= vInstanceColor.rgb;
#endif
vec3 o = c();
  vec3 u = normalize(-light0_viewDirection);
  float v = max(dot(o, u), .0);
#ifdef HAS_TOON
float A = floor(v * toons);
  v = A / toons;
#endif
vec3 B = light0_diffuse.rgb * v * l.rgb;
#if defined(HAS_COLOR) || defined(HAS_COLOR0)
vec3 i = vColor.rgb;
#elif defined(IS_LINE_EXTRUSION)
vec3 i = lineColor.rgb;
#else
vec3 i = polygonFill.rgb;
#endif
#ifdef HAS_INSTANCE_COLOR
i *= vInstanceColor.rgb;
#endif
m *= i.rgb;
  B *= i.rgb;
  vec3 C = normalize(cameraPosition - vFragPos);
  vec3 D = normalize(u + C);
  float E = pow(max(dot(o, D), .0), materialShininess);
#ifdef HAS_TOON
float F = floor(E * specularToons);
  E = F / specularToons;
#endif
vec3 G = specularStrength * lightSpecular * E * k();
#ifdef HAS_OCCLUSION_MAP
float H = texture2D(occlusionTexture, computeTexCoord(vTexCoord1)).r;
  m *= H;
#endif
#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
float I = shadow_computeShadow();
  B = shadow_blend(B, I).rgb;
  G = shadow_blend(G, I).rgb;
#endif
vec3 J = m + B + G;
#ifdef HAS_EMISSIVE_MAP
vec3 K = texture2D(emissiveTexture, computeTexCoord(vTexCoord)).rgb;
  J += K;
#endif
#ifdef IS_LINE_EXTRUSION
glFragColor = vec4(J, lineOpacity * l.a);
#else
glFragColor = vec4(J, polygonOpacity * l.a);
#endif
#if defined(HAS_COLOR) || defined(HAS_COLOR0)
float L = vColor.a;
#elif defined(IS_LINE_EXTRUSION)
float L = lineColor.a;
#else
float L = polygonFill.a;
#endif
glFragColor *= L;
#ifdef HAS_EXTRUSION_OPACITY
float M = extrusionOpacityRange.x;
  float N = extrusionOpacityRange.y;
  float O = M + vExtrusionOpacity * (N - M);
  O = clamp(O, .0, 1.);
  glFragColor *= O;
#endif
if(glFragColor.a < alphaTest) {
    discard;
  }
#ifdef HAS_HEATMAP
glFragColor = heatmap_getColor(glFragColor);
#endif
glFragColor = highlight_blendColor(glFragColor);
#ifdef HAS_LAYER_OPACITY
glFragColor *= layerOpacity;
#endif
#ifdef HAS_MASK_EXTENT
glFragColor = setMask(glFragColor);
#endif
#if __VERSION__ == 100
gl_FragColor = glFragColor;
#endif
}`, YI = `#include <gl2_vert>
attribute vec3 aPosition;
#include <line_extrusion_vert>
#ifdef HAS_MAP
uniform vec2 uvScale;
uniform vec2 uvOffset;
attribute vec2 aTexCoord;
varying vec2 vTexCoord;
#ifdef HAS_I3S_UVREGION
attribute vec4 uvRegion;
varying vec4 vUvRegion;
#endif
#if defined(HAS_AO_MAP)
attribute vec2 aTexCoord1;
varying vec2 vTexCoord1;
#endif
#endif
#if defined(HAS_COLOR)
attribute vec4 aColor;
#elif defined(HAS_COLOR0)
#if COLOR0_SIZE == 3
attribute vec3 aColor0;
#else
attribute vec4 aColor0;
#endif
varying vec4 vColor;
#endif
varying vec3 vFragPos;
varying vec3 vNormal;
uniform mat4 projMatrix;
uniform mat3 modelNormalMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 modelMatrix;
uniform mat4 positionMatrix;
uniform vec2 halton;
uniform vec2 outSize;
uniform mat4 projViewMatrix;
#include <highlight_vert>
#include <get_output>
#include <heatmap_render_vert>
#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
#include <vsm_shadow_vert>
#endif
#ifdef HAS_EXTRUSION_OPACITY
attribute float aExtrusionOpacity;
varying float vExtrusionOpacity;
#endif
#if defined(HAS_TANGENT)
varying vec4 vTangent;
#endif
void c(const highp vec4 q, out highp vec3 d) {
  d = vec3(.0, .0, 1.) + vec3(2., -2., -2.) * q.x * q.zwx + vec3(2., 2., -2.) * q.y * q.wzy;
}
void c(const highp vec4 q, out highp vec3 d, out highp vec3 t) {
  c(q, d);
  t = vec3(1., .0, .0) + vec3(-2., 2., -2.) * q.y * q.yxw + vec3(-2., 2., 2.) * q.z * q.zwx;
}
void main() {
  
#ifdef IS_LINE_EXTRUSION
vec4 e = getPosition(getLineExtrudePosition(aPosition));
#else
vec4 e = getPosition(aPosition);
#endif
mat4 f = getPositionMatrix();
  vFragPos = vec3(modelMatrix * f * e);
#if defined(HAS_NORMAL) || defined(HAS_TANGENT)
mat3 h = modelNormalMatrix * mat3(f);
  vec3 i;
#if defined(HAS_TANGENT)
vec3 t;
  c(aTangent, i, t);
  vTangent = vec4(h * t, aTangent.w);
#else
i = decode_getNormal(aNormal);
#endif
vec3 j = appendMorphNormal(i);
  vNormal = normalize(h * j);
#else
vNormal = vec3(.0);
#endif
mat4 k = projMatrix;
  k[2].xy += halton.xy / outSize.xy;
#ifdef HAS_MASK_EXTENT
gl_Position = k * getMaskPosition(f * e, modelMatrix);
#else
gl_Position = k * modelViewMatrix * f * e;
#endif
#ifdef HAS_MAP
vec2 l = decode_getTexcoord(aTexCoord);
  vTexCoord = l * uvScale + uvOffset;
#endif
#ifdef HAS_AO_MAP
vec2 m = decode_getTexcoord(aTexCoord1);
  vTexCoord1 = m * uvScale + uvOffset;
#endif
#ifdef HAS_EXTRUSION_OPACITY
vExtrusionOpacity = aExtrusionOpacity;
#endif
#if defined(HAS_COLOR)
vColor = aColor / 255.;
#elif defined(HAS_COLOR0)
#if COLOR0_SIZE == 3
vColor = vec4(aColor0 / 255., 1.);
#else
vColor = aColor0 / 255.;
#endif
#endif
#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
shadow_computeShadowPars(f * e);
#endif
#ifdef HAS_HEATMAP
heatmap_compute(projMatrix * modelViewMatrix * f, e);
#endif
#ifdef HAS_I3S_UVREGION
vUvRegion = uvRegion / 65535.;
#endif
highlight_setVarying();
}`;
let ix = class extends qe {
  constructor(t = {}) {
    const e = [], r = [], n = t.uniforms, s = [{
      name: "modelNormalMatrix",
      type: "function",
      fn: function(o, a) {
        return au(e, a.modelMatrix);
      }
    }, {
      name: "modelViewMatrix",
      type: "function",
      fn: function(o, a) {
        return Jt(r, a.viewMatrix, a.modelMatrix);
      }
    }];
    n && s.push(...n), super({
      vert: t.vert || YI,
      frag: t.frag || qI,
      uniforms: s,
      defines: t.defines || {},
      extraCommandProps: t.extraCommandProps || {}
    }), this.version = 300;
  }
  getGeometryDefines(t) {
    const e = {};
    return t.data[t.desc.tangentAttribute] ? e.HAS_TANGENT = 1 : t.data[t.desc.normalAttribute] && (e.HAS_NORMAL = 1), e;
  }
};
var gi = `#if __VERSION__ == 300
#define attribute in
#define varying out
#endif
attribute vec2 aPosition;
attribute vec2 aTexCoord;
varying vec2 vTexCoord;
void main() {
  gl_Position = vec4(aPosition, 0., 1.);
  vTexCoord = aTexCoord;
}`;
const sx = new Int8Array([-1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, -1]), JI = new Uint8Array([0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0]);
let ar = class extends qe {
  constructor(t) {
    t.vert = t.vert || gi, t.extraCommandProps = t.extraCommandProps || {}, t.extraCommandProps.depth || (t.extraCommandProps.depth = {
      enable: !1,
      mask: !1
    }), t.extraCommandProps.stencil || (t.extraCommandProps.stencil = {
      enable: !1
    }), super(t);
  }
  draw(t) {
    return this._quadMesh || this._createQuadMesh(t), super.draw(t, this._quadMesh);
  }
  getMeshCommand(t) {
    const e = this.dkey || "";
    return this.commands[e + "_quad"] || (this.commands[e + "_quad"] = this.createREGLCommand(t, null, this._quadMesh[0].getElements())), this.commands[e + "_quad"];
  }
  _createQuadMesh(t) {
    const e = new er({
      aPosition: sx,
      aTexCoord: JI
    }, null, sx.length / 2, {
      positionSize: 2,
      primitive: "triangles"
    });
    e.generateBuffers(t), this._quadMesh = [new tn(e)];
  }
  dispose() {
    if (this._quadMesh) {
      const t = this._quadMesh[0];
      t.geometry.dispose(), t.dispose();
    }
    return delete this._quadMesh, super.dispose();
  }
}, KI = class extends ar {
  constructor() {
    super({
      vert: gi,
      frag: `#define SHADER_NAME FXAA
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#define FXAA_SPAN_MAX     8.0
precision mediump float;
varying vec2 vTexCoord;
uniform float enableFXAA;
uniform float enableToneMapping;
uniform float enableSharpen;
uniform vec2 resolution;
uniform sampler2D textureSource;
#ifdef HAS_NOAA_TEX
uniform sampler2D noAaTextureSource;
#endif
#ifdef HAS_POINT_TEX
uniform sampler2D pointTextureSource;
#endif
#ifdef HAS_TAA_TEX
uniform sampler2D taaTextureSource;
#ifdef HAS_FXAA_TEX
uniform sampler2D fxaaTextureSource;
#endif
#endif
uniform float pixelRatio;
uniform float sharpFactor;
#ifdef HAS_OUTLINE_TEX
uniform sampler2D textureOutline;
uniform float enableOutline;
uniform float highlightFactor;
uniform float outlineFactor;
uniform float outlineWidth;
uniform vec3 outlineColor;
#endif
vec2 c;
vec4 d(vec2 e) {
  
#ifdef HAS_TAA_TEX
vec4 f = texture2D(textureSource, e);
  vec4 taa = texture2D(taaTextureSource, e);
#ifdef HAS_FXAA_TEX
vec4 h = texture2D(fxaaTextureSource, e);
#else
vec4 h = vec4(.0);
#endif
vec4 i = taa + f * (1. - taa.a);
  return h + i * (1. - h.a);
#else
return texture2D(textureSource, e);
#endif
}
vec4 j(vec2 k) {
  vec4 l;
  mediump vec2 m = vec2(1. / resolution.x, 1. / resolution.y);
  vec3 n = d((k + vec2(-1., -1.)) * m).xyz;
  vec3 o = d((k + vec2(1., -1.)) * m).xyz;
  vec3 u = d((k + vec2(-1., 1.)) * m).xyz;
  vec3 v = d((k + vec2(1.)) * m).xyz;
  vec4 A = d(k * m);
  vec3 B = A.xyz;
  vec3 C = vec3(.299, .587, .114);
  float D = dot(n, C);
  float E = dot(o, C);
  float F = dot(u, C);
  float G = dot(v, C);
  float H = dot(B, C);
  float I = min(H, min(min(D, E), min(F, G)));
  float J = max(H, max(max(D, E), max(F, G)));
  mediump vec2 K;
  K.x = -((D + E) - (F + G));
  K.y = (D + F) - (E + G);
  float L = max((D + E + F + G) * (.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);
  float M = 1. / (min(abs(K.x), abs(K.y)) + L);
  K = min(vec2(FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), K * M)) * m;
  vec4 N = .5 * (d(k * m + K * (1. / 3. - .5)) + d(k * m + K * (2. / 3. - .5)));
  vec4 O = N * .5 + .25 * (d(k * m + K * -.5) + d(k * m + K * .5));
  float P = dot(O.xyz, C);
  if(P < I || P > J)
    l = N;
  else
    l = O;
  return l;
}
vec3 Q(const in vec3 l, const float R) {
  vec2 S = pixelRatio / resolution.xy;
  float T = .0;
  vec4 n = texture2D(textureSource, c + S * vec2(-1., -1.));
  n.rgb = mix(vec3(.0), n.rgb, sign(n.a));
  T += mix(.0, 1., sign(n.a));
  vec4 v = texture2D(textureSource, c + S * vec2(1.));
  v.rgb = mix(vec3(.0), v.rgb, sign(v.a));
  T += mix(.0, 1., sign(v.a));
  vec4 o = texture2D(textureSource, c + S * vec2(1., -1.));
  o.rgb = mix(vec3(.0), o.rgb, sign(o.a));
  T += mix(.0, 1., sign(o.a));
  vec4 u = texture2D(textureSource, c + S * vec2(-1., 1.));
  u.rgb = mix(vec3(.0), u.rgb, sign(u.a));
  T += mix(.0, 1., sign(u.a));
  return l + R * (T * l - n.rgb - o.rgb - u.rgb - v.rgb);
}
vec4 U(const in vec4 l) {
  return vec4(Q(l.rgb, sharpFactor), l.a);
}
vec3 V(const vec3 x) {
  const float a = 2.51;
  const float b = .03;
  const float W = 2.43;
  const float X = .59;
  const float Y = .14;
  return (x * (a * x + b)) / (x * (W * x + X) + Y);
}
vec3 Z(vec3 l) {
  l = l / (l + vec3(1.));
  return l = pow(l, vec3(1. / 2.2));
}
#ifdef HAS_OUTLINE_TEX
vec4 ba() {
  float bb = 2.;
  float bc = 1.;
  float bd = pixelRatio / resolution[0] * outlineWidth;
  float be = pixelRatio / resolution[1] * outlineWidth;
  vec4 bf = (texture2D(textureOutline, c + vec2(bd, be)));
  vec4 bg = (texture2D(textureOutline, c + vec2(bd, .0)));
  vec4 bh = (texture2D(textureOutline, c + vec2(bd, -be)));
  vec4 bi = (texture2D(textureOutline, c + vec2(.0, -be)));
  vec4 bj = (texture2D(textureOutline, c + vec2(-bd, -be)));
  vec4 bk = (texture2D(textureOutline, c + vec2(-bd, .0)));
  vec4 bl = (texture2D(textureOutline, c + vec2(-bd, be)));
  vec4 bm = (texture2D(textureOutline, c + vec2(.0, be)));
  vec4 bn = -bb * bk + bb * bg + -bc * bl + bc * bf + -bc * bj + bc * bh;
  vec4 bo = -bb * bi + bb * bm + -bc * bj + bc * bl + -bc * bh + bc * bf;
  float bp = sqrt(dot(bo, bo) + dot(bn, bn));
  bool bq = bp < 1. / 65025.;
  vec3 br = (texture2D(textureOutline, c)).r * outlineColor;
  if(br == vec3(.0) || (highlightFactor == .0 && bq)) {
    return vec4(.0);
  }
  float bs = bq ? highlightFactor : min(1., sqrt(bp) * outlineFactor);
  return bs * vec4(br, 1.);
}
vec4 bt(const in vec4 l) {
  vec4 ba = ba();
  return ba + vec4(l) * (1. - ba.a);
}
#endif
void main() {
  c = vTexCoord;
  vec4 l;
  if(enableFXAA == 1.) {
    l = j(c * resolution);
  } else {
    l = d(vTexCoord);
  }
  if(enableSharpen == 1.) {
    l = U(l);
  }
#if defined(HAS_NOAA_TEX) || defined(HAS_POINT_TEX)
vec4 bu = vec4(.0);
  vec4 bv = vec4(.0);
#ifdef HAS_POINT_TEX
bu = texture2D(pointTextureSource, vTexCoord);
#endif
#ifdef HAS_NOAA_TEX
bv = texture2D(noAaTextureSource, vTexCoord);
#endif
vec4 bw = bu + bv * (1. - bu.a);
  l = bw + l * (1. - bw.a);
#endif
if(enableToneMapping == 1.) {
    l.rgb = Z(l.rgb);
  }
#ifdef HAS_OUTLINE_TEX
l = bt(l);
#endif
gl_FragColor = l;
}`,
      extraCommandProps: {
        viewport: {
          x: 0,
          y: 0,
          width: (t, e) => e.resolution[0],
          height: (t, e) => e.resolution[1]
        }
      }
    });
  }
  getMeshCommand(t, e) {
    const r = this.dkey || "";
    return this.commands[r + "_fxaa"] || (this.commands[r + "_fxaa"] = this.createREGLCommand(t, null, e.getElements())), this.commands[r + "_fxaa"];
  }
}, QI = class extends ar {
  constructor() {
    super({
      vert: gi,
      frag: `precision mediump float;
#define SHADER_NAME SSAO_BLUR
struct MaterialParams {
  float farPlaneOverEdgeDistance;
  vec2 axis;
  vec2 resolution;
};
uniform sampler2D materialParams_ssao;
uniform sampler2D TextureInput;
uniform MaterialParams materialParams;
varying vec2 vTexCoord;
const int c = 6;
float d[8];
void e() {
  d[0] = .099736;
  d[1] = .096667;
  d[2] = .088016;
  d[3] = .075284;
  d[4] = .060493;
  d[5] = .045662;
}
float f(vec2 h) {
  return (h.x * (256. / 257.) + h.y * (1. / 257.));
}
void tap(inout float i, inout float j, float k, float h, vec2 l) {
  vec3 m = texture2D(materialParams_ssao, l).rgb;
  float n = k;
  i += m.r * n;
  j += n;
}
void main() {
  e();
  highp vec2 o = vTexCoord;
  vec3 m = texture2D(materialParams_ssao, o).rgb;
  if(m.g * m.b == 1.) {
    if(materialParams.axis.y > .0) {
      vec4 u = texture2D(TextureInput, o);
      gl_FragColor = u;
    } else {
      gl_FragColor = vec4(m, 1.);
    }
    return;
  }
  float h = f(m.gb);
  float j = d[0];
  float i = m.r * j;
  vec2 v = materialParams.axis / materialParams.resolution;
  vec2 A = v;
  for(int B = 1; B < c; B++) {
    float k = d[B];
    tap(i, j, k, h, o + A);
    tap(i, j, k, h, o - A);
    A += v;
  }
  float C = i * (1. / j);
  vec2 gb = m.gb;
  if(materialParams.axis.y > .0) {
    vec4 u = texture2D(TextureInput, o);
    gl_FragColor = vec4(u.rgb * C, u.a);
  } else {
    gl_FragColor = vec4(C, gb, 1.);
  }
}`,
      extraCommandProps: {
        viewport: {
          x: 0,
          y: 0,
          width: (t, e) => e.outputSize[0],
          height: (t, e) => e.outputSize[1]
        }
      }
    });
  }
  getMeshCommand(t, e) {
    return this.commands.ssao_blur || (this.commands.ssao_blur = this.createREGLCommand(t, null, e.getElements())), this.commands.ssao_blur;
  }
};
const tD = [-2e-6, 0, 2e-6, -0.095089, 4589e-6, -0.031253, 0.01518, -0.025586, 3765e-6, 0.073426, 0.021802, 2778e-6, 0.094587, 0.043218, 0.089148, -9509e-6, 0.051369, 0.019673, 0.139973, -0.101685, 0.10857, -0.103804, 0.219853, -0.043016, 4841e-6, -0.033988, 0.094187, 0.028011, 0.058466, -0.25711, -0.051031, 0.074993, 0.259843, 0.118822, -0.186537, -0.134192, 0.063949, -0.094894, -0.072683, 0.108176, 0.327108, -0.254058, -0.04718, 0.21918, 0.263895, -0.407709, 0.240834, -0.200352];
let eD = class extends ar {
  constructor() {
    super({
      vert: gi,
      frag: `#if __VERSION__ == 100
#if defined(GL_OES_standard_derivatives)
#extension GL_OES_standard_derivatives : enable
#endif
#endif
precision highp float;
#include <gl2_frag>
varying vec2 vTexCoord;
#define saturate(x)        clamp(x, 0.0, 1.0)
#define SHADER_NAME SSAO_EXTRACT
#define PI 3.14159265359
const float c = .0625;
struct MaterialParams {
  mat4 projMatrix;
  mat4 invProjMatrix;
  vec4 resolution;
  float radius;
  float bias;
  float power;
  vec2 cameraNearFar;
};
uniform MaterialParams materialParams;
uniform sampler2D materialParams_depth;
#define NOISE_NONE      0
#define NOISE_PATTERN   1
#define NOISE_RANDOM    2
#define NOISE_TYPE      NOISE_PATTERN
const int d = 16;
uniform vec3 kSphereSamples[16];
vec3 e(const int x) {
  if(x == 0) {
    return vec3(-.078247, -.749924, -.656880);
  } else if(x == 1) {
    return vec3(-.572319, -.102379, -.813615);
  } else if(x == 2) {
    return vec3(.048653, -.380791, .923380);
  } else if(x == 3) {
    return vec3(.281202, -.656664, -.699799);
  } else if(x == 4) {
    return vec3(.711911, -.235841, -.661485);
  } else if(x == 5) {
    return vec3(-.445893, .611063, .654050);
  } else if(x == 6) {
    return vec3(-.703598, .674837, .222587);
  } else if(x == 7) {
    return vec3(.768236, .507457, .390257);
  } else if(x == 8) {
    return vec3(-.670286, -.470387, .573980);
  } else if(x == 9) {
    return vec3(.199235, .849336, -.488808);
  } else if(x == 10) {
    return vec3(-.768068, -.583633, -.263520);
  } else if(x == 11) {
    return vec3(-.897330, .328853, .294372);
  } else if(x == 12) {
    return vec3(-.570930, -.531056, -.626114);
  } else if(x == 13) {
    return vec3(.699014, .063283, -.712303);
  } else if(x == 14) {
    return vec3(.207495, .976129, -.064172);
  } else if(x == 15) {
    return vec3(-.060901, -.869738, -.489742);
  } else {
    return vec3(.0);
  }
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
}
vec2 f(highp float h) {
  highp float z = clamp(h * 1. / -materialParams.cameraNearFar.y, .0, 1.);
  highp float t = floor(256. * z);
  mediump float i = t * (1. / 256.);
  mediump float j = 256. * z - t;
  return vec2(i, j);
}
float k(highp vec2 l) {
  l = fract(l * vec2(5.3987, 5.4421));
  l += dot(l.yx, l.xy + vec2(21.5351, 14.3137));
  highp float xy = l.x * l.y;
  return fract(xy * 95.4307) + fract(xy * 75.04961) * .5;
}
vec3 m(const vec2 o) {
  
#if NOISE_TYPE == NOISE_RANDOM
return normalize(2. * vec3(k(o), k(o * 2.), k(o * 4.)) - vec3(1.));
#elif NOISE_TYPE == NOISE_PATTERN
vec2 xy = floor(gl_FragCoord.xy);
  float u = mod(xy.x, 4.);
  float v = mod(xy.y, 4.);
  return e(int(u + v * 4.));
#else
return vec3(.0);
#endif
}
highp mat4 A() {
  return materialParams.projMatrix;
}
highp mat4 B() {
  return materialParams.invProjMatrix;
}
highp float C(const vec2 o) {
  return texture2D(materialParams_depth, o).r;
}
highp float D(highp float h) {
  highp mat4 E = A();
  highp float z = h * 2. - 1.;
  return -E[3].z / (z + E[2].z);
}
highp float F(const vec2 o) {
  return D(texture2D(materialParams_depth, o).r);
}
highp vec3 G(in vec2 p, highp float H) {
  p = p * 2. - 1.;
  highp mat4 I = B();
  p.x *= I[0].x;
  p.y *= I[1].y;
  return vec3(p * -H, H);
}
highp vec3 J(const highp vec3 K) {
  highp vec3 L = dFdx(K);
  highp vec3 M = dFdy(K);
  return cross(L, M);
}
highp vec3 J(const highp vec3 K, const vec2 o) {
  vec2 N = o + vec2(materialParams.resolution.z, .0);
  vec2 O = o + vec2(.0, materialParams.resolution.w);
  highp vec3 px = G(N, F(N));
  highp vec3 py = G(O, F(O));
  highp vec3 L = px - K;
  highp vec3 M = py - K;
  return cross(L, M);
}
float P(const highp vec3 Q, const highp float R, mat3 S, const vec3 T, const vec3 U) {
  highp mat4 E = A();
  float V = materialParams.radius;
  float W = materialParams.bias;
  highp vec3 X = S * U;
  float Y = dot(X, T);
  X = sign(Y) * X;
  X = Q + X * V;
  highp vec4 Z = E * vec4(X, 1.);
  Z.xy = Z.xy * (.5 / Z.w) + .5;
  highp float ba = C(Z.xy);
  ba = D(ba);
  float t = saturate(V / abs(R - ba));
  float bb = t * t * (3. - 2. * t);
  return (ba >= X.z + W ? bb : .0);
}
void main() {
  highp vec2 o = vTexCoord;
  highp float h = C(o);
  highp float bc = D(h);
  highp vec3 Q = G(o, bc);
  highp vec3 T = J(Q, o);
  T = normalize(T);
  vec3 bd = m(o);
  vec3 be = bd.xyz;
  vec3 bf = normalize(be - T * dot(be, T));
  vec3 bg = cross(T, bf);
  mat3 S = mat3(bf, bg, T);
  float bh = .0;
  for(int bi = 0; bi < d; bi++) {
    bh += P(Q, bc, S, T, kSphereSamples[bi]);
  }
  float bj = 1. - bh / float(d);
  bj = mix(bj, bj * bj, materialParams.power);
  glFragColor = vec4(bj, f(Q.z), 1.);
#if __VERSION__ == 100
gl_FragColor = glFragColor;
#endif
}`,
      uniforms: [{
        name: "kSphereSamples",
        type: "function",
        fn: function() {
          return tD;
        }
      }],
      extraCommandProps: {
        viewport: {
          x: 0,
          y: 0,
          width: (t, e) => e.outputSize[0],
          height: (t, e) => e.outputSize[1]
        }
      }
    }), this.version = 300;
  }
  getMeshCommand(t, e) {
    return this.commands.ssao_extract || (this.commands.ssao_extract = this.createREGLCommand(t, null, e.getElements())), this.commands.ssao_extract;
  }
};
const nD = [];
let rD = class {
  constructor(t) {
    this._renderer = t;
  }
  render(t, e, r) {
    const { width: n, height: s } = r;
    return this._initShaders(), this._extractFBO || this._createTextures(r), this._extract(t, n, s, r), this._blurAndCombine(e, t.cameraFar, n, s);
  }
  _blurAndCombine(t, e, r, n) {
    const s = Math.floor(r / 2), o = Math.floor(n / 2);
    this._blurHTex.width === s && this._blurHTex.height === o || (this._blurHFBO.resize(s, o), this._blurVFBO.resize(r, n));
    const a = [r, n], l = [1, 0];
    return this._renderer.render(this._ssaoBlurShader, {
      TextureInput: t,
      materialParams_ssao: this._extractTex,
      materialParams: {
        axis: l,
        farPlaneOverEdgeDistance: -e / 0.0625,
        resolution: a
      },
      outputSize: [s, o]
    }, null, this._blurHFBO), l[0] = 0, l[1] = 1, this._renderer.render(this._ssaoBlurShader, {
      TextureInput: t,
      materialParams_ssao: this._blurHTex,
      materialParams: {
        axis: l,
        farPlaneOverEdgeDistance: -e / 0.0625,
        resolution: a
      },
      outputSize: [r, n]
    }, null, this._blurVFBO), this._blurVTex;
  }
  _extract(t, e, r, n) {
    const s = Math.floor(e / 2), o = Math.floor(r / 2);
    this._extractFBO.width === s && this._extractFBO.height === o || this._extractFBO.resize(s, o);
    const { projMatrix: a } = t, l = Is(nD, a);
    this._renderer.render(this._ssaoExtractShader, {
      materialParams_depth: n,
      materialParams: {
        projMatrix: a,
        invProjMatrix: l,
        resolution: [s, o, 1 / s, 1 / o],
        radius: t.radius,
        bias: t.bias,
        power: t.power || 1,
        cameraNearFar: [t.cameraNear, t.cameraFar]
      },
      outputSize: [s, o]
    }, null, this._extractFBO);
  }
  _createTextures(t) {
    const e = Math.floor(t.width / 2), r = Math.floor(t.height / 2);
    this._extractTex = this._createTex(e, r, "uint8"), this._extractFBO = this._createFBO(this._extractTex), this._blurHTex = this._createTex(e, r, "uint8"), this._blurHFBO = this._createFBO(this._blurHTex), this._blurVTex = this._createTex(t.width, t.height, "uint8"), this._blurVFBO = this._createFBO(this._blurVTex);
  }
  _createTex(t, e, r) {
    return this._renderer.regl.texture({
      min: "linear",
      mag: "linear",
      wrap: "clamp",
      type: r,
      width: t,
      height: e
    });
  }
  _createFBO(t) {
    return this._renderer.regl.framebuffer({
      width: t.width,
      height: t.height,
      colors: [t],
      depth: !1,
      stencil: !1
    });
  }
  dispose() {
    this._extractFBO && (this._extractFBO.destroy(), delete this._extractFBO, this._blurVFBO.destroy(), this._blurHFBO.destroy(), this._ssaoExtractShader.dispose(), this._ssaoBlurShader.dispose(), delete this._ssaoExtractShader);
  }
  _initShaders() {
    this._ssaoExtractShader || (this._ssaoExtractShader = new eD(), this._ssaoBlurShader = new QI());
  }
}, iD = class extends ar {
  constructor() {
    super({
      vert: gi,
      frag: `precision mediump float;
varying vec2 vTexCoord;
uniform vec2 resolution;
uniform sampler2D textureSource;
uniform float enableVignette;
uniform float enableGrain;
uniform float enableLut;
uniform float timeGrain;
uniform float grainFactor;
uniform vec2 lensRadius;
uniform float frameMod;
uniform sampler2D lookupTable;
float c(const in vec2 d) {
  vec3 e = fract(vec3(d.xyx) * .1031);
  e += dot(e, e.yzx + 19.19);
  return fract((e.x + e.y) * e.z);
}
float f() {
  float h = c(gl_FragCoord.xy + 1000.0 * fract(timeGrain));
  float i = h * 2. - 1.;
  h = i * inversesqrt(abs(i));
  h = max(-1., h);
  h = h - sign(i) + .5;
  return (h + .5) * .5;
}
vec4 j(const in vec4 k) {
  float l = f();
  return vec4(mix(k.rgb, k.rgb * (k.rgb + (1. - k.rgb) * 2. * l), grainFactor), k.a);
}
float m(const in float k) {
  return k < .0031308 ? k * 12.92 : 1.055 * pow(k, 1. / 2.4) - .055;
}
vec3 m(const in vec3 k) {
  return vec3(k.r < .0031308 ? k.r * 12.92 : 1.055 * pow(k.r, 1. / 2.4) - .055, k.g < .0031308 ? k.g * 12.92 : 1.055 * pow(k.g, 1. / 2.4) - .055, k.b < .0031308 ? k.b * 12.92 : 1.055 * pow(k.b, 1. / 2.4) - .055);
}
vec4 m(const in vec4 k) {
  return vec4(k.r < .0031308 ? k.r * 12.92 : 1.055 * pow(k.r, 1. / 2.4) - .055, k.g < .0031308 ? k.g * 12.92 : 1.055 * pow(k.g, 1. / 2.4) - .055, k.b < .0031308 ? k.b * 12.92 : 1.055 * pow(k.b, 1. / 2.4) - .055, k.a);
}
float n(const in float k) {
  return k < .04045 ? k * (1. / 12.92) : pow((k + .055) * (1. / 1.055), 2.4);
}
vec3 n(const in vec3 k) {
  return vec3(k.r < .04045 ? k.r * (1. / 12.92) : pow((k.r + .055) * (1. / 1.055), 2.4), k.g < .04045 ? k.g * (1. / 12.92) : pow((k.g + .055) * (1. / 1.055), 2.4), k.b < .04045 ? k.b * (1. / 12.92) : pow((k.b + .055) * (1. / 1.055), 2.4));
}
vec4 n(const in vec4 k) {
  return vec4(k.r < .04045 ? k.r * (1. / 12.92) : pow((k.r + .055) * (1. / 1.055), 2.4), k.g < .04045 ? k.g * (1. / 12.92) : pow((k.g + .055) * (1. / 1.055), 2.4), k.b < .04045 ? k.b * (1. / 12.92) : pow((k.b + .055) * (1. / 1.055), 2.4), k.a);
}
float o(const in vec2 d, const in float u) {
  vec3 v = vec3(.06711056, .00583715, 52.9829189);
  return fract(v.z * fract(dot(d.xy + u * vec2(47., 17.) * .695, v.xy)));
}
float A() {
  vec2 B = lensRadius;
  B.y = min(B.y, B.x - 1e-4);
  float C = o(gl_FragCoord.xy, frameMod);
  C = (B.x - B.y) * (B.x + B.y) * .07 * (C - .5);
  return smoothstep(B.x, B.y, C + distance(vTexCoord, vec2(.5)));
}
vec4 D(const in vec4 k) {
  float l = A();
  return vec4(m(n(k.rgb) * l), clamp(k.a + (1. - l), .0, 1.));
}
vec4 E(in vec4 F, in sampler2D G) {
  mediump float H = F.b * 63.;
  mediump vec2 I;
  I.y = floor(floor(H) / 8.);
  I.x = floor(H) - I.y * 8.;
  mediump vec2 J;
  J.y = floor(ceil(H) / 8.);
  J.x = ceil(H) - J.y * 8.;
  highp vec2 K;
  K.x = I.x * .125 + .5 / 512. + (.125 - 1. / 512.) * F.r;
  K.y = I.y * .125 + .5 / 512. + (.125 - 1. / 512.) * F.g;
#ifdef LUT_FLIP_Y
K.y = 1. - K.y;
#endif
highp vec2 L;
  L.x = J.x * .125 + .5 / 512. + (.125 - 1. / 512.) * F.r;
  L.y = J.y * .125 + .5 / 512. + (.125 - 1. / 512.) * F.g;
#ifdef LUT_FLIP_Y
L.y = 1. - L.y;
#endif
lowp vec4 M = texture2D(G, K);
  lowp vec4 N = texture2D(G, L);
  lowp vec4 O = mix(M, N, fract(H));
  return O;
}
void main() {
  vec4 k = texture2D(textureSource, vTexCoord);
  if(enableLut == 1.) {
    k = E(k, lookupTable);
  }
  if(enableVignette == 1.) {
    k = D(k);
  }
  if(enableGrain == 1.) {
    k = j(k);
  }
  gl_FragColor = k;
}`,
      extraCommandProps: {
        viewport: {
          x: 0,
          y: 0,
          width: (t, e) => e.resolution[0],
          height: (t, e) => e.resolution[1]
        }
      }
    });
  }
  getMeshCommand(t, e) {
    return this.commands.postprocess || (this.commands.postprocess = this.createREGLCommand(t, null, e.getElements())), this.commands.postprocess;
  }
}, sD = class extends ar {
  constructor() {
    super({
      vert: gi,
      frag: `#define SHADER_NAME TAA
precision mediump float;
#define saturate(x)        clamp(x, 0.0, 1.0)
#if defined(TARGET_METAL_ENVIRONMENT) || defined(TARGET_VULKAN_ENVIRONMENT)
#define TEXTURE_SPACE_UP    -1
#define TEXTURE_SPACE_DN     1
#else
#define TEXTURE_SPACE_UP     1
#define TEXTURE_SPACE_DN    -1
#endif
#define BOX_TYPE_AABB           0
#define BOX_TYPE_VARIANCE       1
#define BOX_TYPE_AABB_VARIANCE  2
#define VARIANCE_GAMMA          1.0
#define BOX_CLIPPING_ACCURATE   0
#define BOX_CLIPPING_CLAMP      1
#define BOX_CLIPPING_NONE       2
#if defined(TARGET_MOBILE)
#define BOX_CLIPPING            BOX_CLIPPING_ACCURATE
#define BOX_TYPE                BOX_TYPE_VARIANCE
#define USE_YCoCg               0
#define FILTER_INPUT            1
#define FILTER_HISTORY          0
#else
#define BOX_CLIPPING            BOX_CLIPPING_ACCURATE
#define BOX_TYPE                BOX_TYPE_AABB_VARIANCE
#define USE_YCoCg               0
#define FILTER_INPUT            0
#define FILTER_HISTORY          0
#endif
#define HISTORY_REPROJECTION    1
#define PREVENT_FLICKERING      0
struct MaterialParams {
  float alpha;
  mat4 reprojection;
};
uniform sampler2D materialParams_color;
uniform sampler2D materialParams_history;
uniform vec2 materialParams_history_size;
uniform vec2 textureOutputSize;
uniform sampler2D materialParams_depth;
uniform MaterialParams materialParams;
float c(const vec3 d) {
  return dot(d, vec3(.2126, .7152, .0722));
}
float e(const vec3 f) {
  
#if USE_YCoCg
return f.x;
#else
return c(f);
#endif
}
vec3 h(const vec3 i) {
  float j = dot(i.rgb, vec3(1, 2, 1) * .25);
  float k = dot(i.rgb, vec3(2, 0, -2) * .25);
  float l = dot(i.rgb, vec3(-1, 2, -1) * .25);
  return vec3(j, k, l);
}
vec3 m(const vec3 i) {
  float j = i.x;
  float k = i.y;
  float l = i.z;
  float r = j + k - l;
  float g = j + l;
  float b = j - k - l;
  return vec3(r, g, b);
}
vec4 n(const int o, const vec3 u, const vec3 v, const vec4 i, const vec4 A) {
  const float B = .0001;
  if(o == BOX_CLIPPING_ACCURATE) {
    vec4 r = i - A;
    vec3 C = 1. / (B + r.rgb);
    vec3 D = (v - A.rgb) * C;
    vec3 E = (u - A.rgb) * C;
    vec3 F = min(D, E);
    return A + r * saturate(max(max(F.x, F.y), F.z));
  } else if(o == BOX_CLIPPING_CLAMP) {
    return vec4(clamp(A.rgb, u, v), A.a);
  }
  return A;
}
vec4 G(const sampler2D H, const highp vec2 I, const highp vec2 J) {
  highp vec2 K = I * J;
  highp vec2 L = floor(K - .5) + .5;
  highp vec2 M = K - L;
  highp vec2 N = M * M;
  highp vec2 O = N * M;
  vec2 P = N - .5 * (O + M);
  vec2 Q = 1.5 * O - 2.5 * N + 1.;
  vec2 R = .5 * (O - N);
  vec2 S = 1. - P - Q - R;
  vec2 T = Q + S;
  highp vec2 U = L - vec2(1.);
  highp vec2 V = L + vec2(2.);
  highp vec2 W = L + S / T;
  highp vec2 X = 1. / J;
  U *= X;
  V *= X;
  W *= X;
  float Z = T.x * P.y;
  float ba = P.x * T.y;
  float bb = T.x * T.y;
  float bc = R.x * T.y;
  float bd = T.x * R.y;
  vec4 be = texture2D(H, vec2(W.x, U.y)) * Z + texture2D(H, vec2(U.x, W.y)) * ba + texture2D(H, vec2(W.x, W.y)) * bb + texture2D(H, vec2(V.x, W.y)) * bc + texture2D(H, vec2(W.x, V.y)) * bd;
  be *= 1. / (Z + ba + bb + bc + bd);
  return be;
}
vec4 bf(sampler2D H, vec2 I, float bg, ivec2 bh) {
  return texture2D(H, I + vec2(bh));
}
void main() {
  highp vec4 I = (gl_FragCoord.xy / textureOutputSize.xy).xyxy;
  float bi = texture2D(materialParams_depth, I.xy).r;
#if HISTORY_REPROJECTION
#if defined(TARGET_METAL_ENVIRONMENT) || defined(TARGET_VULKAN_ENVIRONMENT)
I.w = 1. - I.w;
#endif
highp vec4 q = materialParams.reprojection * vec4(I.zw, bi, 1.);
  I.zw = (q.xy * (1. / q.w)) * .5 + .5;
#if defined(TARGET_METAL_ENVIRONMENT) || defined(TARGET_VULKAN_ENVIRONMENT)
I.w = 1. - I.w;
#endif
#endif
vec4 f = bf(materialParams_color, I.xy, .0, ivec2(0));
#if FILTER_HISTORY
vec4 bj = G(materialParams_history, I.zw, materialParams_history_size);
#else
vec4 bj = texture2D(materialParams_history, I.zw);
#endif
#if USE_YCoCg
bj.rgb = h(bj.rgb);
#endif
vec3 s[9];
  s[0] = bf(materialParams_color, I.xy, .0, ivec2(-1, TEXTURE_SPACE_DN)).rgb;
  s[1] = bf(materialParams_color, I.xy, .0, ivec2(0, TEXTURE_SPACE_DN)).rgb;
  s[2] = bf(materialParams_color, I.xy, .0, ivec2(1, TEXTURE_SPACE_DN)).rgb;
  s[3] = bf(materialParams_color, I.xy, .0, ivec2(-1, 0)).rgb;
  s[4] = f.rgb;
  s[5] = bf(materialParams_color, I.xy, .0, ivec2(1, 0)).rgb;
  s[6] = bf(materialParams_color, I.xy, .0, ivec2(-1, TEXTURE_SPACE_UP)).rgb;
  s[7] = bf(materialParams_color, I.xy, .0, ivec2(0, TEXTURE_SPACE_UP)).rgb;
  s[8] = bf(materialParams_color, I.xy, .0, ivec2(1, TEXTURE_SPACE_UP)).rgb;
#if USE_YCoCg
for(int bk = 0; bk < 9; bk++) {
    s[bk] = h(s[bk]);
  }
  f.rgb = s[4].rgb;
#endif
#if FILTER_INPUT
#else
vec4 bl = f;
#endif
#if BOX_TYPE == BOX_TYPE_AABB || BOX_TYPE == BOX_TYPE_AABB_VARIANCE
vec3 u = min(s[4], min(min(s[1], s[3]), min(s[5], s[7])));
  vec3 v = max(s[4], max(max(s[1], s[3]), max(s[5], s[7])));
  vec3 bm = min(u, min(min(s[0], s[2]), min(s[6], s[8])));
  vec3 bn = max(v, max(max(s[0], s[2]), max(s[6], s[8])));
  u = (u + bm) * .5;
  v = (v + bn) * .5;
#endif
#if BOX_TYPE == BOX_TYPE_VARIANCE || BOX_TYPE == BOX_TYPE_AABB_VARIANCE
vec3 bo = s[4];
  vec3 bp = s[4] * s[4];
  for(int bk = 1; bk < 9; bk += 2) {
    bo += s[bk];
    bp += s[bk] * s[bk];
  }
  vec3 bq = bo * (1. / 5.);
  vec3 br = bp * (1. / 5.);
  vec3 bs = sqrt(br - bq * bq);
#if BOX_TYPE == BOX_TYPE_VARIANCE
vec3 u = bq - VARIANCE_GAMMA * bs;
  vec3 v = bq + VARIANCE_GAMMA * bs;
#else
u = min(u, bq - VARIANCE_GAMMA * bs);
  v = max(v, bq + VARIANCE_GAMMA * bs);
#endif
#endif
float bt = e(bl.rgb);
  float bu = e(bj.rgb);
  float bv = materialParams.alpha;
#if PREVENT_FLICKERING
float bw = 1. - abs(bt - bu) / (.001 + max(bt, bu));
  bv *= bw * bw;
#endif
bl.rgb *= 1. / (1. + bt);
  bj.rgb *= 1. / (1. + bu);
  vec4 be = mix(bj, bl, bv);
  be.rgb *= 1. / (1. - e(be.rgb));
#if USE_YCoCg
be.rgb = m(be.rgb);
#endif
be = max(vec4(0), be);
  gl_FragColor = be;
}`,
      extraCommandProps: {
        viewport: {
          x: 0,
          y: 0,
          width: (t, e) => e.materialParams_color.width,
          height: (t, e) => e.materialParams_color.height
        },
        blend: {
          enable: !1
        }
      }
    });
  }
  getMeshCommand(t, e) {
    return this.commands.taa || (this.commands.taa = this.createREGLCommand(t, null, e.getElements())), this.commands.taa;
  }
};
const oD = [2, 0, 0, 0, 0, 2, 0, 0, 0, 0, -2, 0, -1, -1, 1, 1];
let aD = class {
  constructor(t, e) {
    this._jitter = e, this._renderer = t, this._halton = [], this._counter = 0;
  }
  needToRedraw() {
    return this._counter < this._jitter.getSampleCount();
  }
  render(t, e, r, n) {
    const s = this._jitter;
    this._initShaders(), this._createTextures(t), n && (this._counter = 0), this._counter++;
    const o = s.getSampleCount();
    if (this._counter >= o) return this._prevTex;
    this._fbo.width === t.width && this._fbo.height === t.height || this._fbo.resize(t.width, t.height);
    const a = this._outputTex, l = this._prevTex, h = this._uniforms || {
      materialParams_history_size: [l.width, l.height],
      textureOutputSize: [],
      materialParams: {
        alpha: 1,
        reprojection: [],
        filterWeights: []
      }
    };
    h.materialParams.alpha = 1 / this._counter;
    const u = h.materialParams.reprojection;
    Jt(u, this._prevProjMatrix || r, Is(u, r)), Jt(u, u, oD), we(h.materialParams_history_size, l.width, l.height), we(h.textureOutputSize, t.width, t.height), h.materialParams_depth = e, h.materialParams_color = t, h.materialParams_history = l, this._renderer.render(this._shader, h, null, this._fbo);
    const c = this._outputTex, f = this._fbo;
    return this._outputTex = this._prevTex, this._fbo = this._prevFbo, this._prevTex = c, this._prevFbo = f, this._prevProjMatrix = Hi(this._prevProjMatrix || [], r), a;
  }
  dispose() {
    this._shader && (this._shader.dispose(), delete this._shader), this._fbo && this._fbo.destroy(), this._prevFbo && this._prevFbo.destroy(), delete this._uniforms;
  }
  _createTextures(t) {
    if (this._outputTex) return;
    const e = this._renderer.regl;
    this._outputTex = this._createColorTex(t), this._fbo = e.framebuffer({
      width: t.width,
      height: t.height,
      colors: [this._outputTex],
      depth: !1,
      stencil: !1
    }), this._prevTex = this._createColorTex(t), this._prevFbo = e.framebuffer({
      width: t.width,
      height: t.height,
      colors: [this._prevTex],
      depth: !1,
      stencil: !1
    });
  }
  _createColorTex(t) {
    return this._renderer.regl.texture({
      min: "linear",
      mag: "linear",
      type: "uint8",
      width: t.width,
      height: t.height
    });
  }
  _initShaders() {
    this._shader || (this._shader = new sD());
  }
};
const pl = [[0.263385, -0.0252475], [-0.38545, 0.054485], [-0.139795, -0.5379925], [-0.2793775, 0.6875475], [0.7139025, 0.4710925], [0.90044, -0.16422], [0.4481775, -0.82799], [-0.9253375, -0.2910625], [0.3468025, 1.02292], [-1.13742, 0.33522], [-0.7676225, -0.9123175], [-0.2005775, -1.1774125], [-0.926525, 0.96876], [1.12909, -0.7500325], [0.9603, 1.14625]], Gh = pl.length, so = [0, 0];
for (let i = 0; i < pl.length; i++) so[0] += pl[i][0], so[1] += pl[i][1];
so[0] /= Gh, so[1] /= Gh;
let lD = class {
  constructor(t) {
    this._frameNum = 0, this._ratio = t || 0.05, this._avg = [so[0] * this._ratio, so[1] * this._ratio];
  }
  getRatio() {
    return this._ratio;
  }
  setRatio(t) {
    this._ratio !== t && (this._ratio = t, this.reset()), this._avg = [so[0] * this._ratio, so[1] * this._ratio];
  }
  getAverage() {
    return this._avg;
  }
  reset() {
    this._frameNum = 0;
  }
  getJitter(t) {
    const e = this._frameNum % Gh, r = this._ratio;
    return we(t, pl[e][0] * r, pl[e][1] * r), t;
  }
  frame() {
    this._frameNum++, this._frameNum % Gh == 0 && (this._frameNum = 0);
  }
  getSampleCount() {
    return Gh;
  }
}, hD = class {
  constructor(t, e, r = 5) {
    this._regl = t, this._renderer = new hn(t), this._inputRGBM = e, this._level = r;
  }
  render(t, e) {
    this._initShaders(), this._createTextures(t), this._blur(t, e || 0);
    const r = {
      blurTex0: this._blur01Tex,
      blurTex1: this._blur11Tex,
      blurTex2: this._blur21Tex,
      blurTex3: this._blur31Tex,
      blurTex4: this._blur41Tex
    };
    return this._level > 5 && (r.blurTex5 = this._blur51Tex, r.blurTex6 = this._blur61Tex), r;
  }
  _blur(t, e) {
    let r = this._blurUniforms;
    r || (r = this._blurUniforms = {
      rgbmRange: 7,
      blurDir: [0, 0],
      outSize: [0, 0],
      pixelRatio: [1, 1],
      outputSize: [0, 0]
    }), we(r.outSize, t.width, t.height), this._blurOnce(this._blur0Shader, t, this._blur00FBO, this._blur01FBO, 0.5, e), this._blurOnce(this._blur1Shader, this._blur01FBO.color[0], this._blur10FBO, this._blur11FBO, 0.5), this._blurOnce(this._blur2Shader, this._blur11FBO.color[0], this._blur20FBO, this._blur21FBO, 0.5), this._blurOnce(this._blur3Shader, this._blur21FBO.color[0], this._blur30FBO, this._blur31FBO, 0.5), this._blurOnce(this._blur4Shader, this._blur31FBO.color[0], this._blur40FBO, this._blur41FBO, 0.5), this._level > 5 && (this._blurOnce(this._blur5Shader, this._blur41FBO.color[0], this._blur50FBO, this._blur51FBO, 0.5), this._blurOnce(this._blur6Shader, this._blur51FBO.color[0], this._blur60FBO, this._blur51FBO, 0.5));
  }
  _blurOnce(t, e, r, n, s, o) {
    const a = Math.ceil(s * e.width), l = Math.ceil(s * e.height);
    r.width === a && r.height === l || r.resize(a, l), n.width === a && n.height === l || n.resize(a, l);
    const h = this._blurUniforms;
    h.luminThreshold = o, h.TextureBlurInput = e, h.inputRGBM = +this._inputRGBM, we(h.blurDir, 0, 1), we(h.outputSize, r.width, r.height), this._renderer.render(t, h, null, r), h.luminThreshold = 0, h.inputRGBM = 1, we(h.blurDir, 1, 0), h.TextureBlurInput = r.color[0], this._renderer.render(t, h, null, n);
  }
  dispose() {
    this._blur0Shader && (this._blur0Shader.dispose(), delete this._blur0Shader, this._blur1Shader.dispose(), this._blur2Shader.dispose(), this._blur3Shader.dispose(), this._blur4Shader.dispose(), this._blur5Shader && (this._blur5Shader.dispose(), this._blur6Shader.dispose(), delete this._blur5Shader)), this._blur00Tex && (delete this._blur00Tex, this._blur00FBO.destroy(), this._blur01FBO.destroy(), this._blur10FBO.destroy(), this._blur11FBO.destroy(), this._blur20FBO.destroy(), this._blur21FBO.destroy(), this._blur30FBO.destroy(), this._blur31FBO.destroy(), this._blur40FBO.destroy(), this._blur41FBO.destroy(), this._blur50FBO && (this._blur50FBO.destroy(), this._blur51FBO.destroy(), this._blur60FBO.destroy(), this._blur61FBO.destroy()));
  }
  _createTextures(t) {
    if (this._blur00Tex) return;
    let e = t.width, r = t.height;
    this._blur00Tex = this._createColorTex(t, e, r), this._blur00FBO = this._createBlurFBO(this._blur00Tex), this._blur01Tex = this._createColorTex(t), this._blur01FBO = this._createBlurFBO(this._blur01Tex), e = Math.ceil(e / 2), r = Math.ceil(r / 2), this._blur10Tex = this._createColorTex(t, e, r), this._blur10FBO = this._createBlurFBO(this._blur10Tex), this._blur11Tex = this._createColorTex(t, e, r), this._blur11FBO = this._createBlurFBO(this._blur11Tex), e = Math.ceil(e / 2), r = Math.ceil(r / 2), this._blur20Tex = this._createColorTex(t, e, r), this._blur20FBO = this._createBlurFBO(this._blur20Tex), this._blur21Tex = this._createColorTex(t, e, r), this._blur21FBO = this._createBlurFBO(this._blur21Tex), e = Math.ceil(e / 2), r = Math.ceil(r / 2), this._blur30Tex = this._createColorTex(t, e, r), this._blur30FBO = this._createBlurFBO(this._blur30Tex), this._blur31Tex = this._createColorTex(t, e, r), this._blur31FBO = this._createBlurFBO(this._blur31Tex), e = Math.ceil(e / 2), r = Math.ceil(r / 2), this._blur40Tex = this._createColorTex(t, e, r), this._blur40FBO = this._createBlurFBO(this._blur40Tex), this._blur41Tex = this._createColorTex(t, e, r), this._blur41FBO = this._createBlurFBO(this._blur41Tex), this._level > 5 && (e = Math.ceil(e / 2), r = Math.ceil(r / 2), this._blur50Tex = this._createColorTex(t, e, r), this._blur50FBO = this._createBlurFBO(this._blur50Tex), this._blur51Tex = this._createColorTex(t, e, r), this._blur51FBO = this._createBlurFBO(this._blur51Tex), e = Math.ceil(e / 2), r = Math.ceil(r / 2), this._blur60Tex = this._createColorTex(t, e, r), this._blur60FBO = this._createBlurFBO(this._blur60Tex), this._blur61Tex = this._createColorTex(t, e, r), this._blur61FBO = this._createBlurFBO(this._blur61Tex));
  }
  _createColorTex(t, e, r) {
    return this._regl.texture({
      min: "linear",
      mag: "linear",
      type: "uint8",
      width: e || t.width,
      height: r || t.height
    });
  }
  _createBlurFBO(t) {
    return this._regl.framebuffer({
      width: t.width,
      height: t.height,
      colors: [t],
      depth: !1,
      stencil: !1
    });
  }
  _initShaders() {
    if (!this._blur0Shader) {
      const t = {
        vert: gi,
        extraCommandProps: {
          viewport: {
            x: 0,
            y: 0,
            width: (e, r) => r.outputSize[0],
            height: (e, r) => r.outputSize[1]
          }
        },
        frag: `#version 100
precision highp float;
uniform float rgbmRange;
uniform sampler2D TextureBlurInput;
uniform sampler2D TextureInput;
uniform vec2 blurDir;
uniform vec2 pixelRatio;
uniform vec2 outputSize;
uniform float inputRGBM;
uniform float luminThreshold;
#define SHADER_NAME GAUSSIAN_BLUR0
const vec3 c = vec3(.2126, .7152, .0722);
float d(const in vec3 e) {
  return dot(e, c);
}
vec4 f(vec4 e) {
  float h = max(sign(d(e.rgb) - luminThreshold), .0);
  return e * h;
}
vec2 i;
vec4 j(const in vec3 e, const in float k) {
  vec4 l;
  vec3 m = e / k;
  l.a = clamp(max(max(m.r, m.g), max(m.b, 1e-6)), .0, 1.);
  l.a = ceil(l.a * 255.) / 255.;
  l.rgb = m / l.a;
  return l;
}
vec3 n(const in vec4 e, const in float k) {
  if(inputRGBM == .0)
    return e.rgb;
  return k * e.rgb * e.a;
}
vec4 o() {
  vec3 u = .375 * (f(vec4(n(texture2D(TextureBlurInput, i.xy), rgbmRange), 1.))).rgb;
  vec2 v;
  vec2 A = pixelRatio.xy * blurDir.xy / outputSize.xy;
  v = A * 1.2;
  u += .3125 * (f(vec4(n(texture2D(TextureBlurInput, i.xy + v.xy), rgbmRange), 1.))).rgb;
  u += .3125 * (f(vec4(n(texture2D(TextureBlurInput, i.xy - v.xy), rgbmRange), 1.))).rgb;
  return vec4(u, 1.);
}
void main(void) {
  i = gl_FragCoord.xy / outputSize.xy;
  vec4 e = o();
  e = j(e.rgb, rgbmRange);
  gl_FragColor = e;
}`
      };
      this._blur0Shader = new ar(t), t.frag = `#version 100
precision highp float;
uniform float rgbmRange;
uniform sampler2D TextureBlurInput;
uniform sampler2D TextureInput;
uniform vec2 blurDir;
uniform vec2 pixelRatio;
uniform vec2 outputSize;
#define SHADER_NAME GAUSSIAN_BLUR1
vec2 c;
vec4 d(const in vec3 e, const in float f) {
  if(f <= .0)
    return vec4(e, 1.);
  vec4 h;
  vec3 i = e / f;
  h.a = clamp(max(max(i.r, i.g), max(i.b, 1e-6)), .0, 1.);
  h.a = ceil(h.a * 255.) / 255.;
  h.rgb = i / h.a;
  return h;
}
vec3 j(const in vec4 e, const in float f) {
  if(f <= .0)
    return e.rgb;
  return f * e.rgb * e.a;
}
vec4 k() {
  vec3 l = .3125 * (vec4(j(texture2D(TextureBlurInput, c.xy), rgbmRange), 1.)).rgb;
  vec2 m;
  vec2 n = pixelRatio.xy * blurDir.xy / outputSize.xy;
  m = n * 1.2857142857142858;
  l += .328125 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;
  l += .328125 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;
  return vec4(l, 1.);
}
void main(void) {
  c = gl_FragCoord.xy / outputSize.xy;
  vec4 e = k();
  e = d(e.rgb, rgbmRange);
  gl_FragColor = e;
}`, this._blur1Shader = new ar(t), t.frag = `#version 100
precision highp float;
uniform float rgbmRange;
uniform sampler2D TextureBlurInput;
uniform sampler2D TextureInput;
uniform vec2 blurDir;
uniform vec2 pixelRatio;
uniform vec2 outputSize;
#define SHADER_NAME GAUSSIAN_BLUR2
vec2 c;
vec4 d(const in vec3 e, const in float f) {
  if(f <= .0)
    return vec4(e, 1.);
  vec4 h;
  vec3 i = e / f;
  h.a = clamp(max(max(i.r, i.g), max(i.b, 1e-6)), .0, 1.);
  h.a = ceil(h.a * 255.) / 255.;
  h.rgb = i / h.a;
  return h;
}
vec3 j(const in vec4 e, const in float f) {
  if(f <= .0)
    return e.rgb;
  return f * e.rgb * e.a;
}
vec4 k() {
  vec3 l = .2734375 * (vec4(j(texture2D(TextureBlurInput, c.xy), rgbmRange), 1.)).rgb;
  vec2 m;
  vec2 n = pixelRatio.xy * blurDir.xy / outputSize.xy;
  m = n * 1.3333333333333333;
  l += .328125 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;
  l += .328125 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;
  m = n * 3.111111111111111;
  l += .03515625 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;
  l += .03515625 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;
  return vec4(l, 1.);
}
void main(void) {
  c = gl_FragCoord.xy / outputSize.xy;
  vec4 e = k();
  e = d(e.rgb, rgbmRange);
  gl_FragColor = e;
}`, this._blur2Shader = new ar(t), t.frag = `#version 100
precision highp float;
uniform float rgbmRange;
uniform sampler2D TextureBlurInput;
uniform sampler2D TextureInput;
uniform vec2 blurDir;
uniform vec2 pixelRatio;
uniform vec2 outputSize;
#define SHADER_NAME GAUSSIAN_BLUR3
vec2 c;
vec4 d(const in vec3 e, const in float f) {
  if(f <= .0)
    return vec4(e, 1.);
  vec4 h;
  vec3 i = e / f;
  h.a = clamp(max(max(i.r, i.g), max(i.b, 1e-6)), .0, 1.);
  h.a = ceil(h.a * 255.) / 255.;
  h.rgb = i / h.a;
  return h;
}
vec3 j(const in vec4 e, const in float f) {
  if(f <= .0)
    return e.rgb;
  return f * e.rgb * e.a;
}
vec4 k() {
  vec3 l = .24609375 * (vec4(j(texture2D(TextureBlurInput, c.xy), rgbmRange), 1.)).rgb;
  vec2 m;
  vec2 n = pixelRatio.xy * blurDir.xy / outputSize.xy;
  m = n * 1.3636363636363635;
  l += .322265625 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;
  l += .322265625 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;
  m = n * 3.1818181818181817;
  l += .0537109375 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;
  l += .0537109375 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;
  return vec4(l, 1.);
}
void main(void) {
  c = gl_FragCoord.xy / outputSize.xy;
  vec4 e = k();
  e = d(e.rgb, rgbmRange);
  gl_FragColor = e;
}`, this._blur3Shader = new ar(t), t.frag = `#version 100
precision highp float;
uniform float rgbmRange;
uniform sampler2D TextureBlurInput;
uniform sampler2D TextureInput;
uniform vec2 blurDir;
uniform vec2 pixelRatio;
uniform vec2 outputSize;
#define SHADER_NAME GAUSSIAN_BLUR4
vec2 c;
vec4 d(const in vec3 e, const in float f) {
  if(f <= .0)
    return vec4(e, 1.);
  vec4 h;
  vec3 i = e / f;
  h.a = clamp(max(max(i.r, i.g), max(i.b, 1e-6)), .0, 1.);
  h.a = ceil(h.a * 255.) / 255.;
  h.rgb = i / h.a;
  return h;
}
vec3 j(const in vec4 e, const in float f) {
  if(f <= .0)
    return e.rgb;
  return f * e.rgb * e.a;
}
vec4 k() {
  vec3 l = .2255859375 * (vec4(j(texture2D(TextureBlurInput, c.xy), rgbmRange), 1.)).rgb;
  vec2 m;
  vec2 n = pixelRatio.xy * blurDir.xy / outputSize.xy;
  m = n * 1.3846153846153846;
  l += .314208984375 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;
  l += .314208984375 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;
  m = n * 3.230769230769231;
  l += .06982421875 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;
  l += .06982421875 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;
  m = n * 5.076923076923077;
  l += .003173828125 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;
  l += .003173828125 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;
  return vec4(l, 1.);
}
void main(void) {
  c = gl_FragCoord.xy / outputSize.xy;
  vec4 e = k();
  e = d(e.rgb, rgbmRange);
  gl_FragColor = e;
}`, this._blur4Shader = new ar(t), this._level > 5 && (t.frag = `precision highp float;
uniform float rgbmRange;
uniform sampler2D TextureBlurInput;
uniform sampler2D TextureInput;
uniform vec2 blurDir;
uniform vec2 outSize;
uniform vec2 pixelRatio;
uniform vec2 outputSize;
#define SHADER_NAME GAUSSIAN_BLUR5
vec2 c;
vec4 d(const in vec3 e, const in float f) {
  if(f <= .0)
    return vec4(e, 1.);
  vec4 h;
  vec3 i = e / f;
  h.a = clamp(max(max(i.r, i.g), max(i.b, 1e-6)), .0, 1.);
  h.a = ceil(h.a * 255.) / 255.;
  h.rgb = i / h.a;
  return h;
}
vec3 j(const in vec4 e, const in float f) {
  if(f <= .0)
    return e.rgb;
  return f * e.rgb * e.a;
}
vec4 k() {
  vec3 l = .20947265625 * (vec4(j(texture2D(TextureBlurInput, c.xy), rgbmRange), 1.)).rgb;
  vec2 m;
  vec2 n = pixelRatio.xy * blurDir.xy / outputSize.xy;
  n *= outSize.y * .00075;
  m = n * 1.4;
  l += .30548095703125 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;
  l += .30548095703125 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;
  m = n * 3.2666666666666666;
  l += .08331298828125 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;
  l += .08331298828125 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;
  m = n * 5.133333333333334;
  l += .00640869140625 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;
  l += .00640869140625 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;
  return vec4(l, 1.);
}
void main(void) {
  c = gl_FragCoord.xy / outputSize.xy;
  vec4 e = k();
  e = d(e.rgb, rgbmRange);
  gl_FragColor = e;
}`, this._blur5Shader = new ar(t), t.frag = `#version 100
precision highp float;
uniform float rgbmRange;
uniform sampler2D TextureBlurInput;
uniform sampler2D TextureInput;
uniform vec2 blurDir;
uniform vec2 outSize;
uniform vec2 pixelRatio;
uniform vec2 outputSize;
#define SHADER_NAME GAUSSIAN_BLUR6
vec2 c;
vec4 d(const in vec3 e, const in float f) {
  if(f <= .0)
    return vec4(e, 1.);
  vec4 h;
  vec3 i = e / f;
  h.a = clamp(max(max(i.r, i.g), max(i.b, 1e-6)), .0, 1.);
  h.a = ceil(h.a * 255.) / 255.;
  h.rgb = i / h.a;
  return h;
}
vec3 j(const in vec4 e, const in float f) {
  if(f <= .0)
    return e.rgb;
  return f * e.rgb * e.a;
}
vec4 k() {
  vec3 l = .196380615234375 * (vec4(j(texture2D(TextureBlurInput, c.xy), rgbmRange), 1.)).rgb;
  vec2 m;
  vec2 n = pixelRatio.xy * blurDir.xy / outputSize.xy;
  n *= outSize.y * .00075;
  m = n * 1.411764705882353;
  l += .2967529296875 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;
  l += .2967529296875 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;
  m = n * 3.2941176470588234;
  l += .09442138671875 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;
  l += .09442138671875 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;
  m = n * 5.176470588235294;
  l += .0103759765625 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;
  l += .0103759765625 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;
  return vec4(l, 1.);
}
void main(void) {
  c = gl_FragCoord.xy / outputSize.xy;
  vec4 e = k();
  e = d(e.rgb, rgbmRange);
  gl_FragColor = e;
}`, this._blur6Shader = new ar(t));
    }
  }
}, uD = class {
  constructor(t) {
    this._regl = t, this._renderer = new hn(t);
  }
  render(t, e, r, n, s, o, a, l, h) {
    this._initShaders(), this._createTextures(t);
    const u = this._blurPass.render(e, r);
    return this._combine(t, u, e, n, s, o, a, l, h);
  }
  _combine(t, e, r, n, s, o, a, l, h) {
    h || this._combineTex.width === t.width && this._combineTex.height === t.height || this._combineFBO.resize(t.width, t.height);
    let u = this._combineUniforms;
    const { blurTex0: c, blurTex1: f, blurTex2: d, blurTex3: p, blurTex4: g } = e;
    u || (u = this._combineUniforms = {
      bloomFactor: 0,
      bloomRadius: 0,
      rgbmRange: 7,
      TextureBloomBlur1: c,
      TextureBloomBlur2: f,
      TextureBloomBlur3: d,
      TextureBloomBlur4: p,
      TextureBloomBlur5: g,
      TextureInput: null,
      TextureSource: null,
      outputSize: [0, 0]
    }), u.noAaTextureSource = o, u.pointTextureSource = a, u.enableAA = l, u.bloomFactor = n, u.bloomRadius = s, u.TextureInput = r, u.TextureSource = t, we(u.outputSize, t.width, t.height);
    const m = {};
    return o ? m.HAS_NOAA_TEX = 1 : delete m.HAS_NOAA_TEX, a ? m.HAS_POINT_TEX = 1 : delete m.HAS_POINT_TEX, this._combineShader.setDefines(m), this._renderer.render(this._combineShader, u, null, h ? null : this._combineFBO), h ? null : this._combineTex;
  }
  dispose() {
    this._combineFBO && (this._combineFBO.destroy(), delete this._combineFBO), this._blurPass && (this._blurPass.dispose(), delete this._blurPass), delete this._uniforms;
  }
  _createTextures(t) {
    this._combineTex || (this._combineTex = this._createColorTex(t, t.width, t.height, "uint8"), this._combineFBO = this._createBlurFBO(this._combineTex));
  }
  _createColorTex(t, e, r, n) {
    return this._renderer.regl.texture({
      min: "linear",
      mag: "linear",
      type: n,
      width: e || t.width,
      height: r || t.height
    });
  }
  _createBlurFBO(t) {
    return this._renderer.regl.framebuffer({
      width: t.width,
      height: t.height,
      colors: [t],
      depth: !1,
      stencil: !1
    });
  }
  _initShaders() {
    if (!this._combineShader) {
      const t = {
        x: 0,
        y: 0,
        width: (e, r) => r.outputSize[0],
        height: (e, r) => r.outputSize[1]
      };
      this._blurPass = new hD(this._regl, !1), this._combineShader = new ar({
        vert: gi,
        frag: `#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#define FXAA_SPAN_MAX     8.0
precision highp float;
uniform float bloomFactor;
uniform float bloomRadius;
uniform float rgbmRange;
uniform sampler2D TextureBloomBlur1;
uniform sampler2D TextureBloomBlur2;
uniform sampler2D TextureBloomBlur3;
uniform sampler2D TextureBloomBlur4;
uniform sampler2D TextureBloomBlur5;
uniform sampler2D TextureInput;
uniform sampler2D TextureSource;
#ifdef HAS_NOAA_TEX
uniform sampler2D noAaTextureSource;
#endif
#ifdef HAS_POINT_TEX
uniform sampler2D pointTextureSource;
#endif
uniform float enableAA;
uniform vec2 outputSize;
#define SHADER_NAME bloomCombine
vec2 c;
vec3 d(const in vec3 e) {
  return vec3(e.r < .0031308 ? e.r * 12.92 : 1.055 * pow(e.r, 1. / 2.4) - .055, e.g < .0031308 ? e.g * 12.92 : 1.055 * pow(e.g, 1. / 2.4) - .055, e.b < .0031308 ? e.b * 12.92 : 1.055 * pow(e.b, 1. / 2.4) - .055);
}
vec3 f(const in vec4 e, const in float h) {
  if(h <= .0)
    return e.rgb;
  return h * e.rgb * e.a;
}
float i(const float j, const float k) {
  return mix(j, k * 2. - j, bloomRadius);
}
vec4 l(sampler2D m, vec2 n) {
  vec4 e;
  mediump vec2 o = vec2(1. / outputSize.x, 1. / outputSize.y);
  vec3 u = texture2D(m, (n + vec2(-1., -1.)) * o).xyz;
  vec3 v = texture2D(m, (n + vec2(1., -1.)) * o).xyz;
  vec3 A = texture2D(m, (n + vec2(-1., 1.)) * o).xyz;
  vec3 B = texture2D(m, (n + vec2(1.)) * o).xyz;
  vec4 C = texture2D(m, n * o);
  vec3 D = C.xyz;
  vec3 E = vec3(.299, .587, .114);
  float F = dot(u, E);
  float G = dot(v, E);
  float H = dot(A, E);
  float I = dot(B, E);
  float J = dot(D, E);
  float K = min(J, min(min(F, G), min(H, I)));
  float L = max(J, max(max(F, G), max(H, I)));
  mediump vec2 M;
  M.x = -((F + G) - (H + I));
  M.y = (F + H) - (G + I);
  float N = max((F + G + H + I) * (.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);
  float O = 1. / (min(abs(M.x), abs(M.y)) + N);
  M = min(vec2(FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), M * O)) * o;
  vec4 P = .5 * (texture2D(m, n * o + M * (1. / 3. - .5)) + texture2D(m, n * o + M * (2. / 3. - .5)));
  vec4 Q = P * .5 + .25 * (texture2D(m, n * o + M * -.5) + texture2D(m, n * o + M * .5));
  float R = dot(Q.xyz, E);
  if(R < K || R > L)
    e = P;
  else
    e = Q;
  return e;
}
vec4 S() {
  vec3 T = vec3(.0);
  const float U = .6;
  const float V = 1.1;
  const float W = .9;
  const float X = .6;
  const float Y = .3;
  const float Z = .1;
  T += (vec4(f(texture2D(TextureBloomBlur1, c), rgbmRange), 1.)).rgb * i(V, U);
  T += (vec4(f(texture2D(TextureBloomBlur2, c), rgbmRange), 1.)).rgb * i(W, U);
  T += (vec4(f(texture2D(TextureBloomBlur3, c), rgbmRange), 1.)).rgb * i(X, U);
  T += (vec4(f(texture2D(TextureBloomBlur4, c), rgbmRange), 1.)).rgb * i(Y, U);
  T += (vec4(f(texture2D(TextureBloomBlur5, c), rgbmRange), 1.)).rgb * i(Z, U);
  vec4 ba;
  if(enableAA == 1.) {
    ba = l(TextureInput, gl_FragCoord.xy);
  } else {
    ba = texture2D(TextureInput, c);
  }
  ba.rgb = mix(vec3(.0), ba.rgb, sign(ba.a));
  vec4 bb = texture2D(TextureSource, c);
#ifdef HAS_NOAA_TEX
vec4 bc = texture2D(noAaTextureSource, c);
  bb = bc + bb * (1. - bc.a);
#endif
vec4 bd = vec4(.0);
#ifdef HAS_POINT_TEX
bd = texture2D(pointTextureSource, c);
#endif
float be = sqrt((T.r + T.g + T.b) / 3.);
  vec4 bf = vec4(d(T * bloomFactor), be);
  return bd + (ba + bb * (1. - ba.a)) * (1. - bd.a) + bf;
}
void main(void) {
  c = gl_FragCoord.xy / outputSize.xy;
  vec4 e = S();
  gl_FragColor = e;
}`,
        extraCommandProps: {
          viewport: t
        }
      });
    }
  }
}, cD = class extends ar {
  constructor() {
    const t = [];
    super({
      vert: gi,
      frag: `precision highp float;
#include <gl2_frag>
#define SHADER_NAME COPY_DEPTH
uniform sampler2D TextureDepth;
uniform vec2 textureSize;
#include <common_pack_float>
void main(void) {
  vec2 c = gl_FragCoord.xy / textureSize.xy;
  float d = texture2D(TextureDepth, c).r;
  glFragColor = common_encodeDepth(d);
#if __VERSION__ == 100
gl_FragColor = glFragColor;
#endif
}`,
      uniforms: [{
        name: "textureSize",
        type: "function",
        fn: (e, r) => (t[0] = r.TextureDepth.width, t[1] = r.TextureDepth.height, t)
      }],
      extraCommandProps: {
        viewport: {
          x: 0,
          y: 0,
          width: (e, r) => r.TextureDepth.width,
          height: (e, r) => r.TextureDepth.height
        }
      }
    }), this.version = 300;
  }
  getMeshCommand(t, e) {
    return this.commands.copy_depth || (this.commands.copy_depth = this.createREGLCommand(t, null, e.getElements())), this.commands.copy_depth;
  }
}, Gd = class {
  static getUniformDeclares() {
    const t = [[0, 0, 0, 0], [0, 0, 0, 0]], e = new Array(16);
    return [{
      name: "invProjMatrix",
      type: "function",
      fn: (r, n) => Is(e, n.projMatrix)
    }, {
      name: "outputFovInfo",
      type: "array",
      length: 2,
      fn: function(r, n) {
        const s = Math.tan(0.5 * n.fov), o = n.outSize[0] / n.outSize[1] * s;
        return Sr(t[0], o, s, o, -s), Sr(t[1], -o, s, -o, -s), t;
      }
    }, {
      name: "reprojViewProjMatrix",
      type: "function",
      fn: (r, n) => Jt([], n.prevProjViewMatrix, n.cameraWorldMatrix)
    }];
  }
  static getDefines() {
    return {
      HAS_SSR: 1
    };
  }
  constructor(t) {
    this._regl = t, this._renderer = new hn(t), this._inputRGBM = 0;
  }
  setup(t) {
    this._initShaders(), this._createTextures(t);
  }
  getSSRUniforms(t, e, r) {
    if (!this._depthCopy) return null;
    const n = this._depthCopy;
    return {
      TextureDepth: n,
      TextureReflected: this.getMipmapTexture(),
      ssrFactor: e || 1,
      ssrQuality: r || 2,
      outSize: [n.width, n.height],
      fov: t.getFov() * Math.PI / 180,
      prevProjViewMatrix: this._projViewMatrix || t.projViewMatrix,
      cameraWorldMatrix: t.cameraWorldMatrix
    };
  }
  genMipMap(t, e, r) {
    return this.setup(t), this._mipmap(t), this.copyDepthTex(e), this._projViewMatrix || (this._projViewMatrix = []), Hi(this._projViewMatrix, r), delete this._depthCopied, this._outputTex;
  }
  getPrevProjViewMatrix() {
    return this._projViewMatrix;
  }
  copyDepthTex(t) {
    return this._depthCopied ? null : (this.setup(t), this._depthCopy ? t.width === this._depthCopy.width && t.height === this._depthCopy.height || this._depthCopyFBO.resize(t.width, t.height) : (this._depthCopy = this._regl.texture({
      min: "nearest",
      mag: "nearest",
      mipmap: !1,
      type: "uint8",
      width: t.width,
      height: t.height
    }), this._depthCopyFBO = this._regl.framebuffer({
      width: t.width,
      height: t.height,
      colors: [this._depthCopy],
      colorFormat: "rgba"
    })), this._renderer.render(this._copyDepthShader, {
      TextureDepth: t
    }, null, this._depthCopyFBO), this._depthCopied = !0, this._depthCopy);
  }
  _mipmap(t) {
    const e = this._targetFBO, r = Math.ceil(0.5 * t.width), n = Math.ceil(0.5 * t.height);
    e.width === r && e.height === n || e.resize(r, n);
    let s = this._blurUniforms;
    s || (s = this._blurUniforms = {
      rgbmRange: 7,
      outputSize: [0, 0]
    }), s.TextureInput = t, s.inputRGBM = +this._inputRGBM, we(s.outputSize, e.width, e.height), this._renderer.render(this._ssrQuadShader, s, null, e);
  }
  getMipmapTexture() {
    return this._outputTex || (this._outputTex = this._renderer.regl.texture({
      type: "uint8",
      width: 2,
      height: 2
    })), this._outputTex;
  }
  dispose() {
    this._copyDepthShader && (this._ssrQuadShader.dispose(), this._copyDepthShader.dispose(), this._targetFBO.destroy(), delete this._copyDepthShader), this._depthCopy && (this._depthCopyFBO.destroy(), delete this._depthCopy, delete this._depthCopyFBO);
  }
  _initShaders() {
    this._copyDepthShader || (this._copyDepthShader = new cD(), this._ssrQuadShader = new ar({
      vert: gi,
      frag: `#version 100
precision mediump float;
uniform sampler2D TextureInput;
uniform vec2 outputSize;
#define SHADER_NAME QUAD
vec2 c;
void main(void) {
  c = gl_FragCoord.xy / outputSize.xy;
  vec4 d = texture2D(TextureInput, c.xy);
  gl_FragColor = d;
}`,
      extraCommandProps: {
        viewport: {
          x: 0,
          y: 0,
          width: (t, e) => e.outputSize[0],
          height: (t, e) => e.outputSize[1]
        }
      }
    }));
  }
  _createTextures(t) {
    if (!this._targetFBO) {
      const e = this._regl;
      this._outputTex && this._outputTex.destroy(), this._outputTex = e.texture({
        min: "linear",
        mag: "linear",
        type: "uint8",
        width: t.width,
        height: t.height
      }), this._targetFBO = e.framebuffer({
        width: t.width,
        height: t.height,
        colors: [this._outputTex],
        depth: !1,
        stencil: !1
      });
    }
  }
}, fD = class extends qe {
  constructor(t) {
    const e = [];
    super({
      vert: `#define SHADER_NAME HEATMAP
uniform mat4 projViewModelMatrix;
uniform float extrudeScale;
uniform float heatmapIntensity;
attribute vec3 aPosition;
varying vec2 vExtrude;
#ifdef HAS_HEAT_WEIGHT
attribute highp float aWeight;
varying highp float weight;
#else
uniform highp float heatmapWeight;
#endif
uniform mediump float heatmapRadius;
const highp float c = 1. / 255. / 16.;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
  
#ifdef HAS_HEAT_WEIGHT
highp float d = aWeight / 255.;
  weight = d;
#else
highp float d = heatmapWeight;
#endif
mediump float e = heatmapRadius;
  vec2 f = vec2(mod(aPosition.xy, 2.) * 2. - 1.);
  float h = sqrt(-2. * log(c / d / heatmapIntensity / GAUSS_COEF)) / 3.;
  vExtrude = h * f;
  vec2 i = vExtrude * e * extrudeScale;
  vec4 j = vec4(floor(aPosition.xy * .5) + i, aPosition.z, 1);
  gl_Position = projViewModelMatrix * j;
}`,
      frag: `#define SHADER_NAME HEATMAP
precision mediump float;
uniform highp float heatmapIntensity;
varying vec2 vExtrude;
#ifdef HAS_HEAT_WEIGHT
varying highp float weight;
#else
uniform highp float heatmapWeight;
#endif
#define GAUSS_COEF 0.3989422804014327
void main() {
  
#ifdef HAS_HEAT_WEIGHT
highp float c = weight;
#else
highp float c = heatmapWeight;
#endif
float d = -.5 * 3. * 3. * dot(vExtrude, vExtrude);
  float e = c * heatmapIntensity * GAUSS_COEF * exp(d);
  gl_FragColor = vec4(e, 1., 1., 1.);
}`,
      uniforms: [{
        name: "extrudeScale",
        type: "function",
        fn: function(r, n) {
          return n.resolution / n.dataResolution * n.tileRatio;
        }
      }, {
        name: "projViewModelMatrix",
        type: "function",
        fn: function(r, n) {
          return Jt(e, n.projViewMatrix, n.modelMatrix);
        }
      }],
      extraCommandProps: $n({}, t && t.extraCommandProps || {}, {
        blend: {
          enable: !0,
          func: {
            src: "one",
            dst: "one"
          },
          equation: "add"
        }
      })
    });
  }
};
var ox = [-1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, 1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, 1, -1, 1], bM = `#define SHADER_NAME SKYBOX
#if __VERSION__ == 100
#ifdef GL_EXT_shader_texture_lod
#extension GL_EXT_shader_texture_lod : enable
#define textureCubeLod(tex, uv, lod) textureCubeLodEXT(tex, uv, lod)
#else
#define textureCubeLod(tex, uv, lod) textureCube(tex, uv, lod)
#endif
#else
#define textureCubeLod(tex, uv, lod) textureLod(tex, uv, lod)
#endif
precision highp float;
#include <gl2_frag>
#include <hsv_frag>
uniform vec3 hsv;
varying vec3 vWorldPos;
#ifdef USE_AMBIENT
uniform vec3 diffuseSPH[9];
#else
uniform samplerCube cubeMap;
uniform float bias;
uniform float size;
#endif
uniform float environmentExposure;
#if defined(INPUT_RGBM) || defined(ENC_RGBM)
uniform float rgbmRange;
#endif
vec4 c(const in vec3 d, const in float e) {
  if(e <= .0)
    return vec4(d, 1.);
  vec4 f;
  vec3 h = d / e;
  f.a = clamp(max(max(h.r, h.g), max(h.b, 1e-6)), .0, 1.);
  f.a = ceil(f.a * 255.) / 255.;
  f.rgb = h / f.a;
  return f;
}
vec3 i(const in vec4 d, const in float e) {
  if(e <= .0)
    return d.rgb;
  return e * d.rgb * d.a;
}
vec4 j(const in samplerCube k, const in vec3 l, const in float m, const in float n) {
  vec3 o = l;
  return textureCubeLod(k, o, n);
}
vec3 u(const in vec3 v, const in vec3 A[9]) {
  float x = v.x;
  float y = v.y;
  float z = v.z;
  vec3 B = (A[0] + A[1] * x + A[2] * y + A[3] * z + A[4] * z * x + A[5] * y * z + A[6] * y * x + A[7] * (3. * z * z - 1.) + A[8] * (x * x - y * y));
  return max(B, vec3(.0));
}
float C(const in vec2 D) {
  vec3 E = fract(vec3(D.xyx) * .1031);
  E += dot(E, E.yzx + 19.19);
  return fract((E.x + E.y) * E.z);
}
void main() {
  vec4 F;
#ifdef USE_AMBIENT
vec3 v = normalize(vWorldPos + mix(-.5 / 255., .5 / 255., C(gl_FragCoord.xy)) * 2.);
  F = vec4(u(v, diffuseSPH), 1.);
  if(length(hsv) > .0) {
    F.rgb = hsv_apply(F.rgb, hsv);
  }
#else
F = j(cubeMap, vWorldPos, size, bias);
#endif
F.rgb *= environmentExposure;
#ifdef ENC_RGBM
#if !defined(USE_AMBIENT) && defined(INPUT_RGBM)
if(length(hsv) > .0) {
    F.rgb = hsv_apply(i(F, rgbmRange).rgb, hsv);
    F = c(F.rgb, rgbmRange);
  }
#else
F = c(F.rgb, rgbmRange);
#endif
glFragColor = F;
#elif !defined(USE_AMBIENT) && defined(INPUT_RGBM)
glFragColor = vec4(i(F, rgbmRange), 1.);
  if(length(hsv) > .0) {
    glFragColor.rgb = hsv_apply(clamp(glFragColor.rgb, .0, 1.), hsv);
  }
#else
if(length(hsv) > .0) {
    F.rgb = hsv_apply(F.rgb, hsv);
  }
  glFragColor = F;
#endif
#if __VERSION__ == 100
gl_FragColor = glFragColor;
#endif
}`;
let dD = class extends qe {
  constructor() {
    super({
      vert: `#include <gl2_vert>
attribute vec3 aPosition;
uniform mat4 projMatrix;
uniform mat4 viewMatrix;
uniform mat3 transformMatrix;
varying vec3 vWorldPos;
void main() {
  vWorldPos = aPosition;
  mat4 c = mat4(mat3(viewMatrix) * transformMatrix);
  vec4 d = projMatrix * c * vec4(vWorldPos, 1.);
  gl_Position = d.xyww;
}`,
      frag: bM,
      extraCommandProps: {
        depth: {
          enable: !0,
          range: [1, 1],
          func: "lequal"
        },
        viewport: {
          x: 0,
          y: 0,
          width: (t, e) => e.resolution[0],
          height: (t, e) => e.resolution[1]
        }
      }
    }), this.version = 300;
  }
  setMode(t, e, r) {
    const n = {};
    return t && (n.INPUT_RGBM = 1), e && (n.ENC_RGBM = 1), r === 0 && (n.USE_AMBIENT = 1), this._skyboxMesh ? this._skyboxMesh[0].setDefines(n) : this._meshDefines = n, this;
  }
  draw(t) {
    return this._skyboxMesh || this._createSkyboxMesh(t), super.draw(t, this._skyboxMesh);
  }
  _createSkyboxMesh(t) {
    const e = new er({
      aPosition: new Int8Array(ox)
    }, null, ox.length / 3);
    e.generateBuffers(t), this._skyboxMesh = [new tn(e)], this._meshDefines && (this._skyboxMesh[0].setDefines(this._meshDefines), delete this._meshDefines);
  }
  dispose() {
    if (this._skyboxMesh) {
      const t = this._skyboxMesh[0];
      t.geometry.dispose(), t.dispose();
    }
    return delete this._skyboxMesh, super.dispose();
  }
}, pD = class extends qe {
  constructor(t, e) {
    const r = {
      blend: {
        enable: !0,
        func: {
          src: "one",
          dst: "one minus src alpha"
        },
        equation: "add"
      },
      viewport: t
    };
    e && e.extraCommandProps && $n(r, e.extraCommandProps);
    const n = [];
    super({
      vert: `#define SHADER_NAME HEATMAP_DISPLAY
uniform mat4 projViewModelMatrix;
attribute vec3 aPosition;
void main() {
  gl_Position = projViewModelMatrix * vec4(aPosition, 1.);
}`,
      frag: `#define SHADER_NAME HEATMAP_DISPLAY
precision mediump float;
uniform sampler2D inputTexture;
uniform sampler2D colorRamp;
uniform vec2 textureOutputSize;
uniform float heatmapOpacity;
void main() {
  vec2 c = gl_FragCoord.xy / textureOutputSize.xy;
  float t = texture2D(inputTexture, c).r;
  vec4 d = texture2D(colorRamp, vec2(t, .5));
  gl_FragColor = d * heatmapOpacity;
}`,
      uniforms: [{
        name: "projViewModelMatrix",
        type: "function",
        fn: function(s, o) {
          return Jt(n, o.projViewMatrix, o.modelMatrix);
        }
      }],
      extraCommandProps: r
    });
  }
}, gD = class extends ar {
  constructor() {
    super({
      vert: gi,
      frag: `precision highp float;
uniform sampler2D texture;
uniform vec2 size;
uniform float enableSharpen;
uniform float sharpFactor;
uniform float pixelRatio;
vec2 c;
vec3 d(const in vec3 e, const float f) {
  vec2 h = pixelRatio / size.xy;
  float i = .0;
  vec4 j = texture2D(texture, c + h * vec2(-1., -1.));
  j.rgb = mix(vec3(.0), j.rgb, sign(j.a));
  i += mix(.0, 1., sign(j.a));
  vec4 k = texture2D(texture, c + h * vec2(1.));
  k.rgb = mix(vec3(.0), k.rgb, sign(k.a));
  i += mix(.0, 1., sign(k.a));
  vec4 l = texture2D(texture, c + h * vec2(1., -1.));
  l.rgb = mix(vec3(.0), l.rgb, sign(l.a));
  i += mix(.0, 1., sign(l.a));
  vec4 m = texture2D(texture, c + h * vec2(-1., 1.));
  m.rgb = mix(vec3(.0), m.rgb, sign(m.a));
  i += mix(.0, 1., sign(m.a));
  return e + f * (i * e - j.rgb - l.rgb - m.rgb - k.rgb);
}
void main() {
  c = gl_FragCoord.xy / size;
  vec4 e = texture2D(texture, c);
  if(enableSharpen == 1.) {
    e.rgb = d(e.rgb, sharpFactor);
  }
  gl_FragColor = e;
}`,
      extraCommandProps: {
        viewport: {
          x: 0,
          y: 0,
          width: (t, e) => e.size[0],
          height: (t, e) => e.size[1]
        }
      }
    });
  }
  getMeshCommand(t, e) {
    return this.commands.copy || (this.commands.copy = this.createREGLCommand(t, null, e.getElements())), this.commands.copy;
  }
};
const mD = [];
let vD = class {
  constructor(t, e, r) {
    this._regl = t, this._layer = r, this._viewport = e, this._init();
  }
  _init() {
    this._shader = new qe({
      vert: `attribute vec3 aPosition;
uniform mat4 projMatrix;
uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 positionMatrix;
varying vec4 vWorldPosition;
#include <get_output>
void main() {
  vec4 c = getPosition(aPosition);
  mat4 d = getPositionMatrix();
  vec4 e = modelMatrix * d * c;
  gl_Position = projMatrix * modelViewMatrix * d * c;
  vWorldPosition = e;
}`,
      frag: `precision mediump float;
varying vec4 vWorldPosition;
uniform vec2 fogDist;
uniform vec3 cameraPosition;
uniform float rainDepth;
void main() {
  vec3 c = vec3(vWorldPosition[0] - cameraPosition[0], vWorldPosition[1] - cameraPosition[1], vWorldPosition[2] - cameraPosition[2]);
  float d = length(c);
  float e = clamp(1. - (d - fogDist.x) / (fogDist.y - fogDist.x), .0, 1.);
  if(vWorldPosition[2] < rainDepth) {
    gl_FragColor = vec4(e, .0, .0, 1.);
  } else {
    gl_FragColor = vec4(e, 1., .0, 1.);
  }
}`,
      uniforms: [{
        name: "modelViewMatrix",
        type: "function",
        fn: function(e, r) {
          return Jt(mD, r.viewMatrix, r.modelMatrix);
        }
      }],
      extraCommandProps: {
        viewport: this._viewport
      }
    });
    const t = this._layer.getRenderer().createFBOInfo();
    this._fbo = this._regl.framebuffer(t), this._scene = new ur(), this.renderer = new hn(this._regl);
  }
  render(t, e) {
    return this._resize(), this.renderer.clear({
      color: [0, 0, 0, 1],
      depth: 1,
      framebuffer: this._fbo
    }), this._scene.setMeshes(t), this.renderer.render(this._shader, {
      projMatrix: e.projMatrix,
      viewMatrix: e.viewMatrix,
      cameraPosition: e.cameraPosition,
      fogDist: e.fogDist,
      rainDepth: e.rainDepth
    }, this._scene, this._fbo), this._fbo;
  }
  dispose() {
    this._fbo && this._fbo.destroy(), this._shader && this._shader.dispose();
  }
  _resize() {
    const t = Ei(this._viewport.width.data) ? this._viewport.width.data() : this._viewport.width, e = Ei(this._viewport.height.data) ? this._viewport.height.data() : this._viewport.height;
    !this._fbo || this._fbo.width === t && this._fbo.height === e || this._fbo.resize(t, e);
  }
}, yD = class extends ar {
  constructor() {
    super({
      vert: gi,
      frag: `#if __VERSION__ == 100
#ifdef GL_OES_standard_derivatives
#extension GL_OES_standard_derivatives : enable
#endif
#endif
precision mediump float;
#include <gl2_frag>
varying vec2 vTexCoord;
#ifdef HAS_RAIN
uniform sampler2D ripplesMap;
#endif
#ifdef HAS_SNOW
uniform sampler2D normalMap;
#endif
#ifdef HAS_FOG
uniform vec3 fogColor;
#endif
uniform sampler2D sceneMap;
uniform sampler2D mixFactorMap;
uniform float time;
uniform vec2 resolution;
uniform float snowIntensity;
float c(float a, float b, float w) {
  return a + w * (b - a);
}
#define HASHSCALE1 .1031
#define HASHSCALE3 vec3(.1031, .1030, .0973)
#define HASHSCALE4 vec3(.1031, .1030, .0973, .1099)
float d = .5;
float e = .2;
float f = .5;
float h = 20.;
float i(float p) {
  vec3 j = fract(vec3(p) * HASHSCALE1);
  j += dot(j, j.yzx + 19.19);
  return fract((j.x + j.y) * j.z);
}
vec2 k(vec2 p) {
  vec3 j = fract(vec3(p.xyx) * HASHSCALE3);
  j += dot(j, j.yzx + 19.19);
  return fract((j.xx + j.yz) * j.zy);
}
vec2 l(vec2 m) {
  float x = fract(sin(dot(m.xy, vec2(122.9898, 783.233))) * 43758.5453);
  float y = fract(sin(dot(m.xy, vec2(457.6537, 537.2793))) * 37573.5913);
  return vec2(x, y);
}
vec3 n(vec2 o, float u) {
  vec3 v = vec3(.0);
  o = o * (2. + u);
  float A = e * snowIntensity;
  float B = o.y * (((i(u) * 2. - 1.) * .5 + 1.) * A);
  float C = (f * time);
  o += vec2(B, C);
  vec2 D = k(floor(o) + 31.1759 * u);
  o = fract(o);
  o -= (D * 2. - 1.) * .35;
  o -= .5;
  float r = length(o);
  float E = .05 * (1. + .3 * sin(time * d));
  float F = smoothstep(E, -E, r);
  vec3 G = vec3(F) * D.x;
  return G;
}
vec3 H() {
  vec3 v = vec3(0);
  vec2 o = gl_FragCoord.xy / resolution.xy;
  o *= vec2(resolution.x / resolution.y, 1.);
  float I = h * snowIntensity;
  for(float J = 0.; J < I; J++) {
    v += n(o, J);
  }
  return v;
}
vec3 K(vec4 L, vec4 M, float N) {
  float O = M.b;
  vec3 P = vec3(1.);
  if(N < 1.) {
    float r = c(.5, P.x, O);
    float g = c(.5, P.y, O);
    float b = c(.5, P.z, O);
    return vec3(r, g, b);
  } else {
    float r = c(L.r, P.x, O);
    float g = c(L.g, P.y, O);
    float b = c(L.b, P.z, O);
    return vec3(r, g, b);
  }
}
void main() {
  vec4 L = texture2D(sceneMap, vTexCoord);
  glFragColor = L;
  vec4 Q = texture2D(mixFactorMap, vTexCoord);
#ifdef HAS_RAIN
vec4 R = texture2D(ripplesMap, vTexCoord);
  if(Q.g < 1.) {
    L = mix(L, R, .4);
  }
  glFragColor = L;
#endif
#ifdef HAS_SNOW
vec3 S = H();
  glFragColor = vec4(L.rgb + S, L.a);
#endif
#ifdef HAS_FOG
float T = Q.r;
  vec3 U = mix(fogColor, glFragColor.rgb, T);
  glFragColor = vec4(U, L.a);
#endif
#if __VERSION__ == 100
gl_FragColor = glFragColor;
#endif
}`,
      extraCommandProps: {
        viewport: {
          x: 0,
          y: 0,
          width: (t, e) => e.resolution[0],
          height: (t, e) => e.resolution[1]
        }
      }
    });
  }
};
const _D = [], xD = [0.03, 0.03, 0.03], bD = [], wD = [], TD = [], AD = Yv([], Qo([], 90, 0, 0), [0, 0, 0]);
let MD = class {
  constructor(t, e) {
    this._regl = t, this._viewport = e, this._init();
  }
  _init() {
    this._shader = new qe({
      vert: `#include <gl2_vert>
attribute vec3 aPosition;
attribute vec3 aNormal;
attribute vec2 aTexCoord;
uniform mat4 projMatrix;
uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 positionMatrix;
varying vec2 vTexCoord;
#include <get_output>
void main() {
  vec4 c = getPosition(aPosition);
  mat4 d = getPositionMatrix();
  gl_Position = projMatrix * modelViewMatrix * d * c;
  vTexCoord = aTexCoord;
}`,
      frag: `#if __VERSION__ == 100
#ifdef GL_OES_standard_derivatives
#extension GL_OES_standard_derivatives : enable
#endif
#endif
precision mediump float;
#include <gl2_frag>
varying vec2 vTexCoord;
uniform float rippleRadius;
uniform float density;
uniform float time;
vec3 c(vec2 p) {
  vec3 q = vec3(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)), dot(p, vec2(419.2, 371.9)));
  return fract(sin(q) * 43758.5453);
}
float d(in vec2 x) {
  vec2 e = x * density / 4000.0;
  vec2 p = floor(e);
  vec2 f = fract(e);
  float h = .0;
  for(int i = -4; i <= 4; i++)
    for(int k = -4; k <= 4; k++) {
      vec2 g = vec2(float(k), float(i));
      vec3 l = c(p + g);
      vec2 r = g - f + l.xy;
      float m = sqrt(dot(r, r));
      float n = max(mix(smoothstep(.99, .999, max(cos(m - time * 2. + (l.x + l.y) * 5.), 0.)), 0., m), 0.);
      h += n;
    }
  return h;
}
void main() {
  vec2 u = vTexCoord;
  float A = 24. / (rippleRadius * .01);
  float f = d(A * u) * smoothstep(.0, .4, sin(u.x * 3.151592) * sin(u.y * 3.141592));
  vec3 B = vec3(-dFdx(f), -dFdy(f), -dFdy(f));
  glFragColor = vec4(B, 1.);
#if __VERSION__ == 100
gl_FragColor = glFragColor;
#endif
}`,
      uniforms: [{
        name: "modelViewMatrix",
        type: "function",
        fn: function(t, e) {
          return Jt(_D, e.viewMatrix, e.modelMatrix);
        }
      }],
      extraCommandProps: {
        viewport: this._viewport
      }
    }), this._shader.version = 300, this._fbo = this._regl.framebuffer({
      color: this._regl.texture({
        width: this._viewport.width(),
        height: this._viewport.height(),
        wrap: "clamp",
        mag: "linear",
        min: "linear"
      }),
      depth: !0
    }), this._scene = new ur(), this.renderer = new hn(this._regl);
  }
  _transformRipples(t) {
    const e = t.coordinateToPointAtRes(t.getCenter(), t.getGLRes()), r = t.getGLScale() / t.getGLScale(this._fixZoom), n = ne(wD, r, r, r), s = Jv(n, xD, n), o = pn(TD);
    Nl(o, Qo(bD, 0, 0, 0), [e.x, e.y, 0], s), Jt(o, o, AD), this._mesh.setLocalTransform(o);
  }
  _createRipplesMask(t) {
    this._fixZoom = t.getZoom();
    const e = 800 * Math.pow(2, 16.685648411389433 - this._fixZoom), r = {};
    r.POSITION = [-e, 0, -e, e, 0, -e, -e, 0, e, e, 0, e], r.NORMAL = [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], r.TEXCOORD_0 = [0, 0, 1, 0, 0, 1, 1, 1];
    const n = new er(r, [3, 1, 0, 0, 2, 3], 0, {
      positionAttribute: "POSITION",
      normalAttribute: "NORMAL",
      uv0Attribute: "TEXCOORD_0"
    });
    n.generateBuffers(this._regl);
    const s = new Nr();
    return new tn(n, s);
  }
  render(t, e) {
    return this._resize(), this.renderer.clear({
      color: [0, 0, 0, 1],
      depth: 1,
      framebuffer: this._fbo
    }), this._mesh = this._mesh || this._createRipplesMask(t), this._scene.setMeshes(this._mesh), this._transformRipples(t), this.renderer.render(this._shader, {
      projMatrix: e.projMatrix,
      viewMatrix: e.viewMatrix,
      time: e.time,
      rippleRadius: e.rippleRadius,
      density: e.density
    }, this._scene, this._fbo), this._fbo;
  }
  dispose() {
    this._fbo && this._fbo.destroy(), this._shader && this._shader.dispose();
  }
  _resize() {
    const t = Ei(this._viewport.width.data) ? this._viewport.width.data() : this._viewport.width, e = Ei(this._viewport.height.data) ? this._viewport.height.data() : this._viewport.height;
    !this._fbo || this._fbo.width === t && this._fbo.height === e || this._fbo.resize(t, e);
  }
};
var ax = `attribute vec3 aPosition;
uniform mat4 positionMatrix;
uniform mat4 projViewModelMatrix;
#ifdef HAS_VIDEO
attribute vec2 aTexCoord;
varying vec2 uv;
#endif
#include <get_output>
void main() {
  mat4 c = getPositionMatrix();
  vec4 d = c * getPosition(aPosition);
  gl_Position = projViewModelMatrix * d;
#ifdef HAS_VIDEO
uv = aTexCoord;
#endif
}`;
const lx = [0, 0, 0, 1];
let hx = class {
  constructor(t, e) {
    this.regl = t, this._viewport = e, this.renderer = new hn(t), this._init();
  }
  _init() {
    this._maskColorFbo = this.renderer.regl.framebuffer({
      color: this.renderer.regl.texture({
        width: 1,
        height: 1,
        wrap: "clamp",
        mag: "linear",
        min: "linear"
      }),
      depth: !0
    }), this._maskModeFbo = this.renderer.regl.framebuffer({
      color: this.renderer.regl.texture({
        width: 1,
        height: 1,
        wrap: "clamp",
        mag: "nearest",
        min: "nearest"
      }),
      depth: !0
    });
    const t = [{
      name: "projViewModelMatrix",
      type: "function",
      fn: (e, r) => Jt([], r.projViewMatrix, r.modelMatrix)
    }];
    this._maskColorShader = new qe({
      vert: ax,
      frag: `#ifdef GL_ES
precision highp float;
#endif
uniform vec4 maskColor;
#ifdef HAS_VIDEO
uniform sampler2D maskTexture;
varying vec2 uv;
#endif
void main() {
  
#ifdef HAS_VIDEO
gl_FragColor = texture2D(maskTexture, uv);
  gl_FragColor.a = maskColor.a;
#else
gl_FragColor = maskColor;
#endif
}`,
      uniforms: t,
      extraCommandProps: {
        viewport: this._viewport
      }
    }), this._maskModeShader = new qe({
      vert: ax,
      frag: `#ifdef GL_ES
precision highp float;
#endif
uniform float maskMode;
#ifdef HAS_MASK_FLAT
uniform float flatHeight;
#endif
#ifdef HAS_MASK_COLOR
uniform vec2 heightRange;
#endif
void main() {
  
#if defined(HAS_MASK_FLAT)
gl_FragColor = vec4(maskMode, flatHeight, .0, 1.);
#elif defined(HAS_MASK_COLOR)
gl_FragColor = vec4(maskMode, .0, heightRange.x, heightRange.y);
#else
gl_FragColor = vec4(maskMode, .0, .0, .0);
#endif
}`,
      uniforms: t,
      extraCommandProps: {
        viewport: this._viewport
      }
    }), this._scene = new ur();
  }
  render(t, e) {
    this._resize(), this.renderer.clear({
      color: lx,
      depth: 1,
      framebuffer: this._maskColorFbo
    }), this.renderer.clear({
      color: lx,
      depth: 1,
      framebuffer: this._maskModeFbo
    }), this._scene.setMeshes(t);
    const r = {
      projViewMatrix: e
    };
    return this.renderer.render(this._maskColorShader, r, this._scene, this._maskColorFbo), this.renderer.render(this._maskModeShader, r, this._scene, this._maskModeFbo), {
      colorExtent: this._maskColorFbo,
      modeExtent: this._maskModeFbo
    };
  }
  _resize() {
    const t = Ei(this._viewport.width) ? this._viewport.width() : this._viewport.width.data(), e = Ei(this._viewport.height) ? this._viewport.height() : this._viewport.height.data();
    !this._maskColorFbo || this._maskColorFbo.width === t && this._maskColorFbo.height === e || (this._maskColorFbo.resize(t, e), this._maskModeFbo.resize(t, e));
  }
  dispose() {
    this._maskColorFbo && (this._maskColorFbo.destroy(), delete this._maskColorFbo), this._maskModeFbo && (this._maskModeFbo.destroy(), delete this._maskModeFbo), this._maskColorShader && (this._maskColorShader.dispose(), delete this._maskColorShader), this._maskModeShader && (this._maskModeShader.dispose(), delete this._maskModeShader);
  }
};
const ux = [], ug = {
  width: 4,
  type: "float"
};
let SD = class {
  constructor(t, e, r) {
    this._regl = t, this.joints = e, this.inverseBindMatrices = [], this.jointMatrices = [], this.jointData = new Float32Array(16 * e.length);
    for (let n = 0; n < e.length; ++n) this.inverseBindMatrices.push(new Float32Array(r.buffer, r.byteOffset + 16 * Float32Array.BYTES_PER_ELEMENT * n, 16)), this.jointMatrices.push(new Float32Array(this.jointData.buffer, 16 * Float32Array.BYTES_PER_ELEMENT * n, 16));
    this.jointTextureSize = [4, 6];
  }
  update(t, e, r) {
    Is(ux, t);
    for (let s = 0; s < this.joints.length; ++s) {
      const o = this.jointMatrices[s];
      Jt(o, ux, e[this.joints[s].nodeIndex]), Jt(o, o, this.inverseBindMatrices[s]);
    }
    ug.height = this.joints.length, ug.data = this.jointData;
    const n = ug;
    return r ? r(n) : r = this._regl.texture(n), r;
  }
};
const CD = [0, 0, 0], PD = [0, 0, 0, 1], ED = [1, 1, 1], OD = [];
let cg = class {
  constructor(t = [0, 0, 0], e = [0, 0, 0, 1], r = [1, 1, 1]) {
    this.translation = t, this.rotation = e, this.scale = r;
  }
  getMatrix() {
    return Nl(OD, this.rotation, this.translation, this.scale);
  }
  decompose(t) {
    MR(this.translation, t), CR(this.rotation, t), SR(this.scale, t);
  }
  update(t) {
    t && (t.translation && !dl(t.translation, CD) && Jn(this.translation, t.translation), t.rotation && !HR(t.rotation, PD) && QA(this.rotation, t.rotation), t.scale && !dl(t.scale, ED) && Jn(this.scale, t.scale));
  }
}, kD = class {
  constructor(t) {
    this._init(t);
  }
  _init(t) {
    this.bbox = t.bbox, this.geometry = t.geometry, this.nodeMatrix = t.nodeMatrix, this.materialInfo = t.materialInfo, this.extraInfo = t.extraInfo, this.animationMatrix = t.animationMatrix, this.morphWeights = t.morphWeights, this.skin = t.skin, this.nodeIndex = t.nodeIndex;
  }
  copyEdgeGeometry() {
    this.copyGeometry || (this.copyGeometry = this._copyEdgeGeometry(this.geometry));
  }
  createCopyBarycentric() {
    this.copyGeometry && !this.copyGeometry.data.aBarycentric && (this.copyGeometry.buildUniqueVertex(), this.copyGeometry.createBarycentric("aBarycentric"));
  }
  _copyEdgeGeometry(t) {
    const e = t.data, r = t.indices || t.elements, n = {};
    for (const l in e) if (l === t.desc.positionAttribute) if (zr(e[l])) n[l] = e[l].slice();
    else if (e[l].buffer && e[l].buffer.destroy) n[l] = {
      buffer: e[l].buffer
    }, zr(e[l].array) && (n[l].array = e[l].array.slice());
    else {
      const h = t._getAttributeData(l);
      n[l] = l !== t.desc.positionAttribute ? h : h.slice();
    }
    const s = r.length !== void 0 ? r.slice() : r, o = JSON.parse(JSON.stringify(t.desc)), a = new DI(n, s, 0, o);
    return a.properties = t.properties, a;
  }
}, ds = 0;
const RD = [];
let ID = class {
  constructor(t, e) {
    this.gltf = t, this.regl = e, this.geometries = [], e && (this._emptyTexture = e.texture({
      width: 2,
      height: 2
    }));
  }
  getMeshesInfo() {
    return this.gltf ? this.geometries.length ? this.geometries : (this._createTextures(this.gltf.textures), this._createSkins(this.gltf.skins), this.gltf.scenes[0].nodes.forEach((t) => {
      this._parserNode(t, this.geometries);
    }), this._checkBaseColorFactor(), this.geometries) : null;
  }
  getGLTFBBox() {
    if (!this.gltf) return null;
    const t = this.geometries;
    if (!t || !t.length) return null;
    const e = [1 / 0, 1 / 0, 1 / 0], r = [-1 / 0, -1 / 0, -1 / 0];
    for (let n = 0; n < t.length; n++) {
      const s = t[n].bbox, o = s.min, a = s.max;
      o[0] < e[0] && (e[0] = o[0]), o[1] < e[1] && (e[1] = o[1]), o[2] < e[2] && (e[2] = o[2]), a[0] > r[0] && (r[0] = a[0]), a[1] > r[1] && (r[1] = a[1]), a[2] > r[2] && (r[2] = a[2]);
    }
    return {
      min: e,
      max: r
    };
  }
  _createSkins(t) {
    if (t) {
      this._skinMap = {};
      for (let e = 0; e < t.length; e++) {
        const r = t[e];
        r.joints = r.joints.map((n) => this.gltf.nodes[n]), this._skinMap[e] = new SD(this.regl, r.joints, r.inverseBindMatrices.array), delete r.inverseBindMatrices;
      }
    }
  }
  _createTextures(t) {
    if (t) {
      this._textureMap = {};
      for (let e = 0; e < t.length; e++) {
        const r = t[e];
        this._textureMap[e] || (this._textureMap[e] = this._toTexture(r), delete r.image);
      }
    }
  }
  _checkBaseColorFactor() {
    if (!this._checkBaseColorFactorAlpha()) for (let t = 0; t < this.geometries.length; t++) {
      const e = this.geometries[t].materialInfo.baseColorFactor;
      e && e[3] === 0 && (e[3] = 1);
    }
  }
  _checkBaseColorFactorAlpha() {
    for (let t = 0; t < this.geometries.length; t++) {
      const e = this.geometries[t].materialInfo.baseColorFactor;
      if (e && e[3] > 0) return !0;
    }
    return !1;
  }
  dispose() {
    this._emptyTexture && this._emptyTexture.destroy();
    const t = this.getMeshesInfo();
    if (t) {
      t.forEach((e) => {
        e.geometry.dispose();
        for (const r in e.materialInfo) {
          const n = e.materialInfo[r];
          n.destroy && !n[pr] && n.destroy();
        }
      });
      for (const e in this._textureMap) {
        const r = this._textureMap[e];
        r.destroy && !r[pr] && r.destroy();
      }
      delete this.gltf;
    }
  }
  updateAnimation(t, e, r, n, s, o, a, l) {
    const h = this.gltf;
    if (!h || (ds = h.animations ? bs.getAnimationTimeSpan(h, n) : null, !ds)) return;
    t -= s;
    let u = 0;
    u = e || !e && this._isFirstLoop(t, r, n, s) ? t * r * 1e-3 % (ds.max - ds.min) + ds.min : t * r * 1e-3 + ds.min, h.scenes[0].nodes.forEach((c) => {
      this._updateNodeMatrix(n, u, c, null, o, l);
    });
    for (const c in this.gltf.nodes) {
      const f = this.gltf.nodes[c], d = o[f.nodeIndex];
      if (f.skin && d) {
        const p = f.skin.update(d, o, a[f.nodeIndex] && a[f.nodeIndex].jointTexture);
        a[f.nodeIndex] || (a[f.nodeIndex] = {
          jointTextureSize: f.skin.jointTextureSize,
          numJoints: f.skin.joints.length
        }), a[f.nodeIndex].jointTexture = p;
      }
    }
  }
  _isFirstLoop(t, e, r, n) {
    const s = this.gltf;
    return !n || !s || (ds = s.animations ? bs.getAnimationTimeSpan(s, r) : null, t * e * 1e-3 / (ds.max - ds.min) < 1);
  }
  hasSkinAnimation() {
    return !!this._isAnimation;
  }
  _updateNodeMatrix(t, e, r, n, s, o) {
    r.trs && (o ? o.indexOf(Number(r.nodeIndex)) > -1 && this._updateNodeTRS(r, e, t) : this._updateNodeTRS(r, e, t)), s[r.nodeIndex] = n ? Jt(s[r.nodeIndex] || [], n, r.matrix || r.trs.getMatrix()) : Hi(s[r.nodeIndex] || [], r.matrix || r.trs.getMatrix()), r.children && r.children.forEach((a) => {
      this._updateNodeMatrix(t, e, a, s[r.nodeIndex], s, o);
    });
  }
  _updateNodeTRS(t, e, r) {
    const n = bs.getAnimationClip(this.gltf, Number(t.nodeIndex), e, r);
    n.weights && this._updateMorph(t, n.weights), t.trs.update(n);
  }
  _updateMorph(t, e) {
    const r = e.length;
    if (!t.influencesList) {
      t.influencesList = [];
      for (let o = 0; o < r; o++) t.influencesList[o] = [o, 0];
    }
    const n = t.influencesList;
    for (let o = 0; o < n.length; o++) {
      const a = n[o];
      a[0] = o, a[1] = e[o];
    }
    n.sort(FD);
    const s = [];
    for (let o = 0; o < 8; o++) s[o] = [o, 0];
    for (let o = 0; o < 8; o++) o < r && n[o][1] ? (s[o][0] = n[o][0], s[o][1] = n[o][1]) : (s[o][0] = Number.MAX_SAFE_INTEGER, s[o][1] = 0);
    s.sort(DD), t.geometries.forEach((o) => {
      const a = o.properties.morphTargets;
      for (let l = 0; l < 8; l++) {
        const h = s[l], u = h[0], c = h[1];
        u !== Number.MAX_SAFE_INTEGER && c ? (o.updateData("POSITION" + l, a["POSITION_" + u].array), o.properties.morphWeights[l] = c) : o.properties.morphWeights[l] = 0;
      }
    });
  }
  _parserNode(t, e, r) {
    if (t.isParsed) return;
    t.nodeMatrix = t.nodeMatrix || pn([]), t.localMatrix = t.localMatrix || pn([]), t.matrix ? (t.trs = new cg(), t.trs.decompose(t.matrix)) : t.trs = new cg(t.translation, t.rotation, t.scale), t.localMatrix = t.trs.getMatrix(), r ? Jt(t.nodeMatrix, r, t.matrix || t.localMatrix) : Hi(t.nodeMatrix, t.matrix || t.localMatrix);
    const n = t.nodeMatrix;
    if (t.children) for (let s = 0; s < t.children.length; s++)
      this._parserNode(t.children[s], e, n);
    if (Oo(t.skin)) {
      this._isAnimation = !0;
      const s = t.skin;
      t.trs = new cg(), t.skin = this._skinMap[s];
    }
    Oo(t.mesh) && (t.mesh = this.gltf.meshes[t.mesh], t.mesh.node = t, t.geometries = t.geometries || [], t.mesh.primitives.forEach((s) => {
      const o = this._createMaterialInfo(s.material), a = function(c, f, d) {
        const p = c.attributes, g = p.COLOR_0;
        if (g && g.array instanceof Float32Array) {
          const y = new Uint8Array(g.array.length);
          for (let x = 0; x < y.length; x++) y[x] = Math.round(255 * g.array[x]);
          g.array = y;
        } else if (g && (g.array instanceof Uint16Array || g.array instanceof Int16Array || g.array instanceof Uint32Array || g.array instanceof Int32Array)) {
          const y = new Uint8Array(g.array);
          g.array = y;
        }
        d && p.TEXCOORD_0 && !p.TEXCOORD_0 && (p.TEXCOORD_1 = p.TEXCOORD_0);
        const m = {};
        for (const y in p) m[y] = $n({}, p[y]), f && (m[y].buffer = CI(f, p[y], {
          dimension: p[y].itemSize
        }));
        if (c.morphTargets) {
          const y = id(m.POSITION) ? m.POSITION.itemSize * m.POSITION.count : m.POSITION.array.length;
          for (let x = 0; x < 8; x++) m["POSITION" + x] || (m["POSITION" + x] = new Float32Array(y).fill(0));
          for (let x = 0; x < 4; x++) {
            const w = m.NORMAL.array ? m.NORMAL.array.length : m.NORMAL.length;
            m["NORMAL" + x] || (m["NORMAL" + x] = new Float32Array(w).fill(0));
          }
        }
        let v = c.indices;
        v && v.bufferView === void 0 && v.array && (v = v.array);
        const _ = new er(m, v, 0, {
          primitive: Ds(c.mode) ? mM(c.mode) : c.mode,
          positionAttribute: "POSITION",
          normalAttribute: "NORMAL",
          uv0Attribute: "TEXCOORD_0",
          uv1Attribute: "TEXCOORD_1",
          color0Attribute: "COLOR_0"
        });
        return c.morphTargets && (_.properties.morphWeights = []), c.mode > 3 && !_.data.NORMAL && _.createNormal("NORMAL"), _;
      }(s, this.regl, o.occlusionTexture);
      a.properties.morphTargets = s.morphTargets, t.geometries.push(a);
      let l = a.boundingBox.copy();
      l = l.transform(pn(RD), n);
      const h = {
        geometry: a,
        bbox: l,
        nodeMatrix: n,
        materialInfo: o,
        extraInfo: this._createExtralInfo(s.material),
        animationMatrix: t.trs.getMatrix(),
        morphWeights: t.weights,
        nodeIndex: t.nodeIndex
      };
      t.skin && (h.skin = {
        jointTextureSize: [4, 6],
        numJoints: t.skin.joints.length,
        jointTexture: t.skin.jointTexture
      });
      const u = new kD(h);
      e.push(u);
    })), t.isParsed = !0;
  }
  _createMaterialInfo(t) {
    const e = {};
    if (this.gltf.materials && this.gltf.materials[t]) {
      const r = this.gltf.materials[t], n = r.pbrMetallicRoughness;
      if (n) {
        const o = n.metallicRoughnessTexture, a = n.baseColorTexture;
        a && (e.baseColorTexture = this._getTexture(a), a.KHR_texture_transform && (e.khr_offset = a.KHR_texture_transform.offset || [0, 0], e.khr_rotation = a.KHR_texture_transform.rotation || 0, e.khr_scale = a.KHR_texture_transform.scale || [1, 1])), n.baseColorFactor && (e.baseColorFactor = n.baseColorFactor), o ? e.metallicRoughnessTexture = this._getTexture(o) : (e.metallicFactor = Oo(n.metallicFactor) ? n.metallicFactor : 1, e.roughnessFactor = Oo(n.roughnessFactor) ? n.roughnessFactor : 1);
      }
      const s = r.extensions;
      if (s && s.KHR_materials_pbrSpecularGlossiness) {
        const o = s.KHR_materials_pbrSpecularGlossiness;
        e.name = "pbrSpecularGlossiness";
        for (const a in o) e[a] = Oo(o[a].index) ? this._getTexture(o[a]) : o[a];
      }
      r.normalTexture && (e.normalTexture = this._getTexture(r.normalTexture)), r.occlusionTexture && (e.occlusionTexture = this._getTexture(r.occlusionTexture)), r.emissiveTexture && (e.emissiveTexture = this._getTexture(r.emissiveTexture)), r.emissiveFactor && (e.emissiveFactor = r.emissiveFactor), e.alphaCutoff = r.alphaCutoff || 0.5;
    }
    return e;
  }
  _createExtralInfo(t) {
    const e = {};
    if (this.gltf.materials && this.gltf.materials[t]) {
      const r = this.gltf.materials[t];
      e.doubleSided = r.doubleSided, e.alphaMode = r.alphaMode || "OPAQUE";
    }
    return e;
  }
  _getTexture(t) {
    const e = t.extensions, r = t.index;
    if (!Oo(r)) return null;
    e && e.KHR_texture_transform && (t.KHR_texture_transform = e.KHR_texture_transform);
    const n = this._textureMap[r];
    return n.texInfo = t, n;
  }
  _toTexture(t) {
    if (!t) return this._emptyTexture;
    const e = t.sampler || {};
    return new Bd({
      width: t.image.width,
      height: t.image.height,
      data: t.image.array,
      mag: TI(e.magFilter) || "linear",
      min: MI(e.minFilter) || "linear",
      wrapS: Y_(e.wrapS) || "repeat",
      wrapT: Y_(e.wrapT) || "repeat"
    });
  }
};
function DD(i, t) {
  return i[0] - t[0];
}
function FD(i, t) {
  return Math.abs(t[1]) - Math.abs(i[1]);
}
function LD(i, t) {
  const { fetchOptions: e, gltfLoaderOptions: r, urlModifier: n } = t, s = r || {};
  s.urlModifier = n;
  const o = i.lastIndexOf("/"), a = i.slice(0, o), l = i.slice(i.lastIndexOf(".")).toLowerCase();
  return l === ".gltf" ? Ts.getJSON(i, e, n).then((h) => cx(a, h, s)) : l === ".glb" ? Ts.getArrayBuffer(i, e, n).then((h) => cx(a, {
    buffer: h.data,
    byteOffset: 0
  }, s)) : null;
}
function zD(i, t) {
  return new ID(i, t);
}
function cx(i, t, e) {
  return new bs(i, t, e).load();
}
const fx = [-1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, 1], ND = [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], dx = [3, 1, 0, 0, 2, 3], px = [0, 0, 1, 0, 0, 1, 1, 1], bc = {
  vertices: [-0.8111000061035156, 2.0102999210357666, -0.8111000061035156, 0, 0.010300000198185444, -0, -0.8111000061035156, 2.0102999210357666, 0.8111000061035156, -0.8111000061035156, 2.0102999210357666, 0.8111000061035156, 0, 0.010300000198185444, -0, 0.8111000061035156, 2.0102999210357666, 0.8111000061035156, 0.8111000061035156, 2.0102999210357666, 0.8111000061035156, 0, 0.010300000198185444, -0, 0.8111000061035156, 2.0102999210357666, -0.8111000061035156, 0.8111000061035156, 2.0102999210357666, -0.8111000061035156, 0, 0.010300000198185444, -0, -0.8111000061035156, 2.0102999210357666, -0.8111000061035156, 0.8111000061035156, 2.0102999210357666, -0.8111000061035156, -0.8111000061035156, 2.0102999210357666, -0.8111000061035156, 0, 2.9419000148773193, -0, 0.8111000061035156, 2.0102999210357666, 0.8111000061035156, 0.8111000061035156, 2.0102999210357666, -0.8111000061035156, 0, 2.9419000148773193, -0, -0.8111000061035156, 2.0102999210357666, -0.8111000061035156, -0.8111000061035156, 2.0102999210357666, 0.8111000061035156, 0, 2.9419000148773193, -0, -0.8111000061035156, 2.0102999210357666, 0.8111000061035156, 0.8111000061035156, 2.0102999210357666, 0.8111000061035156, 0, 2.9419000148773193, -0],
  normals: [-0.9267006516456604, -0.3758002817630768, -0, -0.9267006516456604, -0.3758002817630768, -0, -0.9267006516456604, -0.3758002817630768, -0, 0, -0.3758002817630768, 0.9267006516456604, 0, -0.3758002817630768, 0.9267006516456604, 0, -0.3758002817630768, 0.9267006516456604, 0.9267006516456604, -0.3758002817630768, -0, 0.9267006516456604, -0.3758002817630768, -0, 0.9267006516456604, -0.3758002817630768, -0, 0, -0.3758002817630768, -0.9267006516456604, 0, -0.3758002817630768, -0.9267006516456604, 0, -0.3758002817630768, -0.9267006516456604, 0, 0.656676173210144, -0.7541726231575012, 0, 0.656676173210144, -0.7541726231575012, 0, 0.656676173210144, -0.7541726231575012, 0.7541726231575012, 0.656676173210144, -0, 0.7541726231575012, 0.656676173210144, -0, 0.7541726231575012, 0.656676173210144, -0, -0.7541726231575012, 0.656676173210144, -0, -0.7541726231575012, 0.656676173210144, -0, -0.7541726231575012, 0.656676173210144, -0, 0, 0.656676173210144, 0.7541726231575012, 0, 0.656676173210144, 0.7541726231575012, 0, 0.656676173210144, 0.7541726231575012],
  indices: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]
}, HD = ["cube", "plane", "pyramid"], Ao = {
  cube: {
    meshes: [{
      primitives: [{
        attributes: {
          POSITION: {
            array: new Int8Array([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1])
          },
          NORMAL: {
            array: new Int8Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1])
          },
          TEXCOORD_0: {
            array: new Int8Array([0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1])
          }
        },
        indices: new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]),
        mode: 4
      }]
    }],
    scenes: [{
      nodes: [{
        mesh: 0,
        scale: [60, 60, 60]
      }]
    }]
  },
  "plane-cube": {
    meshes: [{
      primitives: [{
        attributes: {
          POSITION: {
            array: new Int8Array(fx)
          },
          TEXCOORD_0: {
            array: new Int8Array(px)
          }
        },
        indices: new Uint16Array(dx),
        mode: 4
      }]
    }],
    scenes: [{
      nodes: [{
        mesh: 0,
        scale: [60, 60, 60],
        translation: [0, -60, 0]
      }, {
        mesh: 0,
        scale: [60, 60, 60],
        translation: [0, 60, 0]
      }, {
        mesh: 0,
        scale: [60, 60, 60],
        translation: [60, 0, 0],
        rotation: [0, 0, 0.7071067811865475, 0.7071067811865476]
      }, {
        mesh: 0,
        scale: [60, 60, 60],
        translation: [-60, 0, 0],
        rotation: [0, 0, 0.7071067811865475, 0.7071067811865476]
      }, {
        mesh: 0,
        scale: [60, 60, 60],
        translation: [0, 0, 60],
        rotation: [0.7071067811865475, 0, 0, 0.7071067811865476]
      }, {
        mesh: 0,
        scale: [60, 60, 60],
        translation: [0, 0, -60],
        rotation: [0.7071067811865475, 0, 0, 0.7071067811865476]
      }]
    }]
  },
  plane: {
    meshes: [{
      primitives: [{
        attributes: {
          POSITION: {
            array: new Int8Array(fx)
          },
          NORMAL: {
            array: new Int8Array(ND)
          },
          TEXCOORD_0: {
            array: new Int8Array(px)
          }
        },
        indices: new Uint16Array(dx),
        mode: 4
      }]
    }],
    scenes: [{
      nodes: [{
        mesh: 0,
        scale: [60, 60, 60]
      }]
    }]
  },
  pyramid: {
    meshes: [{
      primitives: [{
        attributes: {
          POSITION: {
            array: new Float32Array(bc.vertices)
          },
          NORMAL: {
            array: new Float32Array(bc.normals)
          },
          TEXCOORD_0: {
            array: new Float32Array(bc.uv)
          }
        },
        indices: new Uint16Array(bc.indices),
        mode: 4
      }]
    }],
    scenes: [{
      nodes: [{
        mesh: 0,
        scale: [60, 60, 60]
      }]
    }]
  }
};
let BD = class {
  constructor(t, e) {
    this.regl = t, this.resourceMap = {}, this.options = e || {};
  }
  getGLTF(t) {
    return this.resourceMap[t];
  }
  loginGLTF(t, e) {
    if (this.resourceMap[t]) this.resourceMap[t].refCount += 1;
    else {
      if (Ao[t]) {
        const r = function(n) {
          let s = null;
          return Ao[n] && (s = {
            meshes: Ao[n].meshes
          }, s.scenes = JSON.parse(JSON.stringify(Ao[n].scenes))), s;
        }(t);
        this.resourceMap[t] = this._exportGLTFResource(r, t, !1);
      } else this.resourceMap[t] = e ? e(t).then((r) => (this.resourceMap[t] = this._exportGLTFResource(r, t), this.resourceMap[t])) : this._loadGLTFModel(t);
      this.resourceMap[t].refCount = 1;
    }
  }
  logoutGLTF(t) {
    if (this.resourceMap[t] && (this.resourceMap[t].refCount -= 1, this.resourceMap[t].refCount < 1)) {
      const e = this.resourceMap[t].resources;
      if (e) for (let r = 0; r < e.length; r++) e[r].geometry.dispose(), e[r].copyGeometry && e[r].copyGeometry.dispose(), e[r].material && e[r].material.dispose();
      this.resourceMap[t].gltfPack && this.resourceMap[t].gltfPack.dispose(), delete this.resourceMap[t];
    }
  }
  isSimpleModel(t) {
    return Ao[t];
  }
  addSimpleModel(t, e) {
    (function(r, n) {
      typeof r == "string" && HD.indexOf(r) < 0 && (Ao[r] = n);
    })(t, e);
  }
  removeSimpleModel(t) {
    delete Ao[t];
  }
  _exportGLTFResource(t, e, r = !0) {
    if (!t) return null;
    const n = zD(t, r ? this.regl : null), s = n.getMeshesInfo();
    return {
      bbox: n.getGLTFBBox(),
      gltfPack: n,
      resources: s,
      json: t.json,
      refCount: this.resourceMap[e] ? this.resourceMap[e].refCount : 0
    };
  }
  fetchGLTF(t) {
    return LD(t, this.options).then((e) => e);
  }
  _loadGLTFModel(t) {
    return this.fetchGLTF(t).then((e) => (this.resourceMap[t] = this._exportGLTFResource(e, t), this.resourceMap[t]));
  }
};
const Tf = function() {
  const i = [0, 0, 0], t = 90 * Math.PI / 180, e = [0, 0, 0, 0], r = new Array(16);
  return function(n, s, o, a, l, h) {
    const u = [Eo([], i, [1, 0, 0], h && h[0] || [0, -1, 0]), Eo([], i, [-1, 0, 0], h && h[1] || [0, -1, 0]), Eo([], i, [0, 1, 0], h && h[2] || [0, 0, 1]), Eo([], i, [0, -1, 0], h && h[3] || [0, 0, -1]), Eo([], i, [0, 0, 1], h && h[4] || [0, -1, 0]), Eo([], i, [0, 0, -1], h && h[5] || [0, -1, 0])], c = {
      context: {
        viewMatrix: function(f, d, p) {
          return u[p];
        },
        projMatrix: PR(r, t, 1, 0.5, 1.1)
      }
    };
    return s && (c.framebuffer = s.faces ? function(f, d, p) {
      return s.faces[p];
    } : s), n(c)(6, (f, d, p) => {
      const g = {
        color: e,
        depth: 1
      };
      s && (g.framebuffer = s.faces ? s.faces[p] : s), n.clear(g), o(a), l && l();
    }), s;
  };
}();
var Qs = {
  vertices: [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1],
  textures: [1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0],
  indices: [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]
}, Af = `#define SHADER_NAME CUBE_MAP
attribute vec3 aPosition;
varying vec3 vWorldPos;
uniform mat4 projMatrix;
uniform mat4 viewMatrix;
void main() {
  vWorldPos = aPosition;
  gl_Position = projMatrix * viewMatrix * vec4(vWorldPos, 1.);
}`, jD = `precision highp float;
#define PI 3.1415926
varying vec3 vWorldPos;
uniform sampler2D equirectangularMap;
const vec2 c = vec2(.1591, .3183);
vec2 d(vec3 e) {
  vec2 f = vec2(atan(e.y, e.x), asin(e.z));
  f *= c;
  f += .5;
  return f;
}
vec3 h(const in vec4 i, const in float j) {
  return j * i.rgb * i.a;
}
vec4 k(const in vec3 i, const in float j) {
  vec4 l;
  vec3 m = i / j;
  l.a = clamp(max(max(m.r, m.g), max(m.b, 1e-6)), .0, 1.);
  l.a = ceil(l.a * 255.) / 255.;
  l.rgb = m / l.a;
  return l;
}
void main() {
  vec2 f = d(normalize(vWorldPos));
  vec4 i = texture2D(equirectangularMap, f);
#ifdef INPUT_RGBM
gl_FragColor = i;
#else
gl_FragColor = vec4(h(i, 7.), 1.);
#endif
}`;
/*!
 * from claygl
 * https://github.com/pissang/claygl/
 * License: BSD-2-Clause
 */
function GD(i, t) {
  const e = i[0], r = i[1], n = i[2];
  return t === 0 ? 1 : t === 1 ? e : t === 2 ? r : t === 3 ? n : t === 4 ? e * n : t === 5 ? r * n : t === 6 ? e * r : t === 7 ? 3 * n * n - 1 : e * e - r * r;
}
const VD = {
  px: [2, 1, 0, -1, -1, 1],
  nx: [2, 1, 0, 1, -1, -1],
  py: [0, 2, 1, 1, -1, -1],
  ny: [0, 2, 1, 1, 1, 1],
  pz: [0, 1, 2, -1, -1, -1],
  nz: [0, 1, 2, 1, -1, 1]
}, gx = ["px", "nx", "py", "ny", "pz", "nz"], wM = sd.compile(bM);
function mx(i, t, e) {
  const r = i({
    frag: wM,
    vert: Af,
    attributes: {
      aPosition: Qs.vertices
    },
    uniforms: {
      projMatrix: i.context("projMatrix"),
      viewMatrix: i.context("viewMatrix"),
      cubeMap: t,
      environmentExposure: 1,
      bias: 0,
      size: e,
      hsv: [0, 0, 0]
    },
    elements: Qs.indices
  }), n = [], s = i.framebuffer(e);
  return Tf(i, s, r, {
    size: e
  }, function() {
    const o = i.read();
    n.push(new o.constructor(o));
  }), r.destroy(), s.destroy(), n;
}
const vx = new Int8Array([-1, 1, 0, -1, -1, 0, 1, 1, 0, 1, -1, 0]), UD = new Int8Array([0, 1, 0, 0, 1, 1, 1, 0]);
function TM(i, t, e, r) {
  t = t || 256;
  const n = AM(e = e || 1024, r = r || 256), s = i.texture({
    data: n,
    width: r,
    height: e,
    min: "nearest",
    mag: "nearest"
  }), o = i.buffer(vx), a = i.buffer(UD), l = i.framebuffer({
    radius: t,
    colorType: "uint8",
    colorFormat: "rgba",
    min: "linear",
    mag: "linear"
  }), h = i({
    frag: `precision highp float;
varying vec2 vTexCoords;
uniform sampler2D distributionMap;
const float c = 3.14159265359;
vec4 d(float a, float b) {
  a *= 65535.;
  b *= 65535.;
  vec4 rgba;
  rgba[0] = mod(a, 255.);
  rgba[1] = (a - rgba[0]) / 65280.0;
  rgba[2] = mod(b, 255.);
  rgba[3] = (b - rgba[2]) / 65280.0;
  return rgba;
}
vec3 e(float f, vec3 h, float i) {
  vec4 j = texture2D(distributionMap, vec2(i, f));
  vec3 k = j.xyz;
  float l = sign(j.w - .5);
  float m = sign(j.w - clamp(l, .0, 1.) * 200.0 / 255. - .15);
  k.x *= l;
  k.y *= m;
  vec3 n = abs(h.z) < .999 ? vec3(.0, .0, 1.) : vec3(1., .0, .0);
  vec3 o = normalize(cross(n, h));
  vec3 u = cross(h, o);
  vec3 v = o * k.x + u * k.y + h * k.z;
  return normalize(v);
}
float A(float B, float i) {
  float a = i;
  float C = (a * a) / 2.;
  float D = B;
  float E = B * (1. - C) + C;
  return D / E;
}
float F(float B, float G, float i) {
  float I = A(B, i);
  float J = A(G, i);
  return J * I;
}
vec2 K(float B, float i) {
  vec3 L;
  L.x = sqrt(1. - B * B);
  L.y = .0;
  L.z = B;
  float M = .0;
  float O = .0;
  vec3 h = vec3(.0, .0, 1.);
  const int P = 1024;
  for(int Q = 0; Q < P; ++Q) {
    vec3 k = e(float(Q) / float(P), h, i);
    vec3 R = normalize(2. * dot(L, k) * k - L);
    float G = max(R.z, .0);
    float S = max(k.z, .0);
    float T = max(dot(L, k), .0);
    float B = max(dot(h, L), .0);
    if(G > .0) {
      float U = F(B, G, i);
      float W = (U * T) / (S * B);
      float X = pow(1. - T, 5.);
      M += (1. - X) * W;
      O += X * W;
    }
  }
  M /= float(P);
  O /= float(P);
  return vec2(M, O);
}
void main() {
  vec2 Y = K(vTexCoords.x, vTexCoords.y);
  gl_FragColor = d(Y.x, Y.y);
}`,
    vert: `attribute vec3 aPosition;
attribute vec2 aTexCoord;
varying vec2 vTexCoords;
void main() {
  vTexCoords = aTexCoord;
  gl_Position = vec4(aPosition, 1.);
}`,
    attributes: {
      aPosition: {
        buffer: o
      },
      aTexCoord: {
        buffer: a
      }
    },
    uniforms: {
      distributionMap: s
    },
    framebuffer: l,
    viewport: {
      x: 0,
      y: 0,
      width: t,
      height: t
    },
    count: vx.length / 3,
    primitive: "triangle strip"
  });
  return h(), h.destroy(), o.destroy(), a.destroy(), s.destroy(), l;
}
function AM(i, t) {
  const e = new Array(i * t * 4);
  for (let r = 0; r < i; r++) {
    const { x: n, y: s } = $D(r, i);
    for (let o = 0; o < t; o++) {
      const a = o / t, l = a * a, h = 2 * Math.PI * n, u = Math.sqrt((1 - s) / (1 + (l * l - 1) * s)), c = Math.sqrt(1 - u * u), f = 4 * (r * t + o), d = c * Math.cos(h), p = c * Math.sin(h);
      e[f] = Math.abs(255 * d), e[f + 1] = Math.abs(255 * p), e[f + 2] = 255 * u, e[f + 3] = (d > 0 ? 200 : 0) + (p > 0 ? 55 : 0);
    }
  }
  return e;
}
function $D(i, t) {
  let e = (i << 16 | i >>> 16) >>> 0;
  return e = ((1431655765 & e) << 1 | (2863311530 & e) >>> 1) >>> 0, e = ((858993459 & e) << 2 | (3435973836 & e) >>> 2) >>> 0, e = ((252645135 & e) << 4 | (4042322160 & e) >>> 4) >>> 0, e = (((16711935 & e) << 8 | (4278255360 & e) >>> 8) >>> 0) / 4294967296, {
    x: i / t,
    y: e
  };
}
var WD = Object.freeze({
  __proto__: null,
  createIBLMaps: function(i, t = {}) {
    const e = t.envTexture, r = t.envCubeSize || 512, n = t.sampleSize || 1024, s = t.roughnessLevels || 256, o = t.prefilterCubeSize || 256;
    let a;
    if (Array.isArray(e)) {
      const f = i.cube({
        flipY: !0,
        faces: e
      });
      a = function(d, p, g, m, v) {
        const _ = d({
          frag: `#define ENC_RGBM 1
` + wM,
          vert: Af,
          attributes: {
            aPosition: Qs.vertices
          },
          uniforms: {
            hsv: [0, 0, 0],
            projMatrix: d.context("projMatrix"),
            viewMatrix: d.context("viewMatrix"),
            cubeMap: p,
            bias: 0,
            size: p.width,
            environmentExposure: 1,
            rgbmRange: v
          },
          elements: Qs.indices
        }), y = d.cube({
          width: g,
          height: g,
          min: "linear",
          mag: "linear",
          format: "rgba"
        }), x = d.framebufferCube({
          radius: g,
          color: y
        });
        return Tf(d, x, _, {
          size: g
        }, null, [[0, 0, -1], [0, 0, -1], [0, 0, 1], [0, 0, 1], [0, -1, 0], [0, -1, 0]]), _.destroy(), x;
      }(i, f, r, !0, t.rgbmRange), f.destroy();
    } else a = function(f, d, p, g) {
      p = p || 512;
      const m = f({
        frag: `#define INPUT_RGBM 1
` + jD,
        vert: Af,
        attributes: {
          aPosition: Qs.vertices
        },
        uniforms: {
          projMatrix: f.context("projMatrix"),
          viewMatrix: f.context("viewMatrix"),
          equirectangularMap: d
        },
        elements: Qs.indices
      }), v = f.cube({
        width: p,
        height: p,
        min: "linear",
        mag: "linear",
        format: "rgba"
      }), _ = f.framebufferCube({
        radius: p,
        color: v
      });
      return Tf(f, _, m), m.destroy(), _;
    }(i, e, r);
    const { prefilterMap: l, prefilterMipmap: h } = function(f, d, p, g, m, v) {
      const _ = function(y, x, w, b, T, A) {
        const M = AM(T = T || 1024, A = A || 256), S = y.texture({
          data: M,
          width: A,
          height: T,
          min: "nearest",
          mag: "nearest"
        }), P = y({
          frag: `#define SHADER_NAME PBR_prefilter
precision highp float;
varying vec3 vWorldPos;
uniform samplerCube environmentMap;
uniform sampler2D distributionMap;
uniform float roughness;
uniform float resolution;
uniform float rgbmRange;
const float c = 3.14159265359;
float d(vec3 e, vec3 f, float h) {
  float a = h * h;
  float i = a * a;
  float j = max(dot(e, f), .0);
  float k = j * j;
  float l = i;
  float m = (k * (i - 1.) + 1.);
  m = c * m * m;
  return l / m;
}
vec3 n(float o, vec3 e, float h) {
  vec4 u = texture2D(distributionMap, vec2(h, o));
  vec3 f = u.xyz;
  float v = sign(u.w - .5);
  float A = sign(u.w - 200.0 / 255. * clamp(v, .0, 1.) - .15);
  f.x *= v;
  f.y *= A;
  vec3 B = abs(e.z) < .999 ? vec3(.0, .0, 1.) : vec3(1., .0, .0);
  vec3 C = normalize(cross(B, e));
  vec3 D = cross(e, C);
  vec3 E = C * f.x + D * f.y + e * f.z;
  return normalize(E);
}
vec4 F(const in vec3 G, const in float I) {
  if(I <= .0)
    return vec4(G, 1.);
  vec4 J;
  vec3 K = G / I;
  J.a = clamp(max(max(K.r, K.g), max(K.b, 1e-6)), .0, 1.);
  J.a = ceil(J.a * 255.) / 255.;
  J.rgb = K / J.a;
  return J;
}
vec3 L(const in vec4 G, const in float I) {
  if(I <= .0)
    return G.rgb;
  return I * G.rgb * G.a;
}
void main() {
  vec3 e = normalize(vWorldPos);
  vec3 M = e;
  vec3 O = M;
  const int P = 1024;
  vec3 Q = vec3(.0);
  float S = .0;
  for(int T = 0; T < P; ++T) {
    vec3 f = n(float(T) / float(P), e, roughness);
    vec3 U = normalize(2. * dot(O, f) * f - O);
    float W = max(dot(e, U), .0);
    if(W > .0) {
      Q += L(textureCube(environmentMap, U), rgbmRange).rgb * W;
      S += W;
    }
  }
  Q = Q / S;
  gl_FragColor = F(Q, rgbmRange);
}`,
          vert: Af,
          attributes: {
            aPosition: Qs.vertices
          },
          uniforms: {
            projMatrix: y.context("projMatrix"),
            viewMatrix: y.context("viewMatrix"),
            environmentMap: x,
            distributionMap: S,
            roughness: y.prop("roughness"),
            resolution: b,
            rgbmRange: w || 7
          },
          elements: Qs.indices,
          viewport: {
            x: 0,
            y: 0,
            width: y.prop("size"),
            height: y.prop("size")
          }
        });
        let C = b;
        const k = y.texture({
          radius: b,
          min: "linear",
          mag: "linear"
        }), O = y.framebuffer({
          radius: b,
          color: k
        }), R = Math.log(C) / Math.log(2), I = [];
        for (let D = 0; D <= R; D++) {
          let z = 0;
          Tf(y, O, P, {
            roughness: D / (R - 1),
            size: C
          }, function() {
            const H = y.read({
              framebuffer: O
            });
            I[z] || (I[z] = {
              mipmap: []
            }), I[z].mipmap.push(H), z++;
          }), C /= 2, O.resize(C);
        }
        return S.destroy(), O.destroy(), P.destroy(), I;
      }(f, d, p, g, m, v);
      return {
        prefilterMap: f.cube({
          radius: g,
          min: "linear mipmap linear",
          mag: "linear",
          faces: _
        }),
        prefilterMipmap: _
      };
    }(i, a, t.rgbmRange, o, n, s);
    let u;
    if (!t.ignoreSH) {
      const f = o;
      u = function(p, g, m) {
        const v = new Array(9), _ = [], y = [], x = [];
        for (let w = 0; w < 9; w++) {
          const b = [0, 0, 0];
          for (let T = 0; T < gx.length; T++) {
            const A = p[T], M = [0, 0, 0];
            let S = 0, P = 0;
            const C = VD[gx[T]];
            for (let k = 0; k < m; k++) for (let O = 0; O < g; O++) {
              _[0] = O / (g - 1) * 2 - 1, _[1] = k / (m - 1) * 2 - 1, _[2] = -1, mo(_, _), x[0] = _[C[0]] * C[3], x[1] = _[C[1]] * C[4], x[2] = _[C[2]] * C[5], y[0] = A[P++] / 255, y[1] = A[P++] / 255, y[2] = A[P++] / 255;
              const R = A[P++] / 255 * 7;
              y[0] *= R, y[1] *= R, y[2] *= R, O_(M, M, y, GD(x, w) * -_[2]), S += -_[2];
            }
            O_(b, b, M, 1 / S);
          }
          v[w] = go(b, b, 1 / 6);
        }
        return v;
      }(mx(i, l, f), f, f);
      const d = [];
      for (let p = 0; p < u.length; p++) d.push(...u[p]);
      u = d;
    }
    const c = {
      rgbmRange: t.rgbmRange,
      envMap: a,
      prefilterMap: l
    };
    return u && (c.sh = u), t.format === "array" && (c.envMap = {
      width: a.width,
      height: a.height,
      faces: mx(i, a, r)
    }, c.prefilterMap = {
      width: l.width,
      height: l.height,
      faces: h
    }, a.destroy(), l.destroy()), c;
  },
  generateDFGLUT: TM
});
const ZD = {
  uvScale: [1, 1],
  uvOffset: [0, 0],
  uvRotation: 0,
  textureOrigin: null,
  textureWidth: null,
  baseColorFactor: [1, 1, 1, 1],
  emissiveFactor: [0, 0, 0],
  baseColorIntensity: 1,
  anisotropyDirection: 0,
  anisotropyFactor: 0,
  clearCoatFactor: 0,
  clearCoatIor: 1.4,
  clearCoatRoughnessFactor: 0.04,
  clearCoatThickness: 5,
  emitColorFactor: 1,
  occlusionFactor: 1,
  roughnessFactor: 0.4,
  metallicFactor: 0,
  normalMapFactor: 1,
  specularF0: 0.5,
  emitMultiplicative: 1,
  normalMapFlipY: 0,
  outputSRGB: 1,
  baseColorTexture: null,
  normalTexture: null,
  occlusionTexture: null,
  metallicRoughnessTexture: null,
  emissiveTexture: null,
  uvOrigin: [0, 0],
  noiseTexture: null,
  clearCoatTint: [6e-3, 6e-3, 6e-3],
  specularAAVariance: 20,
  specularAAThreshold: 20,
  hsv: [0, 0, 0],
  contrast: 1,
  bumpTexture: null,
  bumpScale: 0.05,
  bumpMinLayers: 5,
  bumpMaxLayers: 20,
  alphaTest: 0
};
let MM = class extends Nr {
  constructor(t) {
    const e = $n({}, ZD);
    (t.metallicRoughnessTexture || t.metallicRoughnessTexture) && (e.roughnessFactor = 1, e.metallicFactor = 1), super(t, e);
  }
  appendDefines(t, e) {
    super.appendDefines(t, e);
    const r = this.uniforms;
    return r.GAMMA_CORRECT_INPUT && (t.GAMMA_CORRECT_INPUT = 1), e.data[e.desc.colorAttribute] && (t.HAS_COLOR = 1), e.data[e.desc.color0Attribute] && (t.HAS_COLOR0 = 1, t.COLOR0_SIZE = e.getColor0Size()), e.data[e.desc.tangentAttribute] ? t.HAS_TANGENT = 1 : e.data[e.desc.normalAttribute] && (t.HAS_NORMAL = 1), e.data.aVertexColorType && (t.HAS_VERTEX_COLOR = 1), e.data[e.desc.uv0Attribute] && (r.baseColorTexture && (t.HAS_ALBEDO_MAP = 1), r.metallicRoughnessTexture && (t.HAS_METALLICROUGHNESS_MAP = 1), r.occlusionTexture && e.data[e.desc.uv1Attribute] && (t.HAS_AO_MAP = 1), r.emissiveTexture && (t.HAS_EMISSIVE_MAP = 1), r.normalTexture && (t.HAS_NORMAL_MAP = 1), r.bumpTexture && (t.HAS_BUMP_MAP = 1), r.skinTexture && (t.HAS_SKIN_MAP = 1), (t.HAS_ALBEDO_MAP || t.HAS_METALLICROUGHNESS_MAP || t.HAS_AO_MAP || t.HAS_EMISSIVE_MAP || t.HAS_NORMAL_MAP || t.HAS_BUMP_MAP || t.HAS_SKIN_MAP) && (t.HAS_MAP = 1), r.noiseTexture && (t.HAS_RANDOM_TEX = 1), e.data[e.desc.tangentAttribute] ? t.HAS_TANGENT = 1 : e.data[e.desc.normalAttribute] && (t.HAS_NORMAL = 1)), t;
  }
}, XD = class extends yM(MM) {
};
function qD(i, t, e) {
  if (e.ambientUpdate) {
    const { iblTexes: r } = i;
    if (r) {
      const n = e.target;
      c0(r), i.iblTexes = od(t, n);
    } else
      i.iblTexes = od(t, e.target);
  }
}
const YD = [0, 0];
function od(i, t) {
  const e = t.getLightManager(), r = e && e.getAmbientResource();
  return r ? {
    prefilterMap: i.cube({
      width: r.prefilterMap.width,
      height: r.prefilterMap.height,
      faces: r.prefilterMap.faces,
      min: "linear mipmap linear",
      mag: "linear",
      format: "rgba"
    }),
    sh: r.sh,
    rgbmRange: r.rgbmRange
  } : null;
}
function c0(i) {
  for (const t in i) i[t].destroy && i[t].destroy(), delete i[t];
}
var JD = Object.freeze({
  __proto__: null,
  loginIBLResOnCanvas: function(i, t, e) {
    if (!i.dfgLUT && (i.dfgLUT = TM(t), i.dfgLUT.mtkRefCount = 0, e)) {
      const n = qD.bind(this, i, t);
      e.on("updatelights", n), i._iblResListener = n;
    }
    i.dfgLUT.mtkRefCount++;
    const r = e.getLightManager();
    return r && r.getAmbientResource() ? (i.iblTexes || (i.iblTexes = od(t, e)), {
      dfgLUT: i.dfgLUT,
      iblTexes: i.iblTexes
    }) : {
      dfgLUT: i.dfgLUT,
      iblTexes: null
    };
  },
  getIBLResOnCanvas: function(i) {
    const { dfgLUT: t, iblTexes: e } = i;
    return {
      dfgLUT: t,
      iblTexes: e
    };
  },
  logoutIBLResOnCanvas: function(i, t) {
    let e = !1;
    i.dfgLUT && (i.dfgLUT.mtkRefCount--, i.dfgLUT.mtkRefCount <= 0) && (e = !0, t && t.off("updatelights", i._iblResListener), i.dfgLUT.destroy(), delete i.dfgLUT), i.iblTexes && e && (c0(i.iblTexes), delete i.iblTexes);
  },
  getPBRUniforms: function(i, t, e, r, n) {
    const s = i.viewMatrix, o = i.projMatrix, a = i.cameraPosition, l = i.getRenderer().canvas, h = function(c, f) {
      const d = c.getLightManager(), p = d && d.getAmbientResource(), g = d && d.getAmbientLight() || {}, m = d && d.getDirectionalLight() || {};
      let v;
      if (p) {
        const _ = f.prefilterMap.width, y = Math.log(_) / Math.log(2);
        v = {
          prefilterMap: f.prefilterMap,
          diffuseSPH: f.sh,
          prefilterMiplevel: [y, y],
          prefilterSize: [_, _],
          hdrHSV: g.hsv || [0, 0, 0]
        };
      } else v = {
        ambientColor: g.color || [0.2, 0.2, 0.2]
      };
      return v.rgbmRange = p ? f.rgbmRange : 7, v.environmentExposure = Ds(g.exposure) ? g.exposure : 1, v.environmentOrientation = g.orientation || 0, v.light0_diffuse = [...m.color || [1, 1, 1], 1], v.light0_viewDirection = m.direction || [1, 1, -1], v;
    }(i, t), u = $n({
      viewMatrix: s,
      projMatrix: o,
      projViewMatrix: i.projViewMatrix,
      cameraPosition: a,
      outSize: [l.width, l.height],
      cameraNearFar: [i.cameraNear, i.cameraFar]
    }, h);
    return u.brdfLUT = e, r && r.renderUniforms && $n(u, r.renderUniforms), u.halton = n || YD, u;
  },
  createIBLTextures: od,
  disposeIBLTextures: c0,
  isSupported: function(i) {
    return i.hasExtension("EXT_shader_texture_lod");
  }
});
let KD = class extends qe {
  constructor(t) {
    super({
      vert: `attribute vec3 aPosition;
uniform mat4 lightProjViewModelMatrix;
uniform mat4 positionMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 modelMatrix;
#include <line_extrusion_vert>
#include <get_output>
varying vec4 vPosition;
void main() {
  mat4 c = getPositionMatrix();
#ifdef IS_LINE_EXTRUSION
vec3 d = getLineExtrudePosition(aPosition);
  vec4 e = getPosition(d);
#else
vec4 e = getPosition(aPosition);
#endif
gl_Position = lightProjViewModelMatrix * c * e;
  vPosition = gl_Position;
}`,
      frag: `#define SHADER_NAME vsm_mapping
#ifdef USE_VSM
#extension GL_OES_standard_derivatives : enable
#endif
precision highp float;
varying vec4 vPosition;
#ifdef PACK_FLOAT
#include <common_pack_float>
#endif
void main() {
  
#if defined(USE_VSM)
float c = vPosition.z / vPosition.w;
  c = c * .5 + .5;
  float d = c;
  float e = c * c;
  float f = dFdx(c);
  float h = dFdy(c);
  e += .25 * (f * f + h * h);
  gl_FragColor = vec4(d, e, c, .0);
#endif
#if defined(USE_ESM)
#ifdef PACK_FLOAT
gl_FragColor = common_encodeDepth(gl_FragCoord.z);
#else
gl_FragColor = vec4(gl_FragCoord.z, .0, .0, 1.);
#endif
#endif
}`,
      uniforms: [{
        name: "lightProjViewModelMatrix",
        type: "function",
        fn: function(e, r) {
          return Jt([], r.lightProjViewMatrix, r.modelMatrix);
        }
      }],
      extraCommandProps: {},
      defines: t
    });
  }
  filter(t) {
    return t.castShadow;
  }
}, QD = class extends ar {
  constructor({ blurOffset: t }) {
    super({
      vert: gi,
      frag: `precision highp float;
varying vec2 vTexCoord;
uniform sampler2D textureSource;
uniform vec2 resolution;
#include <common_pack_float>
void main() {
  float c = .0;
  float d = .0;
  for(int x = -BOXBLUR_OFFSET; x <= BOXBLUR_OFFSET; ++x)
    for(int y = -BOXBLUR_OFFSET; y <= BOXBLUR_OFFSET; ++y) {
      vec2 e = vTexCoord.st + vec2(float(x) / resolution.x, float(y) / resolution.y);
      e = clamp(e, .0, 1.);
      float f = common_decodeDepth(texture2D(textureSource, e));
      float s = max(.0, sign(1. - f));
      d += sign(f) * s;
      c += f;
    }
  float h = c / max(1., d);
  gl_FragColor = common_encodeDepth(h);
}`,
      defines: {
        BOXBLUR_OFFSET: t || 2
      }
    }), this._blurOffset = t || 2;
  }
  getMeshCommand(t, e) {
    const r = "box_shadow_blur_" + this._blurOffset;
    return this.commands[r] || (this.commands[r] = this.createREGLCommand(t, null, e.getElements())), this.commands[r];
  }
}, SM = null, CM = null, tF = class {
  constructor(t, { width: e, height: r, blurOffset: n, defines: s }) {
    this.renderer = t, this.width = e || 512, this.height = r || 512, this.blurOffset = ri(n) ? 2 : n, this._init(s);
  }
  render(t, { cameraProjViewMatrix: e, lightDir: r, farPlane: n, cameraLookAt: s }) {
    return {
      lightProjViewMatrix: this._renderShadow(t, e, r, n, s),
      shadowMap: this.blurTex || this.depthTex,
      depthFBO: this.depthFBO,
      blurFBO: this.blurFBO
    };
  }
  resize(t, e) {
    return this.depthTex && (this.depthTex.resize(t, e), this.depthFBO.resize(t, e)), this.blurFBO && (this.blurTex.resize(t, e), this.blurFBO.resize(t, e)), this;
  }
  _renderShadow(t, e, r, n, s) {
    const o = this.renderer, a = SM(e);
    if (n) for (let h = 4; h < 8; h++) a[h] = n[h - 4];
    const l = CM(s, a, r);
    return o.clear({
      color: [1, 0, 0, 1],
      depth: 1,
      framebuffer: this.depthFBO
    }), o.render(this.shadowMapShader, {
      lightProjViewMatrix: l
    }, t, this.depthFBO), this.blurFBO && (this.boxBlurShader || (this.boxBlurShader = new QD({
      blurOffset: this.blurOffset
    })), o.clear({
      color: [1, 0, 0, 1],
      depth: 1,
      framebuffer: this.blurFBO
    }), o.render(this.boxBlurShader, {
      resolution: [this.depthTex.width, this.depthTex.height],
      textureSource: this.depthTex
    }, null, this.blurFBO)), l;
  }
  _init(t) {
    const e = this.renderer.regl, r = this.width, n = this.height;
    this.depthTex = e.texture({
      width: r,
      height: n,
      format: "rgb",
      type: "uint8",
      min: "nearest",
      mag: "nearest"
    }), this.shadowMapShader = new KD(t), this.shadowMapShader.filter = (s) => s.castShadow, this.depthFBO = e.framebuffer({
      color: this.depthTex
    }), this.blurOffset <= 0 || (this.blurTex = e.texture({
      width: r,
      height: n,
      format: "rgb",
      type: "uint8",
      min: "linear",
      mag: "linear"
    }), this.blurFBO = e.framebuffer({
      color: this.blurTex
    }));
  }
  dispose() {
    this.depthTex && (this.depthTex.destroy(), this.depthFBO.destroy(), delete this.depthTex, delete this.depthFBO), this.blurTex && (this.blurTex.destroy(), this.blurFBO.destroy(), delete this.blurTex, delete this.blurFBO), this.shadowMapShader && (this.shadowMapShader.dispose(), delete this.shadowMapShader), this.boxBlurShader && (this.boxBlurShader.dispose(), delete this.boxBlurShader);
  }
};
SM = function() {
  const i = [[-1, -1, -1, 1], [1, -1, -1, 1], [1, 1, -1, 1], [-1, 1, -1, 1], [-1, -1, 1, 1], [1, -1, 1, 1], [1, 1, 1, 1], [-1, 1, 1, 1]], t = new Array(16);
  return function(e) {
    Is(t, e);
    const r = [];
    for (let n = 0; n < i.length; n++) {
      const s = ho([], i[n], t);
      Sl(s, s, 1 / s[3]), r.push(s);
    }
    return r;
  };
}(), CM = function() {
  let i = new Array(4);
  const t = new Array(3), e = [0, 0, 0, 0], r = [0, 1, 0], n = new Array(3);
  let s = new Array(16), o = new Array(16);
  const a = new Array(16), l = [1, 1, 1], h = [0, 0, 0];
  return function(u, c, f) {
    Sr(e, ...u, 1), go(t, f, -1), s = Eo(s, qr(n, e, mo(n, t)), e, r), ho(i, c[0], s);
    let d = i[2], p = i[2], g = i[0], m = i[0], v = i[1], _ = i[1];
    for (let b = 1; b < 8; b++) i = ho(i, c[b], s), i[2] > p && (p = i[2]), i[2] < d && (d = i[2]), i[0] > m && (m = i[0]), i[0] < g && (g = i[0]), i[1] > _ && (_ = i[1]), i[1] < v && (v = i[1]);
    o = ER(o, -1, 1, -1, 1, -p, -d);
    const y = l[0] = 2 / (m - g), x = l[1] = -2 / (_ - v);
    h[0] = -0.5 * (g + m) * y, h[1] = -0.5 * (v + _) * x, pn(a), ss(a, a, h), os(a, a, l);
    const w = Jt(o, a, o);
    return Jt(new Array(16), w, s);
  };
}();
let eF = class extends qe {
  constructor(t) {
    super({
      vert: `#define SHADER_NAME SHADOW_DISPLAY
attribute vec3 aPosition;
uniform mat4 projMatrix;
uniform mat4 modelViewMatrix;
uniform vec2 halton;
uniform vec2 globalTexSize;
varying vec4 vPosition;
#include <vsm_shadow_vert>
void main() {
  vec4 c = vec4(aPosition, 1.);
  vec4 d = modelViewMatrix * c;
  mat4 e = projMatrix;
  e[2].xy += halton.xy / globalTexSize.xy;
  gl_Position = e * d;
  vPosition = gl_Position;
  shadow_computeShadowPars(c);
}`,
      frag: `#define SHADER_NAME SHADOW_DISPLAY
precision mediump float;
uniform vec3 color;
#include <vsm_shadow_frag>
void main() {
  float c = shadow_computeShadow();
  float d = 1. - c;
  gl_FragColor = vec4(color * d, d);
}`,
      uniforms: [{
        name: "modelViewMatrix",
        type: "function",
        fn: function(e, r) {
          const n = [];
          return Jt(n, r.viewMatrix, r.modelMatrix), n;
        }
      }],
      defines: t || {
        USE_ESM: 1
      },
      extraCommandProps: {
        depth: {
          enable: !0,
          mask: !1
        },
        viewport: {
          x: 0,
          y: 0,
          width: (e, r) => r.globalTexSize[0],
          height: (e, r) => r.globalTexSize[1]
        }
      }
    });
  }
  getMeshCommand(t, e) {
    return this.commands.shadow_display || (this.commands.shadow_display = this.createREGLCommand(t, null, e.getElements())), this.commands.shadow_display;
  }
};
function wc(i) {
  return 256 * i[2] * 256 + 256 * i[1] + i[0];
}
const Sh = new Uint8Array(4), nF = new Float32Array(Sh.buffer);
let Tc, yx;
const fg = [1, 1], ly = `
    vec3 unpack(highp float f) {
        highp vec3 color;
        color.b = floor(f / 65536.0);
        color.g = floor((f - color.b * 65536.0) / 256.0);
        color.r = f - floor(color.b * 65536.0) - floor(color.g * 256.0);
        // now we have a vec3 with the 3 components in range [0..255]. Let's normalize it!
        return color / 255.0;
    }
`, rF = `
    precision highp float;

    varying float vPickingId;
    varying float vFbo_picking_visible;

    uniform float fbo_picking_meshId;

    ${ly}

    void main() {
        if (vFbo_picking_visible == 0.0) {
            discard;
            return;
        }
        gl_FragColor = vec4(unpack(vPickingId), fbo_picking_meshId / 255.0);
    }
`, iF = `
    precision highp float;

    uniform int fbo_picking_meshId;
    varying float vFbo_picking_visible;

    ${ly}

    void main() {
        if (vFbo_picking_visible == 0.0) {
            discard;
            return;
        }
        gl_FragColor = vec4(unpack(float(fbo_picking_meshId)), 1.0);
        // gl_FragColor = vec4(unpack(float(35)), 1.0);
    }
`, sF = `
    precision highp float;

    varying float vPickingId;
    varying float vFbo_picking_visible;

    ${ly}

    void main() {
        if (vFbo_picking_visible == 0.0) {
            discard;
            return;
        }
        gl_FragColor = vec4(unpack(vPickingId), 1.0);
    }
`;
let Oi = class {
  constructor(t, { vert: e, uniforms: r, defines: n, extraCommandProps: s }, o, a) {
    this._renderer = t, this._fbo = o, this._map = a, this._clearFbo(o), this._vert = e, this._uniforms = r, this._defines = n, this._extraCommandProps = $n({}, s), delete this._extraCommandProps.blend, delete this._extraCommandProps.stencil, this._currentMeshes = [], this._init();
  }
  _init() {
    const t = [];
    this._uniforms && t.push(...this._uniforms);
    const e = {
      ENABLE_PICKING: 1,
      HAS_PICKING_ID: 1
    };
    if (this._defines) for (const o in this._defines) e[o] = this._defines[o];
    const r = this._vert, n = this._extraCommandProps;
    this._shader0 = new qe({
      vert: r,
      frag: rF,
      uniforms: t,
      defines: e,
      extraCommandProps: n
    }), this._shader2 = new qe({
      vert: r,
      frag: sF,
      uniforms: t,
      defines: e,
      extraCommandProps: n
    });
    const s = {
      ENABLE_PICKING: 1,
      HAS_PICKING_ID: 1
    };
    if (this._defines) for (const o in this._defines) s[o] = this._defines[o];
    this._shader1 = new qe({
      vert: r,
      frag: iF,
      uniforms: t,
      defines: s,
      extraCommandProps: n
    }), this._depthShader = new qe({
      vert: r,
      frag: `
    #ifdef GL_ES
        precision highp float;
    #endif
    #if __VERSION__ == 100 && defined(GL_EXT_frag_depth)
        #extension GL_EXT_frag_depth : enable
    #endif
    #include <gl2_frag>
    #include <common_pack_float>
    varying float vFbo_picking_viewZ;
    uniform float logDepthBufFC;
    varying float vFbo_picking_fragDepth;

    const float PackUpscale = 256. / 255.;
    const float UnpackDownscale = 255. / 256.;
    const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
    const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
    const float ShiftRight8 = 1. / 256.;
    vec4 packDepthToRGBA(const in float v ) {
        vec4 r = vec4(fract(v * PackFactors), v);
        r.yzw -= r.xyz * ShiftRight8;
        return r * PackUpscale;
    }

    void main() {
        float fragDepth = vFbo_picking_fragDepth > 1.0 ? vFbo_picking_fragDepth : vFbo_picking_viewZ + 1.0;
        #if __VERSION__ == 300 || __VERSION__ == 100 && defined(GL_EXT_frag_depth)
            gl_FragDepthEXT = log2(fragDepth) * logDepthBufFC * 0.5;
        #endif
        vec4 depthColor = packDepthToRGBA(fragDepth - 1.0);
        glFragColor = common_unpackFloat(dot(depthColor, UnpackFactors));
        #if __VERSION__ == 100
            gl_FragColor = glFragColor;
        #endif
    }
`,
      uniforms: t,
      defines: s,
      extraCommandProps: n
    }), this._scene = new ur(), this._scene1 = new ur();
  }
  filter() {
    return !0;
  }
  render(t, e, r = !1) {
    if (!t || !t.length) return this;
    const n = this._fbo;
    r && this.clear(), t = t.filter((o) => o && o.isValid()), this._scene.setMeshes(t);
    const s = this._getShader(t, r);
    s.filter = this.filter, this._currentShader && s !== this._currentShader && this.clear(), this._currentShader = s, t.forEach((o, a) => {
      o.setUniform("fbo_picking_meshId", a + this._currentMeshes.length);
    });
    for (let o = 0; o < t.length; o++) this._currentMeshes.push(t[o]);
    return this._renderer.render(s, e, this._scene, n), this;
  }
  pickAll(t, e, r, n, s) {
    r = _x(r);
    const { meshIds: o, pickingIds: a, coords: l, points: h } = this._pick(t, e, r, n, s), u = [];
    if (a && o) {
      const c = {};
      for (let f = 0; f < o.length; f++) {
        const d = `${a[f]}_${o[f]}`;
        o[f] == null || a[f] == null || c[d] || (c[d] = !0, u.push({
          meshId: o[f],
          pickingId: a[f],
          point: h[f] || null,
          coordinate: l[f] || null
        }));
      }
    }
    return u;
  }
  pick(t, e, r, n, s = {}) {
    r = _x(r);
    const { meshIds: o, pickingIds: a, width: l, coords: h, points: u } = this._pick(t, e, r, n, s);
    if (a && o) {
      const c = [];
      for (let f = 0; f <= r[0]; f++) c.push(f), f > 0 && c.push(-f);
      for (let f = 0; f < c.length; f++) for (let d = 0; d < c.length; d++) {
        const p = (c[d] + r[1]) * l + (c[f] + r[0]);
        if (o[p] != null && a[p] != null) return {
          meshId: o[p],
          pickingId: a[p],
          point: u[p] || null,
          coordinate: h[p] || null
        };
      }
    }
    return {
      pickingId: null,
      meshId: null,
      point: null
    };
  }
  _pick(t, e, r, n, s = {}) {
    const o = this._currentShader, a = this._currentMeshes;
    if (!o || !a || !a.length) return {
      pickingId: null,
      meshId: null,
      point: null
    };
    t = Math.round(t), e = Math.round(e);
    const l = this._fbo;
    if (t <= 2 || t >= l.width - 2 || e <= 2 || e >= l.height - 2) return {
      pickingId: null,
      meshId: null,
      point: null
    };
    const { px: h, py: u, width: c, height: f } = this._getParams(t, e, r, l), d = new Uint8Array(4 * c * f), p = this._renderer.regl.read({
      data: d,
      x: h,
      y: u,
      framebuffer: l,
      width: c,
      height: f
    }), g = [];
    let m = [];
    for (let T = 0; T < p.length; T += 4) {
      const { pickingId: A, meshId: M } = this._packData(p.subarray(T, T + 4), o);
      g.push(M), m.push(A);
    }
    const v = {}, _ = g.filter((T) => T != null && !v[T] && (v[T] = 1, !0)).map((T) => a[T]);
    let y;
    for (let T = 0; T < _.length; T++) if (_[T] && _[T].geometry) {
      y = _[T];
      break;
    }
    if (!y) return {
      pickingId: null,
      meshId: null,
      point: null
    };
    const x = y.geometry.desc.pickingIdAttribute;
    g.length && o === this._shader1 && (y.getUniform("uPickingId") !== void 0 || y.geometry.data[x]) && (m = this._getPickingId(h, u, c, f, d, _, n));
    const w = [], b = [];
    if (g.length && s.returnPoint) {
      const { viewMatrix: T, projMatrix: A } = s, M = this._pickDepth(h, u, c, f, d, _, n);
      for (let S = 0; S < M.length; S++) if (M[S] && g[S] != null && m[S] != null) {
        const P = this._getWorldPos(t, e, M[S], T, A), C = this._convertPickPoint(P);
        w.push(P), b.push(C);
      } else w.push(null), b.push(null);
    }
    return {
      meshIds: g,
      pickingIds: m,
      coords: b,
      points: w,
      width: c,
      height: f
    };
  }
  _convertPickPoint(t) {
    const e = this._map;
    if (!e) return null;
    const r = e.getGLRes();
    if (!Tc) {
      const o = e.getCenter();
      yx = new o.constructor(0, 0, 0);
      const a = e.coordToPoint(o);
      Tc = new a.constructor(0, 0);
    }
    Tc.set(t[0], t[1]);
    const n = e.pointAtResToCoord(Tc, r, yx), s = e.pointAtResToAltitude(t[2], r);
    return [n.x, n.y, s];
  }
  clear() {
    return this._fbo && this._clearFbo(this._fbo), this._currentMeshes = [], delete this._currentShader, this;
  }
  getMeshAt(t) {
    return this._currentMeshes ? this._currentMeshes[t] : null;
  }
  getRenderedMeshes() {
    return this._currentMeshes;
  }
  dispose() {
    this.clear(), this._shader0 && this._shader0.dispose(), this._shader1 && this._shader1.dispose(), this._shader2 && this._shader2.dispose(), this._scene && this._scene.clear(), this._scene1 && this._scene1.clear();
  }
  _getWorldPos(t, e, r, n, s) {
    const o = this._fbo, a = [], l = o.width / 2 || 1, h = o.height / 2 || 1, u = [(t - l) / l, (h - e) / h, 0, 1], c = [(t - l) / l, (h - e) / h, 1, 1], f = Is(a, s), d = [], p = [];
    Ac(d, u, f), Ac(p, c, f);
    const g = -d[2], m = (r - g) / (-p[2] - g), v = Jt(a, s, n), _ = Is(a, v), y = Ac(u, u, _), x = Ac(c, c, _);
    return [xf(y[0], x[0], m), xf(y[1], x[1], m), xf(y[2], x[2], m)];
  }
  _getPickingId(t, e, r, n, s, o, a) {
    const l = this._renderer.regl, h = this._getFBO1();
    this._clearFbo(h), this._scene1.setMeshes(o), this._renderer.render(this._shader2, a, this._scene1, h);
    const u = l.read({
      data: s,
      x: t,
      y: e,
      framebuffer: h,
      width: r,
      height: n
    }), c = [];
    for (let f = 0; f < u.length; f += 4) c.push(wc(u.subarray(f, f + 4)));
    return c;
  }
  _pickDepth(t, e, r, n, s, o, a) {
    const l = this._renderer.regl, h = this._getFBO1();
    this._scene1.setMeshes(o), this._clearFbo(h), a.logDepthBufFC = 2 / (Math.log(this._map.cameraFar + 1) / Math.LN2), this._renderer.render(this._depthShader, a, this._scene1, h);
    const u = l.read({
      data: s,
      x: t,
      y: e,
      framebuffer: h,
      width: r,
      height: n
    }), c = [];
    for (let d = 0; d < u.length; d += 4) c.push((f = u.subarray(d, d + 4), Sh[0] = f[3], Sh[1] = f[2], Sh[2] = f[1], Sh[3] = f[0], nF[0]));
    var f;
    return c;
  }
  _packData(t, e) {
    if (t[0] === 255 && t[1] === 255 && t[2] === 255 && t[3] === 255) return {
      meshId: null,
      pickingId: null
    };
    let r = null, n = null;
    return e === this._shader1 ? n = wc(t) : e === this._shader0 ? (n = t[3], r = wc(t)) : (n = null, r = wc(t)), {
      meshId: n,
      pickingId: r
    };
  }
  _clearFbo(t) {
    this._renderer.regl.clear({
      color: [1, 1, 1, 1],
      depth: 1,
      stencil: 0,
      framebuffer: t
    });
  }
  _getShader(t, e) {
    return e && t.length < 256 ? this._shader0 : this._shader1;
  }
  _getFBO1() {
    const t = this._renderer.regl, e = this._fbo;
    return this._fbo1 ? this._fbo1.width === e.width && this._fbo1.height === e.height || this._fbo1.resize(e.width, e.height) : this._fbo1 = t.framebuffer(e.width, e.height), this._fbo1;
  }
  _getParams(t, e, r, n) {
    const s = r[0], o = r[1];
    e = n.height - e;
    let a = 2 * s + 1, l = 2 * o + 1;
    const h = (t -= s) + a, u = (e -= o) + l;
    return h > n.width && (a -= h - n.width), u > n.height && (l -= u - n.height), {
      px: t = t < 0 ? 0 : t,
      py: e = e < 0 ? 0 : e,
      width: a,
      height: l
    };
  }
  getPickingVert() {
    return this._vert;
  }
  getUniformDeclares() {
    return this._uniforms;
  }
};
function Ac(i, t, e) {
  const r = t[0], n = t[1], s = t[2], o = 1 / (e[3] * r + e[7] * n + e[11] * s + e[15]);
  return i[0] = (e[0] * r + e[4] * n + e[8] * s + e[12]) * o, i[1] = (e[1] * r + e[5] * n + e[9] * s + e[13]) * o, i[2] = (e[2] * r + e[6] * n + e[10] * s + e[14]) * o, i;
}
function _x(i) {
  return Ds(i) && (fg[0] = fg[1] = i, i = fg), i;
}
var xx = {
  exports: {}
};
function Mc(i, t, e) {
  e = e || 2;
  var r, n, s, o, a, l, h, u = t && t.length, c = u ? t[0] * e : i.length, f = bx(i, 0, c, e, !0), d = [];
  if (!f || f.next === f.prev) return d;
  if (u && (f = function(g, m, v, _) {
    var y, x, w, b = [];
    for (y = 0, x = m.length; y < x; y++) (w = bx(g, m[y] * _, y < x - 1 ? m[y + 1] * _ : g.length, _, !1)) === w.next && (w.steiner = !0), b.push(dF(w));
    for (b.sort(uF), y = 0; y < b.length; y++) v = cF(b[y], v);
    return v;
  }(i, t, f, e)), i.length > 80 * e) {
    r = s = i[0], n = o = i[1];
    for (var p = e; p < c; p += e) (a = i[p]) < r && (r = a), (l = i[p + 1]) < n && (n = l), a > s && (s = a), l > o && (o = l);
    h = (h = Math.max(s - r, o - n)) !== 0 ? 32767 / h : 0;
  }
  return hu(f, d, e, r, n, h, 0), d;
}
function bx(i, t, e, r, n) {
  var s, o;
  if (n === p0(i, t, e, r) > 0) for (s = t; s < e; s += r) o = wx(s, i[s], i[s + 1], o);
  else for (s = e - r; s >= t; s -= r) o = wx(s, i[s], i[s + 1], o);
  return o && Vd(o, o.next) && (cu(o), o = o.next), o;
}
function Wo(i, t) {
  if (!i) return i;
  t || (t = i);
  var e, r = i;
  do
    if (e = !1, r.steiner || !Vd(r, r.next) && Dn(r.prev, r, r.next) !== 0) r = r.next;
    else {
      if (cu(r), (r = t = r.prev) === r.next) break;
      e = !0;
    }
  while (e || r !== t);
  return t;
}
function hu(i, t, e, r, n, s, o) {
  if (i) {
    !o && s && function(u, c, f, d) {
      var p = u;
      do
        p.z === 0 && (p.z = f0(p.x, p.y, c, f, d)), p.prevZ = p.prev, p.nextZ = p.next, p = p.next;
      while (p !== u);
      p.prevZ.nextZ = null, p.prevZ = null, function(g) {
        var m, v, _, y, x, w, b, T, A = 1;
        do {
          for (v = g, g = null, x = null, w = 0; v; ) {
            for (w++, _ = v, b = 0, m = 0; m < A && (b++, _ = _.nextZ); m++) ;
            for (T = A; b > 0 || T > 0 && _; ) b !== 0 && (T === 0 || !_ || v.z <= _.z) ? (y = v, v = v.nextZ, b--) : (y = _, _ = _.nextZ, T--), x ? x.nextZ = y : g = y, y.prevZ = x, x = y;
            v = _;
          }
          x.nextZ = null, A *= 2;
        } while (w > 1);
      }(p);
    }(i, r, n, s);
    for (var a, l, h = i; i.prev !== i.next; ) if (a = i.prev, l = i.next, s ? aF(i, r, n, s) : oF(i)) t.push(a.i / e | 0), t.push(i.i / e | 0), t.push(l.i / e | 0), cu(i), i = l.next, h = l.next;
    else if ((i = l) === h) {
      o ? o === 1 ? hu(i = lF(Wo(i), t, e), t, e, r, n, s, 2) : o === 2 && hF(i, t, e, r, n, s) : hu(Wo(i), t, e, r, n, s, 1);
      break;
    }
  }
}
function oF(i) {
  var t = i.prev, e = i, r = i.next;
  if (Dn(t, e, r) >= 0) return !1;
  for (var n = t.x, s = e.x, o = r.x, a = t.y, l = e.y, h = r.y, u = n < s ? n < o ? n : o : s < o ? s : o, c = a < l ? a < h ? a : h : l < h ? l : h, f = n > s ? n > o ? n : o : s > o ? s : o, d = a > l ? a > h ? a : h : l > h ? l : h, p = r.next; p !== t; ) {
    if (p.x >= u && p.x <= f && p.y >= c && p.y <= d && Ja(n, a, s, l, o, h, p.x, p.y) && Dn(p.prev, p, p.next) >= 0) return !1;
    p = p.next;
  }
  return !0;
}
function aF(i, t, e, r) {
  var n = i.prev, s = i, o = i.next;
  if (Dn(n, s, o) >= 0) return !1;
  for (var a = n.x, l = s.x, h = o.x, u = n.y, c = s.y, f = o.y, d = a < l ? a < h ? a : h : l < h ? l : h, p = u < c ? u < f ? u : f : c < f ? c : f, g = a > l ? a > h ? a : h : l > h ? l : h, m = u > c ? u > f ? u : f : c > f ? c : f, v = f0(d, p, t, e, r), _ = f0(g, m, t, e, r), y = i.prevZ, x = i.nextZ; y && y.z >= v && x && x.z <= _; ) {
    if (y.x >= d && y.x <= g && y.y >= p && y.y <= m && y !== n && y !== o && Ja(a, u, l, c, h, f, y.x, y.y) && Dn(y.prev, y, y.next) >= 0 || (y = y.prevZ, x.x >= d && x.x <= g && x.y >= p && x.y <= m && x !== n && x !== o && Ja(a, u, l, c, h, f, x.x, x.y) && Dn(x.prev, x, x.next) >= 0)) return !1;
    x = x.nextZ;
  }
  for (; y && y.z >= v; ) {
    if (y.x >= d && y.x <= g && y.y >= p && y.y <= m && y !== n && y !== o && Ja(a, u, l, c, h, f, y.x, y.y) && Dn(y.prev, y, y.next) >= 0) return !1;
    y = y.prevZ;
  }
  for (; x && x.z <= _; ) {
    if (x.x >= d && x.x <= g && x.y >= p && x.y <= m && x !== n && x !== o && Ja(a, u, l, c, h, f, x.x, x.y) && Dn(x.prev, x, x.next) >= 0) return !1;
    x = x.nextZ;
  }
  return !0;
}
function lF(i, t, e) {
  var r = i;
  do {
    var n = r.prev, s = r.next.next;
    !Vd(n, s) && PM(n, r, r.next, s) && uu(n, s) && uu(s, n) && (t.push(n.i / e | 0), t.push(r.i / e | 0), t.push(s.i / e | 0), cu(r), cu(r.next), r = i = s), r = r.next;
  } while (r !== i);
  return Wo(r);
}
function hF(i, t, e, r, n, s) {
  var o = i;
  do {
    for (var a = o.next.next; a !== o.prev; ) {
      if (o.i !== a.i && pF(o, a)) {
        var l = EM(o, a);
        return o = Wo(o, o.next), l = Wo(l, l.next), hu(o, t, e, r, n, s, 0), void hu(l, t, e, r, n, s, 0);
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== i);
}
function uF(i, t) {
  return i.x - t.x;
}
function cF(i, t) {
  var e = function(n, s) {
    var o, a = s, l = n.x, h = n.y, u = -1 / 0;
    do {
      if (h <= a.y && h >= a.next.y && a.next.y !== a.y) {
        var c = a.x + (h - a.y) * (a.next.x - a.x) / (a.next.y - a.y);
        if (c <= l && c > u && (u = c, o = a.x < a.next.x ? a : a.next, c === l)) return o;
      }
      a = a.next;
    } while (a !== s);
    if (!o) return null;
    var f, d = o, p = o.x, g = o.y, m = 1 / 0;
    a = o;
    do
      l >= a.x && a.x >= p && l !== a.x && Ja(h < g ? l : u, h, p, g, h < g ? u : l, h, a.x, a.y) && (f = Math.abs(h - a.y) / (l - a.x), uu(a, n) && (f < m || f === m && (a.x > o.x || a.x === o.x && fF(o, a))) && (o = a, m = f)), a = a.next;
    while (a !== d);
    return o;
  }(i, t);
  if (!e) return t;
  var r = EM(e, i);
  return Wo(r, r.next), Wo(e, e.next);
}
function fF(i, t) {
  return Dn(i.prev, i, t.prev) < 0 && Dn(t.next, i, i.next) < 0;
}
function f0(i, t, e, r, n) {
  return (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = (i - e) * n | 0) | i << 8)) | i << 4)) | i << 2)) | i << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - r) * n | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1;
}
function dF(i) {
  var t = i, e = i;
  do
    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
  while (t !== i);
  return e;
}
function Ja(i, t, e, r, n, s, o, a) {
  return (n - o) * (t - a) >= (i - o) * (s - a) && (i - o) * (r - a) >= (e - o) * (t - a) && (e - o) * (s - a) >= (n - o) * (r - a);
}
function pF(i, t) {
  return i.next.i !== t.i && i.prev.i !== t.i && !function(e, r) {
    var n = e;
    do {
      if (n.i !== e.i && n.next.i !== e.i && n.i !== r.i && n.next.i !== r.i && PM(n, n.next, e, r)) return !0;
      n = n.next;
    } while (n !== e);
    return !1;
  }(i, t) && (uu(i, t) && uu(t, i) && function(e, r) {
    var n = e, s = !1, o = (e.x + r.x) / 2, a = (e.y + r.y) / 2;
    do
      n.y > a != n.next.y > a && n.next.y !== n.y && o < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (s = !s), n = n.next;
    while (n !== e);
    return s;
  }(i, t) && (Dn(i.prev, i, t.prev) || Dn(i, t.prev, t)) || Vd(i, t) && Dn(i.prev, i, i.next) > 0 && Dn(t.prev, t, t.next) > 0);
}
function Dn(i, t, e) {
  return (t.y - i.y) * (e.x - t.x) - (t.x - i.x) * (e.y - t.y);
}
function Vd(i, t) {
  return i.x === t.x && i.y === t.y;
}
function PM(i, t, e, r) {
  var n = Cc(Dn(i, t, e)), s = Cc(Dn(i, t, r)), o = Cc(Dn(e, r, i)), a = Cc(Dn(e, r, t));
  return n !== s && o !== a || !(n !== 0 || !Sc(i, e, t)) || !(s !== 0 || !Sc(i, r, t)) || !(o !== 0 || !Sc(e, i, r)) || !(a !== 0 || !Sc(e, t, r));
}
function Sc(i, t, e) {
  return t.x <= Math.max(i.x, e.x) && t.x >= Math.min(i.x, e.x) && t.y <= Math.max(i.y, e.y) && t.y >= Math.min(i.y, e.y);
}
function Cc(i) {
  return i > 0 ? 1 : i < 0 ? -1 : 0;
}
function uu(i, t) {
  return Dn(i.prev, i, i.next) < 0 ? Dn(i, t, i.next) >= 0 && Dn(i, i.prev, t) >= 0 : Dn(i, t, i.prev) < 0 || Dn(i, i.next, t) < 0;
}
function EM(i, t) {
  var e = new d0(i.i, i.x, i.y), r = new d0(t.i, t.x, t.y), n = i.next, s = t.prev;
  return i.next = t, t.prev = i, e.next = n, n.prev = e, r.next = e, e.prev = r, s.next = r, r.prev = s, r;
}
function wx(i, t, e, r) {
  var n = new d0(i, t, e);
  return r ? (n.next = r.next, n.prev = r, r.next.prev = n, r.next = n) : (n.prev = n, n.next = n), n;
}
function cu(i) {
  i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
}
function d0(i, t, e) {
  this.i = i, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function p0(i, t, e, r) {
  for (var n = 0, s = t, o = e - r; s < e; s += r) n += (i[o] - i[s]) * (i[s + 1] + i[o + 1]), o = s;
  return n;
}
xx.exports = Mc, xx.exports.default = Mc, Mc.deviation = function(i, t, e, r) {
  var n = t && t.length, s = Math.abs(p0(i, 0, n ? t[0] * e : i.length, e));
  if (n) for (var o = 0, a = t.length; o < a; o++)
    s -= Math.abs(p0(i, t[o] * e, o < a - 1 ? t[o + 1] * e : i.length, e));
  var l = 0;
  for (o = 0; o < r.length; o += 3) {
    var h = r[o] * e, u = r[o + 1] * e, c = r[o + 2] * e;
    l += Math.abs((i[h] - i[c]) * (i[u + 1] - i[h + 1]) - (i[h] - i[u]) * (i[c + 1] - i[h + 1]));
  }
  return s === 0 && l === 0 ? 0 : Math.abs((l - s) / s);
}, Mc.flatten = function(i) {
  for (var t = i[0][0].length, e = {
    vertices: [],
    holes: [],
    dimensions: t
  }, r = 0, n = 0; n < i.length; n++) {
    for (var s = 0; s < i[n].length; s++) for (var o = 0; o < t; o++) e.vertices.push(i[n][s][o]);
    n > 0 && e.holes.push(r += i[n - 1].length);
  }
  return e;
};
const Kn = {
  PBRHelper: WD,
  StandardMaterial: MM,
  StandardSpecularGlossinessMaterial: XD,
  StandardShader: class extends qe {
    constructor(i = {}) {
      let t = i.extraCommandProps || {};
      const e = i.uniforms;
      t = $n({}, t);
      const r = i.defines || {}, n = [], s = [], o = [], a = [], l = [], h = [{
        name: "modelNormalMatrix",
        type: "function",
        fn: (u, c) => au(n, c.modelMatrix)
      }, {
        name: "modelViewNormalMatrix",
        type: "function",
        fn: (u, c) => {
          const f = Jt(s, c.viewMatrix, c.modelMatrix), d = Is(f, f), p = XA(d, d);
          return au(o, p);
        }
      }, {
        name: "modelViewMatrix",
        type: "function",
        fn: (u, c) => Jt(a, c.viewMatrix, c.modelMatrix)
      }, {
        name: "uEnvironmentTransform",
        type: "function",
        fn: (u, c) => qv(l, Math.PI * (c.environmentOrientation || 0) / 180)
      }];
      e && h.push(...e), super({
        vert: i.vert || `#include <gl2_vert>
#define SHADER_NAME PBR
precision highp float;
attribute vec3 aPosition;
#if defined(HAS_MAP)
attribute vec2 aTexCoord;
uniform vec2 uvOrigin;
uniform vec2 uvScale;
uniform vec2 uvOffset;
uniform float uvRotation;
#ifdef HAS_I3S_UVREGION
attribute vec4 uvRegion;
varying vec4 vUvRegion;
#endif
#if defined(HAS_AO_MAP)
attribute vec2 aTexCoord1;
varying vec2 vTexCoord1;
#endif
#endif
vec3 c;
vec3 d;
vec4 e;
uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 positionMatrix;
uniform mat4 projMatrix;
uniform mediump vec3 cameraPosition;
uniform mat3 modelNormalMatrix;
#ifdef HAS_SSR
uniform mat3 modelViewNormalMatrix;
varying vec3 vViewNormal;
#ifdef HAS_TANGENT
varying vec4 vViewTangent;
#endif
#endif
varying vec3 vModelNormal;
varying vec4 vViewVertex;
#if defined(HAS_TANGENT)
varying vec4 vModelTangent;
varying vec3 vModelBiTangent;
#endif
varying vec3 vModelVertex;
#if defined(HAS_MAP)
varying vec2 vTexCoord;
#endif
#if defined(HAS_COLOR)
attribute vec4 aColor;
varying vec4 vColor;
#endif
#ifdef HAS_OPACITY
attribute float aOpacity;
#endif
varying float vOpacity;
#include <highlight_vert>
#if defined(HAS_COLOR0)
#if COLOR0_SIZE == 3
attribute vec3 aColor0;
varying vec3 vColor0;
#else
attribute vec4 aColor0;
varying vec4 vColor0;
#endif
#endif
#include <line_extrusion_vert>
#include <get_output>
#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
#include <vsm_shadow_vert>
#endif
#include <heatmap_render_vert>
#include <vertex_color_vert>
#if defined(HAS_BUMP_MAP) && defined(HAS_TANGENT)
varying vec3 vTangentViewPos;
varying vec3 vTangentFragPos;
#if __VERSION__ == 100
mat3 f(in mat3 h) {
  vec3 i = h[0];
  vec3 j = h[1];
  vec3 k = h[2];
  return mat3(vec3(i.x, j.x, k.x), vec3(i.y, j.y, k.y), vec3(i.z, j.z, k.z));
}
#else
mat3 f(in mat3 h) {
  return transpose(h);
}
#endif
#endif
void l(const highp vec4 q, out highp vec3 m) {
  m = vec3(.0, .0, 1.) + vec3(2., -2., -2.) * q.x * q.zwx + vec3(2., 2., -2.) * q.y * q.wzy;
}
void l(const highp vec4 q, out highp vec3 m, out highp vec3 t) {
  l(q, m);
  t = vec3(1., .0, .0) + vec3(-2., 2., -2.) * q.y * q.yxw + vec3(-2., 2., 2.) * q.z * q.zwx;
}
const float o = .5;
vec2 u(vec2 v, float A) {
  return vec2(cos(A) * (v.x - o) + sin(A) * (v.y - o) + o, cos(A) * (v.y - o) - sin(A) * (v.x - o) + o);
}
#if defined(HAS_MAP)
vec2 B(vec2 v) {
  vec2 C = decode_getTexcoord(v);
#ifdef HAS_RANDOM_TEX
vec2 D = uvOrigin;
  vec2 E = C * uvScale + uvOffset;
  return mod(D, 1.) + E;
#else
vec2 D = uvOrigin;
  vec2 E = C * uvScale;
  if(uvRotation != .0) {
    D = u(D, uvRotation);
    E = u(E, uvRotation);
  }
  return mod(D, 1.) + E + uvOffset;
#endif
}
#endif
#ifdef PICKING_MODE
#include <fbo_picking_vert>
#endif
#include <excavate_vert>
void main() {
  mat4 F = getPositionMatrix();
#ifdef IS_LINE_EXTRUSION
vec3 G = getLineExtrudePosition(aPosition);
  vec4 H = getPosition(G);
#else
vec4 H = getPosition(aPosition);
#endif
vModelVertex = (modelMatrix * H).xyz;
  vec4 I = F * H;
  vec4 J = modelViewMatrix * I;
  vViewVertex = J;
#ifdef HAS_MASK_EXTENT
gl_Position = projMatrix * getMaskPosition(I, modelMatrix);
#else
gl_Position = projMatrix * J;
#endif
#ifdef PICKING_MODE
float K = 1.;
#if defined(HAS_COLOR)
K *= aColor.a;
#endif
#if defined(HAS_COLOR0) && COLOR0_SIZE == 4
K *= aColor0.a;
#endif
fbo_picking_setData(gl_Position.w, K != .0);
#else
#if defined(HAS_MAP)
vTexCoord = B(aTexCoord);
#ifdef HAS_AO_MAP
vTexCoord1 = B(aTexCoord1);
#endif
#ifdef HAS_I3S_UVREGION
vUvRegion = uvRegion / 65535.;
#endif
#endif
#if defined(HAS_TANGENT) || defined(HAS_NORMAL)
mat3 L = mat3(F);
  mat3 M = modelNormalMatrix * L;
#if defined(HAS_TANGENT)
vec3 t;
  l(aTangent, d, t);
  vModelTangent = vec4(M * t, aTangent.w);
#else
d = decode_getNormal(aNormal);
#endif
vec3 N = d;
  vModelNormal = M * N;
#else
d = vec3(.0);
  vModelNormal = vec3(.0);
#endif
#if defined(HAS_TANGENT)
vModelBiTangent = cross(vModelNormal, vModelTangent.xyz) * sign(aTangent.w);
#endif
#ifdef HAS_SSR
mat3 O = modelViewNormalMatrix * L;
  vViewNormal = O * d;
#if defined(HAS_TANGENT)
vec4 P = vec4(t, aTangent.w);
  vViewTangent = vec4(O * P.xyz, P.w);
#endif
#endif
#if defined(HAS_COLOR)
vColor = aColor / 255.;
#endif
#ifdef HAS_OPACITY
vOpacity = aOpacity / 255.;
#else
vOpacity = 1.;
#endif
highlight_setVarying();
#if defined(HAS_COLOR0)
vColor0 = aColor0 / 255.;
#endif
#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
shadow_computeShadowPars(I);
#endif
#ifdef HAS_HEATMAP
heatmap_compute(projMatrix * modelViewMatrix * F, H);
#endif
#if defined(HAS_BUMP_MAP) && defined(HAS_TANGENT)
mat3 Q = f(mat3(vModelTangent.xyz, vModelBiTangent, vModelNormal));
  vTangentViewPos = Q * cameraPosition;
  vTangentFragPos = Q * vModelVertex;
#endif
#ifdef HAS_VERTEX_COLOR
vertexColor_update();
#endif
#ifdef HAS_EXCAVATE_ANALYSIS
vCoordinateTexcoord = getCoordinateTexcoord();
  vHeight = getWorldHeight();
#endif
#endif
}`,
        frag: i.frag || `#if __VERSION__ == 100
#if defined(GL_EXT_shader_texture_lod)
#extension GL_EXT_shader_texture_lod : enable
#define textureCubeLod(tex, uv, lod) textureCubeLodEXT(tex, uv, lod)
#else
#define textureCubeLod(tex, uv, lod) textureCube(tex, uv, lod)
#endif
#if defined(GL_OES_standard_derivatives)
#extension GL_OES_standard_derivatives : enable
#endif
#else
#define textureCubeLod(tex, uv, lod) textureLod(tex, uv, lod)
#endif
#define saturate(x)        clamp(x, 0.0, 1.0)
precision mediump float;
#include <gl2_frag>
#include <hsv_frag>
uniform vec3 hsv;
uniform float contrast;
const float c = .04;
struct MaterialUniforms {
  vec2 roughnessMetalness;
  vec3 albedo;
  float alpha;
  vec3 normal;
  vec3 emit;
  float ao;
  vec3 specularColor;
  float glossiness;
  vec4 skinColor;
} d;
#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
#include <vsm_shadow_frag>
#endif
uniform vec3 cameraPosition;
uniform float alphaTest;
#if defined(SHADING_MODEL_SPECULAR_GLOSSINESS)
uniform vec4 diffuseFactor;
uniform vec3 specularFactor;
uniform float glossinessFactor;
#if defined(HAS_DIFFUSE_MAP)
uniform sampler2D diffuseTexture;
#endif
#if defined(HAS_SPECULARGLOSSINESS_MAP)
uniform sampler2D specularGlossinessTexture;
#endif
#endif
uniform vec3 emissiveFactor;
uniform vec4 baseColorFactor;
uniform float baseColorIntensity;
uniform float anisotropyDirection;
uniform float anisotropyFactor;
uniform float clearCoatFactor;
uniform float clearCoatIor;
uniform float clearCoatRoughnessFactor;
uniform float clearCoatThickness;
uniform float emitColorFactor;
uniform float occlusionFactor;
uniform float environmentExposure;
uniform float roughnessFactor;
uniform float metallicFactor;
uniform float normalMapFactor;
uniform float rgbmRange;
uniform float specularF0;
uniform int emitMultiplicative;
uniform int normalMapFlipY;
uniform int outputSRGB;
uniform mat3 uEnvironmentTransform;
#if defined(HAS_ALBEDO_MAP)
uniform sampler2D baseColorTexture;
#endif
#if defined(HAS_METALLICROUGHNESS_MAP)
uniform sampler2D metallicRoughnessTexture;
#endif
#if defined(HAS_EMISSIVE_MAP)
uniform sampler2D emissiveTexture;
#endif
#if defined(HAS_AO_MAP)
uniform sampler2D occlusionTexture;
varying vec2 vTexCoord1;
#endif
#if defined(HAS_NORMAL_MAP) && defined(HAS_TANGENT)
uniform sampler2D normalTexture;
#endif
#if defined(HAS_SKIN_MAP)
uniform sampler2D skinTexture;
#endif
#if defined(HAS_ALPHAMODE)
uniform float alphaCutoff;
#endif
#ifdef HAS_RANDOM_TEX
uniform highp vec2 uvOrigin;
uniform sampler2D noiseTexture;
#endif
uniform sampler2D brdfLUT;
#if defined(HAS_IBL_LIGHTING)
uniform vec3 hdrHSV;
uniform samplerCube prefilterMap;
uniform vec3 diffuseSPH[9];
uniform vec2 prefilterMiplevel;
uniform vec2 prefilterSize;
#else
uniform vec3 ambientColor;
#endif
uniform vec2 cameraNearFar;
uniform vec3 clearCoatTint;
uniform vec3 light0_viewDirection;
uniform vec4 light0_diffuse;
#ifdef HAS_SSR
varying vec3 vViewNormal;
#if defined(HAS_TANGENT)
varying vec4 vViewTangent;
#endif
#endif
varying vec3 vModelVertex;
varying vec4 vViewVertex;
#if defined(HAS_MAP)
#include <computeTexcoord_frag>
#endif
varying vec3 vModelNormal;
#if defined(HAS_TANGENT)
varying vec4 vModelTangent;
varying vec3 vModelBiTangent;
#endif
#if defined(HAS_COLOR0)
#if COLOR0_SIZE == 3
varying vec3 vColor0;
#else
varying vec4 vColor0;
#endif
#endif
#if defined(HAS_COLOR)
varying vec4 vColor;
#elif defined(IS_LINE_EXTRUSION)
uniform vec4 lineColor;
#else
uniform vec4 polygonFill;
#endif
#ifdef HAS_LAYER_OPACITY
uniform float layerOpacity;
#endif
varying float vOpacity;
#ifdef HAS_INSTANCE_COLOR
varying vec4 vInstanceColor;
#endif
#ifdef IS_LINE_EXTRUSION
uniform float lineOpacity;
#else
uniform float polygonOpacity;
#endif
#ifdef HAS_PATTERN
uniform sampler2D linePatternFile;
uniform vec2 atlasSize;
uniform float flipY;
uniform float currentTime;
uniform float animSpeedScale;
#ifdef HAS_PATTERN_ANIM
varying float vLinePatternAnimSpeed;
#else
uniform float linePatternAnimSpeed;
#endif
#ifdef HAS_PATTERN_GAP
varying float vLinePatternGap;
#else
uniform float linePatternGap;
#endif
uniform vec4 linePatternGapColor;
uniform vec2 uvScale;
varying float vPatternHeight;
varying float vLinesofar;
varying vec4 vTexInfo;
varying float vNormalY;
vec2 e(vec2 f) {
  vec2 h = mod(f, 1.);
  vec2 i = vTexInfo.xy;
  vec2 j = vTexInfo.zw;
  return (i + h * j) / atlasSize;
}
#endif
#include <heatmap_render_frag>
#include <snow_frag>
#include <mask_frag>
#include <terrain_normal_frag>
#include <vertex_color_frag>
#include <excavate_frag>
#ifdef HAS_RANDOM_TEX
const float k = .5;
vec2 l(vec2 h, float m) {
  return vec2(cos(m) * (h.x - k) + sin(m) * (h.y - k) + k, cos(m) * (h.y - k) - sin(m) * (h.x - k) + k);
}
float n(vec3 o) {
  return o.x + o.y + o.z;
}
#endif
vec4 u(sampler2D A, in vec2 h) {
  
#ifdef HAS_RANDOM_TEX
highp vec2 B = uvOrigin;
  highp vec2 C = h + B - mod(B, 1.);
  float D = texture2D(noiseTexture, .005 * C).x;
  vec2 E = dFdx(C);
  vec2 F = dFdx(C);
  float G = D * 8.;
  float H = fract(G);
#if 1
float I = floor(G);
  float J = I + 1.;
#else
float I = floor(G + .5);
  float J = floor(G);
  H = min(H, 1. - H) * 2.;
#endif
vec2 K = sin(vec2(3., 7.) * I);
  vec2 L = sin(vec2(3., 7.) * J);
  float M = .5;
  vec4 N = texture2DGradEXT(A, h + M * K, E, F);
  vec4 O = texture2DGradEXT(A, h + M * L, E, F);
  return mix(N, O, smoothstep(.2, .8, H - .1 * n(N.xyz - O.xyz)));
#else
return texture2D(A, h);
#endif
}
#if defined(HAS_BUMP_MAP) && defined(HAS_TANGENT)
uniform sampler2D bumpTexture;
uniform float bumpScale;
uniform float bumpMaxLayers;
uniform float bumpMinLayers;
vec2 P(vec2 h, vec3 Q) {
  float R = mix(bumpMaxLayers, bumpMinLayers, abs(dot(vec3(.0, .0, 1.), Q)));
  float S = 1. / R;
  float T = .0;
  vec2 U = Q.xy * bumpScale / (Q.z * R);
  vec2 V = h;
  float W = u(bumpTexture, V).r;
  for(int X = 0; X < 30; X++) {
    T += S;
    V -= U;
    W = u(bumpTexture, V).r;
    if(W < T) {
      break;
    }
  }
  vec2 Y = V + U;
  float Z = W - T;
  float ba = u(bumpTexture, Y).r - T + S;
  return mix(V, Y, Z / (Z - ba));
}
varying vec3 vTangentViewPos;
varying vec3 vTangentFragPos;
#endif
#define SHADER_NAME PBR
vec3 bb(const in vec3 bc) {
  return vec3(bc.r < .0031308 ? bc.r * 12.92 : 1.055 * pow(bc.r, 1. / 2.4) - .055, bc.g < .0031308 ? bc.g * 12.92 : 1.055 * pow(bc.g, 1. / 2.4) - .055, bc.b < .0031308 ? bc.b * 12.92 : 1.055 * pow(bc.b, 1. / 2.4) - .055);
}
vec3 bd(const in vec3 bc) {
  return vec3(bc.r < .04045 ? bc.r * (1. / 12.92) : pow((bc.r + .055) * (1. / 1.055), 2.4), bc.g < .04045 ? bc.g * (1. / 12.92) : pow((bc.g + .055) * (1. / 1.055), 2.4), bc.b < .04045 ? bc.b * (1. / 12.92) : pow((bc.b + .055) * (1. / 1.055), 2.4));
}
vec3 be(const in vec4 bc, const in float bf) {
  if(bf <= .0)
    return bc.rgb;
  return bf * bc.rgb * bc.a;
}
vec3 bg() {
  return d.albedo;
}
float bh() {
  
#if defined(HAS_ALPHAMODE)
if(d.alpha >= alphaCutoff) {
    return 1.;
  } else {
    return .0;
  }
#else
return d.alpha;
#endif
}
float bi() {
  
#if defined(SHADING_MODEL_SPECULAR_GLOSSINESS)
vec3 bc = d.specularColor;
  return max(max(bc.r, bc.g), bc.b);
#else
return d.roughnessMetalness.y;
#endif
}
float bj() {
  return specularF0;
}
float bk() {
  
#if defined(SHADING_MODEL_SPECULAR_GLOSSINESS)
return 1. - d.glossiness;
#else
return d.roughnessMetalness.x;
#endif
}
vec3 bl() {
  return d.emit;
}
vec4 bm() {
  return d.skinColor;
}
vec3 bn() {
  return d.normal;
}
float bo() {
  return clearCoatFactor;
}
float bp() {
  return clearCoatRoughnessFactor;
}
float bq() {
  return d.ao;
}
float br(const in vec4 bs) {
  return bs.r + bs.g / 255.;
}
float bt(const in vec2 bu, const in float bv) {
  vec3 bw = vec3(.06711056, .00583715, 52.9829189);
  return fract(bw.z * fract(dot(bu.xy + bv * vec2(47., 17.) * .695, bw.xy))) * .5;
}
vec3 bx(const in float by, in vec3 bz, const in vec3 t, const in vec3 b, in vec3 bA) {
  bz.xy = by * bz.xy;
  mat3 bB = mat3(t, b, bA);
  return normalize(bB * bz);
}
void bC(const in vec3 bD, const in vec3 bz, const in vec3 bE, out float bF, out vec3 bG, out float bH) {
  bF = 1.;
  bG = -bE;
  bH = dot(bG, bz);
}
vec4 bI(const in vec3 bz, const in vec3 bD, const in float bJ) {
  float bK = clamp(dot(bz, bD), 0., 1.);
  float bL = bJ * bJ;
  return vec4(bL, bL * bL, bK, bK * (1. - bL));
}
float bM(const vec4 bI, const float bN) {
  float bO = bI.y;
  float bP = (bN * bO - bN) * bN + 1.;
  return bO / (3.141593 * bP * bP);
}
vec3 bQ(const vec3 bR, const float bS, const in float bT) {
  float bU = pow(1. - bT, 5.);
  return bS * bU + (1. - bU) * bR;
}
float bQ(const float bR, const float bS, const in float bT) {
  return bR + (bS - bR) * pow(1. - bT, 5.);
}
float bV(const vec4 bI, const float bW) {
  float a = bI.x;
  float bX = bW * (bI.w + a);
  float bY = bI.z * (bW * (1. - a) + a);
  return .5 / (bX + bY);
}
vec3 bZ(const vec4 bI, const vec3 bz, const vec3 bD, const vec3 bG, const vec3 ca, const float bW, const float bS) {
  vec3 cb = normalize(bD + bG);
  float bN = clamp(dot(bz, cb), 0., 1.);
  float bT = clamp(dot(bG, cb), 0., 1.);
  float cc = bM(bI, bN);
  float cd = bV(bI, bW);
  vec3 ce = bQ(ca, bS, bT);
  return (cc * cd * 3.141593) * ce;
}
void cf(const in vec3 bz, const in vec3 bD, const in float bW, const in vec4 bI, const in vec3 cg, const in vec3 ca, const in float bF, const in vec3 ch, const in vec3 bG, const in float bS, out vec3 ci, out vec3 cj, out bool ck) {
  ck = bW > .0;
  if(ck == false) {
    cj = ci = vec3(.0);
    return;
  }
  vec3 cl = bF * bW * ch;
  cj = cl * bZ(bI, bz, bD, bG, ca, bW, bS);
  ci = cl * cg;
}
float cm(float at, float ab, float cn, float co, float cp, float cq, float bK, float bW) {
  float cr = bW * length(vec3(at * cn, ab * co, bK));
  float cs = bK * length(vec3(at * cp, ab * cq, bW));
  return .5 / (cr + cs);
}
float ct(const float at, const float ab, const float cu, const float cv, const float bN) {
  float bO = at * ab;
  vec3 bP = vec3(ab * cu, at * cv, bO * bN);
  float x = bO / dot(bP, bP);
  return bO * (x * x) / 3.141593;
}
vec3 cw(const vec4 bI, const vec3 bz, const vec3 bD, const vec3 bG, const vec3 ca, const float bW, const float bS, const in vec3 cx, const in vec3 cy, const in float cz) {
  vec3 cb = normalize(bD + bG);
  float bN = clamp(dot(bz, cb), 0., 1.);
  float bK = clamp(dot(bz, bD), 0., 1.);
  float bT = clamp(dot(bG, cb), 0., 1.);
  float cn = dot(cx, bD);
  float co = dot(cy, bD);
  float cp = dot(cx, bG);
  float cq = dot(cy, bG);
  float cu = dot(cx, cb);
  float cv = dot(cy, cb);
  float cA = sqrt(1. - abs(cz) * .9);
  if(cz > .0)
    cA = 1. / cA;
  float at = bI.x * cA;
  float ab = bI.x / cA;
  float cc = ct(at, ab, cu, cv, bN);
  float cd = cm(at, ab, cn, co, cp, cq, bK, bW);
  vec3 ce = bQ(ca, bS, bT);
  return (cc * cd * 3.141593) * ce;
}
void cB(const in vec3 bz, const in vec3 bD, const in float bW, const in vec4 bI, const in vec3 cg, const in vec3 ca, const in float bF, const in vec3 ch, const in vec3 bG, const in float bS, const in vec3 cx, const in vec3 cy, const in float cz, out vec3 ci, out vec3 cj, out bool ck) {
  ck = bW > .0;
  if(ck == false) {
    cj = ci = vec3(.0);
    return;
  }
  vec3 cl = bF * bW * ch;
  cj = cl * cw(bI, bz, bD, bG, ca, bW, bS, cx, cy, cz);
  ci = cl * cg;
}
#if defined(HAS_IBL_LIGHTING)
vec3 cC(const in vec3 bz) {
  vec3 bA = uEnvironmentTransform * bz;
  float x = bA.x;
  float y = bA.y;
  float z = bA.z;
  vec3 cD = (diffuseSPH[0] + diffuseSPH[1] * x + diffuseSPH[2] * y + diffuseSPH[3] * z + diffuseSPH[4] * z * x + diffuseSPH[5] * y * z + diffuseSPH[6] * y * x + diffuseSPH[7] * (3. * z * z - 1.) + diffuseSPH[8] * (x * x - y * y));
  if(length(hdrHSV) > .0) {
    cD = hsv_apply(cD, hdrHSV);
  }
  return max(cD, vec3(.0));
}
float cE(const in float cF) {
  return cF;
}
vec3 cG(const in float cH, const in vec3 cI) {
  vec3 cJ = cI;
  float cK = prefilterMiplevel.x;
  float cL = min(cK, cE(cH) * prefilterMiplevel.y);
  vec3 cM = be(textureCubeLod(prefilterMap, cJ, cL), rgbmRange);
  if(length(hdrHSV) > .0) {
    return hsv_apply(cM, hdrHSV);
  } else {
    return cM;
  }
}
vec3 cN(const in vec3 cO, const in vec3 cI, const in float cP) {
  float cQ = 1. - cP;
  float cR = cQ * (sqrt(cQ) + cP);
  return mix(cO, cI, cR);
}
vec3 cS(const in vec3 bz, const in vec3 bD, const in float bJ, const in vec3 cT) {
  vec3 cI = reflect(-bD, bz);
  cI = cN(bz, cI, bJ);
  vec3 cU = cG(bJ, uEnvironmentTransform * cI);
  float by = clamp(1. + dot(cI, cT), .0, 1.);
  cU *= by * by;
  return cU;
}
#else
vec3 cS(const in vec3 bz, const in vec3 bD, const in float bJ, const in vec3 cT) {
  return ambientColor;
}
#endif
vec3 cV(const in vec3 ca, const in float bJ, const in float bK, const in float bS) {
  vec4 rgba = texture2D(brdfLUT, vec2(bK, bJ));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.);
  const float cW = 1. / 65535.;
  return (ca * a + b * bS) * cW;
}
vec3 cX(const in vec3 bz, const in vec3 bD, const in float bJ, const in vec3 ca, const in vec3 cT, const in float bS) {
  float bK = dot(bz, bD);
  return cS(bz, bD, bJ, cT) * cV(ca, bJ, bK, bS);
}
vec3 cY(const float bK, const float bW, const vec3 cZ, const float bP) {
  return exp(cZ * -bP * ((bW + bK) / max(bW * bK, 1e-3)));
}
vec3 da(const in float bK, const in float bW, const in float db) {
  return mix(vec3(1.), cY(bK, bW, clearCoatTint, clearCoatThickness), db);
}
void dc(const in float dd, const in vec3 bz, const in vec3 bD, const in float bH, const in vec4 bI, const in float bF, const in vec3 ch, const in vec3 bG, const in float db, out vec3 de, out vec3 df) {
  if(bH <= .0) {
    de = vec3(.0);
    df = vec3(.0);
    return;
  }
  float dg = clamp(dot(bz, -refract(bG, bz, 1. / clearCoatIor)), 0., 1.);
  vec3 dh = da(dd, dg, db);
  vec3 cb = normalize(bD + bG);
  float bN = clamp(dot(bz, cb), 0., 1.);
  float bT = clamp(dot(bG, cb), 0., 1.);
  float cc = bM(bI, bN);
  float cd = bV(bI, dg);
  float ce = bQ(c, 1., bT);
  de = (bF * bH * db * cc * cd * 3.141593 * ce) * ch;
  df = (1. - ce * db) * dh;
}
float di(const in int dj, const in float dk, const in vec3 bz, const in vec3 bD) {
  if(dj == 0)
    return 1.;
  float bP = dot(bz, bD) + dk;
  return clamp(bP * bP - 1. + dk, .0, 1.);
}
vec3 dl(const in vec3 bz, const in vec3 bD, const in float bJ, const in vec3 cx, const in vec3 cy, const in float cz) {
  vec3 dm = cz >= .0 ? cy : cx;
  vec3 dn = cross(dm, bD);
  vec3 dp = cross(dn, dm);
  float dq = abs(cz) * clamp(5. * bJ, .0, 1.);
  return normalize(mix(bz, dp, dq));
}
void dr() {
  
#ifdef HAS_MAP
vec2 h = computeTexCoord(vTexCoord);
#endif
#ifdef HAS_UV_FLIP
h.y = 1. - h.y;
#endif
#if defined(HAS_BUMP_MAP) && defined(HAS_TANGENT)
h = P(h, normalize(vTangentViewPos - vTangentFragPos));
#endif
d.albedo = baseColorIntensity * baseColorFactor.rgb;
  d.alpha = baseColorFactor.a * vOpacity;
#if defined(HAS_PATTERN)
float ds = vLinesofar;
  vec2 j = vTexInfo.zw;
#ifdef HAS_PATTERN_GAP
float dt = vLinePatternGap;
#else
float dt = linePatternGap;
#endif
#ifdef HAS_PATTERN_ANIM
float du = vLinePatternAnimSpeed;
#else
float du = linePatternAnimSpeed;
#endif
float dv = ceil(j.x * vPatternHeight / j.y);
  float dw = dv * (1. + dt);
  du /= animSpeedScale;
  ds += mod(currentTime * -du * .2, dw);
  float dx = mod(ds / dw, 1.);
  float dy = mod(flipY * vNormalY, 1.);
  vec2 h = e(vec2(dx * (1. + dt) * uvScale[0], dy * uvScale[1]));
  vec4 dz = texture2D(linePatternFile, h);
  float dA = clamp(sign(1. / (1. + dt) - dx) + .000001, .0, 1.);
  dz = mix(linePatternGapColor, dz, dA);
#ifdef IS_SQUARE_TUBE
float o = clamp(sign(abs(vNormalY) - .999999), .0, 1.);
  dz = mix(dz, vec4(1.), o);
#endif
d.albedo *= dz.rgb;
  d.alpha *= dz.a;
#endif
#if defined(HAS_ALBEDO_MAP)
vec4 dB = u(baseColorTexture, h);
  d.albedo *= bd(dB.rgb);
  d.alpha *= dB.a;
#endif
#if defined(HAS_SKIN_MAP)
vec4 dC = u(skinTexture, h);
  d.skinColor = dC;
#endif
#if defined(HAS_COLOR0)
d.albedo *= vColor0.rgb;
#if COLOR0_SIZE == 4
d.alpha *= vColor0.a;
#endif
#endif
#if defined(HAS_COLOR)
d.albedo *= vColor.rgb;
  d.alpha *= vColor.a;
#elif defined(IS_LINE_EXTRUSION)
d.albedo *= lineColor.rgb;
  d.alpha *= lineColor.a;
#else
d.albedo *= polygonFill.rgb;
  d.alpha *= polygonFill.a;
#endif
#if defined(HAS_INSTANCE_COLOR)
d.albedo *= vInstanceColor.rgb;
  d.alpha *= vInstanceColor.a;
#endif
#if defined(IS_LINE_EXTRUSION)
d.alpha *= lineOpacity;
#else
d.alpha *= polygonOpacity;
#endif
#if defined(HAS_METALLICROUGHNESS_MAP)
d.roughnessMetalness = u(metallicRoughnessTexture, h).gb * vec2(roughnessFactor, metallicFactor);
#else
d.roughnessMetalness = vec2(roughnessFactor, metallicFactor);
#endif
d.emit = emissiveFactor;
#if defined(HAS_EMISSIVE_MAP)
if(emitMultiplicative == 1) {
    d.emit *= bd(u(emissiveTexture, h).rgb);
  } else {
    d.emit += bd(u(emissiveTexture, h).rgb);
  }
#endif
d.emit *= emitColorFactor;
#if defined(HAS_AO_MAP)
vec2 dD = computeTexCoord(vTexCoord1);
  d.ao = u(occlusionTexture, dD).r;
#else
d.ao = 1.;
#endif
d.ao *= occlusionFactor;
#if defined(HAS_NORMAL_MAP) && defined(HAS_TANGENT)
vec3 dE = u(normalTexture, h).xyz * 2. - 1.;
  dE.y = normalMapFlipY == 1 ? -dE.y : dE.y;
  d.normal = dE;
#else
d.normal = normalize(vModelNormal);
#endif
#if defined(HAS_TERRAIN_NORMAL) && defined(HAS_TANGENT)
vec3 dE = convertTerrainHeightToNormalMap(h);
  dE.y = normalMapFlipY == 1 ? -dE.y : dE.y;
  d.normal = dE;
#endif
#if defined(SHADING_MODEL_SPECULAR_GLOSSINESS)
d.albedo *= diffuseFactor.rgb;
  d.alpha *= diffuseFactor.a;
#if defined(HAS_DIFFUSE_MAP)
vec4 cg = u(diffuseTexture, h);
  d.albedo *= bd(cg.rgb);
  d.alpha *= cg.a;
#endif
d.specularColor = specularFactor;
  d.glossiness = glossinessFactor;
#if defined(HAS_SPECULARGLOSSINESS_MAP)
vec4 dF = u(specularGlossinessTexture, h);
  d.specularColor *= bd(dF.rgb);
  d.glossiness *= dF.a;
#endif
#endif
}
vec3 dG(const vec3 x) {
  const float a = 2.51;
  const float b = .03;
  const float dH = 2.43;
  const float bP = .59;
  const float dI = .14;
  return (x * (a * x + b)) / (x * (dH * x + bP) + dI);
}
vec3 dJ(vec3 bc) {
  bc = dG(bc);
  return bc = pow(bc, vec3(1. / 2.2));
}
uniform float specularAAVariance;
uniform float specularAAThreshold;
float dK(float bJ, const vec3 dL) {
  
#if defined(GL_OES_standard_derivatives) || __VERSION__ == 300
vec3 dM = dFdx(dL);
  vec3 dN = dFdy(dL);
  float dO = specularAAVariance * (dot(dM, dM) + dot(dN, dN));
  float dP = min(2. * dO, specularAAThreshold);
  float dQ = saturate(bJ * bJ + dP);
  return sqrt(dQ);
#else
return bJ;
#endif
}
#ifdef HAS_SSR
uniform sampler2D TextureDepth;
uniform highp vec2 outSize;
uniform float ssrFactor;
uniform float ssrQuality;
uniform sampler2D TextureReflected;
uniform highp mat4 projMatrix;
uniform mat4 invProjMatrix;
uniform vec4 outputFovInfo[2];
uniform mat4 reprojViewProjMatrix;
vec3 dR(const in mat4 dS, const in vec3 dT) {
  vec4 dU = dS * vec4(dT, 1.);
  return vec3(.5 + .5 * dU.xy / dU.w, dU.w);
}
vec3 dV(const in float dW, const in vec2 h) {
  return texture2D(TextureReflected, h).rgb;
}
float dX(float dY) {
  highp mat4 dS = projMatrix;
  highp float z = dY * 2. - 1.;
  return -dS[3].z / (z + dS[2].z);
}
float dZ(const vec2 h) {
  float dY = br(texture2D(TextureDepth, h));
  return dY;
}
vec3 ea(const in float bv, const in vec3 eb, const in vec3 ec, const in vec3 ed, const in vec3 bD, const in float ee) {
  vec2 ef;
  ef.x = bt(gl_FragCoord.yx, bv);
  ef.y = fract(ef.x * 52.9829189);
  ef.y = mix(ef.y, 1., .7);
  float eg = 2. * 3.14159 * ef.x;
  float eh = pow(max(ef.y, .000001), ee / (2. - ee));
  float ei = sqrt(1. - eh * eh);
  vec3 ej = vec3(ei * cos(eg), ei * sin(eg), eh);
  ej = ej.x * eb + ej.y * ec + ej.z * ed;
  return normalize((2. * dot(bD, ej)) * ej - bD);
}
float ek(const in float bv) {
  return (bt(gl_FragCoord.xy, bv) - .5);
}
vec3 el(const in vec3 em, const in float en, const in vec3 eo) {
  vec3 ep = dR(projMatrix, vViewVertex.xyz + eo * en);
  ep.z = 1. / ep.z;
  ep -= em;
  float eq = min(1., .99 * (1. - em.x) / max(1e-5, ep.x));
  float er = min(1., .99 * (1. - em.y) / max(1e-5, ep.y));
  float es = min(1., .99 * em.x / max(1e-5, -ep.x));
  float et = min(1., .99 * em.y / max(1e-5, -ep.y));
  return ep * min(eq, er) * min(es, et);
}
float eu(const in vec3 em, const in vec3 ep, inout float ev, inout float ew) {
  float ex = (ew + ev) * .5;
  vec3 ey = em + ep * ex;
  float z = dZ(ey.xy);
  float dY = dX(z);
  float ez = -1. / ey.z;
  ev = dY > ez ? ev : ex;
  ew = dY > ez ? ex : ew;
  return ex;
}
vec4 eA(const in vec3 em, const in float en, in float eB, const in vec3 eo, const in float bJ, const in float bv) {
  int eC = 20;
  float eD = 1. / float(eC);
  eB *= eD;
  vec3 ep = el(em, en, eo);
  float eE = eD;
  vec3 eF = vec3(.0, eE, 1.);
  vec3 ey;
  float z, dY, ez, eG, eH, eI;
  bool eJ;
  float eK = 1.;
  float ex;
  for(int X = 0; X < eC; X++) {
    ey = em + ep * eF.y;
    z = dZ(ey.xy);
    dY = dX(z);
    ez = -1. / ey.z;
    float eL = clamp(sign(.999 - z), .0, 1.);
    eG = eL * (ez - dY);
    eG *= clamp(sign(abs(eG) - en * eD * eD), .0, 1.);
    eJ = abs(eG + eB) < eB;
    eH = clamp(eF.x / (eF.x - eG), .0, 1.);
    eI = eJ ? eF.y + eH * eD - eD : 1.;
    eF.z = min(eF.z, eI);
    eF.x = eG;
    if(eJ) {
      float ev = eF.y - eD;
      float ew = eF.y;
      ex = eu(em, ep, ev, ew);
      ex = eu(em, ep, ev, ew);
      ex = eu(em, ep, ev, ew);
      eK = ex;
      break;
    }
    eF.y += eD;
  }
  return vec4(em + ep * eK, 1. - eK);
}
vec4 eM(in vec4 eN, const in float eO, const in vec3 eP, const in vec3 eQ, const in float bJ) {
  vec4 eR = mix(outputFovInfo[0], outputFovInfo[1], eN.x);
  eN.xyz = vec3(mix(eR.xy, eR.zw, eN.y), 1.) * -1. / eN.z;
  eN.xyz = (reprojViewProjMatrix * vec4(eN.xyz, 1.)).xyw;
  eN.xy /= eN.z;
  float eS = clamp(6. - 6. * max(abs(eN.x), abs(eN.y)), .0, 1.);
  eN.xy = .5 + .5 * eN.xy;
  vec3 eT = eQ * dV(bJ * (1. - eN.w), eN.xy);
  return vec4(mix(eP, eT, eO * eS), 1.);
}
vec3 ssr(const in vec3 eP, const in vec3 eQ, const in float bJ, const in vec3 bz, const in vec3 bD) {
  float eU = .0;
  vec4 cD = vec4(.0);
  float ee = bJ * bJ;
  ee = ee * ee;
  vec3 eV = abs(bz.z) < .999 ? vec3(.0, .0, 1.) : vec3(1., .0, .0);
  vec3 eb = normalize(cross(eV, bz));
  vec3 ec = cross(bz, eb);
  float eO = ssrFactor * clamp(-4. * dot(bD, bz) + 3.8, .0, 1.);
  eO *= clamp(4.7 - bJ * 5., .0, 1.);
  vec3 em = dR(projMatrix, vViewVertex.xyz);
  em.z = 1. / em.z;
  vec3 eo = ea(eU, eb, ec, bz, bD, ee);
  float en = mix(cameraNearFar.y + vViewVertex.z, -vViewVertex.z - cameraNearFar.x, eo.z * .5 + .5);
  float eB = .5 * en;
  vec4 eN;
  if(dot(eo, bz) > .001 && eO > .0) {
    eN = eA(em, en, eB, eo, bJ, eU);
    if(eN.w > .0)
      cD += eM(eN, eO, eP, eQ, bJ);
    
  }
  return cD.w > .0 ? cD.rgb / cD.w : eP;
}
#endif
#include <highlight_frag>
void main() {
  dr();
  vec3 bD = normalize(cameraPosition - vModelVertex.xyz);
#if defined(HAS_DOUBLE_SIDE)
vec3 cT = gl_FrontFacing ? normalize(vModelNormal) : -normalize(vModelNormal);
#else
vec3 cT = normalize(vModelNormal);
#endif
#if defined(HAS_TANGENT)
vec4 eW;
  eW = vModelTangent;
#if defined(HAS_DOUBLE_SIDE)
eW.xyz = gl_FrontFacing ? normalize(eW.xyz) : -normalize(eW.xyz);
#else
eW.xyz = normalize(eW.xyz);
#endif
vec3 eX = normalize(vModelBiTangent);
#endif
float bR = .08 * bj();
  float eY = bi();
  vec3 eZ = bg();
#if defined(SHADING_MODEL_SPECULAR_GLOSSINESS)
vec3 fa = d.specularColor;
#else
vec3 fa = mix(vec3(bR), eZ, eY);
#endif
eZ *= 1. - eY;
  float fb = clamp(50.0 * fa.g, .0, 1.);
  float fc = bk();
  if(specularAAVariance > .0) {
    fc = dK(fc, cT);
  }
  vec3 fd = bl();
  vec3 fe = bn();
  vec3 ff = vec3(fe);
#if defined(HAS_TANGENT) && (defined(HAS_NORMAL_MAP) || defined(HAS_TERRAIN_NORMAL))
ff = bx(normalMapFactor, ff, eW.xyz, eX, cT);
#endif
float fg = bo();
  float fh = bp();
  if(specularAAVariance > .0) {
    fh = dK(fh, cT);
  }
  vec3 fi = cT;
#if defined(HAS_TANGENT)
float cz;
  vec3 cx;
  vec3 cy;
  if(anisotropyFactor > .0) {
    cz = anisotropyFactor;
    eW.xyz = normalize(eW.xyz - ff * dot(eW.xyz, ff));
    eX = normalize(cross(ff, eW.xyz)) * eW.w;
    cx = normalize(mix(eW.xyz, eX, anisotropyDirection));
    cy = normalize(mix(eX, -eW.xyz, anisotropyDirection));
  }
#endif
vec3 cg = vec3(.0);
  vec3 ca = vec3(.0);
  vec3 fj;
#if defined(HAS_TANGENT)
if(anisotropyFactor > .0) {
    fj = dl(ff, bD, fc, cx, cy, cz);
  } else {
    fj = ff;
  }
#else
fj = ff;
#endif
#if defined(HAS_IBL_LIGHTING)
cg = eZ * cC(ff) * .5;
#else
cg = eZ * ambientColor;
#endif
ca = cX(fj, bD, fc, fa, cT, fb);
  float dd;
  if(clearCoatFactor > .0) {
    dd = clamp(dot(fi, -refract(bD, fi, 1. / clearCoatIor)), 0., 1.);
    float fk = fg * bQ(c, 1., dd);
    vec3 fl = da(dd, dd, fg);
    ca = mix(ca * fl, cS(fi, bD, fh, cT), fk);
    cg *= fl * (1. - fk);
  }
  float fm = 1.;
  float fn = bq();
  cg *= environmentExposure * fn;
#ifdef HAS_IBL_LIGHTING
fm = di(1, fn, ff, bD);
#endif
#ifdef HAS_SSR
vec3 fo = normalize(gl_FrontFacing ? vViewNormal : -vViewNormal);
  vec3 fp = fo;
#if defined(HAS_TANGENT) && (defined(HAS_NORMAL_MAP) || defined(HAS_TERRAIN_NORMAL))
vec4 fq;
  fq = vViewTangent;
  fq = gl_FrontFacing ? fq : -fq;
  fq.xyz = normalize(fq.xyz);
  vec3 fr = normalize(cross(fo, fq.xyz)) * fq.w;
  fp = bx(normalMapFactor, fe, fq.xyz, fr, fo);
#endif
ca = ssr(ca, fa * fm, fc, fp, -normalize(vViewVertex.xyz));
#endif
ca *= environmentExposure * fm;
  float bF, bH;
  vec3 bG;
  bool ck;
  vec3 fs;
  vec3 ft;
  vec4 fu = bI(ff, bD, max(.045, fc));
  vec3 fv = vModelNormal;
  bC(bD, ff, light0_viewDirection, bF, bG, bH);
#if defined(HAS_TANGENT)
if(anisotropyFactor > .0) {
    cB(ff, bD, bH, fu, eZ, fa, bF, light0_diffuse.rgb, bG, fb, cx, cy, cz, ft, fs, ck);
  } else {
    cf(ff, bD, bH, fu, eZ, fa, bF, light0_diffuse.rgb, bG, fb, ft, fs, ck);
  }
#else
cf(ff, bD, bH, fu, eZ, fa, bF, light0_diffuse.rgb, bG, fb, ft, fs, ck);
#endif
if(clearCoatFactor > .0) {
    vec3 fw;
    vec3 fx;
    vec4 fy = bI(fi, bD, fh);
    dc(dd, fi, bD, dot(fi, bG), fy, bF, light0_diffuse.rgb, bG, fg, fw, fx);
    ft *= fx;
    fs = fw + fs * fx;
  }
#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
float fz = shadow_computeShadow();
  ft = shadow_blend(ft, fz).rgb;
  fs = shadow_blend(fs, fz).rgb;
#endif
vec3 fA = vec3(ca);
  vec3 fB = vec3(cg);
  cg += ft;
  ca += fs;
  cg += fd;
  vec3 fC = ca + cg;
  if(outputSRGB == 1)
    fC = bb(fC);
  
#ifdef HAS_SKIN_MAP
vec4 fD = bm();
  fC.rgb = fC.rgb * (1. - fD.a) + fD.rgb * fD.a;
#endif
float fE = bh();
  glFragColor = vec4(fC * fE, fE);
  if(glFragColor.a < alphaTest) {
    discard;
  }
#ifdef HAS_VERTEX_COLOR
glFragColor *= vertexColor_get();
#endif
#ifdef HAS_EXCAVATE_ANALYSIS
glFragColor = excavateColor(glFragColor);
#endif
#ifdef HAS_HEATMAP
glFragColor = heatmap_getColor(glFragColor);
#endif
#ifdef HAS_SNOW
glFragColor.rgb = snow(glFragColor, bn(), 1.);
#endif
if(contrast != 1.) {
    glFragColor = contrastMatrix(contrast) * glFragColor;
  }
  if(length(hsv) > .0) {
    glFragColor = hsv_apply(glFragColor, hsv);
  }
#ifdef OUTPUT_NORMAL
glFragColor = vec4(cT, 1.);
#endif
glFragColor = highlight_blendColor(glFragColor);
#ifdef HAS_LAYER_OPACITY
glFragColor *= layerOpacity;
#endif
#ifdef HAS_MASK_EXTENT
glFragColor = setMask(glFragColor);
#endif
#if __VERSION__ == 100
gl_FragColor = glFragColor;
#endif
}`,
        uniforms: h,
        extraCommandProps: t,
        defines: r
      }), this.version = 300;
    }
    getGeometryDefines(i) {
      const t = {};
      return i.data[i.desc.tangentAttribute] ? t.HAS_TANGENT = 1 : i.data[i.desc.normalAttribute] && (t.HAS_NORMAL = 1), i.data[i.desc.colorAttribute] && (t.HAS_COLOR = 1), i.data[i.desc.color0Attribute] && (t.HAS_COLOR0 = 1, t.COLOR0_SIZE = i.getColor0Size()), t;
    }
  },
  StandardDepthShader: class extends qe {
    constructor(i = {}) {
      const t = [];
      super({
        vert: `#define SHADER_NAME depth_vert
precision highp float;
attribute vec3 aPosition;
#include <line_extrusion_vert>
uniform mat4 modelViewMatrix;
uniform mat4 positionMatrix;
uniform mat4 projMatrix;
uniform vec2 outSize;
uniform vec2 halton;
#include <get_output>
void main() {
  mat4 c = getPositionMatrix();
#ifdef IS_LINE_EXTRUSION
vec4 d = getPosition(getLineExtrudePosition(aPosition));
#else
vec4 d = getPosition(aPosition);
#endif
vec4 e = modelViewMatrix * c * d;
  mat4 f = projMatrix;
  f[2].xy += halton.xy / outSize.xy;
  gl_Position = f * e;
}`,
        frag: `#define SHADER_NAME depth_frag
precision highp float;
void main() {
  gl_FragColor = vec4(1., .0, .0, 1.);
}`,
        uniforms: [{
          name: "modelViewMatrix",
          type: "function",
          fn: (e, r) => Jt(t, r.viewMatrix, r.modelMatrix)
        }],
        extraCommandProps: i.extraCommandProps,
        defines: i.defines
      });
    }
  },
  PBRUtils: JD
};
var Tx = Array.isArray, Ax = Object.keys, gF = Object.prototype.hasOwnProperty, mF = function i(t, e) {
  if (t === e) return !0;
  if (t && e && typeof t == "object" && typeof e == "object") {
    var r = Tx(t), n = Tx(e), s, o, a;
    if (r && n) {
      if (o = t.length, o != e.length) return !1;
      for (s = o; s-- !== 0; )
        if (!i(t[s], e[s])) return !1;
      return !0;
    }
    if (r != n) return !1;
    var l = t instanceof Date, h = e instanceof Date;
    if (l != h) return !1;
    if (l && h) return t.getTime() == e.getTime();
    var u = t instanceof RegExp, c = e instanceof RegExp;
    if (u != c) return !1;
    if (u && c) return t.toString() == e.toString();
    var f = Ax(t);
    if (o = f.length, o !== Ax(e).length)
      return !1;
    for (s = o; s-- !== 0; )
      if (!gF.call(e, f[s])) return !1;
    for (s = o; s-- !== 0; )
      if (a = f[s], !i(t[a], e[a])) return !1;
    return !0;
  }
  return t !== t && e !== e;
};
const fu = /* @__PURE__ */ Fs(mF);
/*!
 * @maptalks/fusiongl v0.6.13
 * LICENSE : UNLICENSED
 * (c) 2016-2024 maptalks.com
 */
function vF(i) {
  for (let t = 1; t < arguments.length; t++) {
    const e = arguments[t];
    for (const r in e) i[r] = e[r];
  }
  return i;
}
function no(i, ...t) {
  for (let e = 0; e < t.length; e++) vF(i, t[e]);
}
class yF {
  constructor(t) {
    this.context = t, this.COLOR_ATTACHMENT0_WEBGL = 36064, this.COLOR_ATTACHMENT1_WEBGL = 36065, this.COLOR_ATTACHMENT2_WEBGL = 36066, this.COLOR_ATTACHMENT3_WEBGL = 36067, this.COLOR_ATTACHMENT4_WEBGL = 36068, this.COLOR_ATTACHMENT5_WEBGL = 36069, this.COLOR_ATTACHMENT6_WEBGL = 36070, this.COLOR_ATTACHMENT7_WEBGL = 36071, this.COLOR_ATTACHMENT8_WEBGL = 36072, this.COLOR_ATTACHMENT9_WEBGL = 36073, this.COLOR_ATTACHMENT10_WEBGL = 577040, this.COLOR_ATTACHMENT11_WEBGL = 577041, this.COLOR_ATTACHMENT12_WEBGL = 577042, this.COLOR_ATTACHMENT13_WEBGL = 577043, this.COLOR_ATTACHMENT14_WEBGL = 577044, this.COLOR_ATTACHMENT15_WEBGL = 577045, this.DRAW_BUFFER0_WEBGL = 34853, this.DRAW_BUFFER1_WEBGL = 34854, this.DRAW_BUFFER2_WEBGL = 34855, this.DRAW_BUFFER3_WEBGL = 34856, this.DRAW_BUFFER4_WEBGL = 34857, this.DRAW_BUFFER5_WEBGL = 34858, this.DRAW_BUFFER6_WEBGL = 34859, this.DRAW_BUFFER7_WEBGL = 34860, this.DRAW_BUFFER8_WEBGL = 34861, this.DRAW_BUFFER9_WEBGL = 34862, this.DRAW_BUFFER10_WEBGL = 34863, this.DRAW_BUFFER11_WEBGL = 34864, this.DRAW_BUFFER12_WEBGL = 34865, this.DRAW_BUFFER13_WEBGL = 34866, this.DRAW_BUFFER14_WEBGL = 34867, this.DRAW_BUFFER15_WEBGL = 34868, this.MAX_COLOR_ATTACHMENTS_WEBGL = 36063, this.MAX_DRAW_BUFFERS_WEBGL = 2178;
  }
  drawBuffersWEBGL() {
    return this.context.drawBuffers.apply(this.context, arguments);
  }
}
class _F {
  constructor(t) {
    this.context = t, this.VERTEX_ARRAY_BINDING_OES = 34229;
  }
  createVertexArrayOES() {
    return this.context.createVertexArray();
  }
  deleteVertexArrayOES() {
    return this.context.deleteVertexArray.apply(this.context, arguments);
  }
  isVertexArrayOES() {
    return this.context.isVertexArray.apply(this.context, arguments);
  }
  bindVertexArrayOES() {
    return this.context.bindVertexArray.apply(this.context, arguments);
  }
}
class xF {
  constructor(t) {
    this.context = t, this.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE = 35070;
  }
  drawArraysInstancedANGLE() {
    return this.context.drawArraysInstanced.apply(this.context, arguments);
  }
  drawElementsInstancedANGLE() {
    return this.context.drawElementsInstanced.apply(this.context, arguments);
  }
  vertexAttribDivisorANGLE() {
    return this.context.vertexAttribDivisor.apply(this.context, arguments);
  }
}
const dg = { webgl_depth_texture: { UNSIGNED_INT_24_8_WEBGL: 34042 }, oes_element_index_uint: {}, oes_texture_float: {}, oes_texture_half_float: { HALF_FLOAT_OES: 36193 }, ext_color_buffer_float: {}, oes_standard_derivatives: {}, ext_frag_depth: {}, ext_blend_minmax: { MIN_EXT: 32775, MAX_EXT: 32776 }, ext_shader_texture_lod: {} }, Vh = { has(i, t) {
  const e = i.t, r = i.i;
  return !(!e && !r.getExtension(t)) && (t = t.toLowerCase(), e && dg[t] || t === "webgl_draw_buffers" || t === "oes_vertex_array_object" || t === "angle_instanced_arrays");
}, mock: (i, t) => (t = t.toLowerCase(), dg[t] ? i.t ? (t !== "oes_texture_float" && t !== "oes_texture_half_float" || i.i.getExtension("EXT_color_buffer_float"), dg[t]) : i.i.getExtension(t) : t === "webgl_draw_buffers" ? new yF(i) : t === "oes_vertex_array_object" ? new _F(i) : t === "angle_instanced_arrays" ? new xF(i) : null), getInternalFormat: (i, t, e) => t === 6402 ? 33190 : t === 34041 ? 35056 : e === 36193 && t === i.RGBA ? 34842 : e === 36193 && t === i.RGB ? 34843 : e === i.FLOAT && t === i.RGBA ? 34836 : e === i.FLOAT && t === i.RGB ? 34837 : t, getTextureType: (i, t) => t === 36193 ? i.HALF_FLOAT : t };
let bF = 1;
class vs {
  constructor(t) {
    this.uid = bF++, this.states = function(r) {
      return { scissor: [0, 0, r.canvas.width, r.canvas.height], viewport: [0, 0, r.canvas.width, r.canvas.height], blendColor: [0, 0, 0, 0], blendEquationSeparate: [r.FUNC_ADD, r.FUNC_ADD], blendFuncSeparate: [r.ONE, r.ZERO, r.ONE, r.ZERO], clearColor: [0, 0, 0, 0], clearDepth: [1], clearStencil: [0], colorMask: [!0, !0, !0, !0], cullFace: [r.BACK], depthFunc: [r.LESS], depthMask: [!0], depthRange: [0, 1], capabilities: { 3042: !1, 2884: !1, 2929: !1, 3024: !1, 32823: !1, 32926: !1, 32928: !1, 3089: !1, 2960: !1 }, frontFace: [r.CCW], hint: { 33170: [r.DONT_CARE], 35723: [r.DONT_CARE] }, lineWidth: [1], pixelStorei: { 3333: [4], 3317: [4], 37440: [!1], 37441: [!1], 37443: [r.BROWSER_DEFAULT_WEBGL] }, polygonOffset: [0, 0], sampleCoverage: [1, !1], stencilFuncSeparate: { 1028: [r.ALWAYS, 0, 4294967295], 1029: [r.ALWAYS, 0, 4294967295] }, stencilMaskSeparate: { 1028: [4294967295], 1029: [4294967295] }, stencilOpSeparate: { 1028: [r.KEEP, r.KEEP, r.KEEP], 1029: [r.KEEP, r.KEEP, r.KEEP] }, program: null, framebuffer: { 36160: null, 36008: null, 36009: null }, renderbuffer: { 36161: null }, textures: { active: -1, units: function() {
        const n = [], s = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        for (let o = 0; o < s; o++) n.push({ 3553: null, 34067: null });
        return n[-1] = { 3553: null, 34067: null }, n;
      }() }, attributes: {}, arrayBuffer: null, elementArrayBuffer: null };
    }(t), this.i = t, this.i._fusiongl_drawCalls = 0, this.t = window.WebGL2RenderingContext !== void 0 && this.i instanceof window.WebGL2RenderingContext;
    const e = Object.getPrototypeOf(this);
    this.t ? Object.setPrototypeOf(e, window.WebGL2RenderingContext.prototype) : Object.setPrototypeOf(e, WebGLRenderingContext.prototype), this.s = t.getParameter(t.MAX_VERTEX_ATTRIBS);
  }
  get canvas() {
    return this.i.canvas;
  }
  get drawingBufferWidth() {
    return this.i.drawingBufferWidth;
  }
  get drawingBufferHeight() {
    return this.i.drawingBufferHeight;
  }
  get gl() {
    return this.i;
  }
  get buffersOES() {
    return this.h || (this.h = this.i.getExtension("WEBGL_draw_buffers")), this.h;
  }
  get vaoOES() {
    return this.u || (this.u = this.i.getExtension("OES_vertex_array_object")), this.u;
  }
  get angleOES() {
    return this.o || (this.o = this.i.getExtension("ANGLE_instanced_arrays")), this.o;
  }
  get standOES() {
    return this.l || (this.l = this.i.getExtension("OES_standard_derivatives")), this.l;
  }
  attachShader(t, e) {
    return this.i.attachShader(t, e);
  }
  shaderSource(t, e) {
    return this.i.shaderSource(t, e);
  }
  compileShader(t) {
    return this.i.compileShader(t);
  }
  createShader(t) {
    return this.i.createShader(t);
  }
  createProgram() {
    return this.i.createProgram();
  }
  deleteProgram(t) {
    return this.states.program === t && (this.states.program = null), this.i.deleteProgram(t);
  }
  deleteShader(t) {
    return this.i.deleteShader(t);
  }
  detachShader(t, e) {
    return this.i.detachShader(t, e);
  }
  getAttachedShaders(t) {
    return this.i.getAttachedShaders(t);
  }
  linkProgram(t) {
    return this.i.linkProgram(t);
  }
  makeXRCompatible() {
    return this.i.makeXRCompatible();
  }
  getShaderParameter(t, e) {
    return this.i.getShaderParameter(t, e);
  }
  getShaderPrecisionFormat(t, e) {
    return this.i.getShaderPrecisionFormat(t, e);
  }
  getShaderInfoLog(t) {
    return this.i.getShaderInfoLog(t);
  }
  getShaderSource(t) {
    return this.i.getShaderSource(t);
  }
  getProgramInfoLog(t) {
    return this.i.getProgramInfoLog(t);
  }
  getProgramParameter(t, e) {
    return this.i.getProgramParameter(t, e);
  }
  getError() {
    return this.i.getError();
  }
  getContextAttributes() {
    return this.i.getContextAttributes();
  }
  getExtension(t) {
    return Vh.has(this, t) ? Vh.mock(this, t) : this.i.getExtension(t);
  }
  getSupportedExtensions() {
    return this.i.getSupportedExtensions();
  }
  getParameter(t) {
    return this.i.getParameter(t);
  }
  isEnabled(t) {
    return this.i.isEnabled(t);
  }
  isProgram(t) {
    return this.i.isProgram(t);
  }
  isShader(t) {
    return this.i.isShader(t);
  }
  validateProgram(t) {
    return this.i.validateProgram(t);
  }
  clear(t) {
    return this.m(), this.i.clear(t);
  }
  drawArrays(t, e, r) {
    return this.m(), this.g(), this.i.drawArrays(t, e, r);
  }
  drawElements(t, e, r, n) {
    return this.m(), this.g(), this.i.drawElements(t, e, r, n);
  }
  drawBuffers(t) {
    return this.m(), this.g(), this.t ? this.i.drawBuffers(t) : this.buffersOES.drawBuffersWEBGL(t);
  }
  g() {
    this.i._fusiongl_drawCalls++;
  }
  resetDrawCalls() {
    this.i._fusiongl_drawCalls = 0;
  }
  getDrawCalls() {
    return this.i._fusiongl_drawCalls;
  }
  v() {
    const t = this.i, e = t.getParameter(t.CURRENT_PROGRAM), r = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES), n = [];
    for (let s = 0; s < r; s++) n.push(t.getVertexAttrib(s, t.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING));
    this._ = { buffers: n, elements: t.getParameter(t.ELEMENT_ARRAY_BUFFER_BINDING), framebuffer: t.getParameter(t.FRAMEBUFFER_BINDING) }, window.DEBUGGING && (console.log(this.uid, this._), console.log(this.uid, this.states.attributes), console.log(this.states.attributes[0].buffer === this._.buffers[0]), console.log(this.states.attributes[1].buffer === this._.buffers[1]), console.log(this.states.attributes[2].buffer === this._.buffers[2]));
  }
  finish() {
    return this.i.finish();
  }
  flush() {
    return this.m(), this.i.flush();
  }
  commit() {
    return this.m(), this.i.commit();
  }
  isContextLost() {
    return this.i.isContextLost();
  }
  getFragDataLocation(t, e) {
    return this.i.getFragDataLocation(t, e);
  }
  createSampler() {
    return this.i.createSampler();
  }
  deleteSampler() {
    return this.i.deleteSampler();
  }
  bindSampler() {
    return this.i.bindSampler();
  }
  isSampler() {
    return this.i.isSampler();
  }
  getSamplerParameter() {
    return this.i.getSamplerParameter();
  }
  isQuery(t) {
    return this.i.beginQuery(t);
  }
  beginQuery(t, e) {
    return this.i.beginQuery(t, e);
  }
  deleteQuery(t) {
    return this.i.query(t);
  }
  isTransformFeedback(t) {
    return this.i.isTransformFeedback(t);
  }
  beginTransformFeedback(t) {
    return this.i.beginTransformFeedback(t);
  }
  deleteTransformFeedback(t) {
    return this.i.deleteTransformFeedback(t);
  }
  pauseTransformFeedback() {
    return this.i.pauseTransformFeedback();
  }
  resumeTransformFeedback() {
    return this.i.resumeTransformFeedback();
  }
  transformFeedbackVaryings(t, e, r) {
    return this.i.transformFeedbackVaryings(t, e, r);
  }
  bindBufferBase(t, e, r) {
    return this.i.bbindBufferBase(t, e, r);
  }
  bindBufferRange(t, e, r, n, s) {
    return this.i.bindBufferRange(t, e, r, n, s);
  }
  bindTransformFeedback(t, e) {
    return this.i.bindTransformFeedback(t, e);
  }
  fenceSync(t, e) {
    return this.i.fenceSync(t, e);
  }
  isSync(t) {
    return this.i.isSync(t);
  }
  deleteSync(t) {
    return this.i.deleteSync(t);
  }
  clientWaitSync(t, e, r) {
    return this.i.clientWaitSync(t, e, r);
  }
  waitSync(t, e, r) {
    return this.i.waitSync(t, e, r);
  }
  getSyncParameter(t, e) {
    return this.i.getSyncParameter(t, e);
  }
  getIndexedParameter(t, e) {
    return this.i.getIndexedParameter(t, e);
  }
}
no(vs.prototype, { bufferData(...i) {
  return this.m(), this.i.bufferData(...i);
}, bufferSubData(...i) {
  return this.m(), this.i.bufferSubData(...i);
}, createBuffer() {
  return this.i.createBuffer();
}, deleteBuffer(i) {
  const t = this.states;
  t.arrayBuffer === i ? t.arrayBuffer = null : t.elementArrayBuffer === i && (t.elementArrayBuffer = null);
  const e = t.attributes;
  for (const r in e) e[r].buffer === i && (e[r].buffer = null);
  return this.i.deleteBuffer(i);
}, getBufferParameter(i, t) {
  return this.m(), this.i.getBufferParameter(i, t);
}, isBuffer(i) {
  return this.i.isBuffer(i);
}, copyBufferSubData(i, t, e, r, n) {
  return this.i.isBuffer(i, t, e, r, n);
}, readBuffer(i) {
  return this.i.readBuffer(i);
} }), no(vs.prototype, { checkFramebufferStatus(i) {
  return this.i.checkFramebufferStatus(i);
}, createFramebuffer() {
  return this.i.createFramebuffer();
}, deleteFramebuffer(i) {
  const t = this.states.framebuffer;
  for (const e in t) t[e] === i && (t[e] = null);
  return this.i.deleteFramebuffer(i);
}, framebufferRenderbuffer(i, t, e, r) {
  return this.m(), this.i.framebufferRenderbuffer(i, t, e, r);
}, framebufferTexture2D(i, t, e, r, n) {
  return this.m(), this.i.framebufferTexture2D(i, t, e, r, n);
}, getFramebufferAttachmentParameter(i, t, e) {
  return this.m(), this.i.getFramebufferAttachmentParameter(i, t, e);
}, isFramebuffer(i) {
  return this.i.isFramebuffer(i);
}, readPixels(i, t, e, r, n, s, o) {
  return this.m(), this.i.readPixels(i, t, e, r, n, s, o);
}, blitFramebuffer(i, t, e, r, n, s, o, a, l, h) {
  return this.m(), this.i.blitFramebuffer(i, t, e, r, n, s, o, a, l, h);
} }), no(vs.prototype, { createRenderbuffer() {
  return this.i.createRenderbuffer();
}, deleteRenderbuffer(i) {
  const t = this.states.renderbuffer;
  for (const e in t) t[e] === i && (t[e] = null);
  return this.i.deleteRenderbuffer(i);
}, getRenderbufferParameter(i, t) {
  return this.m(), this.i.getRenderbufferParameter(i, t);
}, isRenderbuffer(i) {
  return this.i.isRenderbuffer(i);
}, renderbufferStorage(i, t, e, r) {
  return this.m(), this.i.renderbufferStorage(i, t, e, r);
}, renderbufferStorageMultisample(i, t, e, r, n) {
  return this.m(), this.i.renderbufferStorageMultisample(i, t, e, r, n);
} });
function wF(i, t) {
  const e = t.length;
  for (let r = 0; r < e; r++) i[r] = t[r];
  return i;
}
no(vs.prototype, { scissor(i, t, e, r) {
  this.m();
  const n = this.states.scissor;
  n[0] === i && n[1] === t && n[2] === e && n[3] === r || (n[0] = i, n[1] = t, n[2] = e, n[3] = r, this.i.scissor(i, t, e, r));
}, viewport(i, t, e, r) {
  this.m();
  const n = this.states.viewport;
  n[0] === i && n[1] === t && n[2] === e && n[3] === r || (n[0] = i, n[1] = t, n[2] = e, n[3] = r, this.i.viewport(i, t, e, r));
}, blendColor(i, t, e, r) {
  this.m();
  const n = this.states.blendColor;
  n[0] === i && n[1] === t && n[2] === e && n[3] === r || (n[0] = i, n[1] = t, n[2] = e, n[3] = r, this.i.blendColor(i, t, e, r));
}, blendEquation(i) {
  this.m();
  const t = this.states.blendEquationSeparate;
  t[0] === i && t[1] === i || (t[0] = i, t[1] = i, this.i.blendEquation(i));
}, blendEquationSeparate(i, t) {
  this.m();
  const e = this.states.blendEquationSeparate;
  e[0] === i && e[1] === t || (e[0] = i, e[1] = t, this.i.blendEquationSeparate(i, t));
}, blendFunc(i, t) {
  this.m();
  const e = this.states.blendFuncSeparate;
  e[0] === i && e[2] === i && e[1] === t && e[3] === t || (e[0] = i, e[1] = t, e[2] = i, e[3] = t, this.i.blendFunc(i, t));
}, blendFuncSeparate(i, t, e, r) {
  this.m();
  const n = this.states.blendFuncSeparate;
  n[0] === i && n[1] === t && n[2] === e && n[3] === r || (n[0] = i, n[1] = t, n[2] = e, n[3] = r, this.i.blendFuncSeparate(i, t, e, r));
}, clearColor(i, t, e, r) {
  this.m();
  const n = this.states.clearColor;
  n[0] === i && n[1] === t && n[2] === e && n[3] === r || (n[0] = i, n[1] = t, n[2] = e, n[3] = r, this.i.clearColor(i, t, e, r));
}, clearDepth(i) {
  this.m();
  const t = this.states.clearDepth;
  t[0] !== i && (t[0] = i, this.i.clearDepth(i));
}, clearStencil(i) {
  this.m();
  const t = this.states.clearStencil;
  t[0] !== i && (t[0] = i, this.i.clearStencil(i));
}, colorMask(i, t, e, r) {
  this.m();
  const n = this.states.colorMask;
  n[0] === i && n[1] === t && n[2] === e && n[3] === r || (n[0] = i, n[1] = t, n[2] = e, n[3] = r, this.i.colorMask(i, t, e, r));
}, cullFace(i) {
  this.m();
  const t = this.states.cullFace;
  t[0] !== i && (t[0] = i, this.i.cullFace(i));
}, depthFunc(i) {
  this.m();
  const t = this.states.depthFunc;
  t[0] !== i && (t[0] = i, this.i.depthFunc(i));
}, depthMask(i) {
  this.m();
  const t = this.states.depthMask;
  t[0] !== i && (t[0] = i, this.i.depthMask(i));
}, depthRange(i, t) {
  this.m();
  const e = this.states.depthRange;
  e[0] === i && e[1] === t || (e[0] = i, e[1] = t, this.i.depthRange(i, t));
}, disable(i) {
  this.m();
  const t = this.states.capabilities;
  t[i] && (t[i] = !1, this.i.disable(i));
}, enable(i) {
  this.m();
  const t = this.states.capabilities;
  t[i] || (t[i] = !0, this.i.enable(i));
}, frontFace(i) {
  this.m();
  const t = this.states.frontFace;
  t[0] !== i && (t[0] = i, this.i.frontFace(i));
}, hint(i, t) {
  this.m();
  const e = this.states.hint;
  e[i][0] !== t && (e[i][0] = t, this.i.hint(i, t));
}, lineWidth(i) {
  this.m();
  const t = this.states.lineWidth;
  t[0] !== i && (t[0] = i, this.i.lineWidth(i));
}, pixelStorei(i, t) {
  this.m();
  const e = this.states.pixelStorei;
  e[i] !== t && (e[i] && (e[i][0] = t), this.i.pixelStorei(i, t));
}, polygonOffset(i, t) {
  this.m();
  const e = this.states.polygonOffset;
  e[0] === i && e[1] === t || (e[0] = i, e[1] = t, this.i.polygonOffset(i, t));
}, sampleCoverage(i, t) {
  this.m();
  const e = this.states.sampleCoverage;
  e[0] === i && e[1] === t || (e[0] = i, e[1] = t, this.i.sampleCoverage(i, t));
}, stencilFunc(i, t, e) {
  this.m();
  const r = this.states.stencilFuncSeparate, n = this.i;
  r[n.FRONT][0] === i && r[n.FRONT][1] === t && r[n.FRONT][2] === e && r[n.BACK][0] === i && r[n.BACK][1] === t && r[n.BACK][2] === e || (r[n.FRONT][0] = r[n.BACK][0] = i, r[n.FRONT][1] = r[n.BACK][1] = t, r[n.FRONT][2] = r[n.BACK][2] = e, this.i.stencilFunc(i, t, e));
}, stencilFuncSeparate(i, t, e, r) {
  if (this.m(), i === this.i.FRONT_AND_BACK) return void this.stencilFunc(t, e, r);
  const n = this.states.stencilFuncSeparate;
  n[i][0] === t && n[i][1] === e && n[i][2] === r || (n[i][0] = t, n[i][1] = e, n[i][2] = r, this.i.stencilFuncSeparate(i, t, e, r));
}, stencilMask(i) {
  this.m();
  const t = this.i, e = this.states.stencilMaskSeparate;
  e[t.FRONT][0] === i && e[t.BACK][0] === i || (e[t.FRONT][0] = i, e[t.BACK][0] = i, this.i.stencilMask(i));
}, stencilMaskSeparate(i, t) {
  if (this.m(), i === this.i.FRONT_AND_BACK) return void this.stencilMask(t);
  const e = this.states.stencilMaskSeparate;
  e[i][0] !== t && (e[i][0] = t, this.i.stencilMaskSeparate(i, t));
}, stencilOp(i, t, e) {
  this.m();
  const r = this.states.stencilOpSeparate, n = this.i;
  r[n.FRONT][0] === i && r[n.FRONT][1] === t && r[n.FRONT][2] === e && r[n.BACK][0] === i && r[n.BACK][1] === t && r[n.BACK][2] === e || (r[n.FRONT][0] = r[n.BACK][0] = i, r[n.FRONT][1] = r[n.BACK][1] = t, r[n.FRONT][2] = r[n.BACK][2] = e, this.i.stencilOp(i, t, e));
}, stencilOpSeparate(i, t, e, r) {
  if (this.m(), i === this.i.FRONT_AND_BACK) return void this.stencilOp(t, e, r);
  const n = this.states.stencilOpSeparate;
  n[i][0] === t && n[i][1] === e && n[i][2] === r || (n[i][0] = t, n[i][1] = e, n[i][2] = r, this.i.stencilOpSeparate(i, t, e, r));
}, bindFramebuffer(i, t) {
  this.m();
  const e = this.states.framebuffer;
  e[i] !== t && (e[i] = t, this.i.bindFramebuffer(i, t));
}, bindRenderbuffer(i, t) {
  this.m();
  const e = this.states.renderbuffer;
  e[i] !== t && (e[i] = t, this.i.bindRenderbuffer(i, t));
}, bindTexture(i, t) {
  this.m();
  const e = this.states.textures, r = e.active !== -1 ? e.active - 33984 : -1;
  e.units[r][i] = t, this.i.bindTexture(i, t);
}, activeTexture(i) {
  this.m();
  const t = this.i, e = this.states.textures, r = e.active;
  e.active = i, this.activeUnit !== i && (t.activeTexture(i), this.activeUnit = i), r === -1 && (e.units[i - 33984][t.TEXTURE_2D] = e.units[-1][t.TEXTURE_2D], e.units[i - 33984][t.TEXTURE_CUBE_MAP] = e.units[-1][t.TEXTURE_CUBE_MAP], e.units[-1][t.TEXTURE_2D] = null, e.units[-1][t.TEXTURE_CUBE_MAP] = null);
}, useProgram(i) {
  this.m();
  const t = this.states;
  t.program !== i && (this.states.activeAttribType = 0, t.program = i, i.fid === void 0 && (i.fid = 0), this.S(), this.i.useProgram(i));
}, S() {
  const i = this.states.program;
  if (!i) return;
  const t = i.cachedUniforms = i.cachedUniforms || {};
  for (const e in t) Array.isArray(t[e]) ? t[e].fill(null) : t[e] = null;
}, bindBuffer(i, t) {
  this.m();
  const e = this.i, r = this.states;
  i === e.ELEMENT_ARRAY_BUFFER ? r.elementArrayBuffer = t : r.arrayBuffer = t, e.bindBuffer(i, t);
}, bindVertexArray(i) {
  this.m(), this.states.activeAttribType = 1;
  const t = this.i, e = this.states;
  e.vao !== i && (e.vao = i, this.t ? t.bindVertexArray(i) : this.vaoOES.bindVertexArrayOES(i));
}, vertexAttribPointer(i, t, e, r, n, s) {
  this.m(), this.states.attributes[i] || (this.states.attributes[i] = { enable: !0 });
  const o = this.states.attributes[i];
  return o.buffer = this.states.arrayBuffer, o.args ? (o.args[0] = i, o.args[1] = t, o.args[2] = e, o.args[3] = r, o.args[4] = n, o.args[5] = s) : o.args = [i, t, e, r, n, s], this.i.vertexAttribPointer(i, t, e, r, n, s);
}, vertexAttribDivisor(i, t) {
  return this.m(), this.states.attributes[i].divisor = t, this.t ? this.i.vertexAttribDivisor(i, t) : this.angleOES.vertexAttribDivisorANGLE(i, t);
} }, { m() {
  const i = this.i;
  if (i.A !== this) if (i.A) {
    const t = i.A;
    this.p(t.states), i.A = this;
  } else i.A = this;
}, p(i) {
  if (!i) return;
  delete this.activeUnit;
  const t = this.states, e = this.i;
  let r = 0;
  for (const u in t) if (u !== "capabilities" && u !== "textures" && u !== "attributes" && u !== "arrayBuffer" && u !== "elementArrayBuffer" && u !== "vao") {
    if (u === "program") t.program !== i.program && (e.useProgram(t.program), t.program && (r = e.getProgramParameter(t.program, e.ACTIVE_ATTRIBUTES)));
    else if (u === "framebuffer") for (const c in t[u]) t[u][c] !== i[u][c] && e.bindFramebuffer(+c, t[u][c]);
    else if (u === "renderbuffer") for (const c in t[u]) t[u][c] !== i[u][c] && e.bindRenderbuffer(+c, t[u][c]);
    else if (!fu(t[u], i[u])) {
      if (Array.isArray(i[u])) e[u](...t[u]);
      else if (i[u]) for (const c in t[u]) fu(t[u][c], i[u][c]) || e[u](+c, ...t[u][c]);
    }
  }
  this.S();
  for (const u in t.capabilities) t.capabilities[u] !== i.capabilities[u] && e[t.capabilities[u] ? "enable" : "disable"](+u);
  const n = t.textures, s = i.textures, o = n.units, a = s.units, l = n.active - e.TEXTURE0;
  for (let u = 0; u < o.length; u++) u === l || o[u][e.TEXTURE_2D] === a[u][e.TEXTURE_2D] && o[u][e.TEXTURE_CUBE_MAP] === a[u][e.TEXTURE_CUBE_MAP] || (e.activeTexture(e.TEXTURE0 + u), e.bindTexture(e.TEXTURE_2D, o[u][e.TEXTURE_2D]), e.bindTexture(e.TEXTURE_CUBE_MAP, o[u][e.TEXTURE_CUBE_MAP]));
  if (n.active > -1) {
    const u = o[l];
    u[e.TEXTURE_2D] === a[l][e.TEXTURE_2D] && u[e.TEXTURE_CUBE_MAP] === a[l][e.TEXTURE_CUBE_MAP] || (e.activeTexture(n.active), e.bindTexture(e.TEXTURE_2D, u[e.TEXTURE_2D]), e.bindTexture(e.TEXTURE_CUBE_MAP, u[e.TEXTURE_CUBE_MAP]));
  }
  this.t ? e.bindVertexArray(null) : this.u && this.u.bindVertexArrayOES(null);
  const h = this.s;
  if (this.t || this.angleOES) for (let u = 0; u < h; u++) this.t ? e.vertexAttribDivisor(u, 0) : this.angleOES.vertexAttribDivisorANGLE(u, 0);
  e.bindBuffer(e.ARRAY_BUFFER, t.arrayBuffer), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.elementArrayBuffer), t.activeAttribType === 1 ? this.F(t, e) : this.L(t, e, r);
}, F(i, t) {
  const e = i.vao;
  e && (this.t ? t.bindVertexArray(e || null) : this.u && this.u.bindVertexArrayOES(e || null));
}, L(i, t, e) {
  const r = this.s, n = i.attributes;
  let s = 0;
  for (let o = 0; o < r; o++) {
    const a = n[o];
    if (s < e && a) {
      if (a.buffer) {
        if (t.bindBuffer(t.ARRAY_BUFFER, a.buffer), t.vertexAttribPointer(...a.args), a.divisor && (this.t ? t.vertexAttribDivisor(o, a.divisor) : this.angleOES.vertexAttribDivisorANGLE(o, a.divisor)), a.enable) {
          t.enableVertexAttribArray(o), s++;
          continue;
        }
        t.disableVertexAttribArray(o);
      }
      t.disableVertexAttribArray(o);
    } else t.disableVertexAttribArray(o);
  }
} }), no(vs.prototype, { compressedTexImage2D(i, t, e, r, n, s, o) {
  return this.m(), this.i.compressedTexImage2D(i, t, e, r, n, s, o);
}, copyTexImage2D(i, t, e, r, n, s, o, a) {
  return this.m(), this.i.copyTexImage2D(i, t, e, r, n, s, o, a);
}, copyTexSubImage2D(i, t, e, r, n, s, o, a) {
  return this.m(), this.i.copyTexSubImage2D(i, t, e, r, n, s, o, a);
}, createTexture() {
  return this.i.createTexture();
}, deleteTexture(i) {
  const t = this.states.textures.units;
  for (let e = 0; e < t.length; e++) for (const r in t[e]) t[e][r] === i && (t[e][r] = null);
  return this.i.deleteTexture(i);
}, generateMipmap(i) {
  return this.m(), this.i.generateMipmap(i);
}, getTexParameter(i, t) {
  return this.m(), this.i.getTexParameter(i, t);
}, isTexture(i) {
  return this.i.isTexture(i);
}, texImage2D(...i) {
  if (this.m(), this.t) {
    const t = i[i.length - 2], e = Vh.getInternalFormat(this.i, i[2], t);
    e !== i[2] && (i[2] = e);
    const r = Vh.getTextureType(this.i, t);
    r !== t && (i[i.length - 2] = r);
  }
  return this.i.texImage2D(...i);
}, texSubImage2D(...i) {
  if (this.m(), this.t) {
    const t = i[i.length - 2], e = Vh.getTextureType(this.i, t);
    e !== t && (i[i.length - 2] = e);
  }
  return this.i.texSubImage2D(...i);
}, texParameterf(i, t, e) {
  return this.m(), this.i.texParameterf(i, t, e);
}, texParameteri(i, t, e) {
  return this.m(), this.i.texParameteri(i, t, e);
}, texStorage2D(i, t, e, r, n) {
  return this.m(), this.i.texStorage2D(i, t, e, r, n);
}, texImage3D(i, t, e, r, n, s, o, a, l, h) {
  return this.m(), this.i.texImage3D(i, t, e, r, n, s, o, a, l, h);
}, texStorage3D(i, t, e, r, n, s) {
  return this.m(), this.i.texStorage3D(i, t, e, r, n, s);
}, texSubImage3D(i, t, e, r, n, s, o, a, l, h, u) {
  return this.m(), this.i.texSubImage3D(i, t, e, r, n, s, o, a, l, h, u);
}, copyTexSubImage3D(i, t, e, r, n, s, o, a, l) {
  return this.m(), this.i.copyTexSubImage3D(i, t, e, r, n, s, o, a, l);
}, compressedTexSubImage3D(i, t, e, r, n, s, o, a, l, h, u) {
  return this.m(), this.i.compressedTexSubImage3D(i, t, e, r, n, s, o, a, l, h, u);
} }), no(vs.prototype, { bindAttribLocation(i, t, e) {
  return this.i.bindAttribLocation(i, t, e);
}, enableVertexAttribArray(i) {
  return this.m(), this.states.attributes[i] || (this.states.attributes[i] = {}), this.states.attributes[i].enable = !0, this.i.enableVertexAttribArray(i);
}, disableVertexAttribArray(i) {
  return this.m(), this.states.attributes[i] || (this.states.attributes[i] = {}), this.states.attributes[i].enable = !1, this.i.disableVertexAttribArray(i);
}, getActiveAttrib(i, t) {
  return this.i.getActiveAttrib(i, t);
}, getActiveUniform(i, t) {
  return this.i.getActiveUniform(i, t);
}, getAttribLocation(i, t) {
  return this.i.getAttribLocation(i, t);
}, getUniformLocation(i, t) {
  return this.i.getUniformLocation(i, t);
}, getVertexAttrib(i, t) {
  return this.m(), this.i.getVertexAttrib(i, t);
}, getVertexAttribOffset(i, t) {
  return this.m(), this.i.getVertexAttribOffset(i, t);
}, uniformBlockBinding(i, t, e) {
  return this.m(), this.i.uniformBlockBinding(i, t, e);
}, D(i, ...t) {
  const e = this.states.program;
  if (!e) return !1;
  let r = i.fid;
  r === void 0 && (r = i.fid = e.fid++);
  const n = e.cachedUniforms[r];
  return !!function(s, o) {
    if (!s) return !1;
    const a = o.length;
    for (let l = 0; l < a; l++) if (s[l] && s[l].length !== void 0) {
      const h = s[l].length;
      for (let u = 0; u < h; u++) if (s[l][u] !== o[l][u]) return !1;
    } else if (s[l] !== o[l]) return !1;
    return !0;
  }(n, t) || (e.cachedUniforms[r] = function(s, o) {
    s = s || new Array(o.length);
    const a = o.length;
    for (let l = 0; l < a; l++) s[l] = o[l].length !== void 0 ? wF(s[l] || [], o[l]) : o[l];
    return s;
  }(n, t), !1);
}, uniformMatrix2fv(i, t, e) {
  this.D(i, t, e) || (this.m(), this.i.uniformMatrix2fv(i, t, e));
}, uniformMatrix3fv(i, t, e) {
  this.D(i, t, e) || (this.m(), this.i.uniformMatrix3fv(i, t, e));
}, uniformMatrix4fv(i, t, e) {
  this.D(i, t, e) || this.i.uniformMatrix4fv(i, t, e);
}, uniform1f(i, t) {
  return this.m(), this.i.uniform1f(i, t);
}, uniform1i(i, t) {
  return this.m(), this.i.uniform1i(i, t);
}, uniform2f(i, t, e) {
  return this.m(), this.i.uniform2f(i, t, e);
}, uniform2i(i, t, e) {
  return this.m(), this.i.uniform2i(i, t, e);
}, uniform3f(i, t, e, r) {
  return this.m(), this.i.uniform3f(i, t, e, r);
}, uniform3i(i, t, e, r) {
  return this.m(), this.i.uniform3i(i, t, e, r);
}, uniform4f(i, t, e, r, n) {
  return this.m(), this.i.uniform4f(i, t, e, r, n);
}, uniform4i(i, t, e, r, n) {
  return this.m(), this.i.uniform4i(i, t, e, r, n);
}, uniform1ui(i, t) {
  return this.m(), this.i.uniform1ui(i, t);
}, uniform2ui(i, t, e) {
  return this.m(), this.i.uniform2ui(i, t, e);
}, uniform3ui(i, t, e, r) {
  return this.m(), this.i.uniform3ui(i, t, e, r);
}, uniform4ui(i, t, e, r, n) {
  return this.m(), this.i.uniform4ui(i, t, e, r, n);
}, uniform1fv(i, t, e, r) {
  this.m(), r !== void 0 ? this.i.uniform1fv(i, t, e, r) : e !== void 0 ? this.i.uniform1fv(i, t, e) : this.i.uniform1fv(i, t);
}, uniform2fv(i, t, e, r) {
  this.m(), r !== void 0 ? this.i.uniform2fv(i, t, e, r) : e !== void 0 ? this.i.uniform2fv(i, t, e) : this.i.uniform2fv(i, t);
}, uniform3fv(i, t, e, r) {
  this.m(), r !== void 0 ? this.i.uniform3fv(i, t, e, r) : e !== void 0 ? this.i.uniform3fv(i, t, e) : this.i.uniform3fv(i, t);
}, uniform4fv(i, t, e, r) {
  this.m(), r !== void 0 ? this.i.uniform4fv(i, t, e, r) : e !== void 0 ? this.i.uniform4fv(i, t, e) : this.i.uniform4fv(i, t);
}, uniform1iv(i, t, e, r) {
  this.m(), r !== void 0 ? this.i.uniform1iv(i, t, e, r) : e !== void 0 ? this.i.uniform1iv(i, t, e) : this.i.uniform1iv(i, t);
}, uniform2iv(i, t, e, r) {
  this.m(), r !== void 0 ? this.i.uniform2iv(i, t, e, r) : e !== void 0 ? this.i.uniform2iv(i, t, e) : this.i.uniform2iv(i, t);
}, uniform3iv(i, t, e, r) {
  this.m(), r !== void 0 ? this.i.uniform3iv(i, t, e, r) : e !== void 0 ? this.i.uniform3iv(i, t, e) : this.i.uniform3iv(i, t);
}, uniform4iv(i, t, e, r) {
  this.m(), r !== void 0 ? this.i.uniform4iv(i, t, e, r) : e !== void 0 ? this.i.uniform4iv(i, t, e) : this.i.uniform4iv(i, t);
}, uniform1uiv(i, t, e, r) {
  this.m(), r !== void 0 ? this.i.uniform1uiv(i, t, e, r) : e !== void 0 ? this.i.uniform1uiv(i, t, e) : this.i.uniform1uiv(i, t);
}, uniform2uiv(i, t, e, r) {
  this.m(), r !== void 0 ? this.i.uniform2uiv(i, t, e, r) : e !== void 0 ? this.i.uniform2uiv(i, t, e) : this.i.uniform2uiv(i, t);
}, uniform3uiv(i, t, e, r) {
  this.m(), r !== void 0 ? this.i.uniform3uiv(i, t, e, r) : e !== void 0 ? this.i.uniform3uiv(i, t, e) : this.i.uniform3uiv(i, t);
}, uniform4uiv(i, t, e, r) {
  this.m(), r !== void 0 ? this.i.uniform4uiv(i, t, e, r) : e !== void 0 ? this.i.uniform4uiv(i, t, e) : this.i.uniform4uiv(i, t);
}, vertexAttrib1f(i, t) {
  return this.m(), this.i.vertexAttrib1f(i, t);
}, vertexAttrib2f(i, t, e) {
  return this.m(), this.i.vertexAttrib2f(i, t, e);
}, vertexAttrib3f(i, t, e, r) {
  return this.m(), this.i.vertexAttrib3f(i, t, e, r);
}, vertexAttrib4f(i, t, e, r, n) {
  return this.m(), this.i.vertexAttrib4f(i, t, e, r, n);
}, vertexAttrib1fv(i, t) {
  return this.m(), this.i.vertexAttrib1fv(i, t);
}, vertexAttrib2fv(i, t) {
  return this.m(), this.i.vertexAttrib2fv(i, t);
}, vertexAttrib3fv(i, t) {
  return this.m(), this.i.vertexAttrib3fv(i, t);
}, vertexAttrib4fv(i, t) {
  return this.m(), this.i.vertexAttrib4fv(i, t);
}, vertexAttribI4i(i, t, e, r, n) {
  return this.m(), this.i.vertexAttribI4i(i, t, e, r, n);
}, vertexAttribI4ui(i, t, e, r, n) {
  return this.m(), this.i.vertexAttribI4ui(i, t, e, r, n);
}, vertexAttribI4iv(i, t) {
  return this.m(), this.i.vertexAttribI4iv(i, t);
}, vertexAttribI4uiv(i, t) {
  return this.m(), this.i.vertexAttribI4uiv(i, t);
} }), no(vs.prototype, { createVertexArray() {
  return this.t ? this.i.createVertexArray() : this.vaoOES.createVertexArrayOES();
}, deleteVertexArray(i) {
  const t = this.states;
  return t.vao === i && (t.vao = null), this.t ? this.i.deleteVertexArray(i) : this.vaoOES.deleteVertexArrayOES(i);
}, isVertexArray(i) {
  return this.t ? this.i.isVertexArray(i) : this.vaoOES.isVertexArrayOES(i);
} }), no(vs.prototype, { drawArraysInstanced(i, t, e, r) {
  return this.m(), this.g(), this.t ? this.i.drawArraysInstanced(i, t, e, r) : this.angleOES.drawArraysInstancedANGLE(i, t, e, r);
}, drawElementsInstanced(i, t, e, r, n) {
  return this.m(), this.g(), this.t ? this.i.drawElementsInstanced(i, t, e, r, n) : this.angleOES.drawElementsInstancedANGLE(i, t, e, r, n);
} });
/*!
 * @maptalks/gl v0.97.4
 * LICENSE : UNLICENSED
 * (c) 2016-2024 maptalks.com
 */
var OM = {
  exports: {}
}, kM = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
}, RM = {
  exports: {}
}, TF = function(i) {
  return !(!i || typeof i == "string") && (i instanceof Array || Array.isArray(i) || i.length >= 0 && (i.splice instanceof Function || Object.getOwnPropertyDescriptor(i, i.length - 1) && i.constructor.name !== "String"));
}, AF = Array.prototype.concat, MF = Array.prototype.slice, Mx = RM.exports = function(i) {
  for (var t = [], e = 0, r = i.length; e < r; e++) {
    var n = i[e];
    TF(n) ? t = AF.call(t, MF.call(n)) : t.push(n);
  }
  return t;
};
Mx.wrap = function(i) {
  return function() {
    return i(Mx(arguments));
  };
};
var Uh = kM, rh = RM.exports, IM = Object.hasOwnProperty, DM = /* @__PURE__ */ Object.create(null);
for (var pg in Uh) IM.call(Uh, pg) && (DM[Uh[pg]] = pg);
var ni = OM.exports = {
  to: {},
  get: {}
};
function Us(i, t, e) {
  return Math.min(Math.max(t, i), e);
}
function Pc(i) {
  var t = Math.round(i).toString(16).toUpperCase();
  return t.length < 2 ? "0" + t : t;
}
ni.get = function(i) {
  var t, e;
  switch (i.substring(0, 3).toLowerCase()) {
    case "hsl":
      t = ni.get.hsl(i), e = "hsl";
      break;
    case "hwb":
      t = ni.get.hwb(i), e = "hwb";
      break;
    default:
      t = ni.get.rgb(i), e = "rgb";
  }
  return t ? {
    model: e,
    value: t
  } : null;
}, ni.get.rgb = function(i) {
  if (!i) return null;
  var t, e, r, n = [0, 0, 0, 1];
  if (t = i.match(/^#([a-f0-9]{6})([a-f0-9]{2})?$/i)) {
    for (r = t[2], t = t[1], e = 0; e < 3; e++) {
      var s = 2 * e;
      n[e] = parseInt(t.slice(s, s + 2), 16);
    }
    r && (n[3] = parseInt(r, 16) / 255);
  } else if (t = i.match(/^#([a-f0-9]{3,4})$/i)) {
    for (r = (t = t[1])[3], e = 0; e < 3; e++) n[e] = parseInt(t[e] + t[e], 16);
    r && (n[3] = parseInt(r + r, 16) / 255);
  } else if (t = i.match(/^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/)) {
    for (e = 0; e < 3; e++) n[e] = parseInt(t[e + 1], 0);
    t[4] && (t[5] ? n[3] = 0.01 * parseFloat(t[4]) : n[3] = parseFloat(t[4]));
  } else {
    if (!(t = i.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/))) return (t = i.match(/^(\w+)$/)) ? t[1] === "transparent" ? [0, 0, 0, 0] : IM.call(Uh, t[1]) ? ((n = Uh[t[1]])[3] = 1, n) : null : null;
    for (e = 0; e < 3; e++) n[e] = Math.round(2.55 * parseFloat(t[e + 1]));
    t[4] && (t[5] ? n[3] = 0.01 * parseFloat(t[4]) : n[3] = parseFloat(t[4]));
  }
  for (e = 0; e < 3; e++) n[e] = Us(n[e], 0, 255);
  return n[3] = Us(n[3], 0, 1), n;
}, ni.get.hsl = function(i) {
  if (!i) return null;
  var t = i.match(/^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/);
  if (t) {
    var e = parseFloat(t[4]);
    return [(parseFloat(t[1]) % 360 + 360) % 360, Us(parseFloat(t[2]), 0, 100), Us(parseFloat(t[3]), 0, 100), Us(isNaN(e) ? 1 : e, 0, 1)];
  }
  return null;
}, ni.get.hwb = function(i) {
  if (!i) return null;
  var t = i.match(/^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/);
  if (t) {
    var e = parseFloat(t[4]);
    return [(parseFloat(t[1]) % 360 + 360) % 360, Us(parseFloat(t[2]), 0, 100), Us(parseFloat(t[3]), 0, 100), Us(isNaN(e) ? 1 : e, 0, 1)];
  }
  return null;
}, ni.to.hex = function() {
  var i = rh(arguments);
  return "#" + Pc(i[0]) + Pc(i[1]) + Pc(i[2]) + (i[3] < 1 ? Pc(Math.round(255 * i[3])) : "");
}, ni.to.rgb = function() {
  var i = rh(arguments);
  return i.length < 4 || i[3] === 1 ? "rgb(" + Math.round(i[0]) + ", " + Math.round(i[1]) + ", " + Math.round(i[2]) + ")" : "rgba(" + Math.round(i[0]) + ", " + Math.round(i[1]) + ", " + Math.round(i[2]) + ", " + i[3] + ")";
}, ni.to.rgb.percent = function() {
  var i = rh(arguments), t = Math.round(i[0] / 255 * 100), e = Math.round(i[1] / 255 * 100), r = Math.round(i[2] / 255 * 100);
  return i.length < 4 || i[3] === 1 ? "rgb(" + t + "%, " + e + "%, " + r + "%)" : "rgba(" + t + "%, " + e + "%, " + r + "%, " + i[3] + ")";
}, ni.to.hsl = function() {
  var i = rh(arguments);
  return i.length < 4 || i[3] === 1 ? "hsl(" + i[0] + ", " + i[1] + "%, " + i[2] + "%)" : "hsla(" + i[0] + ", " + i[1] + "%, " + i[2] + "%, " + i[3] + ")";
}, ni.to.hwb = function() {
  var i = rh(arguments), t = "";
  return i.length >= 4 && i[3] !== 1 && (t = ", " + i[3]), "hwb(" + i[0] + ", " + i[1] + "%, " + i[2] + "%" + t + ")";
}, ni.to.keyword = function(i) {
  return DM[i.slice(0, 3)];
};
var hy = {
  exports: {}
}, Ro = kM, FM = {};
for (var gg in Ro) Ro.hasOwnProperty(gg) && (FM[Ro[gg]] = gg);
var ge = hy.exports = {
  rgb: {
    channels: 3,
    labels: "rgb"
  },
  hsl: {
    channels: 3,
    labels: "hsl"
  },
  hsv: {
    channels: 3,
    labels: "hsv"
  },
  hwb: {
    channels: 3,
    labels: "hwb"
  },
  cmyk: {
    channels: 4,
    labels: "cmyk"
  },
  xyz: {
    channels: 3,
    labels: "xyz"
  },
  lab: {
    channels: 3,
    labels: "lab"
  },
  lch: {
    channels: 3,
    labels: "lch"
  },
  hex: {
    channels: 1,
    labels: ["hex"]
  },
  keyword: {
    channels: 1,
    labels: ["keyword"]
  },
  ansi16: {
    channels: 1,
    labels: ["ansi16"]
  },
  ansi256: {
    channels: 1,
    labels: ["ansi256"]
  },
  hcg: {
    channels: 3,
    labels: ["h", "c", "g"]
  },
  apple: {
    channels: 3,
    labels: ["r16", "g16", "b16"]
  },
  gray: {
    channels: 1,
    labels: ["gray"]
  }
};
for (var Ur in ge) if (ge.hasOwnProperty(Ur)) {
  if (!("channels" in ge[Ur])) throw new Error("missing channels property: " + Ur);
  if (!("labels" in ge[Ur])) throw new Error("missing channel labels property: " + Ur);
  if (ge[Ur].labels.length !== ge[Ur].channels) throw new Error("channel and label counts mismatch: " + Ur);
  var SF = ge[Ur].channels, CF = ge[Ur].labels;
  delete ge[Ur].channels, delete ge[Ur].labels, Object.defineProperty(ge[Ur], "channels", {
    value: SF
  }), Object.defineProperty(ge[Ur], "labels", {
    value: CF
  });
}
ge.rgb.hsl = function(i) {
  var t, e, r = i[0] / 255, n = i[1] / 255, s = i[2] / 255, o = Math.min(r, n, s), a = Math.max(r, n, s), l = a - o;
  return a === o ? t = 0 : r === a ? t = (n - s) / l : n === a ? t = 2 + (s - r) / l : s === a && (t = 4 + (r - n) / l), (t = Math.min(60 * t, 360)) < 0 && (t += 360), e = (o + a) / 2, [t, 100 * (a === o ? 0 : e <= 0.5 ? l / (a + o) : l / (2 - a - o)), 100 * e];
}, ge.rgb.hsv = function(i) {
  var t, e, r, n, s, o = i[0] / 255, a = i[1] / 255, l = i[2] / 255, h = Math.max(o, a, l), u = h - Math.min(o, a, l), c = function(f) {
    return (h - f) / 6 / u + 0.5;
  };
  return u === 0 ? n = s = 0 : (s = u / h, t = c(o), e = c(a), r = c(l), o === h ? n = r - e : a === h ? n = 1 / 3 + t - r : l === h && (n = 2 / 3 + e - t), n < 0 ? n += 1 : n > 1 && (n -= 1)), [360 * n, 100 * s, 100 * h];
}, ge.rgb.hwb = function(i) {
  var t = i[0], e = i[1], r = i[2];
  return [ge.rgb.hsl(i)[0], 100 * (1 / 255 * Math.min(t, Math.min(e, r))), 100 * (r = 1 - 1 / 255 * Math.max(t, Math.max(e, r)))];
}, ge.rgb.cmyk = function(i) {
  var t, e = i[0] / 255, r = i[1] / 255, n = i[2] / 255;
  return [100 * ((1 - e - (t = Math.min(1 - e, 1 - r, 1 - n))) / (1 - t) || 0), 100 * ((1 - r - t) / (1 - t) || 0), 100 * ((1 - n - t) / (1 - t) || 0), 100 * t];
}, ge.rgb.keyword = function(i) {
  var t = FM[i];
  if (t) return t;
  var e, r, n, s = 1 / 0;
  for (var o in Ro) if (Ro.hasOwnProperty(o)) {
    var a = Ro[o], l = (r = i, n = a, Math.pow(r[0] - n[0], 2) + Math.pow(r[1] - n[1], 2) + Math.pow(r[2] - n[2], 2));
    l < s && (s = l, e = o);
  }
  return e;
}, ge.keyword.rgb = function(i) {
  return Ro[i];
}, ge.rgb.xyz = function(i) {
  var t = i[0] / 255, e = i[1] / 255, r = i[2] / 255;
  return [100 * (0.4124 * (t = t > 0.04045 ? Math.pow((t + 0.055) / 1.055, 2.4) : t / 12.92) + 0.3576 * (e = e > 0.04045 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92) + 0.1805 * (r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92)), 100 * (0.2126 * t + 0.7152 * e + 0.0722 * r), 100 * (0.0193 * t + 0.1192 * e + 0.9505 * r)];
}, ge.rgb.lab = function(i) {
  var t = ge.rgb.xyz(i), e = t[0], r = t[1], n = t[2];
  return r /= 100, n /= 108.883, e = (e /= 95.047) > 8856e-6 ? Math.pow(e, 1 / 3) : 7.787 * e + 16 / 116, [116 * (r = r > 8856e-6 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116) - 16, 500 * (e - r), 200 * (r - (n = n > 8856e-6 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116))];
}, ge.hsl.rgb = function(i) {
  var t, e, r, n, s, o = i[0] / 360, a = i[1] / 100, l = i[2] / 100;
  if (a === 0) return [s = 255 * l, s, s];
  t = 2 * l - (e = l < 0.5 ? l * (1 + a) : l + a - l * a), n = [0, 0, 0];
  for (var h = 0; h < 3; h++) (r = o + 1 / 3 * -(h - 1)) < 0 && r++, r > 1 && r--, s = 6 * r < 1 ? t + 6 * (e - t) * r : 2 * r < 1 ? e : 3 * r < 2 ? t + (e - t) * (2 / 3 - r) * 6 : t, n[h] = 255 * s;
  return n;
}, ge.hsl.hsv = function(i) {
  var t = i[0], e = i[1] / 100, r = i[2] / 100, n = e, s = Math.max(r, 0.01);
  return e *= (r *= 2) <= 1 ? r : 2 - r, n *= s <= 1 ? s : 2 - s, [t, 100 * (r === 0 ? 2 * n / (s + n) : 2 * e / (r + e)), 100 * ((r + e) / 2)];
}, ge.hsv.rgb = function(i) {
  var t = i[0] / 60, e = i[1] / 100, r = i[2] / 100, n = Math.floor(t) % 6, s = t - Math.floor(t), o = 255 * r * (1 - e), a = 255 * r * (1 - e * s), l = 255 * r * (1 - e * (1 - s));
  switch (r *= 255, n) {
    case 0:
      return [r, l, o];
    case 1:
      return [a, r, o];
    case 2:
      return [o, r, l];
    case 3:
      return [o, a, r];
    case 4:
      return [l, o, r];
    case 5:
      return [r, o, a];
  }
}, ge.hsv.hsl = function(i) {
  var t, e, r, n = i[0], s = i[1] / 100, o = i[2] / 100, a = Math.max(o, 0.01);
  return r = (2 - s) * o, e = s * a, [n, 100 * (e = (e /= (t = (2 - s) * a) <= 1 ? t : 2 - t) || 0), 100 * (r /= 2)];
}, ge.hwb.rgb = function(i) {
  var t, e, r, n, s, o, a, l = i[0] / 360, h = i[1] / 100, u = i[2] / 100, c = h + u;
  switch (c > 1 && (h /= c, u /= c), r = 6 * l - (t = Math.floor(6 * l)), 1 & t && (r = 1 - r), n = h + r * ((e = 1 - u) - h), t) {
    default:
    case 6:
    case 0:
      s = e, o = n, a = h;
      break;
    case 1:
      s = n, o = e, a = h;
      break;
    case 2:
      s = h, o = e, a = n;
      break;
    case 3:
      s = h, o = n, a = e;
      break;
    case 4:
      s = n, o = h, a = e;
      break;
    case 5:
      s = e, o = h, a = n;
  }
  return [255 * s, 255 * o, 255 * a];
}, ge.cmyk.rgb = function(i) {
  var t = i[0] / 100, e = i[1] / 100, r = i[2] / 100, n = i[3] / 100;
  return [255 * (1 - Math.min(1, t * (1 - n) + n)), 255 * (1 - Math.min(1, e * (1 - n) + n)), 255 * (1 - Math.min(1, r * (1 - n) + n))];
}, ge.xyz.rgb = function(i) {
  var t, e, r, n = i[0] / 100, s = i[1] / 100, o = i[2] / 100;
  return e = -0.9689 * n + 1.8758 * s + 0.0415 * o, r = 0.0557 * n + -0.204 * s + 1.057 * o, t = (t = 3.2406 * n + -1.5372 * s + -0.4986 * o) > 31308e-7 ? 1.055 * Math.pow(t, 1 / 2.4) - 0.055 : 12.92 * t, e = e > 31308e-7 ? 1.055 * Math.pow(e, 1 / 2.4) - 0.055 : 12.92 * e, r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : 12.92 * r, [255 * (t = Math.min(Math.max(0, t), 1)), 255 * (e = Math.min(Math.max(0, e), 1)), 255 * (r = Math.min(Math.max(0, r), 1))];
}, ge.xyz.lab = function(i) {
  var t = i[0], e = i[1], r = i[2];
  return e /= 100, r /= 108.883, t = (t /= 95.047) > 8856e-6 ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116, [116 * (e = e > 8856e-6 ? Math.pow(e, 1 / 3) : 7.787 * e + 16 / 116) - 16, 500 * (t - e), 200 * (e - (r = r > 8856e-6 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116))];
}, ge.lab.xyz = function(i) {
  var t, e, r, n = i[0];
  t = i[1] / 500 + (e = (n + 16) / 116), r = e - i[2] / 200;
  var s = Math.pow(e, 3), o = Math.pow(t, 3), a = Math.pow(r, 3);
  return e = s > 8856e-6 ? s : (e - 16 / 116) / 7.787, t = o > 8856e-6 ? o : (t - 16 / 116) / 7.787, r = a > 8856e-6 ? a : (r - 16 / 116) / 7.787, [t *= 95.047, e *= 100, r *= 108.883];
}, ge.lab.lch = function(i) {
  var t, e = i[0], r = i[1], n = i[2];
  return (t = 360 * Math.atan2(n, r) / 2 / Math.PI) < 0 && (t += 360), [e, Math.sqrt(r * r + n * n), t];
}, ge.lch.lab = function(i) {
  var t, e = i[0], r = i[1];
  return t = i[2] / 360 * 2 * Math.PI, [e, r * Math.cos(t), r * Math.sin(t)];
}, ge.rgb.ansi16 = function(i) {
  var t = i[0], e = i[1], r = i[2], n = 1 in arguments ? arguments[1] : ge.rgb.hsv(i)[2];
  if ((n = Math.round(n / 50)) === 0) return 30;
  var s = 30 + (Math.round(r / 255) << 2 | Math.round(e / 255) << 1 | Math.round(t / 255));
  return n === 2 && (s += 60), s;
}, ge.hsv.ansi16 = function(i) {
  return ge.rgb.ansi16(ge.hsv.rgb(i), i[2]);
}, ge.rgb.ansi256 = function(i) {
  var t = i[0], e = i[1], r = i[2];
  return t === e && e === r ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(e / 255 * 5) + Math.round(r / 255 * 5);
}, ge.ansi16.rgb = function(i) {
  var t = i % 10;
  if (t === 0 || t === 7) return i > 50 && (t += 3.5), [t = t / 10.5 * 255, t, t];
  var e = 0.5 * (1 + ~~(i > 50));
  return [(1 & t) * e * 255, (t >> 1 & 1) * e * 255, (t >> 2 & 1) * e * 255];
}, ge.ansi256.rgb = function(i) {
  if (i >= 232) {
    var t = 10 * (i - 232) + 8;
    return [t, t, t];
  }
  var e;
  return i -= 16, [Math.floor(i / 36) / 5 * 255, Math.floor((e = i % 36) / 6) / 5 * 255, e % 6 / 5 * 255];
}, ge.rgb.hex = function(i) {
  var t = (((255 & Math.round(i[0])) << 16) + ((255 & Math.round(i[1])) << 8) + (255 & Math.round(i[2]))).toString(16).toUpperCase();
  return "000000".substring(t.length) + t;
}, ge.hex.rgb = function(i) {
  var t = i.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
  if (!t) return [0, 0, 0];
  var e = t[0];
  t[0].length === 3 && (e = e.split("").map(function(n) {
    return n + n;
  }).join(""));
  var r = parseInt(e, 16);
  return [r >> 16 & 255, r >> 8 & 255, 255 & r];
}, ge.rgb.hcg = function(i) {
  var t, e = i[0] / 255, r = i[1] / 255, n = i[2] / 255, s = Math.max(Math.max(e, r), n), o = Math.min(Math.min(e, r), n), a = s - o;
  return t = a <= 0 ? 0 : s === e ? (r - n) / a % 6 : s === r ? 2 + (n - e) / a : 4 + (e - r) / a + 4, t /= 6, [360 * (t %= 1), 100 * a, 100 * (a < 1 ? o / (1 - a) : 0)];
}, ge.hsl.hcg = function(i) {
  var t = i[1] / 100, e = i[2] / 100, r = 1, n = 0;
  return (r = e < 0.5 ? 2 * t * e : 2 * t * (1 - e)) < 1 && (n = (e - 0.5 * r) / (1 - r)), [i[0], 100 * r, 100 * n];
}, ge.hsv.hcg = function(i) {
  var t = i[1] / 100, e = i[2] / 100, r = t * e, n = 0;
  return r < 1 && (n = (e - r) / (1 - r)), [i[0], 100 * r, 100 * n];
}, ge.hcg.rgb = function(i) {
  var t = i[0] / 360, e = i[1] / 100, r = i[2] / 100;
  if (e === 0) return [255 * r, 255 * r, 255 * r];
  var n, s = [0, 0, 0], o = t % 1 * 6, a = o % 1, l = 1 - a;
  switch (Math.floor(o)) {
    case 0:
      s[0] = 1, s[1] = a, s[2] = 0;
      break;
    case 1:
      s[0] = l, s[1] = 1, s[2] = 0;
      break;
    case 2:
      s[0] = 0, s[1] = 1, s[2] = a;
      break;
    case 3:
      s[0] = 0, s[1] = l, s[2] = 1;
      break;
    case 4:
      s[0] = a, s[1] = 0, s[2] = 1;
      break;
    default:
      s[0] = 1, s[1] = 0, s[2] = l;
  }
  return n = (1 - e) * r, [255 * (e * s[0] + n), 255 * (e * s[1] + n), 255 * (e * s[2] + n)];
}, ge.hcg.hsv = function(i) {
  var t = i[1] / 100, e = t + i[2] / 100 * (1 - t), r = 0;
  return e > 0 && (r = t / e), [i[0], 100 * r, 100 * e];
}, ge.hcg.hsl = function(i) {
  var t = i[1] / 100, e = i[2] / 100 * (1 - t) + 0.5 * t, r = 0;
  return e > 0 && e < 0.5 ? r = t / (2 * e) : e >= 0.5 && e < 1 && (r = t / (2 * (1 - e))), [i[0], 100 * r, 100 * e];
}, ge.hcg.hwb = function(i) {
  var t = i[1] / 100, e = t + i[2] / 100 * (1 - t);
  return [i[0], 100 * (e - t), 100 * (1 - e)];
}, ge.hwb.hcg = function(i) {
  var t = i[1] / 100, e = 1 - i[2] / 100, r = e - t, n = 0;
  return r < 1 && (n = (e - r) / (1 - r)), [i[0], 100 * r, 100 * n];
}, ge.apple.rgb = function(i) {
  return [i[0] / 65535 * 255, i[1] / 65535 * 255, i[2] / 65535 * 255];
}, ge.rgb.apple = function(i) {
  return [i[0] / 255 * 65535, i[1] / 255 * 65535, i[2] / 255 * 65535];
}, ge.gray.rgb = function(i) {
  return [i[0] / 100 * 255, i[0] / 100 * 255, i[0] / 100 * 255];
}, ge.gray.hsl = ge.gray.hsv = function(i) {
  return [0, 0, i[0]];
}, ge.gray.hwb = function(i) {
  return [0, 100, i[0]];
}, ge.gray.cmyk = function(i) {
  return [0, 0, 0, i[0]];
}, ge.gray.lab = function(i) {
  return [i[0], 0, 0];
}, ge.gray.hex = function(i) {
  var t = 255 & Math.round(i[0] / 100 * 255), e = ((t << 16) + (t << 8) + t).toString(16).toUpperCase();
  return "000000".substring(e.length) + e;
}, ge.rgb.gray = function(i) {
  return [(i[0] + i[1] + i[2]) / 3 / 255 * 100];
};
var ad = hy.exports;
function PF(i) {
  var t = function() {
    for (var h = {}, u = Object.keys(ad), c = u.length, f = 0; f < c; f++) h[u[f]] = {
      distance: -1,
      parent: null
    };
    return h;
  }(), e = [i];
  for (t[i].distance = 0; e.length; ) for (var r = e.pop(), n = Object.keys(ad[r]), s = n.length, o = 0; o < s; o++) {
    var a = n[o], l = t[a];
    l.distance === -1 && (l.distance = t[r].distance + 1, l.parent = r, e.unshift(a));
  }
  return t;
}
function EF(i, t) {
  return function(e) {
    return t(i(e));
  };
}
function OF(i, t) {
  for (var e = [t[i].parent, i], r = ad[t[i].parent][i], n = t[i].parent; t[n].parent; ) e.unshift(t[n].parent), r = EF(ad[t[n].parent][n], r), n = t[n].parent;
  return r.conversion = e, r;
}
var mg = hy.exports, kF = function(i) {
  for (var t = PF(i), e = {}, r = Object.keys(t), n = r.length, s = 0; s < n; s++) {
    var o = r[s];
    t[o].parent !== null && (e[o] = OF(o, t));
  }
  return e;
}, Ga = {};
Object.keys(mg).forEach(function(i) {
  Ga[i] = {}, Object.defineProperty(Ga[i], "channels", {
    value: mg[i].channels
  }), Object.defineProperty(Ga[i], "labels", {
    value: mg[i].labels
  });
  var t = kF(i);
  Object.keys(t).forEach(function(e) {
    var r = t[e];
    Ga[i][e] = function(n) {
      var s = function(o) {
        if (o == null) return o;
        arguments.length > 1 && (o = Array.prototype.slice.call(arguments));
        var a = n(o);
        if (typeof a == "object") for (var l = a.length, h = 0; h < l; h++) a[h] = Math.round(a[h]);
        return a;
      };
      return "conversion" in n && (s.conversion = n.conversion), s;
    }(r), Ga[i][e].raw = function(n) {
      var s = function(o) {
        return o == null ? o : (arguments.length > 1 && (o = Array.prototype.slice.call(arguments)), n(o));
      };
      return "conversion" in n && (s.conversion = n.conversion), s;
    }(r);
  });
});
var RF = Ga, Ch = OM.exports, ii = RF, uy = [].slice, LM = ["keyword", "gray", "hex"], g0 = {};
Object.keys(ii).forEach(function(i) {
  g0[uy.call(ii[i].labels).sort().join("")] = i;
});
var ld = {};
function wr(i, t) {
  if (!(this instanceof wr)) return new wr(i, t);
  if (t && t in LM && (t = null), t && !(t in ii)) throw new Error("Unknown model: " + t);
  var e, r;
  if (i == null) this.model = "rgb", this.color = [0, 0, 0], this.valpha = 1;
  else if (i instanceof wr) this.model = i.model, this.color = i.color.slice(), this.valpha = i.valpha;
  else if (typeof i == "string") {
    var n = Ch.get(i);
    if (n === null) throw new Error("Unable to parse color from string: " + i);
    this.model = n.model, r = ii[this.model].channels, this.color = n.value.slice(0, r), this.valpha = typeof n.value[r] == "number" ? n.value[r] : 1;
  } else if (i.length) {
    this.model = t || "rgb", r = ii[this.model].channels;
    var s = uy.call(i, 0, r);
    this.color = m0(s, r), this.valpha = typeof i[r] == "number" ? i[r] : 1;
  } else if (typeof i == "number") i &= 16777215, this.model = "rgb", this.color = [i >> 16 & 255, i >> 8 & 255, 255 & i], this.valpha = 1;
  else {
    this.valpha = 1;
    var o = Object.keys(i);
    "alpha" in i && (o.splice(o.indexOf("alpha"), 1), this.valpha = typeof i.alpha == "number" ? i.alpha : 0);
    var a = o.sort().join("");
    if (!(a in g0)) throw new Error("Unable to parse color from object: " + JSON.stringify(i));
    this.model = g0[a];
    var l = ii[this.model].labels, h = [];
    for (e = 0; e < l.length; e++) h.push(i[l[e]]);
    this.color = m0(h);
  }
  if (ld[this.model]) for (r = ii[this.model].channels, e = 0; e < r; e++) {
    var u = ld[this.model][e];
    u && (this.color[e] = u(this.color[e]));
  }
  this.valpha = Math.max(0, Math.min(1, this.valpha)), Object.freeze && Object.freeze(this);
}
function Bn(i, t, e) {
  return (i = Array.isArray(i) ? i : [i]).forEach(function(r) {
    (ld[r] || (ld[r] = []))[t] = e;
  }), i = i[0], function(r) {
    var n;
    return arguments.length ? (e && (r = e(r)), (n = this[i]()).color[t] = r, n) : (n = this[i]().color[t], e && (n = e(n)), n);
  };
}
function ir(i) {
  return function(t) {
    return Math.max(0, Math.min(i, t));
  };
}
function IF(i) {
  return Array.isArray(i) ? i : [i];
}
function m0(i, t) {
  for (var e = 0; e < t; e++) typeof i[e] != "number" && (i[e] = 0);
  return i;
}
wr.prototype = {
  toString: function() {
    return this.string();
  },
  toJSON: function() {
    return this[this.model]();
  },
  string: function(i) {
    var t = this.model in Ch.to ? this : this.rgb(), e = (t = t.round(typeof i == "number" ? i : 1)).valpha === 1 ? t.color : t.color.concat(this.valpha);
    return Ch.to[t.model](e);
  },
  percentString: function(i) {
    var t = this.rgb().round(typeof i == "number" ? i : 1), e = t.valpha === 1 ? t.color : t.color.concat(this.valpha);
    return Ch.to.rgb.percent(e);
  },
  array: function() {
    return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
  },
  object: function() {
    for (var i = {}, t = ii[this.model].channels, e = ii[this.model].labels, r = 0; r < t; r++) i[e[r]] = this.color[r];
    return this.valpha !== 1 && (i.alpha = this.valpha), i;
  },
  unitArray: function() {
    var i = this.rgb().color;
    return i[0] /= 255, i[1] /= 255, i[2] /= 255, this.valpha !== 1 && i.push(this.valpha), i;
  },
  unitObject: function() {
    var i = this.rgb().object();
    return i.r /= 255, i.g /= 255, i.b /= 255, this.valpha !== 1 && (i.alpha = this.valpha), i;
  },
  round: function(i) {
    return i = Math.max(i || 0, 0), new wr(this.color.map(/* @__PURE__ */ function(t) {
      return function(e) {
        return function(r, n) {
          return Number(r.toFixed(n));
        }(e, t);
      };
    }(i)).concat(this.valpha), this.model);
  },
  alpha: function(i) {
    return arguments.length ? new wr(this.color.concat(Math.max(0, Math.min(1, i))), this.model) : this.valpha;
  },
  red: Bn("rgb", 0, ir(255)),
  green: Bn("rgb", 1, ir(255)),
  blue: Bn("rgb", 2, ir(255)),
  hue: Bn(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function(i) {
    return (i % 360 + 360) % 360;
  }),
  saturationl: Bn("hsl", 1, ir(100)),
  lightness: Bn("hsl", 2, ir(100)),
  saturationv: Bn("hsv", 1, ir(100)),
  value: Bn("hsv", 2, ir(100)),
  chroma: Bn("hcg", 1, ir(100)),
  gray: Bn("hcg", 2, ir(100)),
  white: Bn("hwb", 1, ir(100)),
  wblack: Bn("hwb", 2, ir(100)),
  cyan: Bn("cmyk", 0, ir(100)),
  magenta: Bn("cmyk", 1, ir(100)),
  yellow: Bn("cmyk", 2, ir(100)),
  black: Bn("cmyk", 3, ir(100)),
  x: Bn("xyz", 0, ir(100)),
  y: Bn("xyz", 1, ir(100)),
  z: Bn("xyz", 2, ir(100)),
  l: Bn("lab", 0, ir(100)),
  a: Bn("lab", 1),
  b: Bn("lab", 2),
  keyword: function(i) {
    return arguments.length ? new wr(i) : ii[this.model].keyword(this.color);
  },
  hex: function(i) {
    return arguments.length ? new wr(i) : Ch.to.hex(this.rgb().round().color);
  },
  rgbNumber: function() {
    var i = this.rgb().color;
    return (255 & i[0]) << 16 | (255 & i[1]) << 8 | 255 & i[2];
  },
  luminosity: function() {
    for (var i = this.rgb().color, t = [], e = 0; e < i.length; e++) {
      var r = i[e] / 255;
      t[e] = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
    }
    return 0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2];
  },
  contrast: function(i) {
    var t = this.luminosity(), e = i.luminosity();
    return t > e ? (t + 0.05) / (e + 0.05) : (e + 0.05) / (t + 0.05);
  },
  level: function(i) {
    var t = this.contrast(i);
    return t >= 7.1 ? "AAA" : t >= 4.5 ? "AA" : "";
  },
  isDark: function() {
    var i = this.rgb().color;
    return (299 * i[0] + 587 * i[1] + 114 * i[2]) / 1e3 < 128;
  },
  isLight: function() {
    return !this.isDark();
  },
  negate: function() {
    for (var i = this.rgb(), t = 0; t < 3; t++) i.color[t] = 255 - i.color[t];
    return i;
  },
  lighten: function(i) {
    var t = this.hsl();
    return t.color[2] += t.color[2] * i, t;
  },
  darken: function(i) {
    var t = this.hsl();
    return t.color[2] -= t.color[2] * i, t;
  },
  saturate: function(i) {
    var t = this.hsl();
    return t.color[1] += t.color[1] * i, t;
  },
  desaturate: function(i) {
    var t = this.hsl();
    return t.color[1] -= t.color[1] * i, t;
  },
  whiten: function(i) {
    var t = this.hwb();
    return t.color[1] += t.color[1] * i, t;
  },
  blacken: function(i) {
    var t = this.hwb();
    return t.color[2] += t.color[2] * i, t;
  },
  grayscale: function() {
    var i = this.rgb().color, t = 0.3 * i[0] + 0.59 * i[1] + 0.11 * i[2];
    return wr.rgb(t, t, t);
  },
  fade: function(i) {
    return this.alpha(this.valpha - this.valpha * i);
  },
  opaquer: function(i) {
    return this.alpha(this.valpha + this.valpha * i);
  },
  rotate: function(i) {
    var t = this.hsl(), e = t.color[0];
    return e = (e = (e + i) % 360) < 0 ? 360 + e : e, t.color[0] = e, t;
  },
  mix: function(i, t) {
    if (!i || !i.rgb) throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof i);
    var e = i.rgb(), r = this.rgb(), n = t === void 0 ? 0.5 : t, s = 2 * n - 1, o = e.alpha() - r.alpha(), a = ((s * o == -1 ? s : (s + o) / (1 + s * o)) + 1) / 2, l = 1 - a;
    return wr.rgb(a * e.red() + l * r.red(), a * e.green() + l * r.green(), a * e.blue() + l * r.blue(), e.alpha() * n + r.alpha() * (1 - n));
  }
}, Object.keys(ii).forEach(function(i) {
  if (LM.indexOf(i) === -1) {
    var t = ii[i].channels;
    wr.prototype[i] = function() {
      if (this.model === i) return new wr(this);
      if (arguments.length) return new wr(arguments, i);
      var e = typeof arguments[t] == "number" ? t : this.valpha;
      return new wr(IF(ii[this.model][i].raw(this.color)).concat(e), i);
    }, wr[i] = function(e) {
      return typeof e == "number" && (e = m0(uy.call(arguments), t)), new wr(e, i);
    };
  }
});
var zM = wr;
const DF = typeof Object.assign == "function", FF = [];
function lr(i) {
  if (DF) Object.assign.apply(Object, arguments);
  else for (let t = 1; t < arguments.length; t++) {
    const e = arguments[t];
    for (const r in e) i[r] = e[r];
  }
  return i;
}
function du(i) {
  return i == null;
}
function Ud(i) {
  return typeof i == "number" && !isNaN(i);
}
const LF = [];
function NM(i, t) {
  const e = t._get2DExtentAtRes(t.getGLRes()), r = e.getWidth(), n = e.getHeight(), s = i;
  pn(s);
  const o = Jn(FF, t.cameraLookAt);
  return o[2] = 0, ss(s, s, o), os(s, s, ne(LF, r, n, 1)), s;
}
function HM(i, t) {
  return Object.prototype.hasOwnProperty.call(i, t);
}
function v0(i) {
  for (let t = 1; t < arguments.length; t++) {
    const e = arguments[t];
    if (e) for (let r = 0, n = e.length; r < n; r++) i.push(e[r]);
  }
  return i.length;
}
const hd = {};
function BM(i, t) {
  if (!Array.isArray(t)) {
    const e = t;
    t = hd[e] = hd[e] || zM(t).array();
  }
  for (let e = 0; e < t.length; e++) i[e] = t[e];
  return t.length === 3 && (i[3] = 1), i;
}
function zF(i, t) {
  if (Array.isArray(t)) for (let e = 0; e < t.length; e++) i[e] = 255 * t[e];
  else {
    const e = t;
    t = hd[e] = hd[e] || zM(t).array();
    for (let r = 0; r < t.length; r++) i[r] = t[r];
  }
  return i.length === 3 && i.push(255), i;
}
function vg(i, t, e = 0) {
  if (!(i && t instanceof lt)) return null;
  const r = i.coordinateToPointAtRes(t, i.getGLRes());
  return [r.x, r.y, e];
}
const NF = [0, 0], Sx = [0, 0, 0];
let yg, $h = class {
  static getUniformDeclares() {
    const t = [], e = [];
    return e.push({
      name: "shadow_lightProjViewModelMatrix",
      type: "function",
      fn: function(r, n) {
        const s = n.shadow_lightProjViewMatrix, o = n.modelMatrix;
        return Jt(t, s, o);
      }
    }), e.push("shadow_shadowMap", "shadow_opacity", "esm_shadow_threshold", "shadow_color", "shadow_nearFar"), e;
  }
  constructor(t, e, r) {
    this.renderer = new hn(t), this.sceneConfig = e, this.t = 0.3, this.s = r, this.h();
  }
  resize() {
    const t = this.canvas;
    t.width = this.s.getRenderer().canvas.width, t.height = this.s.getRenderer().canvas.height;
  }
  h() {
    const t = this.sceneConfig.shadow || {};
    let e = 512;
    const r = t.quality;
    r === "high" ? e = 2048 : r === "medium" && (e = 1024);
    const n = this.getDefines();
    this.o = new tF(this.renderer, {
      width: e,
      height: e,
      blurOffset: t.blurOffset,
      defines: n
    }), this.u = new eF(n), this.p();
  }
  getDefines() {
    return {
      HAS_SHADOWING: 1,
      PACK_FLOAT: 1,
      USE_ESM: 1
    };
  }
  render(t, e, r, n, s, o, a, l, h, u) {
    this.m();
    const c = this.s.getMap();
    let f, d;
    if (u || this.v(c, a, !!t)) {
      this._ = this._ || [], this.M = this.M || [];
      const p = Jt(this._, e, r), g = mo(this.M, o);
      yg || (yg = c.getContainerExtent());
      let m = c.height;
      c.getPitch() > 62 && (m = c._getVisualHeight(62));
      const v = yg.set(0, c.height - m, c.width, c.height).convertTo((b) => c._containerPointToPointAtRes(b, c.getGLRes())).toArray();
      t && a.addMesh(this.S);
      const _ = v.map((b) => [b.x, b.y, 0, 1]), { lightProjViewMatrix: y, shadowMap: x, blurFBO: w } = this.o.render(a, {
        cameraProjViewMatrix: p,
        lightDir: g,
        farPlane: _,
        cameraLookAt: c.cameraLookAt
      });
      f = this.C = y, d = this.T = x, this.k = w, this.A = a.getMeshes().reduce((b, T) => (T.castShadow && T.geometry && (b[T.uuid] = {
        v0: T.version,
        v1: T.geometry.version
      }), b), {}), this.O = {
        count: a.getMeshes().length - +!!t,
        displayShadow: !!t
      }, this.I = !0;
    } else f = this.C, d = this.T, this.I = !1;
    return this.L = e, this.F = r, du(s) && (s = 1), t && a.getMeshes().length && this.displayShadow(n, s, l, h), {
      shadow_lightProjViewMatrix: f,
      shadow_shadowMap: d,
      shadow_opacity: s,
      shadow_color: n || Sx,
      esm_shadow_threshold: this.t
    };
  }
  displayShadow(t, e, r, n) {
    const s = this.C, o = this.S, a = this.R || [], l = this.s.getRenderer().canvas, h = this.P = this.P || [];
    h[0] = l.width, h[1] = l.height, this.renderer.render(this.u, {
      halton: r || NF,
      globalTexSize: h,
      projMatrix: this.L,
      viewMatrix: this.F,
      shadow_lightProjViewModelMatrix: Jt(a, s, o.localTransform),
      shadow_shadowMap: this.T,
      esm_shadow_threshold: this.t,
      shadow_opacity: e,
      color: t || Sx
    }, this.D, n);
  }
  dispose() {
    this.o.dispose(), this.u.dispose(), this.S && (this.S.geometry.dispose(), this.S.dispose()), delete this.renderer;
  }
  isUpdated() {
    return this.I !== !1;
  }
  v(t, e, r) {
    if (!this.A) return !0;
    const n = this.O;
    if (e.getMeshes().length !== n.count || r !== n.displayShadow) return !0;
    const s = e.getMeshes();
    for (let o = 0; o < s.length; o++) {
      const a = this.A[s[o].uuid];
      if (s[o].castShadow && (s[o].hasSkinAnimation() || !a || a.v0 !== s[o].version || a.v1 !== s[o].geometry.version)) return !0;
    }
    return !1;
  }
  p() {
    const t = new jd();
    t.generateBuffers(this.renderer.regl), this.S = new tn(t), this.D = new ur([this.S]);
  }
  m() {
    const t = this.s.getMap(), e = NM(this.S.localTransform, t);
    this.S.setLocalTransform(e);
  }
};
const Cx = [0, 0], Mf = new lt(0, 0), Sf = new lt(0, 0), HF = [], BF = [], ya = [];
function _a(i, t, e, r) {
  const n = i.getGLRes(), s = i.distanceToPointAtRes(t, t, n, e ? Mf : null, Sf);
  return r ? s.y : s.x;
}
const { createIBLTextures: Px, disposeIBLTextures: jF, getPBRUniforms: GF } = Kn.PBRUtils, VF = [0, 0], UF = [1, 1], $F = [], WF = [], ZF = [], XF = [], qF = [];
let $d = class jM {
  static getGroundTransform(t, e) {
    return NM(t, e);
  }
  constructor(t, e) {
    this.H = t, this.renderer = new hn(t), this.s = e, this.N = new Hd(), this.G = this.j.bind(this), this.h();
  }
  needToRedraw() {
    const t = this.B();
    return t && (t[0] || t[1]);
  }
  getMap() {
    return this.s && this.s.getMap();
  }
  getSymbol() {
    const t = this.s.getGroundConfig();
    return t && t.symbol;
  }
  isEnable() {
    const t = this.s.getGroundConfig();
    return t && t.enable;
  }
  paint(t) {
    if (!this.isEnable()) return !1;
    const e = this.U();
    if (this.V(t) && e === this.W) return !1;
    const r = this.q(t);
    r && this.S.setDefines(r), this.S.material !== this.material && this.S.setMaterial(this.material);
    const n = this.s.getGroundConfig();
    (n && n.symbol).ssr ? this.S.ssr = 1 : this.S.ssr = 0, this.m();
    const s = this.$(t);
    s.offsetFactor = t.offsetFactor, s.offsetUnits = t.offsetUnits;
    const o = t && t.renderTarget && t.renderTarget.fbo;
    return e === this.W ? (this.renderer.render(e, s, this.D, o), this.s.getRenderer().setCanvasUpdated(), !0) : (e.filter = t.sceneFilter, this.renderer.render(e, s, this.D, o), this.s.getRenderer().setCanvasUpdated(), !0);
  }
  V(t) {
    return !(!this.s.getRenderer().isEnableSSR || !this.s.getRenderer().isEnableSSR()) && !(!t || !t.ssr);
  }
  update() {
    const t = this.s.getGroundConfig();
    if (!t) return;
    const e = t && t.symbol, r = t.urlModifier;
    if (e) {
      this.Y = this.X(e.polygonFill || [1, 1, 1, 1]), this.J = e.polygonOpacity === void 0 ? 1 : e.polygonOpacity;
      const n = e.polygonPatternFile;
      if (n) {
        if (!this.Z || this.Z._pattern_src !== n) {
          const s = new Image();
          s.onload = () => {
            this.Z && this.Z.destroy(), this.Z = this.K(s), this.Z._pattern_src = n, this.setToRedraw();
          }, s.src = r && r(n) || n;
        }
      } else this.Z && (this.Z.destroy(), delete this.Z);
    } else this.Y = [1, 1, 1, 1], this.J = 1, this.Z && (this.Z.destroy(), delete this.Z);
    this.tt();
  }
  setToRedraw() {
    const t = this.s.getRenderer();
    t && t.setToRedraw();
  }
  dispose() {
    this.material && (this.material.dispose(), delete this.material), this.S && (this.S.geometry.dispose(), this.S.material && this.S.material.dispose(), this.S.dispose(), delete this.S), this.Z && (this.Z.destroy(), delete this.Z), this.W && (this.W.dispose(), delete this.W), this.it && (this.it.dispose(), delete this.it), this.et(), this.st && (this.st.destroy(), delete this.st);
    const t = this.getMap();
    t && t.off("updatelights", this.nt, this);
  }
  U() {
    const t = this.s.getGroundConfig();
    if (!t || !t.renderPlugin) return this.W;
    const e = t.renderPlugin.type;
    if (e === "lit") return this.it;
    if (e === "fill") return this.W;
    throw new Error("unsupported render plugin of " + e + " for layer ground");
  }
  $(t) {
    const e = this.rt(t);
    return e.polygonFill = this.Y, e.polygonOpacity = this.J, this.U() === this.W && this.Z && (e.polygonPatternFile = this.Z), e;
  }
  rt(t) {
    let e;
    return this.s.getGroundConfig().renderPlugin.type === "lit" ? (this.ht || (this.ht = Px(this.H, this.getMap())), this.st || (this.st = Kn.PBRHelper.generateDFGLUT(this.H)), e = GF(this.getMap(), this.ht, this.st, t && t.ssr, t && t.jitter)) : e = {
      projViewMatrix: this.getMap().projViewMatrix
    }, this.ot(e, t), e;
  }
  ot(t, e) {
    const r = e && e.includes;
    if (r) for (const n in r) r[n] && e[n].renderUniforms && lr(t, e[n].renderUniforms);
  }
  et() {
    this.ht && (jF(this.ht), delete this.ht);
  }
  h() {
    this.getMap().on("updatelights", this.nt, this);
    const t = this.ct(), e = $h.getUniformDeclares(), r = [];
    e.push({
      name: "projViewModelMatrix",
      type: "function",
      fn: function(s, o) {
        return Jt(r, o.projViewMatrix, o.modelMatrix);
      }
    }), this.W = new qe({
      vert: `attribute vec3 aPosition;
uniform mat4 projViewModelMatrix;
uniform mat4 modelMatrix;
#ifdef HAS_PATTERN
    attribute vec2 aTexCoord;
    uniform vec2 uvScale;
    uniform vec2 uvOffset;
    varying vec2 vTexCoord;
#endif
#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
    #include <vsm_shadow_vert>
#endif
void main () {
    #ifdef HAS_PATTERN
        vTexCoord = aTexCoord * uvScale + uvOffset;
    #endif
    vec3 position = vec3(aPosition);
    gl_Position = projViewModelMatrix * vec4(position, 1.0);
    #if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
        shadow_computeShadowPars(vec4(position, 1.0));
    #endif
}`,
      frag: `precision mediump float;
#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
    #include <vsm_shadow_frag>
#endif
#ifdef HAS_PATTERN
    uniform sampler2D polygonPatternFile;
    varying vec2 vTexCoord;
#endif
uniform vec4 polygonFill;
uniform float polygonOpacity;
void main() {
    #ifdef HAS_PATTERN
        vec4 color = texture2D(polygonPatternFile, vTexCoord);
    #else
        vec4 color = polygonFill;
    #endif
    gl_FragColor = color * polygonOpacity;
    #if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
        float shadowCoeff = shadow_computeShadow();
        gl_FragColor.rgb = shadow_blend(gl_FragColor.rgb, shadowCoeff);
    #endif
}`,
      uniforms: e,
      extraCommandProps: t
    });
    const n = $h.getUniformDeclares();
    n.push(...Gd.getUniformDeclares()), this.it = new Kn.StandardShader({
      uniforms: n,
      extraCommandProps: t
    }), this.p(), this.update();
  }
  ct() {
    const t = [0, 1], e = this.s.getRenderer().canvas;
    return {
      viewport: {
        x: 0,
        y: 0,
        width: () => e.width,
        height: () => e.height
      },
      cull: {
        enable: !0
      },
      depth: {
        enable: !0,
        mask: () => {
          const r = this.s.getGroundConfig();
          return r.depth || r.depth === void 0;
        },
        range: () => {
          const r = this.s.getGroundConfig(), n = r && r.renderPlugin.sceneConfig;
          return n && n.depthRange || t;
        },
        func: "<="
      },
      blend: {
        enable: !0,
        func: {
          src: "src alpha",
          dst: "one minus src alpha"
        },
        equation: "add"
      },
      polygonOffset: {
        enable: !0,
        offset: {
          factor: (r, n) => n.offsetFactor,
          units: (r, n) => n.offsetUnits
        }
      }
    };
  }
  lt() {
    const t = this.getMap().getLightManager();
    return !!(t && t.getAmbientResource());
  }
  p() {
    const t = new jd();
    t.data.aTexCoord = new Uint8Array([0, 0, 1, 0, 0, 1, 1, 1]), t.createTangent(), t.generateBuffers(this.renderer.regl), this.S = new tn(t, null, {
      castShadow: !1
    });
    const e = this.it.getGeometryDefines(t);
    this.S.setDefines(e), this.D = new ur([this.S]);
  }
  m() {
    const t = this.getMap(), e = jM.getGroundTransform(this.S.localTransform, t);
    this.S.setLocalTransform(e);
    const r = t.getGLRes(), n = t._get2DExtentAtRes(r), s = n.getWidth(), o = n.getHeight(), a = t.cameraLookAt, l = a[0] - s, h = a[1] - o, u = this.Z ? this.Z.width / this.Z.height : 1, c = this.getSymbol(), f = this.material ? this.material.get("textureOrigin") : c.polygonPatternFileOrigin, d = !!(this.material ? this.material.get("uvOffsetInMeter") : c.uvOffsetInMeter), p = (this.material ? this.material.get("uvOffset") : c.uvOffset) || VF, g = this.material && this.material.get("uvScale") || UF, m = this.material ? this.material.get("textureWidth") : c.polygonPatternFileWidth, v = this.material ? m * (g[1] / g[0]) : c.polygonPatternFileHeight, _ = this.B(), [y, x, w, b, T] = function(S, P, C, k, O, R, I, D, z, H, G) {
      const $ = S.getGLRes();
      k && (Mf.set(k[0], k[1]), S.coordToPointAtRes(Mf, $, Sf), P -= Sf.x, C -= Sf.y);
      const K = k ? Mf : null;
      H = R_(BF, H);
      const dt = !z && H || Cx;
      let it = z && H || Cx;
      it = R_(HF, it), it[0] && (it[0] = _a(S, it[0], K)), it[1] && (it[1] = _a(S, it[1], K, 1));
      let st = 0.5;
      O && (st = _a(S, O, K));
      let pt = st / I;
      if (R && (pt = _a(S, R, K, 1)), G && (G[0] || G[1])) {
        const Tt = performance.now() / 1e3;
        let $t = G[0], Wt = G[1];
        z && ($t = -_a(S, G[0], K), Wt = -_a(S, G[1], K, 1)), G[0] && (z ? it[0] = Tt * $t : dt[0] = Tt * $t), G[1] && (z ? it[1] = Tt * Wt : dt[1] = Tt * Wt);
      }
      const Ht = (P + it[0]) / (st / D[0]), Rt = (C - it[1]) / (pt / D[1]);
      return ya[0] = st / D[0], ya[1] = pt / D[1], ya[2] = Ht, ya[3] = Rt, ya[4] = dt, ya;
    }(t, l, h, f, m, v, u, g, d, p, _), A = 2 * n.getWidth() / y, M = 2 * n.getHeight() / x;
    if (!this.material) return this.S.setUniform("uvScale", we($F, A, M)), void this.S.setUniform("uvOffset", we(WF, w % 1 + T[0], b % 1 + T[1]));
    this.S.setUniform("uvScale", we(qF, A, M)), this.S.setUniform("uvOffset", we(ZF, w % 1 + T[0], b % 1 + T[1])), this.S.setUniform("uvOrigin", we(XF, w - w % 1, b - b % 1)), this.S.setUniform("uvRotation", 0);
  }
  q(t) {
    let e = !1;
    const r = this.S.defines, n = this.s.ut && this.s.ut(), s = this.s.getGroundConfig();
    function o(l, h) {
      l ? r[h] || (r[h] = 1, e = !0) : r[h] && (delete r[h], e = !0);
    }
    o(this.lt(), "HAS_IBL_LIGHTING"), o(t && t.ssr && s && s.symbol && s.symbol.ssr, "HAS_SSR");
    const a = t && n && n.shadow && n.shadow.enable;
    return o(a, "HAS_SHADOWING"), o(a, "USE_ESM"), o(!!this.Z, "HAS_PATTERN"), o(t && t.ssao, "HAS_SSAO"), e ? r : null;
  }
  tt() {
    const t = this.getSymbol() && this.getSymbol().material;
    if (!t) return;
    const e = {};
    let r = !1;
    const n = this.s.getGroundConfig();
    this.N.setURLModifier(n.urlModifier);
    for (const s in t) if (HM(t, s)) if (s.indexOf("Texture") > 0) {
      let o = t[s];
      if (!o) continue;
      o = typeof o == "string" ? {
        url: o,
        wrap: "repeat"
      } : o, o.flipY = !0, o.min = "linear mipmap linear", o.mag = "linear", o.flipY = !0, e[s] = new Bd(o, this.N), r = !0;
    } else e[s] = t[s];
    this.material ? (this.ft = new Kn.StandardMaterial(e), this.ft.isReady() ? this.j() : this.ft.once("complete", this.G)) : (this.material = new Kn.StandardMaterial(e), this.material.once("complete", this.G, this)), r || this.j();
  }
  j() {
    this.ft && (this.material.dispose(), this.material = this.ft, delete this.ft), this.setToRedraw(!0);
  }
  K(t) {
    t = pM.resizeToPowerOfTwo(t);
    const e = this.H, r = {
      width: t.width,
      height: t.height,
      data: t,
      mag: "linear",
      min: "linear mipmap linear",
      flipY: !0,
      wrap: "repeat"
    };
    return e.texture(r);
  }
  nt(t) {
    if (t.ambientUpdate) {
      this.et();
      const e = this.getMap();
      e && (this.ht = Px(this.H, e));
    }
    this.setToRedraw();
  }
  X(t) {
    return BM([], t);
  }
  B() {
    return this.material && this.material.get("uvOffsetAnim");
  }
  getRenderMeshes() {
    return this.D.getMeshes();
  }
};
const { createIBLTextures: YF, disposeIBLTextures: Ex } = Kn.PBRUtils, JF = [0, 0, 0], _g = [], xg = [];
let KF = class {
  constructor(t, e) {
    this.dt = 4, this.H = t, this.renderer = new hn(t), this.s = e, this.h(), this.pt();
  }
  paint(t) {
    if (!this.isEnable() || !this.gt) return;
    const e = this.$(t), r = t && t.renderTarget && t.renderTarget.fbo;
    this.renderer.render(this.vt, e, null, r);
  }
  update() {
    const t = this.getMap();
    if (!t || !this.isEnable()) return;
    const e = t.getLightManager(), r = e && e.getAmbientResource();
    r !== this.gt && this.ht && (Ex(this.ht), delete this.ht), this.gt = r, this.pt();
  }
  dispose() {
    this.vt.dispose(), Ex(this.ht), delete this.vt, delete this.ht, delete this.gt;
  }
  getMap() {
    return this.s.getMap();
  }
  pt() {
    if (!this.gt) return;
    const t = this.s.ut();
    this.vt.setMode(1, 0, t.environment && t.environment.mode ? 1 : 0);
  }
  isEnable() {
    const t = this.s.ut();
    return this.lt() && t && t.environment && t.environment.enable;
  }
  lt() {
    const t = this.getMap().getLightManager();
    return !!(t && t.getAmbientResource());
  }
  $() {
    const t = this.getMap(), e = this.getMap().getLightManager(), r = e && e.getAmbientLight();
    let n = this.ht;
    n || (n = this.ht = YF(this.H, t));
    const s = this.s.getRenderer().canvas, o = this.s.ut().environment || {}, a = o.level || 0, l = n.prefilterMap.width, h = this.wt = this.wt || [], u = r && r.hsv || JF, c = o.brightness || 0;
    return Jn(_g, u), c && (_g[2] += c), xg[0] = s.width, xg[1] = s.height, {
      rgbmRange: n.rgbmRange,
      cubeMap: n.prefilterMap,
      bias: a,
      size: l / Math.pow(2, Math.max(0, a - 1)),
      environmentExposure: Ud(r && r.exposure) ? r.exposure : 1,
      diffuseSPH: n.sh,
      viewMatrix: t.viewMatrix,
      projMatrix: t.projMatrix,
      resolution: xg,
      hsv: _g,
      transformMatrix: qv(h, r && Math.PI / 180 * -r.orientation || 0)
    };
  }
  h() {
    const t = this.getMap();
    if (t.on("updatelights", this.update, this), this.vt = new dD(), t.options.lights) {
      const e = this.getMap().getLightManager().getAmbientResource();
      this.gt = e;
    }
  }
};
const QF = [], t4 = [0.03, 0.03, 0.03], e4 = [], n4 = [], r4 = [], i4 = [1, 1, 1], s4 = [-1200, -1200, 0], o4 = [1200, 1200, 1e3], bg = {
  min: [],
  max: []
}, a4 = Yv([], Qo([], 90, 0, 0), [0, 0, 0]);
let Ox = class {
  constructor(t, e) {
    this.H = t, this.renderer = new hn(t), this.s = e, this._t = new l4(), this.h();
  }
  getMap() {
    return this.s && this.s.getMap();
  }
  h() {
    const t = this.s.getRenderer().canvas, e = {
      x: 0,
      y: 0,
      width: () => t.width,
      height: () => t.height
    };
    this.vt = new qe({
      vert: `attribute vec3 aPosition;
attribute vec3 aNormal;
attribute vec2 aTexCoord;
uniform mat4 projMatrix;
uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 positionMatrix;
uniform vec3 cameraPosition;
uniform float top;
uniform float bottom;
uniform float time;
varying vec2 vTexCoord;
#include <get_output>
float angle(float x, float y){
    return atan(y, x);
}
vec2 getFoot(vec2 camera, vec2 normal, vec2 pos) {
    vec2 position = vec2(0.0, 0.0);
    float distanceLen = distance(pos, normal);
    float a = angle(camera.x - normal.x, camera.y - normal.y);
    pos.x > normal.x ? a -= 0.785 : a += 0.785;
    position.x = cos(a) * distanceLen;
    position.y = sin(a) * distanceLen;
    return position + normal;
    return position;
}
void main()
{
    vec4 localPosition = getPosition(aPosition);
    mat4 localPositionMatrix = getPositionMatrix();
    vec2 foot = getFoot(vec2(cameraPosition.x, cameraPosition.z), vec2(aNormal.x, aNormal.z), vec2(localPosition.x, localPosition.z));
    float height = top - bottom;
    float y = aNormal.y - bottom - height * time;
    y = y + (y < 0.0 ? height : 0.0);
    float ratio = (1.0 - y / height) * (1.0 - y / height);
    y = height * (1.0 - ratio);
    y += bottom;
    y += aPosition.y - aNormal.y;
    localPosition = vec4( foot.x, y, foot.y , 1.0);
    gl_Position = projMatrix * modelViewMatrix * localPositionMatrix * localPosition;
    vTexCoord = aTexCoord;
}`,
      frag: `precision mediump float;
varying vec2 vTexCoord;
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D rainMap;
void main() {
    vec4 rainColor = texture2D(rainMap, vTexCoord);
    vec4 diffuseColor = vec4(diffuse, opacity);
    diffuseColor *= rainColor;
    gl_FragColor = diffuseColor;
}`,
      uniforms: [{
        name: "modelViewMatrix",
        type: "function",
        fn: function(r, n) {
          return Jt(QF, n.viewMatrix, n.modelMatrix);
        }
      }],
      extraCommandProps: {
        viewport: e,
        depth: {
          enable: !0,
          mask: !1,
          func: "less",
          range: [0, 1]
        },
        blend: {
          enable: !0,
          func: {
            src: "src alpha",
            dst: "one minus src alpha"
          },
          equation: "add"
        }
      }
    }), this.Mt();
  }
  Mt() {
    const t = this.H.texture({
      width: 2,
      height: 2
    });
    if (this.xt = this.yt(), !this.xt) return;
    this.bt = new ur(this.xt);
    const e = this.St();
    e.rainTexture ? this.Ct(e.rainTexture).then((r) => {
      this.xt.material.set("rainMap", r);
    }) : (this.xt.material.set("rainMap", t), console.warn("should set rain texture."));
  }
  yt() {
    const t = this.getMap(), e = this.St();
    if (!e) return null;
    this.Tt = t.getZoom();
    const r = this.kt(), n = this.At = e.density, s = this.Ot = e.rainWidth || 1, o = this.It = e.rainHeight || 1, a = [], l = [], h = [], u = [];
    for (let g = 0; g < n; g++) {
      const m = {};
      m.x = Math.random() * (r.max[0] - r.min[0]) + r.min[0], m.y = Math.random() * (r.max[2] - r.min[2]) + r.min[2], m.z = Math.random() * (r.max[1] - r.min[1]) + r.min[1];
      const v = (r.max[2] - r.min[2]) / 37.5 * o, _ = v / 3 * s;
      a.push(m.x + _, m.y + v, m.z, m.x - _, m.y + v, m.z, m.x - _, m.y, m.z, m.x + _, m.y, m.z), l.push(m.x, m.y - v / 2, m.z, m.x, m.y - v / 2, m.z, m.x, m.y - v / 2, m.z, m.x, m.y - v / 2, m.z), h.push(1, 1, 0, 1, 0, 0, 1, 0), u.push(4 * g + 0, 4 * g + 1, 4 * g + 2, 4 * g + 0, 4 * g + 2, 4 * g + 3);
    }
    const c = {};
    c.POSITION = a, c.NORMAL = l, c.TEXCOORD_0 = h;
    const f = new er(c, u, 0, {
      primitive: "triangles",
      positionAttribute: "POSITION",
      normalAttribute: "NORMAL",
      uv0Attribute: "TEXCOORD_0"
    });
    f.generateBuffers(this.renderer.regl);
    const d = new Nr({
      rainMap: this.H.texture({
        width: 2,
        height: 2
      }),
      diffuse: e.color || [1, 1, 1],
      opacity: e.opacity || 1
    }), p = new tn(f, d);
    return p.setUniform("top", r.max[2]), p.setUniform("bottom", r.min[2]), this.Et(p), p.transparent = !0, p;
  }
  Ct(t) {
    const e = new Image();
    return e.src = this.Lt = t, new Promise((r, n) => {
      e.onload = () => {
        const s = this.H.texture({
          mag: "linear",
          min: "linear mipmap nearest",
          wrapS: "clamp",
          wrapT: "clamp",
          data: e
        });
        r(s);
      }, e.onerror = (s) => {
        n(s);
      };
    });
  }
  paint(t) {
    if (!this.bt) return;
    const e = this.St(), r = {}, n = this.getMap();
    r.projMatrix = n.projMatrix, r.viewMatrix = n.viewMatrix, r.cameraPosition = n.cameraPosition;
    const s = e.speed || 1, o = this._t.getElapsedTime() / (2 / s) % 1;
    r.time = o, this.xt.material.set("diffuse", e.color || i4), this.xt.material.set("opacity", e.opacity || 1), this.Et(this.xt);
    const a = t && t.renderTarget && t.renderTarget.fbo;
    this.renderer.render(this.vt, r, this.bt, a), this.s.getRenderer().setCanvasUpdated();
  }
  Et(t) {
    const e = this.getMap(), r = e.coordinateToPointAtRes(e.getCenter(), e.getGLRes()), n = e.getGLScale() / e.getGLScale(this.Tt), s = ne(n4, n, n, n), o = Jv(s, t4, s), a = pn(r4), l = this.St(), h = e.getBearing();
    Nl(a, Qo(e4, l.windDirectionX || 0, l.windDirectionY || 0, 90 - h), [r.x, r.y, 0], o), Jt(a, a, a4), t.setLocalTransform(a);
  }
  setToRedraw() {
    const t = this.s.getRenderer();
    t && t.setToRedraw();
  }
  update() {
    const t = this.St();
    if (t) {
      if (this.xt || this.Mt(), t.density !== this.At || t.rainWidth !== this.Ot || t.rainHeight !== this.It) {
        const e = this.xt.material.get("rainMap");
        this.xt.geometry.dispose(), this.xt.dispose(), this.bt.clear(), this.xt = this.yt(), this.xt.material.set("rainMap", e), this.bt.setMeshes(this.xt);
      }
      t.rainTexture !== this.Lt && this.Ct(t.rainTexture).then((e) => {
        this.xt.material.set("rainMap", e);
      });
    }
  }
  dispose() {
    this.xt && (this.xt.geometry.dispose(), this.xt.material && this.xt.material.dispose(), this.xt.dispose(), delete this.xt), this.vt && (this.vt.dispose(), delete this.vt);
  }
  isEnable() {
    const t = this.St();
    return t && t.enable;
  }
  St() {
    const t = this.s.getWeatherConfig();
    return t && t.rain;
  }
  kt() {
    const t = 16.685648411389433 - this.getMap().getZoom();
    return go(bg.min, s4, Math.pow(2, t)), go(bg.max, o4, Math.pow(2, t)), bg;
  }
}, l4 = class {
  constructor(t) {
    this.autoStart = t === void 0 || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = (typeof performance > "u" ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let t = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const e = (typeof performance > "u" ? Date : performance).now();
      t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t;
    }
    return 0;
  }
};
const h4 = [], u4 = [0.03, 0.03, 0.03], c4 = [], f4 = [], d4 = [], p4 = Yv([], Qo([], 90, 0, 0), [0, 0, 0]);
let kx = class {
  constructor(t, e) {
    this.H = t, this.s = e, this.h();
  }
  h() {
    const t = this.s.getRenderer().canvas, e = {
      x: 0,
      y: 0,
      width: () => t.width,
      height: () => t.height
    };
    this.vt = new qe({
      vert: `#include <gl2_vert>
attribute vec3 aPosition;
attribute vec2 aTexCoord;
varying vec2 vTexCoord;
uniform mat4 projMatrix;
uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 positionMatrix;
#include <get_output>
void main()
{
    mat4 localPositionMatrix = getPositionMatrix();
    vec4 localPosition = getPosition(aPosition);
    gl_Position = projMatrix * modelViewMatrix * localPositionMatrix * localPosition;
    vTexCoord = aTexCoord;
}`,
      frag: `#if __VERSION__ == 100
  #ifdef GL_OES_standard_derivatives
    #extension GL_OES_standard_derivatives : enable
  #endif
#endif
precision mediump float;
#include <gl2_frag>
precision mediump float;
uniform sampler2D perlinTexture;
varying vec2 vTexCoord;
float lerp(float a, float b, float w) {
    return a + w * (b - a);
}
void main() {
    float snowIntense = texture2D(perlinTexture, vTexCoord).r;
    vec3 fixedC = vec3(1.0, 1.0, 1.0);
    float r = lerp(0.5, fixedC.x, snowIntense);
    float g = lerp(0.5, fixedC.y, snowIntense);
    float b = lerp(0.5, fixedC.z, snowIntense);
    glFragColor = vec4(r, g, b, 1.0);
    #if __VERSION__ == 100
        gl_FragColor = glFragColor;
    #endif
}`,
      uniforms: [{
        name: "modelViewMatrix",
        type: "function",
        fn: function(n, s) {
          return Jt(h4, s.viewMatrix, s.modelMatrix);
        }
      }],
      extraCommandProps: {
        viewport: e
      }
    }), this.vt.version = 300, this.bt = new ur(), this.Ft = this.Rt(), this.bt.setMeshes(this.Ft), this.renderer = new hn(this.H);
    const r = this.Pt();
    r && (r.snowGroundTexture ? this.Dt(r.snowGroundTexture) : (this.Ht = this.H.texture({
      width: 2,
      height: 2
    }), console.warn("should set snow ground texture.")));
  }
  render(t) {
    this.Ht && this.Ft.material.set("perlinTexture", this.Ht);
    const e = this.s.getMap();
    this.Nt(e);
    const r = {
      projMatrix: e.projMatrix,
      viewMatrix: e.viewMatrix,
      cameraPosition: e.cameraPosition
    }, n = t && t.renderTarget && t.renderTarget.fbo;
    this.renderer.render(this.vt, r, this.bt, n), this.s.getRenderer().setCanvasUpdated();
  }
  Nt(t) {
    const e = t.coordinateToPointAtRes(t.getCenter(), t.getGLRes()), r = t.getGLScale() / t.getGLScale(this.Tt), n = ne(f4, r, r, r), s = Jv(n, u4, n), o = pn(d4);
    Nl(o, Qo(c4, 0, 0, 0), [e.x, e.y, 5e-3], s), Jt(o, o, p4), this.Ft.setLocalTransform(o);
  }
  Dt(t) {
    const e = new Image();
    e.onload = () => {
      this.Ht = this.H.texture({
        mag: "linear",
        min: "linear mipmap nearest",
        wrapS: "repeat",
        wrapT: "repeat",
        data: e
      });
    }, e.onerror = (r) => {
      console.log(r);
    }, e.src = this.Gt = t;
  }
  Rt() {
    const t = this.s.getMap();
    this.Tt = t.getZoom();
    const e = 16e3 * Math.pow(2, 16.685648411389433 - this.Tt), r = [-e, 0, -e, e, 0, -e, -e, 0, e, e, 0, e], n = {};
    n.POSITION = r, n.NORMAL = [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], n.TEXCOORD_0 = [0, 0, 1, 0, 0, 1, 1, 1];
    const s = new er(n, [3, 1, 0, 0, 2, 3], 0, {
      positionAttribute: "POSITION",
      normalAttribute: "NORMAL",
      uv0Attribute: "TEXCOORD_0"
    });
    s.generateBuffers(this.H);
    const o = new Nr({
      perlinTexture: this.H.texture({
        with: 2,
        height: 2
      })
    });
    return new tn(s, o);
  }
  getMeshes() {
    return this.Ft;
  }
  dispose() {
    this.Ft && (this.Ft.geometry.dispose(), this.Ft.material && this.Ft.material.dispose(), this.Ft.dispose(), delete this.Ft), this.vt && (this.vt.dispose(), delete this.vt);
  }
  update() {
    const t = this.Pt();
    t && t.snowGroundTexture === !this.Gt && this.Dt(t.snowGroundTexture);
  }
  isEnable() {
    const t = this.St();
    return t && t.enable;
  }
  Pt() {
    const t = this.s.getWeatherConfig();
    return t && t.snow;
  }
};
/*!
 * @maptalks/gltf-loader v0.97.2
 * LICENSE : UNLICENSED
 * (c) 2016-2024 maptalks.org
 */
if (Kv([]), typeof TextDecoder < "u" && new TextDecoder("utf-8"), typeof TextDecoder < "u" && new TextDecoder("utf-8"), typeof OffscreenCanvas < "u") {
  let i;
  try {
    i = new OffscreenCanvas(2, 2).getContext("2d");
  } catch {
  }
}
typeof document < "u" && document.createElement("canvas");
const g4 = [];
let m4 = class {
  constructor(t, e, r) {
    this.H = t, this.s = e, this.jt = r, this.h();
  }
  h() {
    this.renderer = new hn(this.H);
    const t = this.s.getRenderer(), e = this.Bt = {
      x: 0,
      y: 0,
      width: () => t.canvas ? t.canvas.width : 1,
      height: () => t.canvas ? t.canvas.height : 1
    };
    this.Ut = e.width, this.zt = e.height, this.Vt = this.H.framebuffer({
      color: this.H.texture({
        width: t.canvas ? t.canvas.width : 1,
        height: t.canvas ? t.canvas.height : 1,
        wrap: "clamp",
        mag: "linear",
        min: "linear"
      }),
      depth: !0
    }), this.EMPTY_TEXTURE = this.H.texture({
      with: 2,
      height: 2
    }), this.Wt = new Ox(this.H, this.s), this.qt = new MD(this.H, e), this.$t = new kx(this.H, this.s), this.Yt = new vD(this.H, e, this.s), this.Xt = new yD(), this.Xt.version = 300;
  }
  getMap() {
    return this.s && this.s.getMap();
  }
  renderScene(t) {
    this.renderSnowMask(t), this.renderRain(t);
  }
  renderRain(t) {
    this.isEnableRain() && this.Wt.paint(t);
  }
  renderSnowMask(t) {
    if (!this.isEnableSnow()) return;
    const e = this.getMap();
    this.$t.render(t, e);
  }
  paint(t, e) {
    if (!e || !e.length) return t;
    this.Jt();
    const r = this.s.getWeatherConfig(), n = {};
    var s;
    if (this.isEnableRain() ? (n.ripplesMap = this.Zt(), this.Xt.shaderDefines.HAS_RAIN = 1) : delete this.Xt.shaderDefines.HAS_RAIN, this.isEnableSnow() ? (this.Xt.shaderDefines.HAS_SNOW = 1, n.snowIntensity = typeof (s = r.snow.snowIntensity) != "number" || isNaN(s) ? 0.5 : r.snow.snowIntensity, e.forEach((o) => {
      o.defines.HAS_SNOW = 1;
    })) : (delete this.Xt.shaderDefines.HAS_SNOW, e.forEach((o) => {
      delete o.defines.HAS_SNOW;
    })), this.isEnableFog()) {
      const o = r.fog;
      n.fogColor = o.color || [0.9, 0.9, 0.9], this.Xt.shaderDefines.HAS_FOG = 1;
    } else delete this.Xt.shaderDefines.HAS_FOG;
    return this.Xt.setDefines(this.Xt.shaderDefines), n.mixFactorMap = this.Kt(e) || this.EMPTY_TEXTURE, n.sceneMap = t, n.time = this.Qt() / 1e3, n.resolution = we(g4, this.Vt.width, this.Vt.height), this.renderer.render(this.Xt, n, null, this.Vt), this.ti = e, this.Vt;
  }
  Kt(t) {
    const e = {}, r = this.getMap(), n = r.getZoom(), s = Math.pow(2, 16.685648411389433 - n), o = this.s.getWeatherConfig(), a = o.fog;
    if (!a || !a.enable) return null;
    const l = a.start || 0.1, h = a.end || 100;
    e.projMatrix = r.projMatrix, e.viewMatrix = r.viewMatrix, e.cameraPosition = r.cameraPosition, e.fogDist = [l * s, h * s], e.rainDepth = r.altitudeToPoint(o.rain && o.rain.rainDepth || 0.1, r.getGLRes());
    const u = this.Yt.render(t, e);
    return this.s.getRenderer().ii(u);
  }
  Zt() {
    const t = this.getMap(), e = this.s.getWeatherConfig(), r = e.rain.rippleRadius || 24, n = {};
    return n.projMatrix = t.projMatrix, n.viewMatrix = t.viewMatrix, n.time = this.Qt() / 1e3, n.rippleRadius = r, n.density = e.rain.density || 2e3, this.qt.render(t, n);
  }
  Qt() {
    if (!this.s) return 0;
    if (this.ei === void 0 && (this.ei = 0), this.isPlaying()) {
      const t = this.s.getRenderer();
      this.ei = t.getFrameTime();
    }
    return this.ei;
  }
  isEnable() {
    const t = this.s.getWeatherConfig();
    return t && t.enable;
  }
  isEnableRain() {
    const t = this.s.getWeatherConfig();
    return t && t.enable && t.rain && t.rain.enable;
  }
  isEnableFog() {
    const t = this.s.getWeatherConfig();
    return t && t.enable && t.fog && t.fog.enable;
  }
  isEnableSnow() {
    const t = this.s.getWeatherConfig();
    return t && t.enable && t.snow && t.snow.enable;
  }
  isPlaying() {
    const t = this.s.getWeatherConfig();
    return !!t && t.playing !== !1;
  }
  si() {
    return this.isEnableRain() || this.isEnableFog() || this.isEnableSnow();
  }
  update() {
    !this.isEnable() && this.ti && this.ti.forEach((t) => {
      delete t.defines.HAS_SNOW, delete t.defines.HAS_RAIN, delete t.defines.HAS_FOG;
    }), this.isEnableRain() && (this.Wt = this.Wt || new Ox(this.H, this.s), this.Wt.update()), this.isEnableSnow() && (this.$t = this.$t || new kx(this.H, this.s), this.$t.update());
  }
  getShadowMeshes() {
    return this.$t.getMeshes();
  }
  Jt() {
    const t = this.Ut(), e = this.zt();
    !this.Vt || this.Vt.width === t && this.Vt.height === e || this.Vt.resize(t, e);
  }
  dispose() {
    this.Vt && this.Vt.destroy(), this.Xt && (this.Xt.dispose(), delete this.Xt), this.Wt && (this.Wt.dispose(), delete this.Wt), this.$t && (this.$t.dispose(), delete this.$t);
  }
};
const Rx = [], v4 = (i) => !!i.bloom, y4 = (i) => !!i.ssr;
let GM = class {
  constructor(t, e, r) {
    this.H = t, this.s = e, this.ni = new hn(t), this.ri = new KI(), this.hi = new aD(this.ni, r), this.oi = new gD(), this.ai = new Gd(this.H);
  }
  setContextIncludes() {
  }
  bloom(t, e, r, n, s, o, a) {
    this.ci || (this.ci = new uD(this.H));
    const l = this.s.getRenderer().ii(this.li);
    return this.ci.render(t, l, n, s, o, e, r, a);
  }
  drawBloom(t) {
    const e = this.s.getRenderer(), r = this.H, n = this.li;
    if (n) {
      const { width: f, height: d } = t;
      n.width === f && n.height === d || n.resize(f, d), r.clear({
        color: [0, 0, 0, 0],
        framebuffer: n
      });
    } else {
      const f = this.ui(t);
      this.li = r.framebuffer(f);
    }
    const s = e.getFrameTime(), o = e.getFrameEvent(), a = e.getFrameContext(), l = a.renderMode, h = a.sceneFilter, u = a.renderTarget;
    a.isPostProcess = !0, a.renderMode = "default", a.sceneFilter = v4, a.renderTarget = {
      fbo: this.li,
      getFramebuffer: _4,
      getDepthTexture: x4
    };
    const c = e.glCtx;
    return c.resetDrawCalls(), o ? e.forEachRenderer((f) => {
      e.clearStencil(f, n), f.drawOnInteracting(o, s, a);
    }) : e.forEachRenderer((f) => {
      e.clearStencil(f, n), f.draw(s, a);
    }), delete a.isPostProcess, a.renderMode = l, a.sceneFilter = h, a.renderTarget = u, c.getDrawCalls();
  }
  genSsrMipmap(t, e) {
    const r = this.s.getMap().projViewMatrix;
    this.ai.genMipMap(t, e, r);
  }
  getPrevSsrProjViewMatrix() {
    return this.ai && this.ai.getPrevProjViewMatrix();
  }
  drawSSR(t, e, r) {
    r && this.ai.copyDepthTex(t);
    const n = this.s.getRenderer(), s = n.getFrameTime(), o = n.getFrameEvent(), a = n.getFrameContext();
    a.isPostProcess = !0, a.ssr = this.getSSRContext();
    const l = a.renderMode, h = a.sceneFilter;
    a.renderMode = "default", a.sceneFilter = y4, a.renderTarget.fbo = e;
    const u = n.glCtx;
    let c = !1;
    o ? n.forEachRenderer((d) => {
      n.clearStencil(d, e), c || (u.resetDrawCalls(), c = !0), d.drawOnInteracting(o, s, a);
    }) : n.forEachRenderer((d) => {
      n.clearStencil(d, e), c || (u.resetDrawCalls(), c = !0), d.draw(s, a);
    });
    const f = n.drawGround();
    return delete a.ssr, delete a.isPostProcess, a.renderMode = l, a.sceneFilter = h, this.fi = u.getDrawCalls() > 0, f;
  }
  getSSRUniforms() {
    const t = this.s.ut(), e = t && t.postProcess, r = this.s.getMap();
    return this.ai.getSSRUniforms(r, e.ssr.factor, e.ssr.quality);
  }
  getSSRContext() {
    const t = this.s.ut(), e = t && t.postProcess, r = this.s.getMap(), n = this.ai.getSSRUniforms(r, e.ssr.factor, e.ssr.quality);
    return n ? {
      renderUniforms: n,
      defines: {
        HAS_SSR: 1
      }
    } : null;
  }
  taa(t, e, { projMatrix: r, needClear: n }) {
    const s = this.hi;
    return {
      outputTex: s.render(t, e, r, n),
      redraw: s.needToRedraw()
    };
  }
  isTaaNeedRedraw() {
    return this.hi.needToRedraw();
  }
  ssao(t, e, r) {
    return this.di || (this.di = new rD(this.ni), this.s.getRenderer().setToRedraw()), this.di.render({
      projMatrix: r.projMatrix,
      cameraNear: r.cameraNear,
      cameraFar: r.cameraFar,
      bias: r.ssaoBias,
      radius: r.ssaoRadius,
      intensity: r.ssaoIntensity,
      quality: 0.6
    }, t, e);
  }
  fxaa(t, e, r, n, s, o, a, l, h, u, c, f, d, p, g, m) {
    !t || t.width === e.fbo && t.height === e.height || t.resize(e.width, e.height);
    const v = {};
    s ? v.HAS_TAA_TEX = 1 : delete v.HAS_TAA_TEX, o ? v.HAS_FXAA_TEX = 1 : delete v.HAS_FXAA_TEX, f ? v.HAS_OUTLINE_TEX = 1 : delete v.HAS_OUTLINE_TEX, r ? v.HAS_NOAA_TEX = 1 : delete v.HAS_NOAA_TEX, n ? v.HAS_POINT_TEX = 1 : delete v.HAS_POINT_TEX, this.ri.setDefines(v), this.ni.render(this.ri, {
      textureSource: e,
      noAaTextureSource: r,
      pointTextureSource: n,
      taaTextureSource: s,
      fxaaTextureSource: o,
      resolution: we(Rx, e.width, e.height),
      enableFXAA: a,
      enableToneMapping: l,
      enableSharpen: h,
      pixelRatio: u,
      sharpFactor: c,
      textureOutline: f,
      highlightFactor: d,
      outlineFactor: p,
      outlineWidth: g,
      outlineColor: m
    }, null, t);
  }
  renderFBOToScreen(t, e, r, n) {
    this.pi || (this.pi = []), this.pi[0] = t.width, this.pi[1] = t.height;
    const s = this.s.getRenderer();
    this.ni.render(this.oi, {
      texture: t.color && s.ii(t) || t,
      size: this.pi,
      enableSharpen: +!!e,
      sharpFactor: r,
      pixelRatio: n
    });
  }
  postprocess(t, e, r) {
    this.gi || (this.gi = new iD());
    const n = this.s && this.s.getRenderer(), s = r || n.ii(t);
    return e.resolution = we(Rx, s.width, s.height), e.textureSource = s, e.timeGrain = performance.now(), this.ni.render(this.gi, e), this.mi;
  }
  dispose() {
    this.li && (this.li.destroy(), delete this.li), this.hi && (this.hi.dispose(), delete this.hi), this.di && (this.di.dispose(), delete this.di), this.ci && (this.ci.dispose(), delete this.ci), this.gi && (this.gi.dispose(), delete this.gi), this.ri && (this.ri.dispose(), delete this.ri), this.oi && (this.oi.dispose(), delete this.oi);
  }
  ui(t, e) {
    const { width: r, height: n } = this.s.getRenderer().canvas, s = this.H;
    let o;
    o = this.s.getRenderer().vi() ? s.renderbuffer({
      width: r,
      height: n,
      samples: this.s.options.multiSamples,
      format: "rgba8"
    }) : s.texture({
      min: "nearest",
      mag: "nearest",
      format: e || "rgba",
      width: r,
      height: n
    });
    const a = {
      width: r,
      height: n,
      colors: [o]
    };
    return t && (a.depthStencil = t), a;
  }
};
function _4(i) {
  return i._framebuffer.framebuffer;
}
function x4(i) {
  return i.depthStencil._texture.texture;
}
let b4 = class extends ar {
  constructor(t) {
    super({
      vert: `#if __VERSION__ == 300
	#define attribute in
	#define varying out
#endif
attribute vec2 aPosition;
attribute vec2 aTexCoord;
varying vec2 vTexCoord;
void main()
{
  gl_Position = vec4(aPosition, 0., 1.);
  vTexCoord = aTexCoord;
}`,
      frag: `#if __VERSION__ == 100
  #ifdef GL_OES_standard_derivatives
    #extension GL_OES_standard_derivatives : enable
  #endif
#endif
precision mediump float;
#include <gl2_frag>
varying vec2 vTexCoord;
#ifdef HAS_FLOODANALYSE
    uniform vec3 flood_waterColor;
    uniform float flood_waterOpacity;
    uniform sampler2D floodMap;
#endif
#ifdef HAS_SKYLINE
    uniform sampler2D skylineMap;
#endif
#ifdef HAS_VIEWSHED
    uniform vec4 viewshed_visibleColor;
    uniform vec4 viewshed_invisibleColor;
    uniform sampler2D viewshedMap;
#endif
#ifdef HAS_INSIGHT
    uniform vec4 insight_visibleColor;
    uniform vec4 insight_invisibleColor;
    uniform sampler2D insightMap;
#endif
#ifdef HAS_CUT
    uniform sampler2D meshesMap;
    uniform sampler2D invisibleMap;
#endif
#ifdef HAS_EXCAVATE
    uniform sampler2D excavateMap;
#endif
#ifdef HAS_CROSSCUT
    uniform sampler2D crosscutMap;
    uniform vec4 cutLineColor;
#endif
#ifdef HAS_HEIGHTLIMIT
    uniform vec3 limitColor;
    uniform sampler2D heightLimitMap;
#endif
uniform sampler2D sceneMap;
void main() {
    vec4 sceneColor = texture2D(sceneMap, vTexCoord);
    glFragColor = sceneColor;
    #ifdef HAS_VIEWSHED
        vec4 viewshedColor = texture2D(viewshedMap, vTexCoord);
        if (viewshedColor.r > 0.99) {
            glFragColor = vec4(mix(viewshed_invisibleColor.rgb, sceneColor.rgb, viewshed_invisibleColor.a), sceneColor.a);
        } else if (viewshedColor.g > 0.99) {
            glFragColor = vec4(mix(viewshed_visibleColor.rgb, sceneColor.rgb, viewshed_visibleColor.a), sceneColor.a);
        } else if (viewshedColor.a < 0.01) {
            glFragColor = vec4(viewshedColor.rgb, 1.0);
        }
    #endif
    #ifdef HAS_FLOODANALYSE
        vec4 floodColor = texture2D(floodMap, vTexCoord);
        if (floodColor.r > 0.0) {
            glFragColor = vec4(mix(glFragColor.rgb, flood_waterColor, flood_waterOpacity), glFragColor.a);
        }
    #endif
    #ifdef HAS_SKYLINE
        vec4 skylineColor = texture2D(skylineMap, vTexCoord);
        if (skylineColor.r > 0.0 || skylineColor.g > 0.0 || skylineColor.b > 0.0) {
            glFragColor = skylineColor;
        }
    #endif
    #ifdef HAS_INSIGHT
        vec4 insightColor = texture2D(insightMap, vTexCoord);
        if (insightColor.g > 0.0) {
            glFragColor = insight_visibleColor;
        } else if (insightColor.r > 0.0) {
            glFragColor = insight_invisibleColor;
        }
    #endif
    #ifdef HAS_CUT
        vec4 cutColor = texture2D(invisibleMap, vTexCoord);
        vec4 meshesMapColor = texture2D(meshesMap, vTexCoord);
        if (cutColor.r == 1.0 && cutColor.g == 0.0 && cutColor.b == 0.0) {
            glFragColor = meshesMapColor;
        } else if (cutColor.r == 0.0 && cutColor.g == 1.0 && cutColor.b == 0.0) {
            glFragColor = meshesMapColor;
        } else if (cutColor.r == 0.0 && cutColor.g == 0.0 && cutColor.b == 1.0) {
          glFragColor = sceneColor;
        }
    #endif
    #ifdef HAS_EXCAVATE
        vec4 excavateColor = texture2D(excavateMap, vTexCoord);
        if (excavateColor.r == 1.0 && excavateColor.g == 0.0 && excavateColor.b == 0.0) {
          glFragColor = sceneColor;
        }  else {
          glFragColor = excavateColor;
        }
    #endif
    #ifdef HAS_CROSSCUT
        vec4 crosscutColor = texture2D(crosscutMap, vTexCoord);
        if (crosscutColor.r > 0.0) {
            glFragColor = vec4(mix(cutLineColor.rgb, glFragColor.rgb, 0.99), glFragColor.a);
        }
    #endif
    #ifdef HAS_HEIGHTLIMIT
        vec4 heightLimitColor = texture2D(heightLimitMap, vTexCoord);
        if (heightLimitColor.r > 0.0) {
            glFragColor = vec4(mix(limitColor, glFragColor.rgb, 0.6), glFragColor.a);
        }
    #endif
    #if __VERSION__ == 100
        gl_FragColor = glFragColor;
    #endif
}`,
      extraCommandProps: {
        viewport: t,
        cull: {
          enable: !0
        },
        blend: {
          enable: !0,
          func: {
            srcRGB: "src alpha",
            srcAlpha: 1,
            dstRGB: "one minus src alpha",
            dstAlpha: "one minus src alpha"
          },
          equation: "add"
        }
      }
    });
  }
}, w4 = class {
  constructor(t, e, r) {
    this.H = t, this.s = e, this.jt = r, this.h();
  }
  h() {
    this.renderer = new hn(this.H);
    const t = this.s.getRenderer(), e = this.Bt = {
      x: 0,
      y: 0,
      width: () => t.canvas ? t.canvas.width : 1,
      height: () => t.canvas ? t.canvas.height : 1
    };
    this.Vt = this.H.framebuffer({
      color: this.H.texture({
        width: t.canvas ? t.canvas.width : 1,
        height: t.canvas ? t.canvas.height : 1,
        wrap: "clamp",
        mag: "linear",
        min: "linear"
      }),
      depth: !0
    }), this.vt = new b4(e);
  }
  getMap() {
    return this.s && this.s.getMap();
  }
  paint(t, e) {
    if (!e && e.length) return t;
    this.Jt();
    const r = {}, n = this.s.wi;
    if (!this._i()) return t;
    this.H.clear({
      color: [0, 0, 0, 0],
      depth: 1,
      stencil: 0,
      framebuffer: this.Vt
    }), delete this.vt.shaderDefines.HAS_FLOODANALYSE, delete this.vt.shaderDefines.HAS_VIEWSHED, delete this.vt.shaderDefines.HAS_SKYLINE, delete this.vt.shaderDefines.HAS_INSIGHT, delete this.vt.shaderDefines.HAS_CUT, delete this.vt.shaderDefines.HAS_CROSSCUT, delete this.vt.shaderDefines.HAS_HEIGHTLIMIT;
    for (let s = 0; s < n.length; s++) {
      const o = n[s];
      if (!o.isEnable()) continue;
      const a = o.getDefines();
      lr(this.vt.shaderDefines, a);
      const l = this.getMap(), h = l.width, u = l.height, c = this.Mi(e, o.getExcludeLayers()), f = o.renderAnalysis(c, h, u);
      f && lr(r, f);
    }
    return r.sceneMap = t, this.vt.setDefines(this.vt.shaderDefines), this.renderer.render(this.vt, r, null, this.Vt), this.Vt;
  }
  Mi(t, e) {
    let r = [];
    for (let n = 0; n < t.length; n++) {
      if (e.indexOf(t[n].getId()) > -1) continue;
      const s = t[n].getRenderer();
      if (s && s.getAnalysisMeshes) {
        const o = s.getAnalysisMeshes();
        o.forEach((a) => {
          a.setUniform("useAnalysis", 1);
        }), r = r.concat(o);
      }
    }
    return r;
  }
  Jt() {
    const t = Yr.isFunction(this.Bt.width.data) ? this.Bt.width.data() : this.Bt.width, e = Yr.isFunction(this.Bt.height.data) ? this.Bt.height.data() : this.Bt.height;
    !this.Vt || this.Vt.width === t && this.Vt.height === e || this.Vt.resize(t, e);
  }
  _i() {
    const t = this.s && this.s.wi;
    if (!t) return !1;
    for (let e = 0; e < t.length; e++) if (t[e].isEnable()) return !0;
    return !1;
  }
};
const Mo = [0, 0, 0, 0], wg = [1, 1, -1], Tg = [0, 0], T4 = (i) => !i.bloom && !i.ssr, A4 = (i) => !i.bloom, M4 = (i) => !i.ssr;
let S4 = class extends zs.CanvasRenderer {
  setToRedraw() {
    this.setRetireFrames(), super.setToRedraw();
  }
  onAdd() {
    super.onAdd(), this.prepareCanvas();
  }
  updateSceneConfig() {
    this.xi && this.xi.update(), this.yi && this.yi.update(), this.bi && this.bi.update(), this.setToRedraw();
  }
  render(...t) {
    this.getMap() && this.layer.isVisible() && (this.forEachRenderer((e) => {
      e._replacedDrawFn || (e.draw = this.Si(e.draw), e.drawOnInteracting = this.Ci(e.drawOnInteracting), e.setToRedraw = this.Ti(e.setToRedraw), e._replacedDrawFn = !0);
    }), this.prepareRender(), this.prepareCanvas(), this.layer.ki(), this._toRedraw = !1, this.Ai("render", t), this.Oi(), this.Ii());
  }
  prepareCanvas() {
    super.prepareCanvas(), this.forEachRenderer((t) => {
      t.prepareCanvas();
    });
  }
  drawOnInteracting(...t) {
    this.getMap() && this.layer.isVisible() && (this.layer.ki(), this._toRedraw = !1, this.Ai("drawOnInteracting", t), this.Oi(), this.Ii());
  }
  Ai(t, e) {
    this.Ei = "default";
    const r = this.hasRenderTarget(), n = this.Li(e);
    if (r && (this.Fi.renderTarget = this.Ri()), this.yi.paint(n), this.drawGround(!0), !r) return void this.Pi("default", null, t, e, !0);
    const s = this.glCtx, o = this.layer.ut(), a = o && o.postProcess, l = this.isSSROn(), h = this.isEnableTAA(), u = n.jitter;
    n.jitter = Tg;
    const c = this.layer.getGroundConfig();
    if (n.hasSSRGround = !!(l && c && c.enable && c.symbol && c.symbol.ssr), s.resetDrawCalls(), this.Pi(h ? "fxaaBeforeTaa" : "fxaa", this.Di, t, e), this.Hi = s.getDrawCalls(), l && this.Ni.drawSSR(this.Gi(), this.Di), h) {
      const f = this.getMap(), d = this.Ni.isTaaNeedRedraw() || this.ji || f.getRenderer().isViewChanged();
      n.jitter = d ? u : this.Bi.getAverage(), n.onlyUpdateDepthInTaa = !d;
      let p = this.Ui;
      if (p) p.width === this.Di.width && p.height === this.Di.height || p.resize(this.Di.width, this.Di.height);
      else {
        const m = this.regl, v = this.createFBOInfo(a, this.zi);
        p = this.Ui = m.framebuffer(v);
      }
      s.resetDrawCalls(), this.Pi("taa", p, t, e), this.Vi = s.getDrawCalls(), delete n.onlyUpdateDepthInTaa, n.jitter = Tg;
      let g = this.Wi;
      if (g) g.width === this.Di.width && g.height === this.Di.height || g.resize(this.Di.width, this.Di.height);
      else {
        const m = this.regl, v = this.createFBOInfo(a, this.zi);
        g = this.Wi = m.framebuffer(v);
      }
      s.resetDrawCalls(), this.Pi("fxaaAfterTaa", this.Wi, t, e), this.qi = s.getDrawCalls();
    } else this.Ui && (this.Ui.destroy(), this.Wi.destroy(), delete this.Ui, delete this.Wi, delete this.qi);
    a.bloom && a.bloom.enable && (this.$i = this.Ni.drawBloom(this.zi)), l === 2 && this.Ni.drawSSR(this.Gi(), this.Di, !0), s.resetDrawCalls(), this.Pi("noAa", this.Yi, t, e), this.Xi = s.getDrawCalls(), s.resetDrawCalls(), this.Pi("point", this.Ji, t, e, !0), this.bi.renderScene(n), this.Zi = s.getDrawCalls();
  }
  Pi(t, e, r, n, s) {
    this.Ei = t;
    const o = this.Li(n);
    o.renderMode = this.Ei, o.renderTarget && (o.renderTarget.fbo = e), s && (o.isFinalRender = !0), this.forEachRenderer((a, l) => {
      l.isVisible() && (t === "default" || !a.supportRenderMode && (t === "fxaa" || t === "fxaaAfterTaa") || a.supportRenderMode && a.supportRenderMode(t)) && (this.clearStencil(a, e), a[r].apply(a, n));
    });
  }
  Li(t) {
    let e = t[0];
    return Ix(e) || (e = t[1]), e !== this.Ki && (this.forEachRenderer((r, n) => {
      n.isVisible() && r.needRetireFrames && r.needRetireFrames() && this.setRetireFrames();
    }), this.Fi = this.Qi(e), this.Ki = e, this.te = Ix(t[0]) ? null : t[0]), this.Fi;
  }
  Oi() {
    if (!this.isEnableOutline()) return;
    const t = this.ie(), e = this.glCtx;
    e.resetDrawCalls(), this.forEachRenderer((r, n) => {
      n.isVisible() && r.drawOutline && r.drawOutline(t);
    }), this.ee = e.getDrawCalls();
  }
  ie() {
    const { width: t, height: e } = this.canvas;
    let r = this.se;
    if (r) t === r.width && e === r.height || r.resize(t, e);
    else {
      const n = this.regl.texture({
        width: t,
        height: e,
        format: "rgba4"
      });
      r = this.se = this.regl.framebuffer({
        width: t,
        height: e,
        colors: [n],
        depth: !1,
        stencil: !1
      });
    }
    return r;
  }
  ii(t) {
    if (this.vi()) {
      const e = this.ne(t);
      return e.width !== t.width || e.height !== t.height ? e.resize(t.width, t.height) : this.regl.clear({
        color: [0, 0, 0, 0],
        fbo: e
      }), e.blit(t), e.color[0];
    }
    return t.color[0];
  }
  Gi() {
    if (this.zi.subimage) return this.zi;
    const { width: t, height: e } = this.zi;
    if (!this.re) {
      const r = this.regl, n = {
        depthStencil: r.texture({
          min: "nearest",
          mag: "nearest",
          mipmap: !1,
          type: "depth stencil",
          width: t,
          height: e,
          format: "depth stencil"
        }),
        colors: [r.renderbuffer({
          width: t,
          height: e,
          format: "rgba4"
        })],
        colorFormat: "rgba4",
        width: t,
        height: e
      };
      this.re = r.framebuffer(n);
    }
    return this.re.width === t && this.re.height === e || this.re.resize(t, e), this.regl.clear({
      color: [0, 0, 0, 0],
      depth: 1,
      fbo: this.re
    }), this.re.blit(this.Di, 256, "nearest"), this.re.depthStencil;
  }
  ne(t) {
    if (this.he || (this.he = []), !t.oe) {
      const e = this.ae(!0, t.width, t.height), r = this.regl.framebuffer(e);
      this.he.push(r), t.oe = r;
    }
    return t.oe;
  }
  vi() {
    return this.regl.limits.version.indexOf("WebGL 2.0") === 0 && this.layer.options.antialias;
  }
  hasRenderTarget() {
    const t = this.layer.ut(), e = t && t.postProcess;
    return !(!e || !e.enable);
  }
  testIfNeedRedraw() {
    if (this.layer.options.forceRedrawPerFrame) return !0;
    if (this._toRedraw) return this._toRedraw = !1, !0;
    if (this.getMap().isInteracting() && (this.xi && this.xi.isEnable() || this.yi && this.yi.isEnable()) || this.bi && this.bi.isEnable()) return !0;
    const t = this.layer.ce;
    if (t) {
      const r = t.getRenderer();
      if (r && r.testIfNeedRedraw()) return this.le = !0, !0;
    }
    const e = this.ue();
    for (const r of e) {
      const n = r.getRenderer();
      if (n && n.testIfNeedRedraw()) return this.le = !0, !0;
    }
    return !1;
  }
  isRenderComplete() {
    const t = this.ue();
    for (const e of t) {
      const r = e.getRenderer();
      if (r && !r.isRenderComplete()) return !1;
    }
    return !0;
  }
  mustRenderOnInteracting() {
    const t = this.ue();
    for (const e of t) {
      const r = e.getRenderer();
      if (r && r.mustRenderOnInteracting()) return !0;
    }
    return !1;
  }
  isCanvasUpdated() {
    if (super.isCanvasUpdated()) return !0;
    const t = this.ue();
    for (const e of t) {
      const r = e.getRenderer();
      if (r && r.isCanvasUpdated()) return !0;
    }
    return !1;
  }
  isBlank() {
    if (this.xi && this.xi.isEnable() || this.yi && this.yi.isEnable()) return !1;
    const t = this.layer.getTerrainLayer();
    if (t) {
      const r = t.getRenderer();
      if (r && !r.isBlank()) return !1;
    }
    const e = this.ue();
    for (const r of e) {
      const n = r.getRenderer();
      if (n && !n.isBlank()) return !1;
    }
    return !0;
  }
  createContext() {
    const t = this.layer, e = t.options.glOptions || {
      alpha: !0,
      depth: !0,
      stencil: !0
    };
    e.preserveDrawingBuffer = !0, e.antialias = !!t.options.antialias, this.glOptions = e;
    const r = this.gl = function(l, h, u) {
      const c = u ? ["webgl", "experimental-webgl"] : ["webgl2", "webgl", "experimental-webgl"];
      let f = null;
      for (let d = 0; d < c.length; ++d) {
        try {
          f = l.getContext(c[d], h);
        } catch {
        }
        if (f) break;
      }
      return f || console.error("Browser doesn't support WebGL."), f;
    }(this.canvas, e, t.options.onlyWebGL1);
    this.fe(r), r.wrap = () => new vs(this.gl), this.glCtx = r.wrap(), this.canvas.gl = this.gl, this.reglGL = r.wrap(), this.regl = zu({
      gl: this.reglGL,
      attributes: e,
      extensions: t.options.extensions,
      optionalExtensions: t.options.optionalExtensions
    }), this.gl.regl = this.regl, this.de = [0, 0], this.xi = new $d(this.regl, this.layer), this.yi = new KF(this.regl, this.layer);
    const n = this.layer.getWeatherConfig();
    this.bi = new m4(this.regl, t, n), this.pe = new w4(this.regl, t);
    const s = this.layer.ut() || {}, o = s && s.postProcess, a = o && o.antialias && o.antialias.jitterRatio || 0.2;
    this.Bi = new lD(a), this.Ni = new GM(this.regl, this.layer, this.Bi), this.o = new $h(this.regl, s, this.layer);
  }
  fe() {
    const t = this.layer, e = this.gl, r = t.options.extensions;
    r && r.forEach((s) => {
      e.getExtension(s);
    });
    const n = t.options.optionalExtensions;
    n && n.forEach((s) => {
      e.getExtension(s);
    }), this.gl.clearColor(0, 0, 0, 0);
  }
  clearCanvas() {
    super.clearCanvas(), this.ge();
  }
  ge() {
    const t = this.regl;
    this.Di && (t.clear({
      color: Mo,
      depth: 1,
      stencil: 255,
      framebuffer: this.Di
    }), t.clear({
      color: Mo,
      framebuffer: this.Yi
    }), t.clear({
      color: Mo,
      framebuffer: this.Ji
    }), this.Ui && this.Vi && t.clear({
      color: Mo,
      framebuffer: this.Ui
    }), this.Wi && this.qi && t.clear({
      color: Mo,
      framebuffer: this.Wi
    })), this.se && t.clear({
      color: Mo,
      framebuffer: this.se
    }), t.clear({
      color: Mo,
      depth: 1,
      stencil: 255
    });
  }
  resizeCanvas() {
    const t = this.canvas.width, e = this.canvas.height;
    !this.Di || this.Di.width === t && this.Di.height === e || (super.resizeCanvas(), this.Di.resize(t, e), this.Yi.resize(t, e), this.Ji.resize(t, e), this.Ui && this.Ui.resize(t, e), this.Wi && this.Wi.resize(t, e), this.ge(), this.forEachRenderer((r) => {
      r.canvas && r.resizeCanvas();
    }));
  }
  getCanvasImage() {
    return this.forEachRenderer((t) => {
      t.getCanvasImage();
    }), super.getCanvasImage();
  }
  ue() {
    return this.layer.ue();
  }
  forEachRenderer(t) {
    const e = this.ue();
    for (const n of e) {
      if (!n.isVisible() || !n.options.beneathTerrain) continue;
      const s = n.getRenderer();
      s && t(s, n);
    }
    const r = this.layer.ce;
    if (r) {
      const n = r.getRenderer();
      n && t(n, r);
    }
    for (const n of e) {
      if (!n.isVisible() || n.options.beneathTerrain) continue;
      const s = n.getRenderer();
      s && t(s, n);
    }
  }
  clearStencil(t, e) {
    const r = {
      stencil: t.getStencilValue ? t.getStencilValue() : 255
    };
    e && (r.framebuffer = e), this.regl.clear(r);
  }
  onRemove() {
    this.canvas.pickingFBO && this.canvas.pickingFBO.destroy && this.canvas.pickingFBO.destroy(), this.me(), this.xi && (this.xi.dispose(), delete this.xi), this.yi && (this.yi.dispose(), delete this.yi), this.o && (this.o.dispose(), delete this.o), this.Ni && (this.Ni.dispose(), delete this.Ni), this.se && (this.se.destroy(), delete this.se), this.bi && (this.bi.dispose(), delete this.bi), super.onRemove();
  }
  me() {
    if (this.Di && (this.Di.destroy(), this.Yi.destroy(), this.Ji.destroy(), this.Ui && (this.Ui.destroy(), delete this.Ui), this.Wi && (this.Wi.destroy(), delete this.Wi), delete this.Di, delete this.Yi, delete this.Ji, this.ve && (this.ve.destroy(), delete this.ve), this.re && (this.re.destroy(), delete this.re), this.he)) {
      for (let t = 0; t < this.he.length; t++) this.he[t] && this.he[t].destroy();
      delete this.he;
    }
  }
  setRetireFrames() {
    this.ji = !0;
  }
  getFrameTime() {
    return this.Ki;
  }
  getFrameEvent() {
    return this.te;
  }
  getFrameContext() {
    return this.Fi;
  }
  drawGround(t) {
    const e = this.layer.getGroundConfig();
    if (!e || !e.enable || !this.xi) return !1;
    const r = this.getFrameContext(), n = r.jitter;
    r.jitter = Tg;
    const s = this.layer.getPolygonOffsetCount();
    let o;
    r.offsetFactor = s + 1, r.offsetUnits = s + 1, t && (o = r.sceneFilter, delete r.sceneFilter);
    const a = this.xi.paint(r);
    return this.xi.needToRedraw() && this.setToRedraw(), o && (r.sceneFilter = o), r.jitter = n, a;
  }
  Si(t) {
    const e = this;
    return function(r, n) {
      return (n = n || e.Fi) && n.renderTarget && (n.renderTarget.getFramebuffer = Dx, n.renderTarget.getDepthTexture = Fx), t.call(this, r, n);
    };
  }
  Ci(t) {
    const e = this;
    return function(r, n, s) {
      return (s = s || e.Fi) && s.renderTarget && (s.renderTarget.getFramebuffer = Dx, s.renderTarget.getDepthTexture = Fx), t.call(this, r, n, s);
    };
  }
  Ti(t) {
    return function(...e) {
      return t.apply(this, e);
    };
  }
  isEnableSSR() {
    const t = this.layer.ut(), e = t && t.postProcess;
    return e && e.enable && e.ssr && e.ssr.enable;
  }
  isSSROn() {
    const t = this.isEnableSSR(), e = this.getMap();
    if (!t || e.getPitch() <= -1e-3) return 0;
    const r = e.projViewMatrix, n = this.Ni.getPrevSsrProjViewMatrix();
    return n && yf(n, r) ? 1 : 2;
  }
  isEnableTAA() {
    return !1;
  }
  isEnableSSAO() {
    const t = this.layer.ut(), e = t && t.postProcess;
    return e && e.enable && e.ssao && e.ssao.enable;
  }
  isEnableOutline() {
    const t = this.layer.ut(), e = t && t.postProcess;
    return e && e.enable && e.outline && e.outline.enable;
  }
  isEnableWeather() {
    const t = this.layer.ut(), e = t && t.weather;
    return e && e.enable;
  }
  we() {
    const t = this.layer.getMap();
    if (!this.O) {
      this.O = {
        center: t.getCenter(),
        bearing: t.getBearing(),
        pitch: t.getPitch(),
        res: t.getResolution()
      };
      let a = !1;
      if (t.options.lights) {
        const l = t.getLightManager().getDirectionalLight().direction || wg;
        this.O.lightDirection = Jn([], l), a = !0;
      }
      return {
        viewChanged: !0,
        lightDirectionChanged: a
      };
    }
    const e = t.getResolution() / this.O.res, r = t.coordToContainerPoint(this.O.center), n = this.layer.options.viewMoveThreshold, s = r._sub(t.width / 2, t.height / 2).mag() > n || e < 0.95 || e > 1.05;
    let o = !1;
    if (t.options.lights) {
      const a = t.getLightManager().getDirectionalLight().direction || wg;
      o = !dl(this.O.lightDirection, a), o && (this.O.lightDirection = Jn([], a));
    }
    return s && (this.O.center = t.getCenter(), this.O.bearing = t.getBearing(), this.O.pitch = t.getPitch(), this.O.res = t.getResolution()), {
      viewChanged: s,
      lightDirectionChanged: o
    };
  }
  Qi(t) {
    const e = this.layer.ut(), r = e && e.postProcess, n = e && e.weather, s = {
      timestamp: t,
      renderMode: this.Ei || "default",
      includes: {},
      states: this.we(),
      testSceneFilter: (u) => !s.sceneFilter || s.sceneFilter(u),
      isFinalRender: !1,
      weather: {
        fog: n && n.fog
      }
    }, o = r && r.antialias && r.antialias.jitterRatio || 0.2, a = this.Bi;
    a && a.setRatio(o);
    const l = this.isSSROn();
    let h;
    if (r && r.enable) {
      this.isEnableTAA() ? ((this.getMap().isInteracting() || this.ji) && a.reset(), a.getJitter(this.de), a.frame()) : we(this.de, 0, 0), s.jitter = this.de;
      const u = r.bloom && r.bloom.enable;
      u && l ? (s.bloom = 1, s.sceneFilter = T4) : u ? (s.bloom = 1, s.sceneFilter = A4) : l && (s.sceneFilter = M4), h = this.Ri(), h && (s.renderTarget = h);
    } else this.me();
    return this.Ei !== "noAa" && (this._e = this.Me(s), this._e && (s.includes.shadow = 1), this.xe = this.ye(s)), this._e && (s.shadow = this._e, s.includes.shadow = 1), s.states.includesChanged = this.xe, r && r.enable && this.Ni && this.Ni.setContextIncludes(s), s;
  }
  be(t) {
    const e = this.ue().filter((r) => r.isVisible());
    return this.layer.ce && e.push(this.layer.ce), this.pe.paint(t, e);
  }
  ye(t) {
    let e = !1;
    const r = Object.keys(t.includes), n = this.Se;
    if (n) {
      const s = r.filter((o) => n.indexOf(o) === -1).concat(n.filter((o) => r.indexOf(o) === -1));
      s.length && (e = s.reduce((o, a) => (o[a] = 1, o), {}));
    }
    return this.Se = r, e;
  }
  Me(t) {
    const e = this.layer.ut();
    if (!e || !e.shadow || !e.shadow.enable) return this.o && (this.o.dispose(), delete this.o), null;
    this.o || (this.o = new $h(this.regl, this.layer.ut() || {}, this.layer));
    const r = {
      config: e.shadow,
      defines: this.o.getDefines(),
      uniformDeclares: $h.getUniformDeclares()
    };
    return r.renderUniforms = this.Ce(t), r;
  }
  Ce(t) {
    const e = t.renderTarget && t.renderTarget.fbo, r = this.layer.ut(), n = [];
    let s = t.states.lightDirectionChanged || t.states.viewChanged;
    this.forEachRenderer((c, f) => {
      if (!c.getShadowMeshes || !f.isVisible()) return;
      const d = c.getShadowMeshes();
      if (Array.isArray(d)) for (let p = 0; p < d.length; p++) d[p].needUpdateShadow && (s = !0), d[p].needUpdateShadow = !1, n.push(d[p]);
    }), this.Te || (this.Te = new ur()), this.Te.setMeshes(n);
    const o = this.getMap(), a = r.shadow, l = o.getLightManager(), h = l && l.getDirectionalLight().direction || wg, u = !r.ground || !r.ground.enable;
    return this.o.render(u, o.projMatrix, o.viewMatrix, a.color, a.opacity, h, this.Te, this.de, e, s);
  }
  ke(t) {
    let e = [];
    if (this.forEachRenderer((n, s) => {
      if (!n.getAnalysisMeshes || !s.isVisible()) return;
      const o = n.getAnalysisMeshes();
      e = e.concat(o);
    }), this.xi) {
      const n = this.xi.getRenderMeshes();
      e = e.concat(n);
    }
    const r = this.layer.getWeatherConfig();
    return this.bi.paint(t, e, r);
  }
  getGroundMesh() {
    return this.xi ? this.xi.getRenderMeshes() : [];
  }
  Ri() {
    const t = this.layer.ut(), e = t && t.postProcess;
    if (!this.Di) {
      const r = this.regl;
      let n = this.zi;
      (!n || !n._texture || n._texture.refCount <= 0) && (n = null);
      const s = this.createFBOInfo(e, n);
      this.zi = s.depth || s.depthStencil, this.Di = r.framebuffer(s);
      const o = this.createFBOInfo(e, this.zi);
      this.Yi = r.framebuffer(o);
      const a = this.createFBOInfo(e, this.zi);
      this.Ji = r.framebuffer(a), this.ge();
    }
    return {
      fbo: this.Di
    };
  }
  ae(t, e, r) {
    e = e || this.canvas.width, r = r || this.canvas.height;
    const n = this.regl, s = this.vi();
    let o;
    return !t && s ? o = n.renderbuffer({
      width: e,
      height: r,
      samples: this.layer.options.multiSamples,
      format: "rgba8"
    }) : o = n.texture({
      min: "nearest",
      mag: "nearest",
      type: "uint8",
      width: e,
      height: r
    }), {
      width: e,
      height: r,
      colors: [o],
      colorFormat: s ? "rgba8" : "rgba"
    };
  }
  createFBOInfo(t, e) {
    const { width: r, height: n } = this.canvas, s = this.regl, o = this.ae(), a = this.vi(), l = s.hasExtension("WEBGL_depth_texture");
    if (a) {
      const h = e || s.renderbuffer({
        width: r,
        height: n,
        format: "depth24 stencil8",
        samples: this.layer.options.multiSamples
      });
      o.depthStencil = h;
    } else if (l) {
      const h = e || s.texture({
        min: "nearest",
        mag: "nearest",
        mipmap: !1,
        type: "depth stencil",
        width: r,
        height: n,
        format: "depth stencil"
      });
      o.depthStencil = h;
    } else {
      const h = e || s.renderbuffer({
        width: r,
        height: n,
        format: "depth stencil"
      });
      o.depthStencil = h;
    }
    return o;
  }
  Ii() {
    if (!this.Di) return void (this.ji = !1);
    const t = this.layer.ut(), e = t && t.postProcess;
    if (!e || !e.enable) {
      if (this.isEnableWeather()) throw new Error("you must enable the post process to turn on weather");
      return;
    }
    this.layer.fire("postprocessstart");
    const r = this.layer.getMap();
    let n;
    if (this.isEnableTAA()) {
      const T = this.ji || r.getRenderer().isViewChanged();
      T && this.layer.fire("taastart");
      const { outputTex: A, redraw: M } = this.Ni.taa(this.ii(this.Ui), this.Gi(), {
        projMatrix: r.projMatrix,
        needClear: T
      });
      n = A, M ? this.setToRedraw() : this.layer.fire("taaend"), this.ji = !1;
    }
    let s = e.sharpen && e.sharpen.factor;
    s || s === 0 || (s = 0.2);
    let o = 0, a = 0.2, l = 0.3, h = 1, u = [1, 1, 0];
    e.outline && (o = +!!e.outline.enable, a = xa(e.outline, "highlightFactor", a), l = xa(e.outline, "outlineFactor", l), h = xa(e.outline, "outlineWidth", h), u = xa(e.outline, "outlineColor", u));
    const c = this.isEnableSSAO(), f = e.ssr && e.ssr.enable, d = e.bloom && e.bloom.enable, p = d && this.$i, g = +!(!e.antialias || !e.antialias.enable), m = this.pe._i(), v = this.bi.si(), _ = c || d || f || m || v;
    let y = this.ve;
    if (_) {
      if (!y) {
        const M = this.ae();
        this.vi() && (M.depthStencil = this.regl.renderbuffer({
          width: this.canvas.width,
          height: this.canvas.height,
          samples: this.layer.options.multiSamples,
          format: "depth24 stencil8"
        })), y = this.ve = this.regl.framebuffer(M);
      }
      const { width: T, height: A } = this.canvas;
      y.width === T && y.height === A || y.resize(T, A);
    } else y = null, this.ve && (this.ve.destroy(), delete this.ve);
    let x = this.ii(this.Di);
    const w = this.Xi && this.ii(this.Yi), b = this.Zi && this.ii(this.Ji);
    if (this.Ni.fxaa(y, x, !p && w, !p && b, n, this.qi && this.Wi && this.ii(this.Wi), g, +!(!e.toneMapping || !e.toneMapping.enable), +!(_ || !e.sharpen || !e.sharpen.enable), r.getDevicePixelRatio(), s, o && this.ee > 0 && this.ie(), a, l, h, u), y && (x = this.ii(y)), c && (this.qi || this.Vi || this.Hi) && (x = this.Ni.ssao(x, this.Gi(), {
      projMatrix: r.projMatrix,
      cameraNear: r.cameraNear,
      cameraFar: r.cameraFar,
      ssaoBias: e.ssao && e.ssao.bias || 10,
      ssaoRadius: e.ssao && e.ssao.radius || 100,
      ssaoIntensity: e.ssao && e.ssao.intensity || 0.5
    })), d && this.$i) {
      const T = e.bloom, A = +T.threshold || 0, M = xa(T, "factor", 1), S = xa(T, "radius", 1);
      x = this.Ni.bloom(x, w, b, A, M, S, g);
    }
    if (f && (this.Ni.genSsrMipmap(x, this.Gi()), this.le)) {
      const T = this.ji;
      this.setToRedraw(), this.ji = T, this.le = !1;
    }
    this.pe && (x = this.be(x)), this.isEnableWeather() && (x = this.ke(x)), _ && this.Ni.renderFBOToScreen(x, +!(!e.sharpen || !e.sharpen.enable), s, r.getDevicePixelRatio()), this.layer.fire("postprocessend");
  }
};
function Ix(i) {
  return typeof i == "number" && !isNaN(i);
}
function Dx(i) {
  return i._framebuffer.framebuffer;
}
function Fx(i) {
  return i.depthStencil._texture.texture;
}
function xa(i, t, e) {
  return i[t] == null ? e : i[t];
}
let C4 = class extends VA.Actor {
  constructor(t) {
    super("@maptalks/terrain"), this.mapId = t;
  }
  checkUrl(t) {
    return t && Yr.isString(t) ? Yr.getAbsoluteURL(t) : t;
  }
  fetchTerrain(t, e, r) {
    t = this.checkUrl(t);
    const n = {
      actorId: this.actorId,
      mapId: this.mapId,
      command: "fetchTerrain",
      params: {
        url: t,
        origin: location.origin,
        terrainWidth: e.terrainWidth,
        type: e.type,
        accessToken: e.accessToken,
        cesiumIonTokenURL: e.cesiumIonTokenURL,
        error: e.error
      }
    };
    this.send(n, null, (s, o) => {
      s ? r(s) : r(s, o);
    });
  }
  abortTerrain(t, e) {
    const r = {
      actorId: this.actorId,
      mapId: this.mapId,
      command: "abortTerrain",
      params: {
        url: t
      }
    };
    this.broadcast(r, null, e);
  }
  addLayer(t, e, r) {
    const n = {
      actorId: this.actorId,
      mapId: this.mapId,
      layerId: t,
      command: "addLayer",
      params: {}
    };
    this.broadcast(n, null, r);
  }
  createTerrainMesh(t, e) {
    const r = {
      actorId: this.actorId,
      command: "createTerrainMesh",
      params: t
    };
    this.send(r, [t.terrainHeights.data.buffer], (n, s) => {
      n ? e(n) : e(n, s);
    });
  }
  removeLayer(t, e, r) {
    const n = {
      mapId: this.mapId,
      layerId: t,
      command: "removeLayer"
    };
    this.broadcast(n, null, r);
  }
}, P4 = class {
  constructor(t = 257) {
    this.gridSize = t;
    const e = t - 1;
    if (e & e - 1) throw new Error(`Expected grid size to be 2^n+1, got ${t}.`);
    this.numTriangles = e * e * 2 - 2, this.numParentTriangles = this.numTriangles - e * e, this.indices = new Uint32Array(this.gridSize * this.gridSize), this.coords = new Uint16Array(4 * this.numTriangles);
    for (let r = 0; r < this.numTriangles; r++) {
      let n = r + 2, s = 0, o = 0, a = 0, l = 0, h = 0, u = 0;
      for (1 & n ? a = l = h = e : s = o = u = e; (n >>= 1) > 1; ) {
        const f = s + a >> 1, d = o + l >> 1;
        1 & n ? (a = s, l = o, s = h, o = u) : (s = a, o = l, a = h, l = u), h = f, u = d;
      }
      const c = 4 * r;
      this.coords[c + 0] = s, this.coords[c + 1] = o, this.coords[c + 2] = a, this.coords[c + 3] = l;
    }
  }
  createTile(t) {
    return new E4(t, this);
  }
}, E4 = class {
  constructor(t, e) {
    const r = e.gridSize;
    if (t.length !== r * r) throw new Error(`Expected terrain data of length ${r * r} (${r} x ${r}), got ${t.length}.`);
    this.terrain = t, this.martini = e, this.errors = new Float32Array(t.length), this.update();
  }
  update() {
    const { numTriangles: t, numParentTriangles: e, coords: r, gridSize: n } = this.martini, { terrain: s, errors: o } = this;
    for (let a = t - 1; a >= 0; a--) {
      const l = 4 * a, h = r[l + 0], u = r[l + 1], c = r[l + 2], f = r[l + 3], d = h + c >> 1, p = u + f >> 1, g = d + p - u, m = p + h - d, v = (s[u * n + h] + s[f * n + c]) / 2, _ = p * n + d, y = Math.abs(v - s[_]);
      if (o[_] = Math.max(o[_], y), a < e) {
        const x = (u + m >> 1) * n + (h + g >> 1), w = (f + m >> 1) * n + (c + g >> 1);
        o[_] = Math.max(o[_], o[x], o[w]);
      }
    }
  }
  getMesh(t = 0) {
    const { gridSize: e, indices: r } = this.martini, { errors: n } = this;
    let s = 0, o = 0;
    const a = e - 1;
    function l(d, p, g, m, v, _) {
      const y = d + g >> 1, x = p + m >> 1;
      Math.abs(d - v) + Math.abs(p - _) > 1 && n[x * e + y] > t ? (l(v, _, d, p, y, x), l(g, m, v, _, y, x)) : (r[p * e + d] = r[p * e + d] || ++s, r[m * e + g] = r[m * e + g] || ++s, r[_ * e + v] = r[_ * e + v] || ++s, o++);
    }
    r.fill(0), l(0, 0, a, a, a, 0), l(a, a, 0, 0, 0, a);
    const h = new Uint16Array(2 * s), u = new Uint32Array(3 * o);
    let c = 0;
    function f(d, p, g, m, v, _) {
      const y = d + g >> 1, x = p + m >> 1;
      if (Math.abs(d - v) + Math.abs(p - _) > 1 && n[x * e + y] > t) f(v, _, d, p, y, x), f(g, m, v, _, y, x);
      else {
        const w = r[p * e + d] - 1, b = r[m * e + g] - 1, T = r[_ * e + v] - 1;
        h[2 * w] = d, h[2 * w + 1] = p, h[2 * b] = g, h[2 * b + 1] = m, h[2 * T] = v, h[2 * T + 1] = _, u[c++] = w, u[c++] = b, u[c++] = T;
      }
    }
    return f(0, 0, a, a, a, 0), f(a, a, 0, 0, 0, a), {
      vertices: h,
      triangles: u
    };
  }
  getMeshWithSkirts(t = 0, e) {
    const { gridSize: r, indices: n } = this.martini, { errors: s } = this;
    let o = 0, a = 0;
    const l = r - 1;
    let h, u, c = 0;
    const f = [], d = [], p = [], g = [];
    function m(D, z, H, G, $, K) {
      const dt = D + H >> 1, it = z + G >> 1;
      Math.abs(D - $) + Math.abs(z - K) > 1 && s[it * r + dt] > t ? (m($, K, D, z, dt, it), m(H, G, $, K, dt, it)) : (h = z * r + D, u = G * r + H, c = K * r + $, n[h] === 0 && (D === 0 ? f.push(o) : D === l && d.push(o), z === 0 ? p.push(o) : z === l && g.push(o), n[h] = ++o), n[u] === 0 && (H === 0 ? f.push(o) : H === l && d.push(o), G === 0 ? p.push(o) : G === l && g.push(o), n[u] = ++o), n[c] === 0 && ($ === 0 ? f.push(o) : $ === l && d.push(o), K === 0 ? p.push(o) : K === l && g.push(o), n[c] = ++o), a++);
    }
    let v;
    n.fill(0), m(0, 0, l, l, l, 0), m(l, l, 0, 0, 0, l), v = e ? 2 * (o + 3 * f.length - 2 + 3 * d.length - 2 + 3 * p.length - 2 + 3 * g.length - 2) : 2 * (o + f.length + d.length + p.length + g.length);
    const _ = 3 * (a + 2 * (f.length - 1) + 2 * (d.length - 1) + 2 * (p.length - 1) + 2 * (g.length - 1)), y = new Uint16Array(v), x = new Uint32Array(_);
    let w = 0;
    function b(D, z, H, G, $, K) {
      const dt = D + H >> 1, it = z + G >> 1;
      if (Math.abs(D - $) + Math.abs(z - K) > 1 && s[it * r + dt] > t) b($, K, D, z, dt, it), b(H, G, $, K, dt, it);
      else {
        const st = n[z * r + D] - 1, pt = n[G * r + H] - 1, Ht = n[K * r + $] - 1;
        y[2 * st] = D, y[2 * st + 1] = z, y[2 * pt] = H, y[2 * pt + 1] = G, y[2 * Ht] = $, y[2 * Ht + 1] = K, x[w++] = st, x[w++] = pt, x[w++] = Ht;
      }
    }
    b(0, 0, l, l, l, 0), b(l, l, 0, 0, 0, l), f.sort((D, z) => y[2 * D + 1] - y[2 * z + 1]), d.sort((D, z) => y[2 * z + 1] - y[2 * D + 1]), p.sort((D, z) => y[2 * z] - y[2 * D]), g.sort((D, z) => y[2 * D] - y[2 * z]);
    let T, A, M, S, P = 2 * o, C = 0;
    function k(D) {
      C = D.length;
      for (let z = 0; z < C - 1; z++) T = D[z], A = D[z + 1], M = P / 2, S = (P + (e ? 6 : 2)) / 2, y[P++] = 2 * T, y[P++] = 2 * T + 1, e && (y[P++] = 2 * T, y[P++] = 2 * T + 1, y[P++] = 2 * A, y[P++] = 2 * A + 1), e ? (x[w++] = M + 1, x[w++] = M, x[w++] = M + 2, x[w++] = M, x[w++] = S, x[w++] = M + 2) : (x[w++] = T, x[w++] = M, x[w++] = A, x[w++] = M, x[w++] = S, x[w++] = A);
      y[P++] = 2 * D[C - 1], y[P++] = 2 * D[C - 1] + 1;
    }
    k(f);
    const O = P;
    k(d);
    const R = P;
    k(p);
    const I = P;
    return k(g), {
      vertices: y,
      triangles: x,
      numVerticesWithoutSkirts: o,
      numTrianglesWithoutSkirts: a,
      leftSkirtIndex: O,
      rightSkirtIndex: R,
      bottomSkirtIndex: I,
      topSkirtIndex: P
    };
  }
};
const Lx = {};
function VM(i, t, e, r) {
  let n = Lx[e];
  n || (n = Lx[e] = new P4(e));
  const s = n.createTile(t), o = s.getMeshWithSkirts(i, !0), { triangles: a, vertices: l, leftSkirtIndex: h, rightSkirtIndex: u, bottomSkirtIndex: c, topSkirtIndex: f } = o;
  let { numVerticesWithoutSkirts: d, numTrianglesWithoutSkirts: p } = o;
  d || (d = l.legnth / 3, p = a.length / 3);
  const g = l.length / 2, m = new Float32Array(3 * g), v = new Float32Array(2 * g);
  let _ = 1 / 0, y = -1 / 0;
  const x = e - 1;
  for (let w = 0; w < g; w++) {
    const b = l[2 * w], T = l[2 * w + 1];
    if (w >= d) {
      const M = b / 2 * 3;
      let S, P = 1e-3;
      (w - (w < h / 2 ? d : w < u / 2 ? h / 2 : w < c / 2 ? u / 2 : c / 2)) % 3 == 0 ? (S = 0, P = 0) : S = m[M + 2], m[3 * w] = m[M], m[3 * w + 1] = m[M + 1], m[3 * w + 2] = S, v[2 * w] = m[M] / x + P, v[2 * w + 1] = -m[M + 1] / x + P;
    } else m[3 * w] = 1 * b, m[3 * w + 1] = 1 * -T, m[3 * w + 2] = t[T * e + b], v[2 * w] = b / x, v[2 * w + 1] = T / x;
    const A = m[m.length - 1];
    A < _ && (_ = A), A > y && (y = A);
  }
  return {
    positions: m,
    texcoords: v,
    triangles: a,
    leftSkirtIndex: h,
    rightSkirtIndex: u,
    bottomSkirtIndex: c,
    topSkirtIndex: f,
    numTrianglesWithoutSkirts: p,
    numVerticesWithoutSkirts: d,
    minHeight: _,
    maxHeight: y,
    terrainWidth: e
  };
}
function UM(i, t, e, r, n, s, o, a, l) {
  const h = {};
  for (let u = 0; u < l; u++) h[u + ""] = $M(i, t, e, r, n, s, o, a, u);
  return h;
}
const O4 = [];
function $M(i, t, e, r, n, s, o, a, l) {
  if ((r -= l) <= 0) return O4;
  const h = i.getTileSize().width, u = i._getTileOffset(r, n), c = s[0] - u[0], f = u[1] - s[1], d = i._getTileConfig(), p = i.getSpatialReference().getResolution(r), g = d.tileSystem.scale.y;
  let m = 0, v = 0, _ = a /= Math.pow(2, l), y = a;
  if (c < 0 ? _ += Math.ceil(-c / h - 1e-7) : c > 0 && (m -= Math.ceil(c / h - 1e-7)), f > 0 ? v -= Math.ceil(f / h - 1e-7) : f < 0 && (y += Math.ceil(-f / h - 1e-7)), m === 0 && v === 0 && _ <= 1 && y <= 1) {
    const w = Math.floor(t * a);
    let b = Math.floor(e * a);
    const T = b;
    return g !== o && (b = zx(d, b, p)), [{
      x: w,
      y: b,
      skinY: T,
      z: r,
      offset: u,
      tileSize: h,
      id: i._getTileId(w, b, r)
    }];
  }
  const x = [];
  for (let w = m; w < _; w++) for (let b = v; b < y; b++) {
    const T = t * a + w;
    let A = e * a + b;
    const M = A;
    g !== o && (A = zx(d, A, p)), x.push({
      x: T,
      y: A,
      skinY: M,
      z: r,
      offset: u,
      tileSize: h,
      id: i._getTileId(T, A, r)
    });
  }
  return x;
}
function y0(i, t, e, r) {
  let n = i / e * r / t;
  return n < 1 ? (n = 1 / n, n = 1 / Math.round(n)) : n = Math.round(n), n;
}
function _0(i, t, e) {
  const r = i.getResolution(t), n = t - Math.log(e / r) * Math.LOG2E;
  return {
    zoom: n,
    res: i.getResolution(n)
  };
}
function zx(i, t, e) {
  const r = i.fullExtent, n = i.tileSize.width, s = Math.max(r.top, r.bottom), o = Math.min(r.top, r.bottom);
  return Math.ceil(s / n / e) - 1 - Math.floor(o / n / e) - t;
}
function x0(i, t) {
  const e = t * t, r = i !== 0 ? new Float32Array(e) : new Uint8Array(e);
  return r.fill(i), {
    data: r,
    width: t,
    height: t,
    max: i,
    min: i
  };
}
new Y(0, 0);
const Nx = x0(0, 5), ud = VM(1, Nx.data, Nx.width);
ud.empty = !0;
const Hx = [], Bx = [];
let b0 = class {
  constructor(t) {
    this.layer = t, this.regl = t.getRenderer().regl, this.renderer = new hn(this.regl), this.Ae = new ur();
    const e = new Uint8Array(16);
    e.fill(255), this.Oe = this.regl.texture({
      width: 2,
      height: 2,
      data: e
    }), this.Ie = new Hd(this.Oe), this.Ee();
  }
  setToRedraw() {
    this.layer.getRenderer().setToRedraw();
  }
  getMap() {
    return this.layer.getMap();
  }
  startFrame() {
    this.shader || this.initShader(), this.Ae.clear();
  }
  createTerrainMesh(t, e) {
    const { mesh: r, image: n } = e;
    let s = e.terrainMesh;
    const { positions: o, texcoords: a, triangles: l, empty: h } = r;
    if (s && s.geometry !== this.Le) s.geometry.updateData("aPosition", o), s.geometry.updateData("aTexCoord", a), s.geometry.setElements(l);
    else {
      const u = h ? this.Le : new er({
        aPosition: o,
        aTexCoord: a
      }, l, 0);
      s ? s.geometry = u : (s = new tn(u, null, {
        disableVAO: !0
      }), u.generateBuffers(this.regl));
    }
    if (!s.uniforms.skin) {
      const u = this.getEmptyTexture();
      s.setUniform("skin", u);
    }
    return s.setUniform("heightTexture", n), this.prepareMesh(s, t, e), s;
  }
  Fe(t) {
    const e = this.layer.getRenderer();
    e && e.updateMaskDefines(t);
  }
  Re(t) {
    const e = this.Pe(100) / 100, r = pn(t);
    return os(r, r, [1, 1, e]), r;
  }
  De(t, e, r) {
    const n = this.getMap(), s = this.layer.getTileSize().width, o = e.res / n.getGLRes(), a = s / (r - 1), { extent2d: l, offset: h } = e;
    ne(Hx, (l.xmin - h[0]) * o, (e.extent2d.ymax - h[1]) * o, 0);
    const u = pn(t);
    return ss(u, u, Hx), ne(Bx, o * a, o * a, 1), os(u, u, Bx), u;
  }
  prepareMesh(t, e, r) {
    if (!t.isValid()) return;
    const { mesh: n } = r;
    this.Fe(t);
    const { triangles: s, numTrianglesWithoutSkirts: o, terrainWidth: a } = n;
    t.localTransform = this.De(t.localTransform || [], e, a), t.positionMatrix = this.Re(t.positionMatrix || []), t.properties.skirtOffset = 3 * o, t.properties.skirtCount = s.length - 3 * o, t.properties.z = e.z, t.properties.minHeight = n.minHeight, t.properties.maxHeight = n.maxHeight, t.properties.terrainWidth = a, t.castShadow = !1, HM(t.uniforms, "minAltitude") || Object.defineProperty(t.uniforms, "minAltitude", {
      enumerable: !0,
      get: () => r.minAltitude || 0
    });
  }
  addTerrainImage(t, e) {
    const r = e.terrainMesh;
    r && r.geometry && e.skin && (r.setUniform("skin", e.skin.color[0]), r.setUniform("polygonOpacity", 1), this.Ae.addMesh(r));
  }
  endFrame(t) {
    this.updateIBLDefines(this.shader);
    let e = 0;
    const r = this.getUniformValues(), n = this.He(t);
    return this.shader.filter = t && t.sceneFilter, e += this.renderer.render(this.shader, r, this.Ae, n), e;
  }
  delete() {
    this.shader && (this.shader.dispose(), delete this.shader), this.Oe && (this.Oe.destroy(), delete this.Oe), this.Le && (this.Le.dispose(), delete this.Le);
  }
  deleteMesh(t) {
    if (!t) return;
    const e = t.geometry;
    t.dispose(), e !== this.Le && e.dispose();
  }
  initShader() {
    const t = [], e = [];
    this.shader = new qe({
      vert: `#define SHADER_NAME TERRAIN_MESH
attribute vec3 aPosition;
attribute vec2 aTexCoord;
uniform float minAltitude;
uniform mat4 projViewModelMatrix;
uniform mat4 projMatrix;
uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 positionMatrix;
uniform float heightScale;
varying vec2 vUv;
#include <mask_vert>
void main() {
    vec3 position = vec3(aPosition.xy, (aPosition.z + minAltitude) * heightScale);
    #ifdef HAS_MASK_EXTENT
        gl_Position = projMatrix * getMaskPosition(positionMatrix * vec4(position, 1.0), modelMatrix);
    #else
        gl_Position = projViewModelMatrix * positionMatrix * vec4(position, 1.0);
    #endif
    vUv = aTexCoord;
}`,
      frag: `#define SHADER_NAME TERRAIN_MESH
precision mediump float;
uniform sampler2D skin;
uniform float polygonOpacity;
varying vec2 vUv;
#include <mask_frag>
void main() {
    vec2 uv = vec2(vUv);
    uv.y = 1.0 - uv.y;
    vec4 color = texture2D(skin, uv);
    gl_FragColor = color * polygonOpacity;
    #ifdef HAS_MASK_EXTENT
      gl_FragColor = setMask(gl_FragColor);
    #endif
}`,
      uniforms: [{
        name: "modelViewMatrix",
        type: "function",
        fn: function(r, n) {
          return Jt(e, n.viewMatrix, n.modelMatrix);
        }
      }, {
        name: "projViewModelMatrix",
        type: "function",
        fn: function(r, n) {
          return Jt(t, n.projViewMatrix, n.modelMatrix);
        }
      }],
      extraCommandProps: this.getExtraCommandProps()
    });
  }
  getExtraCommandProps() {
    const t = this.layer.getRenderer().canvas;
    return {
      viewport: {
        x: 0,
        y: 0,
        width: () => t ? t.width : 1,
        height: () => t ? t.height : 1
      },
      stencil: {
        enable: !1
      },
      cull: {
        enable: !0,
        face: "back"
      },
      depth: {
        enable: !0,
        mask: () => !!this.layer.options.depthMask,
        func: this.layer.options.depthFunc || "<="
      },
      blend: {
        enable: !0,
        func: {
          src: this.layer.options.blendSrc,
          dst: this.layer.options.blendDst
        },
        equation: "add"
      }
    };
  }
  He(t) {
    return t && t.renderTarget && t.renderTarget.fbo;
  }
  getUniformValues() {
    const t = this.getMap(), e = t.projViewMatrix, r = this.layer.getRenderer().getMaskUniforms(), n = {
      viewMatrix: t.viewMatrix,
      projMatrix: t.projMatrix,
      projViewMatrix: e,
      heightScale: 1
    };
    return lr(n, r), n;
  }
  Pe(t) {
    const e = this.layer.getMap();
    return e ? e.altitudeToPoint(t, e.getGLRes()) : null;
  }
  getEmptyTexture() {
    return this.Oe;
  }
  hasIBL() {
    const t = this.getMap().getLightManager();
    return !!(t && t.getAmbientResource());
  }
  updateIBLDefines(t) {
    const e = t.shaderDefines;
    let r = !1;
    this.hasIBL() ? e[["HAS_IBL_LIGHTING"]] || (e.HAS_IBL_LIGHTING = 1, r = !0) : e[["HAS_IBL_LIGHTING"]] && (delete e.HAS_IBL_LIGHTING, r = !0), r && (t.shaderDefines = e);
  }
  Ee() {
    const t = ud, { positions: e, texcoords: r, triangles: n } = t;
    this.Le = new er({
      aPosition: e,
      aTexCoord: r
    }, n, 0), this.Le.generateBuffers(this.regl);
  }
};
const { getIBLResOnCanvas: k4, getPBRUniforms: R4, loginIBLResOnCanvas: I4, logoutIBLResOnCanvas: D4 } = Kn.PBRUtils, jx = {
  baseColorFactor: [1, 1, 1, 1],
  emissiveFactor: [0, 0, 0],
  baseColorIntensity: 1,
  emitColorFactor: 1,
  roughnessFactor: 1,
  metallicFactor: 0,
  emitMultiplicative: 1,
  outputSRGB: 1,
  hsv: [0, 0, 0],
  contrast: 1,
  alphaTest: 0
};
let Gx = class extends b0 {
  constructor(...t) {
    super(...t), this.createIBLTextures(), this.Ne = 0;
  }
  updateMaterial(t, e) {
    this.Ne = e, this.Ge = this.Ge || {}, lr(this.Ge, t), this.setToRedraw();
  }
  setMaterial(t, e) {
    this.Ne = e, this.Ge = lr({}, jx, t), this.setToRedraw();
  }
  createIBLTextures() {
    const t = this.getMap().getRenderer().canvas;
    I4(t, this.regl, this.getMap()), this.layer.fire("iblupdated");
  }
  disposeIBLTextures() {
    const t = this.getMap().getRenderer().canvas;
    D4(t, this.getMap());
  }
  createTerrainMesh(t, e) {
    const { mesh: r, image: n } = e, { positions: s, texcoords: o, triangles: a, leftSkirtIndex: l, rightSkirtIndex: h, bottomSkirtIndex: u, numVerticesWithoutSkirts: c } = r, f = new Int8Array(s.length);
    for (let x = 2; x < f.length; x += 3) x < 3 * c ? f[x] = 1 : x < l / 2 * 3 ? f[x - 2] = -1 : x < h / 2 * 3 ? f[x - 2] = 1 : f[x - 1] = x < u / 2 * 3 ? -1 : 1;
    const d = new er({
      aPosition: s,
      aTexCoord: o,
      aNormal: f
    }, a, 0);
    let p;
    d.createTangent(), delete d.data.aNormal, d.generateBuffers(this.regl), p = n ? this.regl.texture({
      width: n.width,
      height: n.height,
      data: n,
      min: "linear",
      mag: "linear"
    }) : this.getEmptyTexture();
    const g = this.getEmptyTexture(), m = lr({}, jx, this.layer.options.material || {});
    m.skinTexture = g, m.terrainHeightTexture = p;
    const v = new Kn.StandardMaterial(m), _ = new tn(d, v);
    _.properties.matVer = this.Ne;
    const y = _.defines;
    return y.HAS_UV_FLIP = 1, y.HAS_TERRAIN_NORMAL = 1, y.HAS_MAP = 1, _.defines = y, _.setUniform("terrainTileResolution", t.res), this.prepareMesh(_, t, e), _;
  }
  addTerrainImage(t, e) {
    const r = e.terrainMesh;
    if (r) {
      if (this.Ge && r.properties.matVer !== this.Ne) {
        for (const n in this.Ge) r.material.set(n, this.Ge[n]);
        r.properties.matVer = this.Ne;
      }
      e.skin && r.material.set("skinTexture", e.skin), r.setUniform("polygonOpacity", 1), this.Ae.addMesh(r);
    }
  }
  getUniformValues() {
    const t = this.getMap(), e = t.getRenderer().canvas, { iblTexes: r, dfgLUT: n } = k4(e), s = R4(t, r, n), o = this.layer.getTileSize().width, a = this.layer.getRenderer().getMaskUniforms(), l = this.Pe(100) / 100;
    return lr(s, {
      viewMatrix: t.viewMatrix,
      projMatrix: t.projMatrix,
      projViewMatrix: t.projViewMatrix,
      outSize: [e.width, e.height],
      polygonFill: [1, 1, 1, 1],
      terrainHeightMapResolution: [o, o],
      terrainResolution: [e.width, e.height],
      terrainHeightScale: l,
      terrainUnpackFactors: [6553.6, 25.6, 0.1, 1e4]
    }), lr(s, a), s;
  }
  initShader() {
    this.shader = new Kn.StandardShader({
      extraCommandProps: this.getExtraCommandProps()
    });
  }
  delete() {
    return this.disposeIBLTextures(), super.delete();
  }
};
function Ag(i, t, e, r) {
  const n = WM.call(this, e, r);
  this._projViewMatrix = t;
  const { colorExtent: s, modeExtent: o } = this._extentPass.render(n, t);
  this._maskUniforms = this._maskUniforms || {}, this._maskUniforms.mask_colorExtent = s, this._maskUniforms.mask_extent = i, this._maskUniforms.mask_modeExtent = o, this._maskUniforms.mask_hasFlatOut = Mg.call(this, "flat-outside"), this._maskUniforms.mask_hasClipOut = Mg.call(this, "clip-outside"), this._maskUniforms.mask_hasVideo = Mg.call(this, "video"), this._maskUniforms.mask_heightRatio = e, this._maskUniforms.mask_heightOffset = r, this.setToRedraw();
}
function WM(i, t) {
  const e = [], r = this.layer.getMasks();
  for (let n = 0; n < r.length; n++) {
    const s = r[n].getMesh(this.regl, i, t);
    s && e.push(s);
  }
  return e;
}
function F4() {
  if (!this._extentPass || !this._maskUniforms) return;
  const i = this._maskUniforms.mask_heightRatio, t = this._maskUniforms.mask_heightOffset, e = WM.call(this, i, t);
  this._extentPass.render(e, this._projViewMatrix);
  const r = this.layer.getMasks();
  for (let n = 0; n < r.length; n++) r[n].getMode() === "video" && r[n].je();
}
function Mg(i) {
  const t = this.layer.getMasks();
  for (let e = 0; e < t.length; e++) if (t[e].getMode() === i) return 1;
  return 0;
}
function Vx() {
  const i = this.layer.getMasks();
  if (!i) return !1;
  for (let t = 0; t < i.length; t++) if (i[t].getMode() === "video" && i[t].Be()) return !0;
  return !1;
}
function L4(i) {
  return class extends i {
    setMask(t, e, r, n) {
      this.viewport || (this.viewport = {
        x: 0,
        y: 0,
        width: () => this.canvas ? this.canvas.width : 1,
        height: () => this.canvas ? this.canvas.height : 1
      }), this._extentPass ? Ag.call(this, t, e, r, n) : this.regl ? (this._extentPass = new hx(this.regl, this.viewport), Ag.call(this, t, e, r, n)) : this.layer.once("contextcreate", () => {
        this._extentPass = new hx(this.regl, this.viewport), Ag.call(this, t, e, r, n);
      }, this);
    }
    needToRedraw() {
      return !!super.needToRedraw() || !!Vx.call(this);
    }
    getMaskUniforms() {
      return Vx.call(this) && F4.call(this), this.layer.updateExtent(), this._maskUniforms;
    }
    getMaskDefines() {
      return this._maskDefines || (this._maskDefines = {}), this._maskUniforms && this._maskUniforms.mask_colorExtent ? this._maskDefines.HAS_MASK_EXTENT = 1 : delete this._maskDefines.HAS_MASK_EXTENT, this._maskDefines;
    }
    updateMaskDefines(t) {
      const e = t.getDefines();
      delete e.HAS_MASK_EXTENT, lr(e, this.getMaskDefines()), t.setDefines(e);
    }
    _clearMask() {
      this._deleteMaskUniforms(), this._extentPass && (this._extentPass.dispose(), delete this._extentPass), this.setToRedraw();
    }
    _deleteMaskUniforms() {
      delete this._maskUniforms;
    }
  };
}
let z4 = class {
  constructor(t, e) {
    this.max = t, this.onRemove = e, this.reset();
  }
  reset() {
    if (this.data) {
      const t = this.data.values();
      for (const e of t) this.onRemove(e);
    }
    return this.data = /* @__PURE__ */ new Map(), this;
  }
  clear() {
    this.reset(), delete this.onRemove;
  }
  add(t, e) {
    return e ? (this.has(t) ? (this.data.delete(t), this.data.set(t, e)) : this.data.set(t, e), this) : this;
  }
  keys() {
    const t = new Array(this.data.size);
    let e = 0;
    const r = this.data.keys();
    for (const n of r) t[e++] = n;
    return t;
  }
  has(t) {
    return this.data.has(t);
  }
  getAndRemove(t) {
    if (!this.has(t)) return null;
    const e = this.data.get(t);
    return this.data.delete(t), e;
  }
  get(t) {
    return this.has(t) ? this.data.get(t) : null;
  }
  pop() {
    if (this.data.size < this.max) return null;
    const t = this.data.keys().next();
    return this.data.get(t.value).current ? (this.max += Math.ceil(this.max / 2), null) : this.getAndRemove(t.value);
  }
  remove(t) {
    if (!this.has(t)) return this;
    const e = this.data.get(t);
    return this.data.delete(t), this.onRemove(e), this;
  }
  resetCurrent(t) {
    this.data && this.data.forEach((e) => {
      e.current = t;
    });
  }
};
const ba = new Y(0, 0), ih = new Y(0, 0), N4 = new Se(0, 0, 0, 0), H4 = new Y(0, 0), Sg = new Y(20, 20), Ux = {
  color: [0, 0, 0, 0],
  depth: 1,
  stencil: 0
};
let B4 = class extends L4(zs.TileLayerCanvasRenderer) {
  isDrawable() {
    return !0;
  }
  getTempTileOnLoading(t, e) {
    if (e.image && !e.image.reset) return e;
    const r = this.Ue(t);
    return r.temp = !0, e.image || (e.image = r), delete e.image.reset, e.current = !0, e.info = t, lr(e.image, r), this.ze(e.image, t), e;
  }
  Ve(t, e, r) {
    e.reset = !0, delete e.data, delete e.loadTime, delete e.rendered, delete e.minAltitude;
    const n = t.id + "-temp", s = e.skinImages;
    if (s) for (let o = 0; o < s.length; o++) {
      const a = s[o];
      if (a) {
        for (let l = 0; l < a.length; l++) {
          const h = a[l];
          h && (h.refs.delete(n), h.refs.size || r.push(h));
        }
        delete a.currentSkins, delete a.tileIds;
      }
    }
    delete e.sourceZoom, delete e.skinImages, delete e.skinStatus, delete e.skinTileIds, e.debugTexture && (e.debugTexture.destroy(), delete e.debugTexture);
  }
  Ue(t, e) {
    for (e = e || this.findParentTile(t); e && e.image && (e.image.sourceZoom === -1 || e.image.originalError); ) e = this.findParentTile(e.info);
    const r = (e && e.info || t).res, n = this.getMap().pointAtResToDistance(1, 1, r), s = e && e.image && e.image.data && this.We(e, t), o = s && e.image.sourceZoom !== -1 ? e.info.z : -1;
    if (!s || s.width <= 1) {
      const l = this.qe(t, e);
      return {
        data: x0(l || 0, 5),
        minAltitude: l,
        mesh: ud,
        sourceZoom: o
      };
    }
    const a = s.width;
    return {
      data: s,
      mesh: VM(n, s.data, a),
      sourceZoom: o
    };
  }
  qe(t, e) {
    if (e && e.minAltitude) return e.minAltitude;
    const { idx: r, idy: n, z: s } = t;
    for (let o = -1; o <= 1; o++) for (let a = -1; a <= 1; a++) {
      if (o === 0 && a === 0) continue;
      const l = this.layer.getTileId(r + o, n + a, s), h = this.layer.tileInfoCache.get(l);
      if (h && h.minAltitude) return h.minAltitude;
    }
    return 0;
  }
  consumeTile(t, e) {
    if (t.empty && !t.mesh) {
      const r = this.findParentTile(e);
      if (!r || r.image && r.image.empty) {
        t.mesh = ud;
        const n = this.qe(e);
        t.data = x0(n || 0, 5), t.minAltitude = n, t.sourceZoom = -1;
      } else t = this.Ue(e, r);
    }
    this.ze(t, e), super.consumeTile(t, e), this.$e(e);
  }
  ze(t, e) {
    if (t && t.mesh) {
      t.terrainMesh = this.Ye.createTerrainMesh(e, t), e.minAltitude = t.data.min, e.maxAltitude = t.data.max, delete t.mesh;
      const r = this.layer.tileInfoCache;
      if (r && e.parent && !t.empty && !t.temp) {
        const n = r.get(e.parent);
        if (n) {
          const { minAltitude: s, maxAltitude: o } = e;
          (n.minAltitude === void 0 || n.minAltitude > s) && (n.minAltitude = s), (n.maxAltitude === void 0 || n.maxAltitude < o) && (n.maxAltitude = o);
        }
      }
    }
  }
  $e(t) {
    const e = this.getMap();
    if (e.updateCenterAltitude && e.centerAltitude === void 0 && t.z === this.getCurrentTileZoom()) {
      const r = e._getPrjCenter(), n = e._prjToPointAtRes(r, t.res, H4);
      t.extent2d.contains(n) && e.updateCenterAltitude();
    }
  }
  draw(t, e) {
    this.Xe(), this.Ye.startFrame(), super.draw(t, e), this.Je(e);
  }
  drawTile(t, e) {
    const r = this.getMap();
    if (!t || !r || !e || !this.drawingCurrentTiles && !this.drawingChildTiles) return;
    let n = this.drawingCurrentTiles ? this.getTileOpacity(e) : 1;
    n *= this.layer.options.opacity || 1, this.Ye.addTerrainImage(t, e, n);
  }
  _drawTiles(t, e, r, n, s, o, a) {
    const l = [], h = this.Ze(o, l);
    this.Ke = 0;
    const u = this.layer.getSkinCount();
    v0(t, h);
    const c = /* @__PURE__ */ new Set();
    for (let f = 0; f < u; f++) this.Qe(f, a, c, l);
    for (let f = 0; f < u; f++) this.Qe(f, t, c, l);
    for (let f = 0; f < t.length; f++) this.ts(t[f].info, t[f].image);
    for (let f = 0; f < l.length; f++) l[f] && l[f].texture && !l[f].refs.size && (this.es.delete(l[f].tile.id), this.ss(l[f]));
    return this.ns(), super._drawTiles(...arguments);
  }
  Ze(t, e) {
    const r = [];
    let n = this.rs;
    n || (n = this.rs = new z4(this.layer.options.tempTileCacheSize, (s) => {
      const { info: o, image: a } = s;
      this.hs(o, a);
    })), n.resetCurrent(!1);
    for (let s = 0; s < t.length; s++) {
      const o = t[s];
      let a;
      n.has(o.id) ? a = n.getAndRemove(o.id) : (a = n.pop(), a ? a.image && (this.Ve(a.info, a.image, e), a.image.temp = !0) : a = {
        info: o
      }), a.current = !0, n.add(o.id, a), r.push(a);
    }
    for (let s = 0; s < t.length; s++) this.getTempTileOnLoading(t[s], r[s]);
    return r;
  }
  ns() {
    if (!this.es) return;
    const t = this.getCurrentTimestamp();
    if (this.os && t - this.os < 1e3) return;
    const e = /* @__PURE__ */ new Set();
    for (const r of this.tileCache.data.values()) this.as(r, e);
    for (const r in this.tilesInView) {
      const n = this.tilesInView[r];
      this.as(n, e);
    }
    if (this.rs) for (const r of this.rs.data.values()) this.as(r, e);
    e.size && (this.es.forEach((r, n) => {
      e.has(n) || (console.log("deleted:", n), this.ss(this.es.get(n)), this.es.delete(n));
    }), this.os = t);
  }
  as(t, e) {
    const r = t.image && t.image.skinImages;
    if (r && r.length) for (let n = 0; n < r.length; n++) {
      const s = r[n] && r.currentSkins;
      if (s) for (const o of s) e.add(o);
    }
  }
  Qe(t, e, r, n) {
    const s = this.layer.getSkinLayer(t).getRenderer();
    if (!s) return;
    const o = [];
    for (let a = 0; a < e.length; a++) {
      const { info: l, image: h } = e[a];
      if (this.cs(t, l, h, n)) {
        const u = e[a].image.skinImages[t];
        for (let c = 0; c < u.length; c++) {
          const f = u[c].tile.info.id;
          r.has(f) || (o.push(u[c]), r.add(f));
        }
      }
    }
    s.renderTerrainSkin(this.regl, this.layer, o);
  }
  cs(t, e, r, n) {
    const s = this.getMap();
    if (delete r.path, !e || !s || !r || !r.terrainMesh) return !1;
    const o = this.layer.getSkinLayer(t), a = o.getRenderer();
    if (!a) return !1;
    r.skinImages || (r.skinImages = []), r.skinStatus || (r.skinStatus = []), r.skinTileIds || (r.skinTileIds = []);
    const l = a.isAnimating && a.isAnimating(), h = r.skinStatus[t], u = a.needToRefreshTerrainTileOnZooming && a.needToRefreshTerrainTileOnZooming(), c = l || u && r.renderedZoom !== s.getZoom();
    if (h && !c) return !1;
    const f = o.getSpatialReference(), { x: d, y: p, z: g, res: m, offset: v } = e;
    let _ = e.nw;
    _ || (_ = e.nw = this.getMap().pointAtResToCoord(e.extent2d.getMin(ba), e.res));
    const y = this.layer.getTileSize().width, { res: x, zoom: w } = _0(f, g, m), b = y0(x, o.getTileSize().width, m, y);
    let T = r.skinTileIds[t];
    if (!T) {
      const H = this.layer._getTileConfig().tileSystem.scale.y;
      T = r.skinTileIds[t] = UM(o, d, p, w, _, v, H, b, j4);
    }
    const A = T[0];
    let M = !0;
    const S = [];
    for (let H = 0; H < A.length; H++) {
      const G = a.getCachedTile(A[H], !1);
      if (G) S.push(G);
      else {
        M = !1;
        const $ = a.findParentTile(A[H]);
        $ && S.push($);
      }
    }
    const P = r.skinImages[t] || [];
    P.currentSkins = P.currentSkins || /* @__PURE__ */ new Set();
    const C = /* @__PURE__ */ new Set();
    let k = !1;
    for (let H = 0; H < P.length; H++) {
      if (!P[H].tile) {
        k = !0;
        continue;
      }
      const G = P[H].tile.info.id;
      C.add(G);
    }
    if (!S.length) return P.currentSkins.clear(), r.skinImages[t] = [], !1;
    const O = S.length ? S.map((H) => H.info.id).join() : S[0].info.id;
    if (!c && !k && P.tileIds === O) return !1;
    P.tileIds = O;
    let R = !1;
    P.currentSkins.clear(), P.length = 0;
    const I = P.currentSkins;
    let D = e.id;
    r.temp && (D += "-temp");
    for (let H = 0; H < S.length; H++) {
      const G = S[H].info.id;
      I.add(G);
      let $ = this.ls(G);
      $ && (z = $) && z.texture || ($ = {
        tile: lr({}, S[H]),
        layer: o,
        refs: /* @__PURE__ */ new Set(),
        texture: a.createTerrainTexture(this.regl)
      }, this.us(G, $)), $.refs.add(D), P.push($), R = !0;
    }
    var z;
    return this.fs(e, r, C, I, n), R && this.Ke++, r.skinImages[t] = P, o.fire("renderterrainskin", {
      tile: e,
      skinTiles: S
    }), M && (r.skinStatus[t] = 1), !0;
  }
  fs(t, e, r, n, s) {
    if (!r.size) return;
    let o = t.id;
    e.temp && (o += "-temp");
    for (const a of r) if (!n || !n.has(a)) {
      const l = this.ls(a);
      this.ds(l, o, s);
    }
  }
  ls(t) {
    return this.es || (this.es = /* @__PURE__ */ new Map()), this.es.get(t);
  }
  us(t, e) {
    this.es.set(t, e);
  }
  ts(t, e) {
    const r = this.getMap();
    if (!t || !r || !e) return;
    const n = e.skinImages, s = this.ps(e.renderedZoom);
    if (e.rendered && !s) return;
    e.skin ? (Ux.framebuffer = e.skin, this.regl.clear(Ux)) : e.skin = this.gs(), this.ms();
    const o = this.layer.options.debug, a = [], l = o && [], h = this.layer.getTileSize().width;
    if (n) for (let u = 0; u < n.length; u++) {
      const c = n[u];
      for (let f = 0; f < c.length; f++) {
        const { tile: d, texture: p, layer: g } = c[f];
        if ((d.info.offset[0] || d.info.offset[1]) && t.skinTileIds) {
          const y = t.skinTileIds[g.getId()];
          for (let x = 0; x < y.length; x++) if (d.info.x === y[x].x && d.info.y === y[x].y) {
            d.info.offset = y[x].offset;
            break;
          }
        }
        const m = V4(t, d, h), v = c[f].skinMesh || new tn(this.vs);
        v.setUniform("skinTexture", p);
        const _ = g.getOpacity();
        v.setUniform("opacity", du(_) ? 1 : _), v.setUniform("skinDim", m), v.setUniform("tileSize", h), v.setUniform("x", t.x), v.setUniform("y", t.y), c[f].skinMesh = v, a.push(v);
      }
    }
    if (o) {
      const u = e.skinDebugMesh || new tn(this.vs);
      u.setUniform("tileSize", h);
      const c = e.debugTexture || this.ws(t, h);
      e.debugTexture = c, e.skinDebugMesh = u, u.setUniform("opacity", 1), u.setUniform("skinTexture", c), u.setUniform("skinDim", [0, 0, 1]), u.setUniform("tileSize", h), l.push(u);
    }
    if (a.length) {
      this._s.setMeshes(a);
      try {
        this.renderer.render(this.Ms, null, this._s, e.skin);
      } catch (u) {
        throw console.error(e), u;
      }
    }
    l && l.length && this.layer.options.debug && (this._s.setMeshes(l), this.renderer.render(this.Ms, null, this._s, e.skin)), e.rendered = this.xs(e), e.renderedZoom = r.getZoom();
  }
  ws(t, e) {
    e *= 2;
    const { x: r, y: n, z: s } = t, o = `terrain:${r}/${n}/${s}`, a = document.createElement("canvas");
    a.width = e, a.height = e;
    const l = a.getContext("2d");
    l.font = "40px monospace";
    const h = this.layer.options.debugOutline;
    return l.fillStyle = h, l.strokeStyle = h, l.fillText(o, 20, e - 40), l.beginPath(), l.lineWidth = 4, l.moveTo(0, 0), l.lineTo(e, 0), l.lineTo(e, e), l.lineTo(0, e), l.lineTo(0, 0), l.stroke(), this.regl.texture({
      data: a,
      flipY: !0,
      mag: "linear",
      min: "linear"
    });
  }
  gs() {
    const t = this.layer.getTileSize().width, e = 2 * t, r = 2 * t, n = this.regl, s = n.texture({
      min: "linear",
      mag: "linear",
      type: "uint8",
      width: e,
      height: r,
      flipY: !0
    }), o = {
      width: e,
      height: r,
      colors: [s],
      colorFormat: "rgba",
      ignoreStatusCheck: !0,
      depthStencil: !1,
      depth: !1,
      stencil: !1
    }, a = n.framebuffer(o);
    return a.colorTex = s, a;
  }
  Je(t) {
    this.Ye.endFrame(t) && !Object.keys(this.tilesLoading).length && this.layer.fire("terrainreadyandrender");
  }
  We(t, e) {
    const { image: r, info: n } = t, s = r.data, o = s.width, { extent2d: a, res: l } = n, { extent2d: h, res: u } = e, c = a.getWidth(), f = a.getHeight();
    let d = (h.xmin * u / l - a.xmin) / c * (o - 1), p = (a.ymax - h.ymax * u / l) / f * (o - 1);
    const g = (h.xmax * u / l - a.xmin) / c * (o - 1);
    let m = Math.round(g - d);
    const v = Math.log2(m);
    m = Math.pow(2, Math.round(v)) + 1, d = Math.floor(d), p = Math.floor(p);
    const _ = new Float32Array(m * m);
    let y = 1 / 0, x = -1 / 0;
    for (let w = 0; w < m; w++) for (let b = 0; b < m; b++) {
      let T = w + d, A = b + p;
      T > o - 1 ? T = o - 1 : T < 0 && (T = 0), A > o - 1 ? A = o - 1 : A < 0 && (A = 0);
      const M = s.data[T + A * o];
      _[w + b * m] = M, M < y && (y = M), M > x && (x = M);
    }
    return {
      width: m,
      height: m,
      data: _,
      min: y,
      max: x
    };
  }
  getTileOpacity(t) {
    return this.xs(t) ? super.getTileOpacity(t) : (this.resetTileLoadTime(t), 0);
  }
  xs(t) {
    const e = this.layer.getSkinCount();
    if (!e) return !0;
    if (!t.skinStatus) return !1;
    for (let r = 0; r < e; r++) if (!t.skinStatus[r]) return !1;
    return !0;
  }
  ps(t) {
    const e = this.getMap().getZoom(), r = this.layer.getSkinLayers();
    for (let n = 0; n < r.length; n++) {
      const s = r[n] && r[n].getRenderer();
      if (s && (s.isAnimating && s.isAnimating() || s.needToRefreshTerrainTileOnZooming && s.needToRefreshTerrainTileOnZooming() && t !== e))
        return !0;
    }
    return !1;
  }
  isValidCachedTile(t) {
    const e = !t.image.skinStatus;
    return t.image && !t.image.temp && (e || this.xs(t.image));
  }
  isTileComplete(t) {
    return t.image && !t.image.temp && this.xs(t.image);
  }
  ys() {
    const t = this.layer.options;
    return du(t.terrainWidth) ? t.tileSize + 1 : t.terrainWidth;
  }
  bs(t, e) {
    const r = this.layer.options.maxAvailableZoom - this.layer.options.zoomOffset, n = t.z - r, s = Math.pow(2, n), o = Math.floor(t.x / s), a = Math.floor(t.y / s), l = Math.floor(t.idx / s), h = Math.floor(t.idy / s), u = $x(o, a);
    this.Ss || (this.Ss = {});
    const c = !this.Ss[u];
    return c && e && (this.Ss[u] = /* @__PURE__ */ new Set(), this.Ss[u].url = this.layer.getTileUrl(o, a, r + this.layer.options.zoomOffset)), {
      x: o,
      y: a,
      idx: l,
      idy: h,
      requests: this.Ss[u],
      isFirst: c,
      key: u
    };
  }
  loadTile(t) {
    const e = this.layer, r = this.ys(), n = e.getSpatialReference().getResolution(t.z);
    let s = this.getMap().pointAtResToDistance(1, 1, n);
    const o = e.options.zoomOffset || 0, a = e.options.maxAvailableZoom && e.options.maxAvailableZoom - o;
    if (a && t.z > a) {
      const f = this.Ue(t);
      if (f.sourceZoom !== -1) return this.onTileLoad(f, t), f;
      {
        const { requests: d, isFirst: p, x: g, y: m, idx: v, idy: _ } = this.bs(t, !0);
        if (d.add(t), !p) return f;
        const y = t.z - a;
        s *= Math.pow(2, y);
        const x = [g, m, a, v, _, t.res * Math.pow(2, y), t.error * Math.pow(2, y)];
        t = e.createTileNode ? e.createTileNode(...x) : e.Cs(...x);
      }
    }
    const l = t.url, h = {}, u = e.options, c = {
      terrainWidth: r,
      type: u.type,
      accessToken: u.accessToken,
      cesiumIonTokenURL: u.cesiumIonTokenURL,
      error: s
    };
    return this.workerConn.fetchTerrain(l, c, (f, d) => {
      if (this.Ss) {
        const p = $x(t.x, t.y), g = this.Ss[p];
        if (g && g.size) {
          this.tileCache.add(t.id, {
            info: t,
            image: h
          });
          for (const m of g) this.removeTileLoading(m);
        }
        delete this.Ss[p];
      }
      if (f)
        return f.canceled ? void 0 : (console.warn(f), void this.onTileError(h, t));
      Yr.extend(h, d), this.onTileLoad(h, t);
    }), h;
  }
  deleteTile(t) {
    if (!t || !t.image) return;
    super.deleteTile(t);
    const { info: e, image: r } = t;
    r.temp || (delete e.skinTileIds, this.hs(t.info, r));
  }
  hs(t, e) {
    const r = e.skin;
    r && (r.destroy(), r.colorTex.destroy(), delete r.colorTex), e.debugTexture && (e.debugTexture.destroy(), delete e.debugTexture, e.skinDebugMesh.dispose(), delete e.skinDebugMesh);
    const n = e.skinImages;
    if (n && n.length) {
      let s = t.id;
      e.temp && (s += "-temp");
      for (let o = 0; o < n.length; o++) {
        const a = n[o];
        if (a) {
          for (let l = 0; l < a.length; l++) {
            if (!a[l] || !a[l].tile) continue;
            const h = a[l].tile.info.id, u = this.es && this.es.get(h);
            u && this.ds(u, s);
          }
          a.length = 0;
        }
      }
    }
    e.terrainMesh && this.Ye.deleteMesh(e.terrainMesh), e.image && e.image.close && e.image.close(), delete e.skinImages, delete e.skin, delete e.skinStatus, delete e.skinTileIds, delete e.terrainMesh, delete e.image, delete e.data, delete e.mesh, delete e.rendered;
  }
  ds(t, e, r) {
    t && (t.refs.delete(e), t.refs.size || (r ? r.push(t) : this.ss(t)));
  }
  ss(t) {
    if (!t || !t.tile) return;
    const e = t.tile.info.id, r = t.layer.getRenderer();
    delete t.canvas, delete t.layer, t.refs.clear(), t.texture && (r ? r.deleteTerrainTexture(t.texture) : t.texture.destroy && t.texture.destroy(), delete t.texture), t.skinMesh && (t.skinMesh.dispose(), delete t.skinMesh), r && (r.removeTileCache && r.removeTileCache(e), r.deleteTile && r.constructor.prototype.deleteTile.call(r, t.tile)), delete t.tile, this.es.delete(e);
  }
  Ts() {
    if (!this.es) return;
    const t = this.es.keys();
    for (const e of t) {
      const r = this.ls(e);
      this.ss(r);
    }
    this.es.clear();
  }
  abortTileLoading(t, e) {
    const r = this.layer, n = r.options.maxAvailableZoom && r.options.maxAvailableZoom - r.options.zoomOffset;
    if (e) if (n && e.z > n) {
      const { requests: s, key: o } = this.bs(e);
      s && s.size && (s.delete(e), s.size || (delete this.Ss[o], this.workerConn && this.workerConn.abortTerrain(s.url)));
    } else e && e.url && this.workerConn && this.workerConn.abortTerrain(e.url);
    super.abortTileLoading(t, e);
  }
  onTileError(t, e) {
    super.onTileError(t, e);
  }
  ks(t) {
    const e = this.getCurrentTileZoom(), r = this.layer.getSpatialReference().getResolution(e), n = this.layer._getTileConfig().getTileIndex(t, r, this.layer.options.repeatWorld);
    return n.z = e, n;
  }
  As(t, e, r, n, s) {
    const o = this.layer.getMinZoom(), a = this.Os(e, r.x, r.y, r.z, o);
    if (a && a.image && a.image.data) {
      const l = a.info.extent2d, h = a.info.res / s, u = n.x - l.xmin * h, c = l.ymax * h - n.y, f = this.Is(a.image.data, u / (l.getWidth() * h), c / (l.getHeight() * h));
      t[0] = f, t[1] = f === null ? 0 : +(a.info.z === r.z);
    } else t[0] = null, t[1] = 0;
    return t;
  }
  Os(t, e, r, n, s) {
    t || (t = this.layer._getTileId(e, r, n));
    const o = this.tilesInView[t] || this.tileCache.get(t);
    return !o && n - 1 >= s ? this.Os(null, Math.floor(e / 2), Math.floor(r / 2), n - 1, s) : o;
  }
  Is(t, e, r) {
    const { width: n, height: s, data: o } = t, a = Math.floor((n - 1) * e), l = Math.floor((s - 1) * r) * n + a;
    return o[l] === void 0 ? null : o[l];
  }
  Es(t, e, r) {
    t || (t = {
      tiles: {},
      dirty: !0,
      complete: !1
    });
    const n = this.layer, s = this.getCurrentTileZoom(), o = n.getSpatialReference().getResolution(s), { xmin: a, ymin: l, xmax: h, ymax: u } = e, c = n._getTileConfig();
    ba.set(a, l).Ls(r);
    const f = c._getTileNum(ba, r, !0);
    ih.set(h, u).Ls(r);
    const d = c._getTileNum(ih, r, !0), p = Math.min(f.x, d.x), g = Math.max(f.x, d.x), m = Math.min(f.y, d.y), v = Math.max(f.y, d.y), _ = r / o;
    ba.set(a, l).Ls(_), ih.set(h, u).Ls(_);
    const y = N4.set(ba.x, ba.y, ih.x, ih.y), x = n.getTileSize().width + 1;
    y.Fs(y.getWidth() / x), t.array = t.array || new Float32Array(x * x);
    const w = t.tiles;
    t.complete = !0, t.array.fill(0);
    for (let b = p; b <= g; b++) for (let T = m; T <= v; T++) {
      const A = this.layer._getTileId(b, T, s);
      if (w[A]) continue;
      const M = this.tileCache.get(A);
      M ? (this.Rs(t.array, M, y, x), t.dirty = !0, w[A] = 1) : (t.dirty = t.dirty || t.tiles[A] !== void 0, t.tiles[A] && delete t.tiles[A], t.complete = !1);
    }
    return t;
  }
  Rs(t, e, r, n) {
    const s = e.info.extent2d, o = s.intersection(r), { xmin: a, ymin: l, xmax: h, ymax: u } = o, { data: c } = e.image, f = c.width, d = r.getWidth() / n, p = Math.floor((a - r.xmin) / d), g = Math.floor((l - r.ymin) / d), m = Math.floor((h - r.xmin) / d) - p, v = Math.floor((u - r.ymin) / d) - g, _ = s.getWidth() / f, y = Math.floor((a - s.xmin) / _), x = Math.floor((l - s.ymin) / _), w = Math.floor(d / _);
    for (let b = 0; b <= m; b++) for (let T = 0; T <= v; T++) {
      const A = b + p + (g + T) * n;
      let M = 0;
      for (let S = 0; S < w; S++) for (let P = 0; P < w; P++) {
        const C = (y + Math.floor(b * w)) * f + S + x + Math.floor(T * w) + P;
        M += c.data[C];
      }
      t[A] = M / Math.max(w, 1);
    }
    return t;
  }
  clear() {
    return this.clearTempResources(), super.clear();
  }
  clearTempResources() {
    this.rs && (this.rs.reset(), delete this.rs), this.es && this.Ts();
  }
  onAdd() {
    super.onAdd(), this.prepareWorker();
  }
  onRemove() {
    this.workerConn && (this.workerConn.removeLayer(this.layer.getId(), (t) => {
      if (t) throw t;
    }), this.workerConn.remove(), delete this.workerConn), this.clearTempResources(), this.Ms && (this.Ms.dispose(), delete this.Ms), this.vs && (this.vs.dispose(), delete this.vs), delete this.Ss, super.onRemove(), this.Ye && (this.Ye.delete(), delete this.Ye);
  }
  prepareWorker() {
    const t = this.layer.getMap();
    this.workerConn || (this.workerConn = new C4(t.id));
    const e = this.workerConn;
    if (!e.isActive()) return;
    const r = this.layer.options || {}, n = this.layer.getId();
    e.addLayer(n, r, (s) => {
      if (s) throw s;
      this.layer && (this.ready = !0, this.setToRedraw(), this.layer.fire("workerready"));
    });
  }
  createContext() {
    this.canvas.gl && this.canvas.gl.wrap ? (this.gl = this.canvas.gl.wrap(), this.regl = this.canvas.gl.regl) : this.Ps(), this.renderer = new hn(this.regl), this.layer.fire("contextcreate", {
      regl: this.regl
    });
  }
  Xe() {
    const t = this.Ye;
    this.layer.options.shader === "lit" || this.layer.options.shader === "pbr" ? (t && t.constructor === b0 || !t) && (t && (t.delete(), this.clear(), this.setToRedraw()), this.Ye = new Gx(this.layer), this.layer.fire("paintercreated")) : (t && t.constructor === Gx || !t) && (t && (t.delete(), this.clear(), this.setToRedraw()), this.Ye = new b0(this.layer), this.layer.fire("paintercreated"));
  }
  Ps() {
    const t = this.layer, e = t.options.glOptions || {
      alpha: !0,
      depth: !0,
      antialias: this.layer.options.antialias
    };
    e.preserveDrawingBuffer = !0, e.stencil = !0, this.glOptions = e, this.gl = this.gl || this.Ds(this.canvas, e), this.regl = ZA.createREGL({
      gl: this.gl,
      attributes: e,
      extensions: ["OES_element_index_uint"],
      optionalExtensions: t.options.glExtensions
    });
  }
  Ds(t, e) {
    const r = ["webgl", "experimental-webgl"];
    let n = null;
    for (let s = 0; s < r.length; ++s) {
      try {
        n = t.getContext(r[s], e);
      } catch {
      }
      if (n) break;
    }
    return n;
  }
  resizeCanvas(t) {
    this.canvas && super.resizeCanvas(t);
  }
  clearCanvas() {
    this.canvas && super.clearCanvas();
  }
  ms() {
    if (this.Ms) return;
    const t = this.layer.getTileSize().width;
    this.Ms = new qe({
      vert: `#define SHADER_NAME TERRAIN_SKIN
attribute vec2 aPosition;
void main() {
    gl_Position = vec4(aPosition, 0.0, 1.0);
}`,
      frag: `#define SHADER_NAME TERRAIN_SKIN
precision mediump float;
uniform float tileSize;
uniform sampler2D skinTexture;
uniform vec3 skinDim;
uniform float opacity;
void main() {
    vec2 fragCoord = gl_FragCoord.xy / 2.0;
    vec2 resolution = vec2(tileSize);
    vec2 uv = (fragCoord - skinDim.xy) /  (resolution * skinDim.z);
    if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0) {
        gl_FragColor = texture2D(skinTexture, uv) * opacity;
    } else {
        gl_FragColor = vec4(0.0);
    }
}`,
      extraCommandProps: {
        cull: {
          enable: !1
        },
        viewport: {
          x: 0,
          y: 0,
          width: 2 * t,
          height: 2 * t
        },
        depth: {
          enable: !1
        },
        stencil: {
          enable: !1
        },
        blend: {
          enable: !0,
          func: {
            src: "one",
            dst: "one minus src alpha"
          },
          equation: "add"
        }
      }
    });
    const e = new Int8Array([-1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1]);
    this.vs = this.vs || new er({
      aPosition: e
    }, 0, 6, {
      positionSize: 2
    }), this.vs.generateBuffers(this.regl), this._s = this._s || new ur();
  }
  updateMaterial(t) {
    this.Ye && t && this.Ye.updateMaterial && (this.Ne === void 0 && (this.Ne = 1), this.Ye.updateMaterial(t, this.Ne++));
  }
  setMaterial(t) {
    this.Ye && t && this.Ye.setMaterial && (this.Ne === void 0 && (this.Ne = 1), this.Ye.setMaterial(t, this.Ne++));
  }
  getAnalysisMeshes() {
    return this.Ye && this.Ye.Ae ? this.Ye.Ae.getMeshes() : [];
  }
};
const j4 = 1;
function G4(i, t, e, r, n, s, o, a, l = 0) {
  i.font = "20px monospace", i.fillStyle = e, Sg.y = a - 30, i.globalAlpha = 1, i.fillText(t, Sg.x + n, Sg.y + s + l), i.globalAlpha = 0.6, i.strokeStyle = e, i.lineWidth = r, i.beginPath(), i.moveTo(n, s), i.lineTo(n + o, s), i.lineTo(n + o, s + a), i.lineTo(n, s + a), i.lineTo(n, s), i.stroke(), i.globalAlpha = 1;
}
function V4(i, t, e) {
  const { res: r, extent2d: n, offset: s } = i, { info: o } = t, a = o.res / r, l = o.offset, h = o.extent2d.xmin * a, u = o.extent2d.ymin * a, c = s[0] - l[0], f = l[1] - s[1];
  return [h - n.xmin + c, -(n.ymin - u + f), a * o.tileSize / e];
}
function $x(i, t) {
  return i + "-" + t;
}
zs.TileLayerCanvasRenderer.include({
  renderTerrainSkin(i, t, e) {
    const r = this.layer.getTileSize().width, n = t.options.debug;
    for (let s = 0; s < e.length; s++) {
      const { tile: o, texture: a } = e[s];
      if (!o.image) continue;
      const l = document.createElement("canvas");
      e[s].canvas = l, l.width = r, l.height = r;
      const h = l.getContext("2d");
      if (h.drawImage(o.image, 0, 0), n) {
        const { x: u, y: c, z: f } = o.info;
        G4(h, `${u}/${c}/${f}`, "yellow", 1, 0, 0, r, r, -18);
      }
      a({
        data: l,
        width: r,
        height: r,
        flipY: !0,
        min: "linear mipmap linear",
        mag: "linear"
      });
    }
  },
  createTerrainTexture(i) {
    const t = this.layer.getTileSize().width, e = {
      width: t,
      height: t,
      flipY: !0,
      min: "linear mipmap linear",
      mag: "linear",
      depthStencil: !1,
      depth: !1,
      stencil: !1
    };
    return i.texture(e);
  },
  deleteTerrainTexture(i) {
    i.destroy();
  }
});
var w0 = {
  exports: {}
};
function Ec(i, t, e) {
  e = e || 2;
  var r, n, s, o, a, l, h, u = t && t.length, c = u ? t[0] * e : i.length, f = Wx(i, 0, c, e, !0), d = [];
  if (!f || f.next === f.prev) return d;
  if (u && (f = function(g, m, v, _) {
    var y, x, w, b, T, A = [];
    for (y = 0, x = m.length; y < x; y++) w = m[y] * _, b = y < x - 1 ? m[y + 1] * _ : g.length, (T = Wx(g, w, b, _, !1)) === T.next && (T.steiner = !0), A.push(J4(T));
    for (A.sort(X4), y = 0; y < A.length; y++) v = q4(A[y], v);
    return v;
  }(i, t, f, e)), i.length > 80 * e) {
    r = s = i[0], n = o = i[1];
    for (var p = e; p < c; p += e) (a = i[p]) < r && (r = a), (l = i[p + 1]) < n && (n = l), a > s && (s = a), l > o && (o = l);
    h = (h = Math.max(s - r, o - n)) !== 0 ? 32767 / h : 0;
  }
  return pu(f, d, e, r, n, h, 0), d;
}
function Wx(i, t, e, r, n) {
  var s, o;
  if (n === M0(i, t, e, r) > 0) for (s = t; s < e; s += r) o = Zx(s, i[s], i[s + 1], o);
  else for (s = e - r; s >= t; s -= r) o = Zx(s, i[s], i[s + 1], o);
  return o && Wd(o, o.next) && (mu(o), o = o.next), o;
}
function Zo(i, t) {
  if (!i) return i;
  t || (t = i);
  var e, r = i;
  do
    if (e = !1, r.steiner || !Wd(r, r.next) && Fn(r.prev, r, r.next) !== 0) r = r.next;
    else {
      if (mu(r), (r = t = r.prev) === r.next) break;
      e = !0;
    }
  while (e || r !== t);
  return t;
}
function pu(i, t, e, r, n, s, o) {
  if (i) {
    !o && s && function(u, c, f, d) {
      var p = u;
      do
        p.z === 0 && (p.z = T0(p.x, p.y, c, f, d)), p.prevZ = p.prev, p.nextZ = p.next, p = p.next;
      while (p !== u);
      p.prevZ.nextZ = null, p.prevZ = null, function(g) {
        var m, v, _, y, x, w, b, T, A = 1;
        do {
          for (v = g, g = null, x = null, w = 0; v; ) {
            for (w++, _ = v, b = 0, m = 0; m < A && (b++, _ = _.nextZ); m++) ;
            for (T = A; b > 0 || T > 0 && _; ) b !== 0 && (T === 0 || !_ || v.z <= _.z) ? (y = v, v = v.nextZ, b--) : (y = _, _ = _.nextZ, T--), x ? x.nextZ = y : g = y, y.prevZ = x, x = y;
            v = _;
          }
          x.nextZ = null, A *= 2;
        } while (w > 1);
      }(p);
    }(i, r, n, s);
    for (var a, l, h = i; i.prev !== i.next; ) if (a = i.prev, l = i.next, s ? $4(i, r, n, s) : U4(i)) t.push(a.i / e | 0), t.push(i.i / e | 0), t.push(l.i / e | 0), mu(i), i = l.next, h = l.next;
    else if ((i = l) === h) {
      o ? o === 1 ? pu(i = W4(Zo(i), t, e), t, e, r, n, s, 2) : o === 2 && Z4(i, t, e, r, n, s) : pu(Zo(i), t, e, r, n, s, 1);
      break;
    }
  }
}
function U4(i) {
  var t = i.prev, e = i, r = i.next;
  if (Fn(t, e, r) >= 0) return !1;
  for (var n = t.x, s = e.x, o = r.x, a = t.y, l = e.y, h = r.y, u = n < s ? n < o ? n : o : s < o ? s : o, c = a < l ? a < h ? a : h : l < h ? l : h, f = n > s ? n > o ? n : o : s > o ? s : o, d = a > l ? a > h ? a : h : l > h ? l : h, p = r.next; p !== t; ) {
    if (p.x >= u && p.x <= f && p.y >= c && p.y <= d && Ka(n, a, s, l, o, h, p.x, p.y) && Fn(p.prev, p, p.next) >= 0) return !1;
    p = p.next;
  }
  return !0;
}
function $4(i, t, e, r) {
  var n = i.prev, s = i, o = i.next;
  if (Fn(n, s, o) >= 0) return !1;
  for (var a = n.x, l = s.x, h = o.x, u = n.y, c = s.y, f = o.y, d = a < l ? a < h ? a : h : l < h ? l : h, p = u < c ? u < f ? u : f : c < f ? c : f, g = a > l ? a > h ? a : h : l > h ? l : h, m = u > c ? u > f ? u : f : c > f ? c : f, v = T0(d, p, t, e, r), _ = T0(g, m, t, e, r), y = i.prevZ, x = i.nextZ; y && y.z >= v && x && x.z <= _; ) {
    if (y.x >= d && y.x <= g && y.y >= p && y.y <= m && y !== n && y !== o && Ka(a, u, l, c, h, f, y.x, y.y) && Fn(y.prev, y, y.next) >= 0 || (y = y.prevZ, x.x >= d && x.x <= g && x.y >= p && x.y <= m && x !== n && x !== o && Ka(a, u, l, c, h, f, x.x, x.y) && Fn(x.prev, x, x.next) >= 0)) return !1;
    x = x.nextZ;
  }
  for (; y && y.z >= v; ) {
    if (y.x >= d && y.x <= g && y.y >= p && y.y <= m && y !== n && y !== o && Ka(a, u, l, c, h, f, y.x, y.y) && Fn(y.prev, y, y.next) >= 0) return !1;
    y = y.prevZ;
  }
  for (; x && x.z <= _; ) {
    if (x.x >= d && x.x <= g && x.y >= p && x.y <= m && x !== n && x !== o && Ka(a, u, l, c, h, f, x.x, x.y) && Fn(x.prev, x, x.next) >= 0) return !1;
    x = x.nextZ;
  }
  return !0;
}
function W4(i, t, e) {
  var r = i;
  do {
    var n = r.prev, s = r.next.next;
    !Wd(n, s) && ZM(n, r, r.next, s) && gu(n, s) && gu(s, n) && (t.push(n.i / e | 0), t.push(r.i / e | 0), t.push(s.i / e | 0), mu(r), mu(r.next), r = i = s), r = r.next;
  } while (r !== i);
  return Zo(r);
}
function Z4(i, t, e, r, n, s) {
  var o = i;
  do {
    for (var a = o.next.next; a !== o.prev; ) {
      if (o.i !== a.i && K4(o, a)) {
        var l = XM(o, a);
        return o = Zo(o, o.next), l = Zo(l, l.next), pu(o, t, e, r, n, s, 0), void pu(l, t, e, r, n, s, 0);
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== i);
}
function X4(i, t) {
  return i.x - t.x;
}
function q4(i, t) {
  var e = function(n, s) {
    var o, a = s, l = n.x, h = n.y, u = -1 / 0;
    do {
      if (h <= a.y && h >= a.next.y && a.next.y !== a.y) {
        var c = a.x + (h - a.y) * (a.next.x - a.x) / (a.next.y - a.y);
        if (c <= l && c > u && (u = c, o = a.x < a.next.x ? a : a.next, c === l)) return o;
      }
      a = a.next;
    } while (a !== s);
    if (!o) return null;
    var f, d = o, p = o.x, g = o.y, m = 1 / 0;
    a = o;
    do
      l >= a.x && a.x >= p && l !== a.x && Ka(h < g ? l : u, h, p, g, h < g ? u : l, h, a.x, a.y) && (f = Math.abs(h - a.y) / (l - a.x), gu(a, n) && (f < m || f === m && (a.x > o.x || a.x === o.x && Y4(o, a))) && (o = a, m = f)), a = a.next;
    while (a !== d);
    return o;
  }(i, t);
  if (!e) return t;
  var r = XM(e, i);
  return Zo(r, r.next), Zo(e, e.next);
}
function Y4(i, t) {
  return Fn(i.prev, i, t.prev) < 0 && Fn(t.next, i, i.next) < 0;
}
function T0(i, t, e, r, n) {
  return (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = (i - e) * n | 0) | i << 8)) | i << 4)) | i << 2)) | i << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - r) * n | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1;
}
function J4(i) {
  var t = i, e = i;
  do
    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
  while (t !== i);
  return e;
}
function Ka(i, t, e, r, n, s, o, a) {
  return (n - o) * (t - a) >= (i - o) * (s - a) && (i - o) * (r - a) >= (e - o) * (t - a) && (e - o) * (s - a) >= (n - o) * (r - a);
}
function K4(i, t) {
  return i.next.i !== t.i && i.prev.i !== t.i && !function(e, r) {
    var n = e;
    do {
      if (n.i !== e.i && n.next.i !== e.i && n.i !== r.i && n.next.i !== r.i && ZM(n, n.next, e, r)) return !0;
      n = n.next;
    } while (n !== e);
    return !1;
  }(i, t) && (gu(i, t) && gu(t, i) && function(e, r) {
    var n = e, s = !1, o = (e.x + r.x) / 2, a = (e.y + r.y) / 2;
    do
      n.y > a != n.next.y > a && n.next.y !== n.y && o < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (s = !s), n = n.next;
    while (n !== e);
    return s;
  }(i, t) && (Fn(i.prev, i, t.prev) || Fn(i, t.prev, t)) || Wd(i, t) && Fn(i.prev, i, i.next) > 0 && Fn(t.prev, t, t.next) > 0);
}
function Fn(i, t, e) {
  return (t.y - i.y) * (e.x - t.x) - (t.x - i.x) * (e.y - t.y);
}
function Wd(i, t) {
  return i.x === t.x && i.y === t.y;
}
function ZM(i, t, e, r) {
  var n = kc(Fn(i, t, e)), s = kc(Fn(i, t, r)), o = kc(Fn(e, r, i)), a = kc(Fn(e, r, t));
  return n !== s && o !== a || !(n !== 0 || !Oc(i, e, t)) || !(s !== 0 || !Oc(i, r, t)) || !(o !== 0 || !Oc(e, i, r)) || !(a !== 0 || !Oc(e, t, r));
}
function Oc(i, t, e) {
  return t.x <= Math.max(i.x, e.x) && t.x >= Math.min(i.x, e.x) && t.y <= Math.max(i.y, e.y) && t.y >= Math.min(i.y, e.y);
}
function kc(i) {
  return i > 0 ? 1 : i < 0 ? -1 : 0;
}
function gu(i, t) {
  return Fn(i.prev, i, i.next) < 0 ? Fn(i, t, i.next) >= 0 && Fn(i, i.prev, t) >= 0 : Fn(i, t, i.prev) < 0 || Fn(i, i.next, t) < 0;
}
function XM(i, t) {
  var e = new A0(i.i, i.x, i.y), r = new A0(t.i, t.x, t.y), n = i.next, s = t.prev;
  return i.next = t, t.prev = i, e.next = n, n.prev = e, r.next = e, e.prev = r, s.next = r, r.prev = s, r;
}
function Zx(i, t, e, r) {
  var n = new A0(i, t, e);
  return r ? (n.next = r.next, n.prev = r, r.next.prev = n, r.next = n) : (n.prev = n, n.next = n), n;
}
function mu(i) {
  i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
}
function A0(i, t, e) {
  this.i = i, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function M0(i, t, e, r) {
  for (var n = 0, s = t, o = e - r; s < e; s += r) n += (i[o] - i[s]) * (i[s + 1] + i[o + 1]), o = s;
  return n;
}
w0.exports = Ec, w0.exports.default = Ec, Ec.deviation = function(i, t, e, r) {
  var n = t && t.length, s = n ? t[0] * e : i.length, o = Math.abs(M0(i, 0, s, e));
  if (n) for (var a = 0, l = t.length; a < l; a++) {
    var h = t[a] * e, u = a < l - 1 ? t[a + 1] * e : i.length;
    o -= Math.abs(M0(i, h, u, e));
  }
  var c = 0;
  for (a = 0; a < r.length; a += 3) {
    var f = r[a] * e, d = r[a + 1] * e, p = r[a + 2] * e;
    c += Math.abs((i[f] - i[p]) * (i[d + 1] - i[f + 1]) - (i[f] - i[d]) * (i[p + 1] - i[f + 1]));
  }
  return o === 0 && c === 0 ? 0 : Math.abs((c - o) / o);
}, Ec.flatten = function(i) {
  for (var t = i[0][0].length, e = {
    vertices: [],
    holes: [],
    dimensions: t
  }, r = 0, n = 0; n < i.length; n++) {
    for (var s = 0; s < i[n].length; s++) for (var o = 0; o < t; o++) e.vertices.push(i[n][s][o]);
    n > 0 && (r += i[n - 1].length, e.holes.push(r));
  }
  return e;
};
var Xx = w0.exports;
const Q4 = {
  "clip-inside": 0.1,
  "clip-outside": 0.2,
  "flat-inside": 0.3,
  "flat-outside": 0.4,
  color: 0.5,
  video: 0.6,
  elevate: 0.7
}, tL = [], eL = [1, 1, 1], qx = {
  polygonFill: [255, 0, 0],
  polygonOpacity: 0.8
}, Cg = new lt(0, 0), Pg = new lt(0, 0), Rc = [], ps = new lt(0, 0), nL = new Y(0, 0), rL = new Y(0, 0), iL = new Y(0, 0);
let Pl = class extends vn {
  getMode() {
    return this.Hs;
  }
  remove() {
    const t = this.getLayer();
    return t ? (t.removeMask(this), this.Ns(), super.remove(), this) : this;
  }
  getMesh(t, e, r) {
    return this.isVisible() ? (this.xt || (this.xt = this.ze(t, e, r)), this.Gs(this.xt, e, r), this.xt) : null;
  }
  js(t) {
    const e = this.getMap(), r = this.toGeoJSON(), n = Xx.flatten(r.geometry.coordinates);
    for (let u = 0; u < n.vertices.length; u += 2) {
      ps.x = n.vertices[u], ps.y = n.vertices[u + 1];
      const c = vg(e, ps);
      n.vertices[u] = c[0], n.vertices[u + 1] = c[1];
    }
    const s = vg(e, this.getCenter()), o = [], a = this.getMode() === "video" ? 4 : n.vertices.length / 2;
    for (let u = 0; u < a; u++) o.push(n.vertices[2 * u] - s[0]), o.push(n.vertices[2 * u + 1] - s[1]), o.push(0);
    const l = Xx(o, n.holes, 3), h = new er({
      POSITION: o,
      TEXCOORD: this.Bs(n.vertices)
    }, l, 0, {
      positionAttribute: "POSITION",
      uv0Attribute: "TEXCOORD"
    });
    return h.generateBuffers(t), h;
  }
  Bs(t) {
    const e = [0, 0, 1, 0, 1, 1, 0, 1];
    if (this.hasHoles()) for (let r = e.length / 2 - 1; r < t.length; r += 2) e[r] = e[r + 1] = 0;
    return e;
  }
  Us() {
    this.Ns(), delete this.xt;
  }
  zs() {
    return Q4[this.Hs];
  }
  Vs() {
    const t = this.getSymbol(), { polygonFill: e, polygonOpacity: r } = t || qx, n = BM([], e);
    return n[0] /= 255, n[1] /= 255, n[2] /= 255, n[3] = Ud(r) ? r : qx.polygonOpacity, n;
  }
  Ws(t = 0) {
    const e = this.getMap(), r = e.getGLRes();
    return e.altitudeToPoint(t, r);
  }
  qs(t) {
    const e = vg(this.getMap(), this.getCenter()), r = Nl(t.localTransform, Kv(tL), e, eL);
    t.localTransform = r;
  }
  Ns() {
    this.xt && (this.xt.material && this.xt.material.dispose(), this.xt.geometry && this.xt.geometry.dispose(), this.xt.dispose(), delete this.xt);
  }
  containsPoint(t) {
    const e = this.getExtent();
    if (ps.x = t[0], ps.y = t[1], !e.contains(ps)) return !1;
    const r = this.getHoles();
    for (let s = 0; s < r.length; s++) if (this.$s(r[s], t)) return !1;
    const n = this.getShell();
    return this.$s(n, t);
  }
  $s(t, e) {
    const r = this.Ys(t);
    let n = 0;
    for (let s = 0; s < t.length; s++) {
      Cg.x = t[s].x, Cg.y = t[s].y;
      const o = s + 1 >= t.length ? 0 : s + 1;
      Pg.x = t[o].x, Pg.y = t[o].y, ps.x = e[0], ps.y = e[1], Rc[0] = ps, Rc[1] = Cg, Rc[2] = Pg, n += this.Ys(Rc);
    }
    return !(Math.abs(n - r) > 1e-8);
  }
  Ys(t) {
    const e = this.getMap();
    let r = 0;
    const n = e.getGLRes(), s = e.coordToPointAtRes(t[0], n, nL);
    for (let h = 1; h < t.length - 1; h++) {
      const u = e.coordToPointAtRes(t[h], n, rL), c = e.coordToPointAtRes(t[h + 1], n, iL);
      r += Math.abs((o = s, l = c, ((a = u).x - o.x) * (l.y - o.y) - (a.y - o.y) * (l.x - o.x))) / 2;
    }
    var o, a, l;
    return r;
  }
};
const sL = ["shapechange", "heightrangechange", "flatheightchange"], wa = new lt(0, 0), oL = [], aL = [];
function lL() {
  return this._maskList ? (this._maskList.forEach((i) => {
    i.remove();
  }), this._maskList = [], this.updateExtent("shapechange"), this) : this;
}
function hL(i) {
  const t = this.getMap(), e = t.getView(), r = t.getFitZoom(i), n = i.getCenter();
  t.setView({
    center: n,
    zoom: r,
    pitch: 0,
    bearing: 0
  });
  const s = t.getExtent(), o = Hi([], t.projViewMatrix);
  return t.setView(e), {
    mapExtent: s,
    projViewMatrix: o
  };
}
function uL() {
  for (let i = 0; i < this._maskList.length; i++) if (this._maskList[i].isVisible()) return !0;
  return !1;
}
function cL(i) {
  return class extends i {
    removeMask(t) {
      if (!this._maskList) return this;
      if (!t) return lL.call(this), this;
      const e = Array.isArray(t) ? t : [t];
      for (let r = 0; r < e.length; r++) {
        const n = e[r], s = this._maskList.indexOf(n);
        s > -1 && this._maskList.splice(s, 1);
      }
      return this.updateExtent("shapechange"), this;
    }
    setMask(t) {
      return this.removeMask(), this._maskList || (this._maskList = []), Array.isArray(t) ? t.forEach((e) => {
        this._maskList.push(e);
      }) : this._maskList.push(t), this._maskList.forEach((e) => {
        e._bindLayer(this), e.Xs && e.Xs();
      }), this.updateExtent("shapechange"), this;
    }
    onAdd() {
      super.onAdd(), this.updateExtent("shapechange");
    }
    getMasks() {
      return this._maskList || [];
    }
    _onGeometryEvent(t) {
      if (!t || !t.target) return;
      const e = t.type;
      e === "shapechange" && t.target instanceof Pl && t.target.Us(), t.target instanceof Pl && sL.indexOf(e) > -1 && this.updateExtent(e), super._onGeometryEvent && super._onGeometryEvent(t);
    }
    identifyMask(t, e) {
      if (!this.getMap()) return [];
      if (!this._maskList || !this._maskList.length) return [];
      const r = lr({}, e);
      r.excludeMasks = !0;
      const n = this.identifyAtPoint(t, r), s = n.length && n[0].coordinate;
      return s ? this._hitMasks(s) : [];
    }
    _hitMasks(t) {
      const e = this._maskList;
      if (!e) return [];
      const r = [];
      for (let n = 0; n < e.length; n++) {
        const s = e[n].getMode();
        !e[n].containsPoint(t) || s !== "color" && s !== "video" || r.push(e[n]);
      }
      return r;
    }
    remove() {
      this._maskList && this._maskList.length && this._maskList.forEach((t) => {
        t.remove();
      }), super.remove();
    }
    updateMask(t) {
      const e = this.getMap(), { projViewMatrix: r, mapExtent: n } = hL.call(this, t);
      wa.x = n.xmin, wa.y = n.ymin;
      const s = Yx(oL, wa, e);
      wa.x = n.xmax, wa.y = n.ymax;
      const o = Yx(aL, wa, e);
      return {
        projViewMatrix: r,
        extentInWorld: [s[0], s[1], o[0], o[1]]
      };
    }
    updateExtent(t) {
      if (!this._maskList || !this.getMap()) return;
      const e = this.getRenderer();
      if (e && !this._maskList.length) return void e._clearMask();
      if (e && !uL.call(this)) return e._deleteMaskUniforms(), void e.setToRedraw();
      const r = this.getMaskExtent();
      if (!r) return;
      const { extent: n, ratio: s, minHeight: o } = r;
      if (t || !this._projViewMatrix || !this._projViewMatrix) {
        const { projViewMatrix: a, extentInWorld: l } = this.updateMask(n);
        this._projViewMatrix = a, this.Js = l;
      }
      e ? e.setMask(this.Js, this._projViewMatrix, s, o) : this.once("renderercreate", (a) => {
        a.renderer.setMask(this.Js, this._projViewMatrix, s, o);
      });
    }
    getMaskExtent() {
      let t = 1 / 0, e = 1 / 0, r = -1 / 0, n = -1 / 0, s = -1 / 0, o = 1 / 0, a = !1;
      for (let u = 0; u < this._maskList.length; u++) {
        const c = this._maskList[u];
        if (!c.isVisible()) continue;
        const f = c.getExtent();
        if (f && this.Zs(f) && (a = !0, f.xmin < t && (t = f.xmin), f.ymin < e && (e = f.ymin), f.xmax > r && (r = f.xmax), f.ymax > n && (n = f.ymax), c.Ks)) {
          const d = c.Ks();
          d[0] < o && (o = d[0]), d[1] > s && (s = d[1]);
        }
      }
      if (!a) return null;
      const { ratio: l, minHeight: h } = function(u, c) {
        const f = u === 1 / 0 ? 0 : u, d = c === -1 / 0 ? 0 : c, p = Math.abs(d - f);
        return p === 0 ? {
          ratio: 1,
          minHeight: 0
        } : {
          ratio: Math.pow(p, -1),
          minHeight: f
        };
      }(o, s);
      return {
        extent: new dn(t, e, r, n),
        ratio: l,
        minHeight: h
      };
    }
    Zs(t) {
      return this.getMap().getExtent().intersects(t);
    }
  };
}
function Yx(i, t, e, r = 0) {
  if (!(e && t instanceof lt)) return null;
  const n = e.coordinateToPointAtRes(t, e.getGLRes());
  return i[0] = n.x, i[1] = n.y, i[2] = r, i;
}
const fL = new lt(0, 0), dL = new lt(0, 0), sh = new Y(0, 0), Jx = [], Eg = {
  tileGrids: [],
  count: 0
}, pL = "01", gL = "1";
let Cf = class extends cL(Pn) {
  constructor(t, e) {
    e && !e.tileSystem && (e.type === "cesium" || e.type === "cesium-ion" ? e.tileSystem = [1, 1, -180, -90] : e.type === "tianditu" && (e.tileSystem = [1, -1, -180, 90])), super(t, e);
  }
  getTileUrl(t, e, r) {
    let n = super.getTileUrl(t, e, r);
    return this.options.type === "mapbox" && this.options.requireSkuToken && (this.Qs || (this.Qs = this.tn()), n.indexOf("?") > -1 ? n += "&sku=" + this.Qs : n += "?sku=" + this.Qs), n;
  }
  getMaxAvailableZoom() {
    return this.getSpatialReference().getMaxZoom();
  }
  tn() {
    let t = "";
    for (let e = 0; e < 10; e++) t += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
    return [gL, pL, t].join("");
  }
  setSkinLayers(t) {
    this.in = t;
    const e = this.getRenderer();
    e && (e.clear(), e.setToRedraw());
  }
  getSkinTiles(t) {
    const e = this.getRenderer();
    if (!e) return Eg;
    const r = e.getTileGridsInCurrentFrame().tileGrids[0];
    if (!r) return Eg;
    const n = t.getId(), s = this._getTileConfig().tileSystem.scale, o = t.getTileSize().width, a = r.tiles;
    if (!a.length) return Eg;
    const l = this.getMap(), h = r.parents || Jx, u = h.length, c = h.concat(a), f = t.getSpatialReference(), d = a[0].extent2d.getWidth(), p = s.x, g = s.y, m = [], v = [], _ = /* @__PURE__ */ new Set(), y = this._getTileConfig().tileSystem.scale.y;
    for (let x = 0; x < c.length; x++) {
      const w = c[x], { res: b } = w;
      let T = w.nw;
      T || (T = w.nw = l.pointAtResToCoord(w.extent2d.getMin(sh), w.res));
      const { res: A, zoom: M } = _0(f, w.z, b), S = A / b, P = y0(A, o, b, d), { extent2d: C, offset: k } = w, O = P * w.x, R = P * w.y;
      if (w.skinTileIds || (w.skinTileIds = {}), !w.skinTileIds[n]) {
        const D = /* @__PURE__ */ new Set(), z = [], H = $M(t, w.x, w.y, M, T, k, g, P, 0);
        for (let G = 0; G < H.length; G++) {
          const $ = H[G];
          if (D.has($.id)) continue;
          $.idx = $.x, $.idy = $.y, $.res = A, $.url = t.getTileUrl($.x, $.y, $.z + t.options.zoomOffset);
          const K = p * ($.x - O) * o, dt = g * ($.skinY - R) * o, it = C.xmin * S + K, st = C.ymax * S + dt, pt = C.ymin * S + dt;
          $.extent2d = y > 0 ? new Se(it, pt, it + o, pt + o) : new Se(it, st - o, it + o, st), D.add($.id), z.push($);
        }
        w.skinTileIds[n] = z;
      }
      const I = w.skinTileIds[n];
      for (let D = 0; D < I.length; D++) _.has(I[D].id) || (x < u ? m.push(I[D]) : v.push(I[D]), _.add(I[D].id));
    }
    return {
      tileGrids: [{
        extent: r.extent,
        tiles: v,
        parents: m,
        count: v.length
      }],
      count: v.length
    };
  }
  getSkinLayer(t) {
    return this.getSkinLayers()[t];
  }
  getSkinLayers() {
    return this.in || Jx;
  }
  getSkinCount() {
    return this.in && this.in.length || 0;
  }
  queryTerrainByProjCoord(t, e) {
    e = e || [];
    const r = this.getRenderer();
    if (!r) return e[0] = null, e[1] = 0, e;
    const n = this.getMap(), s = r.ks(t);
    if (!s) return e[0] = null, e[1] = 0, e;
    const o = n._prjToPointAtRes(t, 1, sh);
    return r.As(e, s.id, s, o, 1);
  }
  queryTileTerrainByProjCoord(t, e, r, n) {
    n = n || [];
    const s = this.getRenderer();
    if (!s) return n[0] = null, n[1] = 0, n;
    const o = this.getMap()._prjToPointAtRes(t, 1, sh);
    return s.As(n, e, r, o, 1);
  }
  queryTileTerrainByPointAtRes(t, e, r, n, s) {
    s = s || [];
    const o = this.getRenderer();
    return o ? o.As(s, r, n, t, e) : (s[0] = null, s[1] = 0, s);
  }
  queryTerrain(t, e) {
    if (e = e || [], !this.getRenderer()) return e[0] = null, e[1] = 0, e;
    const r = this.getMap().getProjection().project(t, fL);
    return this.queryTerrainByProjCoord(r, e);
  }
  queryTileMesh(t, e) {
    const r = this.getRenderer();
    r && r.en(t, e);
  }
  getTerrainTiles(t) {
    const { x: e, y: r, z: n, res: s, offset: o } = t, a = t.extent2d.getWidth(), l = this._getTileConfig(), h = this.getSpatialReference(), { res: u, zoom: c } = _0(h, n, s), f = this.getTileSize().width, d = y0(u, f, s, a);
    let p = t.nw;
    p || (p = t.nw = this.getMap().pointAtResToCoord(t.extent2d.getMin(sh), t.res));
    const g = UM(this, e, r, c, p, o, l.tileSystem.scale.y, d, 1)[0];
    for (let m = 0; m < g.length; m++) {
      const { x: v, y: _ } = g[m], y = l.getTilePointNW(v, _, u, sh);
      g[m].res = u, g[m].extent2d = new Se(y.x, y.y, y.x + f, y.y - f);
    }
    return g;
  }
  isTerrainTileLoaded(t) {
    const e = this.getRenderer();
    return !!e && e.isTileCached(t);
  }
  updateMaterial(t) {
    if (!t) return;
    this.options.material || (this.options.material = {}), lr(this.options.material, t);
    const e = this.getRenderer();
    e && e.updateMaterial(t);
  }
  setMaterial(t) {
    if (!t) return;
    this.options.material = t;
    const e = this.getRenderer();
    e && e.setMaterial(t);
  }
  Cs(t, e, r, n, s, o, a, l, h, u) {
    const c = this.getMap(), f = this.options.zoomOffset;
    h || (h = this._getTileConfig().getTilePrjExtent(t, e, o).convertTo((p) => c._prjToPointAtRes(p, o, dL)));
    const d = this._getTileOffset(r);
    return {
      parent: l,
      layer: this.getId(),
      x: t,
      y: e,
      z: r,
      idx: n,
      idy: s,
      res: o,
      extent2d: h,
      id: u || this._getTileId(t, e, r),
      url: this.getTileUrl(t, e, r + f),
      offset: d,
      error: a,
      children: []
    };
  }
};
Cf.mergeOptions({
  forceRenderOnMoving: !0,
  forceRenderOnZooming: !0,
  forceRenderOnRotating: !0,
  fadeAnimation: !1,
  fadeDuration: 1e3 / 60 * 15,
  tileLimitPerFrame: 2,
  newTerrainTileRenderLimitPerFrameOnInteracting: 1,
  opacity: 1,
  renderer: "gl",
  pyramidMode: 1,
  tileSize: 256,
  terrainWidth: 65,
  backZoomOffset: 0,
  depthMask: !0,
  blendSrc: "one",
  blendDst: "one minus src alpha",
  requireSkuToken: !0,
  cesiumIonTokenURL: "https://api.cesium.com/v1/assets/1/endpoint?access_token=",
  tileRetryCount: 0,
  shader: "default",
  terrainTileMode: !0,
  tempTileCacheSize: 64,
  tileStackStartDepth: 7,
  tileStackDepth: 6,
  currentTilesFirst: !1
}), Cf.registerJSONType("TerrainLayer"), Cf.registerRenderer("gl", B4);
const Kx = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1], Ic = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23], Ji = [], Qx = [], mL = [], vL = [], Og = [], yL = [], _L = [], xL = [], kg = new Y(0, 0), bL = [], wL = [], TL = [], AL = [], t2 = [], e2 = [], n2 = [], ML = [], SL = [], CL = [], r2 = [];
let qM = class {
  constructor(t, e, r = {}) {
    this.setFromPoint(t), this.setToPoint(e), this.sn = r, this.nn = {}, this.rn = 0;
  }
  setFromPoint(t) {
    this.hn = this.an(t), this.cn();
  }
  setToPoint(t) {
    this.ln = this.an(t), this.cn();
  }
  setOptions(t) {
    this.sn = t;
  }
  cn() {
    this.nn = {}, this.rn++;
  }
  test(t, e) {
    const r = [];
    for (let n = 0; n < t.length; n++) {
      const s = t[n], o = s.uuid + "-" + s.version + "-" + s.geometry.version + "-" + this.rn;
      if (this.nn[o]) {
        r.push(this.nn[o]);
        continue;
      }
      if (!this.un(s.getBoundingBox(), e)) continue;
      const a = s.localTransform, l = s.geometry, h = l.data[l.desc.positionAttribute].array, u = l.data[l.desc.altitudeAttribute] && l.data[l.desc.altitudeAttribute].array || bL, c = l.indices;
      if (!h || !c) {
        console.warn("there are no POSITION or inidces in mesh");
        continue;
      }
      const f = Jt(AL, a, s.positionMatrix), d = this.dn(s, e, h, u, c, l.desc.positionSize, f);
      if (d) {
        const p = {
          mesh: s,
          coordinates: d
        };
        r.push(p), this.nn[o] = p;
      }
    }
    return r;
  }
  dn(t, e, r, n, s, o, a) {
    const l = Dc(e, this.hn.x, this.hn.y, this.hn.z), h = Dc(e, this.ln.x, this.ln.y, this.ln.z), u = we(mL, l, h), c = [];
    for (let f = 0; f < s.length && !(f > t.properties.skirtOffset); f += 3) {
      const d = s[f], p = s[f + 1], g = s[f + 2], m = ne(t2, r[d * o], r[d * o + 1], r[d * o + 2]), v = this.pn(yL, e, m, n[d] / 100, a), _ = ne(e2, r[p * o], r[p * o + 1], r[p * o + 2]), y = this.pn(_L, e, _, n[p] / 100, a), x = ne(n2, r[g * o], r[g * o + 1], r[g * o + 2]), w = this.pn(xL, e, x, n[g] / 100, a), b = ne(Qx, v, y, w), T = Ti(wL, v, y), A = Ti(TL, v, w), M = this.gn(r2, b, u);
      if (M) {
        if (!M[0] || !M[1]) continue;
        const S = e.pointAtResToAltitude(M[2], e.getGLRes());
        kg.x = M[0], kg.y = M[1];
        const P = e.pointAtResToCoordinate(kg, e.getGLRes());
        P.z = S, c.push({
          coordinate: P,
          indices: [d, p, g],
          normal: hi([], T, A)
        });
      }
    }
    return c.length ? c : null;
  }
  pn(t, e, r, n, s) {
    let o;
    return Yr.isNumber(n) ? (o = e.altitudeToPoint(n, e.getGLRes()), Sr(t, r[0], r[1], 0, 1), ho(t, t, s), t[2] = o) : (o = r[2], Sr(t, r[0], r[1], o, 1), ho(t, t, s)), t;
  }
  gn(t, e, r) {
    const n = e[0], s = e[1], o = e[2], a = r[0], l = r[1], h = a[0], u = a[1], c = a[2], f = l[0] - a[0], d = l[1] - a[1], p = l[2] - a[2];
    let g = 0, m = 0, v = 0;
    n[0] === s[0] && n[0] === o[0] ? g = 1 : n[1] === s[1] && n[1] === o[1] ? m = 1 : n[2] === s[2] && n[2] === o[2] ? v = 1 : (g = (e[2][1] - e[0][1]) * (e[2][2] - e[0][2]) - (e[1][2] - e[0][2]) * (e[2][1] - e[0][1]), m = (e[2][0] - e[0][0]) * (e[1][2] - e[0][2]) - (e[1][0] - e[0][0]) * (e[2][2] - e[0][2]), v = (e[1][0] - e[0][0]) * (e[2][1] - e[0][1]) - (e[2][0] - e[0][0]) * (e[1][1] - e[0][1]));
    const _ = -(g * e[0][0] + m * e[0][1] + v * e[0][2]), y = g * f + m * d + v * p;
    if (y === 0) return null;
    const x = -(g * h + m * u + v * c + _) / y, w = f * x + h, b = d * x + u, T = p * x + c, A = ne(vL, w, b, T);
    return this.mn(e, A) && (this.sn.allowPointNotOnLine || this.vn(r, A)) ? ne(t, w, b, T) : null;
  }
  mn(t, e) {
    const r = this.sn.tolerance || 1;
    if (!this.wn(t, e)) return !1;
    const n = t[0], s = t[1], o = t[2], a = e;
    n[2] = s[2] = o[2] = a[2] = 0;
    const l = this.Ys(n, s, o), h = this.Ys(a, n, s), u = this.Ys(a, n, o), c = this.Ys(a, s, o);
    return !(Math.abs(h + u + c - l) > r);
  }
  wn(t, e) {
    const r = this.sn.tolerance || 1, n = t[0], s = t[1], o = t[2], a = Rg(n, s, o, 0) - r, l = Rg(n, s, o, 1) - r, h = Rg(n, s, o, 2) - r, u = Ig(n, s, o, 0) + r, c = Ig(n, s, o, 1) + r, f = Ig(n, s, o, 2) + r;
    return e[0] >= a && e[0] <= u && e[1] >= l && e[1] <= c && e[2] >= h && e[2] <= f;
  }
  vn(t, e) {
    const r = this.sn.tolerance || 1, n = t[0], s = t[1], o = e, a = qa(Ti(Og, n, s)), l = qa(Ti(Og, n, o)), h = qa(Ti(Og, s, o));
    return !(Math.abs(l + h - a) > r);
  }
  Ys(t, e, r) {
    const n = Ti(ML, e, t), s = Ti(SL, r, t), o = hi(CL, n, s);
    return 0.5 * qa(o);
  }
  an(t) {
    return t instanceof lt ? t : Array.isArray(t) ? new lt(t) : null;
  }
  un(t, e) {
    const r = [Dc(e, this.hn.x, this.hn.y, this.hn.z), Dc(e, this.ln.x, this.ln.y, this.ln.z)], n = t[0], s = t[1];
    for (let o = 0; o < Kx.length; o += 3) for (let a = 0; a < 3; a++) {
      const l = o + a;
      Ji[l] = Kx[l] > 0 ? s[a] : n[a];
    }
    for (let o = 0; o < Ic.length; o += 3) {
      const a = Ic[o], l = Ic[o + 1], h = Ic[o + 2], u = ne(t2, Ji[3 * a], Ji[3 * a + 1], Ji[3 * a + 2]), c = ne(e2, Ji[3 * l], Ji[3 * l + 1], Ji[3 * l + 2]), f = ne(n2, Ji[3 * h], Ji[3 * h + 1], Ji[3 * h + 2]), d = ne(Qx, u, c, f);
      if (this.gn(r2, d, r)) return !0;
    }
    return !1;
  }
};
const i2 = new lt(0, 0);
function Dc(i, t, e, r) {
  if (!i) return null;
  i2.set(t, e);
  const n = i.coordinateToPointAtRes(i2, i.getGLRes()), s = i.altitudeToPoint(r || 0, i.getGLRes());
  return [n.x, n.y, s];
}
function Rg(i, t, e, r) {
  let n = i[r];
  return n > t[r] && (n = t[r]), n > e[r] && (n = e[r]), n;
}
function Ig(i, t, e, r) {
  let n = i[r];
  return n < t[r] && (n = t[r]), n < e[r] && (n = e[r]), n;
}
const Dg = () => {
}, PL = new lt(0, 0), EL = new lt(0, 0), OL = [], oh = [0, 0, 0], Ta = [0, 0, 0, 1], Aa = [0, 0, 0, 1];
let Ph = class S0 extends gr {
  static fromJSON(t) {
    if (!t || t.type !== "GroupGLLayer") return null;
    const e = t.layers.map((r) => gr.fromJSON(r));
    return new S0(t.id, e, t.options);
  }
  constructor(t, e, r) {
    super(t, r), this.layers = e && e.slice() || [], this.layers.forEach((n) => {
      if (n.getMap()) throw new Error(`layer(${n.getId()} is already added on map`);
    }), this._n(), this.sortLayersByZIndex(), this.Mn = {};
  }
  sortLayersByZIndex() {
    if (this.layers && this.layers.length) {
      for (let t = 0, e = this.layers.length; t < e; t++) this.layers[t].__group_gl_order = t;
      this.layers.sort(RL);
    }
  }
  setSceneConfig(t) {
    this.options.sceneConfig = t;
    const e = this.getRenderer();
    return e && e.updateSceneConfig(), this;
  }
  getSceneConfig() {
    return JSON.parse(JSON.stringify(this.ut()));
  }
  ut() {
    return this.options.sceneConfig || {};
  }
  getGroundConfig() {
    return this.ut().ground;
  }
  getWeatherConfig() {
    return this.ut().weather;
  }
  addLayer(t, e) {
    if (t.getMap()) throw new Error(`layer(${t.getId()}) is already added on map`);
    if (t.options.renderer !== "gl") throw new Error(`layer(${t.getId()})'s renderer is canvas, not supported to be added to GroupGLLayer`);
    e === void 0 ? this.layers.push(t) : this.layers.splice(e, 0, t), this._n(), this.sortLayersByZIndex();
    const r = this.getRenderer();
    return r ? (this.xn(t), this.yn(), r.setToRedraw(), this) : this;
  }
  removeLayer(t) {
    Yr.isString(t) && (t = this.getChildLayer(t));
    const e = this.layers.indexOf(t);
    if (e < 0) return this;
    const r = t.getRenderer();
    r && r.setTerrainHelper && r.setTerrainHelper(null), t._doRemove(), this.bn(t), delete this.Mn[t.getId()], this.layers.splice(e, 1);
    const n = this.getRenderer();
    return n ? (this.yn(), n.setToRedraw(), this) : this;
  }
  clearLayers() {
    const t = this.getLayers();
    for (let e = 0; e < t.length; e++) t[e] && t[e].remove();
    return this;
  }
  ki() {
    let t = 0;
    for (let r = 0; r < this.layers.length; r++) this.layers[r].setPolygonOffset && this.layers[r].getPolygonOffsetCount && (t += this.layers[r].getPolygonOffsetCount());
    let e = 0;
    for (let r = this.layers.length - 1; r >= 0; r--) this.layers[r].setPolygonOffset && this.layers[r].getPolygonOffsetCount && (this.layers[r].setPolygonOffset(e, t), e += this.layers[r].getPolygonOffsetCount());
    this.Sn = e;
  }
  getPolygonOffsetCount() {
    return this.Sn;
  }
  getLayers() {
    return this.layers.slice();
  }
  ue() {
    return this.layers;
  }
  toJSON() {
    const t = [];
    if (this.layers) for (let e = 0; e < this.layers.length; e++) {
      const r = this.layers[e];
      r && r && r.toJSON && t.push(r.toJSON());
    }
    return {
      type: this.getJSONType(),
      id: this.getId(),
      layers: t,
      options: this.config()
    };
  }
  onLoadEnd() {
    this.layers.forEach((t) => {
      this.xn(t);
    }), this.options.terrain && this.Cn(), super.onLoadEnd();
  }
  xn(t) {
    const e = this.getMap();
    this.Mn[t.getId()] = t, t._canvas = this.getRenderer().canvas, t._bindMap(e), t.once("renderercreate", this.Tn, this), t.remove = () => {
      this.removeLayer(t), t.constructor.prototype.remove.call(t), delete t.remove;
    }, t.load(), this.kn(t);
  }
  onRemove() {
    this.An(), this.layers.forEach((t) => {
      this.On(t), t._doRemove(), this.bn(t);
    }), this.Mn = {}, this.clearAnalysis(), super.onRemove();
  }
  getChildLayer(t) {
    return this.Mn[t] || null;
  }
  getLayer(t) {
    return this.getChildLayer(t);
  }
  kn(t) {
    t.on("show hide", this.In, this), t.on("idchange", this.En, this);
  }
  bn(t) {
    t.off("show hide", this.In, this), t.off("idchange", this.En, this);
  }
  In() {
    const t = this.getRenderer();
    t && t.setToRedraw();
  }
  En(t) {
    const e = t.new, r = t.old, n = this.getLayer(r);
    delete this.Mn[r], this.Mn[e] = n;
  }
  Tn(t) {
    t.renderer.clearCanvas = kL;
  }
  _n() {
    const t = {};
    this.layers.forEach((e) => {
      const r = e.getId();
      if (t[r]) throw new Error(`Duplicate child layer id (${r}) in the GroupGLLayer (${this.getId()})`);
      t[r] = 1;
    });
  }
  addAnalysis(t) {
    this.wi = this.wi || [], this.wi.push(t);
    const e = this.getRenderer();
    e && e.setToRedraw();
  }
  removeAnalysis(t) {
    if (this.wi) {
      const r = this.wi.indexOf(t);
      r > -1 && (this.wi.splice(r, 1), t.remove());
    }
    const e = this.getRenderer();
    e && e.setToRedraw();
  }
  clearAnalysis() {
    this.wi && (this.wi.forEach((e) => {
      e.remove();
    }), this.wi = []);
    const t = this.getRenderer();
    t && t.setToRedraw();
  }
  identify(t, e = {}) {
    const r = this.getMap(), n = this.getRenderer();
    if (!r || !n) return [];
    const s = r.coordToContainerPoint(new lt(t));
    return this.identifyAtPoint(s, e);
  }
  identifyAtPoint(t, e = {}) {
    const r = e.includeInternals, n = this.getLayers(), s = e && e.childLayers || n, o = this.getMap();
    if (!o) return [];
    const a = du(e.count) ? 1 : e.count;
    let l = [];
    for (let h = s.length - 1; h >= 0; h--) {
      const u = s[h];
      if (n.indexOf(u) < 0 || !u.identifyAtPoint) continue;
      const c = u.options.geometryEvents;
      if (r && (c === void 0 || c === !1 || c === 0) || u.isGeometryListening && r && e.eventTypes.indexOf("mousemove") >= 0 && !u.isGeometryListening(e.eventTypes)) continue;
      let f = u.identifyAtPoint(t, e);
      if (!f || !f.length || (e.filter && (f = f.filter((p) => e.filter(p))), !f.length)) continue;
      const d = u.getId();
      for (let p = 0; p < f.length; p++) f[p] && (f[p].layer = d);
      l.push(...f);
    }
    if (e.orderByCamera) {
      const h = o.cameraPosition;
      l.sort((u, c) => c.point ? u.point ? Ya(u.point, h) - Ya(c.point, h) : 1 : -1);
    }
    return a && (l = l.slice(0, a)), l;
  }
  getTerrain() {
    return this.options.terrain;
  }
  setTerrain(t) {
    return this.options.terrain = t, this.getRenderer() ? (this.Cn(), this.getMap().updateCenterAltitude(), this) : this;
  }
  removeTerrain() {
    return this.setTerrain(null);
  }
  updateTerrainMaterial(t) {
    this.ce && t && (this.options.terrain.material ? lr(this.options.terrain.material, t) : this.options.terrain.material = t, this.ce.updateMaterial(t));
  }
  Cn() {
    const t = this.getRenderer();
    t && t.setToRedraw();
    const e = this.options.terrain;
    if (this.ce) {
      const n = this.ce.options;
      if (e && n.urlTemplate === e.urlTemplate && n.spatialReference === e.spatialReference) {
        for (const s in e) s === "material" ? this.ce.setMaterial(e[s]) : s !== "urlTemplate" && s !== "spatialReference" && this.ce.config(s, e[s]);
        return this;
      }
      this.An();
    }
    if (this.Ln(), !e) return this;
    this.ce = new Cf("__terrain_in_group", e), this.yn(), this.ce.on("tileload", this.Fn, this), this.xn(this.ce);
    const r = e.masks;
    return r && r.length ? this.ce.setMask(r) : this.ce.removeMask(), this.fire("terrainlayercreated"), this;
  }
  queryTerrain(t, e) {
    return this.ce ? this.ce.queryTerrain(t, e) : (e && (e[0] = null, e[1] = 0), [null, 0]);
  }
  queryTerrainAtPoint(t, e = {}) {
    if (!this.ce) return null;
    const r = this.map.getGLRes(), n = this.map, s = n.width / 2 || 1, o = n.height / 2 || 1, a = t;
    ne(oh, (a.x - s) / s, (o - a.y) / o, 0), ne(Ta, oh[0], oh[1], 0), ne(Aa, oh[0], oh[1], 0.5), Ta[3] = Aa[3] = 1, s2(Ta, Ta, n.projViewMatrixInverse), s2(Aa, Aa, n.projViewMatrixInverse);
    const l = new Y(Ta.slice(0, 3)), h = new Y(Aa.slice(0, 3)), u = n.pointAtResToCoordinate(l, r, PL);
    u.z = Ta[2] / n.altitudeToPoint(1, r);
    const c = n.pointAtResToCoordinate(h, r, EL);
    c.z = Aa[2] / n.altitudeToPoint(1, r), this.Rn ? (this.raycaster.setFromPoint(u), this.raycaster.setToPoint(c)) : (e.allowPointNotOnLine = !0, this.raycaster = new qM(u, c, e));
    const f = this.ce.getRenderer().getAnalysisMeshes(), d = this.raycaster.test(f, n), p = [], g = ne(OL, u.x, u.y, u.z);
    return d.forEach((m) => {
      m.coordinates.forEach((v) => {
        p.push(v.coordinate);
      });
    }), p.sort((m, v) => Ya(m.toArray(), g) - Ya(v.toArray(), g)), p[0];
  }
  queryTerrainByProjCoord(t, e) {
    return this.ce ? this.ce.queryTerrainByProjCoord(t, e) : (e && (e[0] = null, e[1] = 0), [null, 0]);
  }
  yn() {
    if (!this.ce) return;
    const t = this.layers, e = [];
    for (let r = 0; r < t.length; r++) {
      if (!t[r]) continue;
      const n = t[r], s = n.getRenderer();
      if (s.renderTerrainSkin) {
        if (s.deleteTile === Dg) {
          e.push(t[r]);
          continue;
        }
        n.getTiles = () => this.ce.getSkinTiles(n), s.drawTileOnTerrain ? s.drawTile = (...o) => s.drawTileOnTerrain(...o) : s.drawTile = Dg, s.deleteTile = Dg, e.push(t[r]);
      }
      s.setTerrainHelper && s.setTerrainHelper(this.ce);
    }
    this.ce.setSkinLayers(e);
  }
  On(t) {
    if (!function(r) {
      if (!r) return !1;
      const n = r.getRenderer();
      return n ? !!n.renderTerrainSkin : !1;
    }(t)) return;
    const e = t.getRenderer();
    e && (e.setTerrainHelper && e.setTerrainHelper(null), e.clear && e.clear(), delete e.drawTile, delete e.deleteTile), delete t.getTiles;
  }
  Ln() {
    const t = this.layers;
    for (let e = 0; e < t.length; e++) t[e] && this.On(t[e]);
  }
  Fn() {
    const t = this.getRenderer();
    t && t.setToRedraw();
  }
  An() {
    if (this.ce) {
      const t = this.ce;
      t.off("tileload", this.Fn, this), this.bn(t), this.ce._doRemove(), delete this.ce, this.fire("terrainlayerremoved");
    }
  }
  getTerrainLayer() {
    return this.ce;
  }
  _bindMap(...t) {
    if (this.options.single) {
      const e = t[0].getLayers();
      for (let r = 0; r < e.length; r++) if (e[r] instanceof S0) throw new Error("Only one GroupGLLayer is allowed in a map instance. Set options.single to false if you want to add two or more GroupGLLayers.");
    }
    return super._bindMap(...t);
  }
  fire(...t) {
    if (t[0] === "layerload") {
      const e = this.ue();
      for (const r of e) {
        const n = r.getRenderer();
        n && n.isRenderComplete() && r.fire("layerload");
      }
    }
    super.fire(...t);
  }
};
function kL() {
}
function RL(i, t) {
  const e = i.getZIndex() - t.getZIndex();
  return e === 0 ? i.__group_gl_order - t.__group_gl_order : e;
}
function s2(i, t, e) {
  const r = t[0], n = t[1], s = t[2], o = 1 / (e[3] * r + e[7] * n + e[11] * s + e[15]);
  return i[0] = (e[0] * r + e[4] * n + e[8] * s + e[12]) * o, i[1] = (e[1] * r + e[5] * n + e[9] * s + e[13]) * o, i[2] = (e[2] * r + e[6] * n + e[10] * s + e[14]) * o, i;
}
Ph.mergeOptions({
  renderer: "gl",
  antialias: !0,
  extensions: [],
  single: !0,
  onlyWebGL1: !1,
  optionalExtensions: ["ANGLE_instanced_arrays", "OES_element_index_uint", "OES_standard_derivatives", "OES_vertex_array_object", "OES_texture_half_float", "OES_texture_half_float_linear", "OES_texture_float", "OES_texture_float_linear", "WEBGL_depth_texture", "EXT_shader_texture_lod", "EXT_frag_depth", "EXT_texture_filter_anisotropic", "WEBGL_compressed_texture_astc", "WEBGL_compressed_texture_etc", "WEBGL_compressed_texture_etc1", "WEBGL_compressed_texture_pvrtc", "WEBGL_compressed_texture_s3tc", "WEBGL_compressed_texture_s3tc_srgb"],
  forceRenderOnZooming: !0,
  forceRenderOnMoving: !0,
  forceRenderOnRotating: !0,
  viewMoveThreshold: 100,
  geometryEvents: !0,
  multiSamples: 4,
  forceRedrawPerFrame: !1
}), Ph.registerJSONType("GroupGLLayer"), Ph.registerRenderer("gl", S4), Ph.registerRenderer("canvas", null);
let IL = class {
  constructor(t) {
    this.Pn = t, this.N = new Hd(), this.onHDRLoaded = this.Dn.bind(this), this.onHDRError = this.Hn.bind(this);
  }
  getDirectionalLight() {
    return this.jt && this.jt.directional || {};
  }
  getAmbientLight() {
    return this.jt && this.jt.ambient || {};
  }
  getAmbientResource() {
    return this.Nn;
  }
  setConfig(t) {
    const e = this.jt;
    this.Gn = t.urlModifier, this.jt = JSON.parse(JSON.stringify(t));
    let r = !1;
    if (t && t.ambient && t.ambient.resource) {
      if (!(e && e.ambient && function(n, s) {
        return !(!n.resource || n.resource.url !== s.resource.url);
      }(e.ambient, t.ambient))) return void this.jn();
      this.Nn && (t.ambient.prefilterCubeSize !== e.ambient && e.ambient.prefilterCubeSize && this.Dn(), r = !0, t.ambient.resource.sh && (this.Nn.sh = t.ambient.resource.sh));
    } else this.Bn(), r = e && e.ambient && e.ambient.resource;
    this.Pn.fire("updatelights", {
      ambientUpdate: r
    });
  }
  Un(t) {
    const e = t.getLayers();
    for (let s = 0; s < e.length; s++) {
      const o = e[s] && e[s].getRenderer();
      if (o && o.regl) return o.regl;
    }
    const r = document.createElement("canvas"), n = zu({
      canvas: r,
      attributes: {
        depth: !1,
        stencil: !1,
        alpha: !1
      }
    });
    return n.zn = !0, n;
  }
  jn() {
    const t = this.jt.ambient.resource, e = t && t.url;
    if (!e) return;
    const r = [];
    let n = 0, s = 0;
    const o = () => {
      s++, s >= n && this.Vn(r);
    }, a = function() {
      throw new Error(`skybox image with url(${this.src}) failed to load, please check the image's url.`);
    }, l = this.Gn;
    if (e.top || e.nx) {
      const { front: h, back: u, right: c, left: f, top: d, bottom: p } = e, { nx: g, ny: m, px: v, py: _, nz: y, pz: x } = e;
      let w;
      w = h ? [f, c, u, h, d, p] : [g, v, y, x, _, m], n = w.length;
      for (let b = 0; b < n; b++) {
        const T = new Image();
        T.onload = o, T.onerror = a, T.src = l && l(w[b]) || w[b], r[b] = T;
      }
    } else {
      const h = {
        url: t.url,
        arrayBuffer: !0,
        hdr: !0,
        flipY: !0
      };
      this.N.setURLModifier(l), this.Wn = new Bd(h, this.N), this.Wn.once("complete", this.onHDRLoaded), this.Wn.once("error", this.onHDRError);
    }
  }
  dispose() {
    this.Bn();
  }
  Dn() {
    this.Wn && (this.Nn = this.qn(this.Wn), this.Pn.fire("updatelights", {
      ambientUpdate: !0
    }));
  }
  Hn() {
    this.Pn.fire("hdrerror");
  }
  Vn(t) {
    this.Nn = this.qn(t), this.Pn.fire("updatelights", {
      ambientUpdate: !0
    });
  }
  qn(t) {
    const e = this.jt.ambient.resource, r = e.prefilterCubeSize || 128, n = this.Un(this.Pn), s = Kn.PBRHelper.createIBLMaps(n, {
      envTexture: Array.isArray(t) ? t : t.getREGLTexture(n),
      rgbmRange: Array.isArray(t) ? 9 : t.rgbmRange,
      ignoreSH: !!e.sh,
      envCubeSize: r,
      prefilterCubeSize: r,
      format: "array"
    });
    if (e.sh && (s.sh = e.sh, Array.isArray(s.sh[0]))) {
      const o = s.sh, a = [];
      for (let l = 0; l < o.length; l++) a.push(...o[l]);
      s.sh = a;
    }
    return n.zn && (delete this.Wn, n.destroy()), s;
  }
  Bn() {
    this.Wn && (this.Wn.dispose(), delete this.Wn), delete this.Nn;
  }
}, _i, Ma, o2, a2, Fg;
xe.include({
  setLights(i) {
    return this.options.lights = i, this.$n(), this;
  },
  getLights() {
    return this.options.lights;
  },
  $n() {
    this.Yn || (this.Yn = new IL(this)), this.Yn.setConfig(this.getLights());
  },
  getLightManager() {
    return this.Yn ? this.Yn : (this.Xn || (this.Xn = !0, console.warn("map's light config is not set, use map.setLights(config) to set lights.")), null);
  }
}), xe.addOnLoadHook(function() {
  this.options.lights && this.$n();
});
const DL = {
  color: [0, 0, 0, 0]
}, Lg = {
  enable: !0
};
xe.include({
  setPostProcessConfig(i) {
    return this.options.postProcessConfig = i, this;
  },
  getPostProcessConfig() {
    return this.options.postProcessConfig;
  }
});
const FL = zs.MapCanvasRenderer.prototype.drawLayerCanvas;
zs.MapCanvasRenderer.prototype.drawLayerCanvas = function() {
  const i = FL.apply(this, arguments);
  return i && zL(this, this.canvas), i;
};
const LL = zs.MapCanvasRenderer.prototype.renderFrame;
function zL(i, t) {
  const e = i.map.getPostProcessConfig();
  if (!e || !e.enable) return;
  var r, n;
  _i || (r = t.width, n = t.height, _i = document.createElement("canvas", r, n), Ma = zu({
    canvas: _i,
    attributes: {
      depth: !1,
      stencil: !1,
      alpha: !0,
      antialias: !1,
      premultipliedAlpha: !1
    }
  }), o2 = Ma.texture({
    mag: "linear",
    min: "linear",
    mipmap: !1,
    flipY: !0,
    width: r,
    height: n
  }), a2 = Ma.texture()), _i.width === t.width && _i.height === t.height || (_i.width = t.width, _i.height = t.height), Ma.clear(DL);
  const s = e.filmicGrain || Lg;
  s.enable === void 0 && (s.enable = !0);
  const o = e.vignette || Lg;
  o.enable === void 0 && (o.enable = !0);
  const a = e.colorLUT || Lg;
  a.enable === void 0 && (a.enable = !0), i.Jn || (i.Jn = {});
  const l = i.Jn;
  if (a.enable) {
    const u = a.lut;
    if (!l.lutTexture || l.lutTexture.url !== u) {
      const c = new Image();
      c.onload = function() {
        const f = {
          data: c,
          min: "linear",
          mag: "linear"
        }, d = l.lutTexture ? l.lutTexture.texture(f) : Ma.texture(f);
        l.lutTexture = {
          url: u,
          texture: d
        }, i.setLayerCanvasUpdated();
      }, c.src = u;
    }
  }
  const h = {
    enableGrain: +!!s.enable,
    grainFactor: s.factor === void 0 ? 0.15 : s.factor,
    timeGrain: performance.now(),
    enableVignette: +!!o.enable,
    lensRadius: o.lensRadius || [0.8, 0.25],
    frameMod: 1,
    enableLut: +!!a.enable,
    lookupTable: l.lutTexture ? l.lutTexture.texture : a2
  };
  Fg || (Fg = new GM(Ma)), Fg.postprocess(null, h, o2({
    width: _i.width,
    height: _i.height,
    data: t,
    flipY: !0,
    mag: "linear",
    min: "linear",
    mipmap: !1
  })), s.enable && i.setLayerCanvasUpdated(), i.context.drawImage(_i, 0, 0, _i.width, _i.height);
}
zs.MapCanvasRenderer.prototype.renderFrame = function() {
  const i = LL.apply(this, arguments), t = this.map.getPostProcessConfig(), e = t && t.filmicGrain;
  return !e || e.enable !== void 0 && e.enable !== !0 || this.setLayerCanvasUpdated(), i;
};
const NL = [];
function l2(i) {
  i.properties.showOnlyTimestamp && (delete i.properties.showOnlyTimestamp, cy(i));
}
function h2(i, t) {
  const e = i.geometry.properties;
  e.oldElementsBeforeHighlight || (e.oldElementsBeforeHighlight = i.geometry.elements), e.elements && (e.oldElementsArrBeforeHighlight || (e.oldElementsArrBeforeHighlight = e.elements), e.elements = t);
}
function cy(i) {
  const t = i.geometry.properties.oldElementsBeforeHighlight;
  t && i.geometry.elements !== t && (i.geometry.deleteElements(), i.geometry.setElements(i.geometry.properties.oldElementsBeforeHighlight), i.geometry.properties.oldElementsArrBeforeHighlight && (i.geometry.properties.elements = i.geometry.properties.oldElementsArrBeforeHighlight, delete i.geometry.properties.oldElementsArrBeforeHighlight), delete i.geometry.properties.hasInvisible, delete i.geometry.properties.oldElementsBeforeHighlight);
}
function u2(i) {
  if (!i.properties.highlightTimestamp) return;
  const t = i.defines;
  delete t.HAS_HIGHLIGHT_COLOR, delete t.HAS_HIGHLIGHT_OPACITY, i.setDefines(t), delete i.properties.highlightTimestamp, cy(i), C0(i);
}
function C0(i) {
  if (!i) return;
  const { hlBloomMesh: t } = i.properties;
  if (t) {
    const e = t.geometry;
    e.elements && e.elements.destroy && e.deleteElements(), t.dispose(), delete i.properties.hlBloomMesh;
  }
}
var zg = Object.freeze({
  __proto__: null,
  clearShowOnly: l2,
  showOnly: function(i, t, e, r, n) {
    const { showOnlyTimestamp: s } = t.properties;
    if (!e) return void (s && l2(t));
    if (r === s) return;
    t.properties.showOnlyTimestamp = r;
    const o = e.keys(), a = [];
    for (const h of o) {
      if (!n.has(h)) continue;
      const u = n.get(h);
      u && v0(a, u);
    }
    h2(t, a), t.geometry.elements !== t.geometry.properties.oldElementsBeforeHighlight && t.geometry.elements.destroy && t.geometry.deleteElements();
    const l = {
      data: a,
      primitive: t.geometry.getPrimitive()
    };
    t.geometry.setElements(i.elements(l)), t.geometry.generateBuffers(i);
  },
  clearHighlight: u2,
  highlightMesh: function(i, t, e, r, n) {
    const { highlightTimestamp: s } = t.properties;
    if (!e) return void (s && u2(t));
    if (r === s) return;
    const o = t.geometry.getVertexCount();
    let { aHighlightColor: a, aHighlightOpacity: l } = t.geometry.properties;
    a && a.fill(0), l && l.fill(255);
    let h = !1, u = !1;
    const c = e.keys();
    let f = null, d = null;
    for (const m of c) if (n.has(m)) {
      const v = e.get(m), { color: _, bloom: y, visible: x } = v;
      let w, { opacity: b } = v;
      if (_ && (h || (a || (a = new Uint8Array(4 * o)), h = !0), w = zF(NL, _)), b = du(b) ? 1 : b, b < 1 && (u || (l || (l = new Uint8Array(o), l.fill(255)), u = !0)), x === !1 && (d || (d = /* @__PURE__ */ new Set()), d.add(m)), w || b < 1 || y) {
        const T = n.get(m);
        if (T) for (let A = 0; A < T.length; A++) {
          const M = T[A];
          w && Sr(a.subarray(4 * M, 4 * M + 4), ...w), b < 1 && (l[M] = 255 * b), y && (f || (f = []), f.push(M));
        }
      }
    }
    const p = t.defines;
    if (h ? (t.geometry.data.aHighlightColor ? t.geometry.updateData("aHighlightColor", a) : (t.geometry.data.aHighlightColor = a, t.geometry.generateBuffers(i)), t.geometry.properties.aHighlightColor = a, p.HAS_HIGHLIGHT_COLOR = 1) : p.HAS_HIGHLIGHT_COLOR && (t.geometry.updateData("aHighlightColor", a), delete p.HAS_HIGHLIGHT_COLOR), u ? (t.geometry.data.aHighlightOpacity ? t.geometry.updateData("aHighlightOpacity", l) : (t.geometry.data.aHighlightOpacity = l, t.geometry.generateBuffers(i)), t.geometry.properties.aHighlightOpacity = l, p.HAS_HIGHLIGHT_OPACITY = 1) : p.HAS_HIGHLIGHT_OPACITY && (t.geometry.updateData("aHighlightOpacity", l), delete p.HAS_HIGHLIGHT_OPACITY), d && d.size > 0) {
      let m = [];
      n.forEach((_, y) => {
        d.has(y) || v0(m, _);
      }), t.geometry.properties.hasInvisible = !0, h2(t, m);
      const v = {
        data: m,
        primitive: t.geometry.getPrimitive()
      };
      t.geometry.elements !== t.geometry.properties.oldElementsBeforeHighlight && t.geometry.elements.destroy && t.geometry.deleteElements(), m = i.elements(v), t.geometry.setElements(m), t.geometry.generateBuffers(i);
    } else t.geometry.properties.hasInvisible && cy(t);
    t.setDefines(p), t.properties.highlightTimestamp = r;
    let g = t.properties.hlBloomMesh;
    if (f && f.length) {
      if (g) {
        const m = Hi(g.localTransform, t.localTransform), v = Hi(g.positionMatrix, t.positionMatrix);
        g.setLocalTransform(m), g.setPositionMatrix(v), t.properties.hlBloomMesh.geometry.setElements(f);
      } else {
        const m = new er(t.geometry.data, f, 0, t.geometry.desc);
        m.generateBuffers(i);
        const v = t.material;
        g = new tn(m, v, t.config);
        const _ = t.uniforms;
        for (const b in _) Object.defineProperty(g.uniforms, b, {
          enumerable: !0,
          get: function() {
            return t.getUniform(b);
          }
        });
        const y = lr({}, t.defines);
        y.HAS_BLOOM = 1;
        const x = Hi([], t.localTransform), w = Hi([], t.positionMatrix);
        g.setLocalTransform(x), g.setPositionMatrix(w), lr(g.properties, t.properties), lr(m.properties, t.geometry.properties), g.setDefines(y), g.bloom = 1;
      }
      t.properties.hlBloomMesh = g;
    } else g && C0(t);
  },
  deleteHighlightBloomMesh: C0
});
const HL = [0, 0, 0, 0];
let BL = class {
  constructor(t, e, r, n, s, o) {
    this.renderer = new hn(t), this.sceneConfig = e, this.s = r, this.Zn = n, this.Kn = s, this.Sn = o || {
      factor: 0,
      units: 0
    }, this.h(), this.Qn = [];
  }
  render(t, e, r) {
    this.tr();
    const n = this.s.getMap();
    this.renderer.regl.clear({
      color: HL,
      depth: 1,
      stencil: 255,
      framebuffer: this.ir
    }), this.renderer.render(this.er, e, t, this.ir);
    const s = this.s.getRenderer().canvas;
    this.Qn[0] = s.width, this.Qn[1] = s.height;
    const o = lr({
      colorRamp: this.sr,
      inputTexture: this.ir,
      projViewMatrix: n.projViewMatrix,
      textureOutputSize: this.Qn
    }, e);
    return this.m(), this.renderer.render(this.nr, o, this.D, r);
  }
  dispose() {
    this.er && (this.er.dispose(), delete this.er), this.nr && (this.nr.dispose(), delete this.nr), this.S && (this.S.geometry.dispose(), this.S.dispose(), delete this.S, delete this.D), this.ir && (this.ir.destroy(), delete this.ir);
  }
  rr() {
    const t = this.Zn;
    let e = this.hr, r = this.or;
    r ? r.clearRect(0, 0, 256, 1) : (e = this.hr = document.createElement("canvas"), e.width = 256, e.height = 1, r = this.or = e.getContext("2d"));
    const n = r.createLinearGradient(0, 0, 256, 1);
    for (let o = 0; o < t.length; o++) n.addColorStop(t[o][0], t[o][1]);
    r.fillStyle = n, r.fillRect(0, 0, 256, 1), this.sr && this.sr.destroy();
    const s = this.renderer.regl;
    this.sr = s.texture({
      width: 256,
      height: 1,
      data: e,
      min: "linear",
      mag: "linear",
      premultiplyAlpha: !0
    });
  }
  tr() {
    const t = this.s.getRenderer().canvas, e = Math.ceil(t.width / 4), r = Math.ceil(t.height / 4), n = this.ir;
    n.width === e && n.height === r || n.resize(e, r);
  }
  h() {
    this.rr(), this.ar(), this.cr(), this.p();
  }
  p() {
    const t = new jd();
    t.generateBuffers(this.renderer.regl), this.S = new tn(t), this.D = new ur([this.S]);
  }
  m() {
    const t = this.s.getMap(), e = $d.getGroundTransform(this.S.localTransform, t);
    this.S.setLocalTransform(e);
  }
  cr() {
    const t = this.s.getRenderer().canvas, e = this.renderer.regl, r = e.hasExtension("OES_texture_half_float") ? "half float" : "float", n = Math.ceil(t.width / 4), s = Math.ceil(t.height / 4), o = e.texture({
      width: n,
      height: s,
      type: r,
      min: "linear",
      mag: "linear",
      format: "rgba"
    });
    this.ir = e.framebuffer({
      width: n,
      height: s,
      color: [o]
    });
  }
  ar() {
    const t = this.s.getRenderer().canvas, e = this.sceneConfig.depthRange, r = {
      viewport: {
        x: 0,
        y: 0,
        width: () => t ? Math.ceil(t.width / 4) : 1,
        height: () => t ? Math.ceil(t.height / 4) : 1
      },
      depth: {
        enable: !0,
        func: "always"
      }
    };
    this.Kn && (r.stencil = this.Kn), this.er = new fD({
      extraCommandProps: r
    }), this.nr = new pD({
      x: 0,
      y: 0,
      width: () => t ? t.width : 1,
      height: () => t ? t.height : 1
    }, {
      extraCommandProps: {
        stencil: {
          enable: !1
        },
        depth: {
          enable: !0,
          range: e || [0, 1],
          func: "<="
        },
        polygonOffset: {
          enable: !0,
          offset: this.Sn
        },
        scissor: {
          enable: !1
        }
      }
    });
  }
}, fy = class extends Pl {
  constructor(t, e) {
    super(t, e);
  }
  ze(t) {
    const e = this.js(t), r = new tn(e);
    return this.lr(r), this.qs(r), r;
  }
  Gs(t, e, r) {
    const n = this.zs();
    t.setUniform("maskMode", n);
    const s = this.Vs();
    if (t.setUniform("maskColor", s), Ud(e)) {
      const o = this.Ks();
      o[0] = (o[0] - r) * e, o[1] = (o[1] - r) * e, t.setUniform("heightRange", o);
    }
  }
  setHeightRange(t) {
    this.options.heightRange = t, this._fireEvent("heightrangechange");
  }
  getHeightRange() {
    return this.options.heightRange;
  }
  Ks() {
    const t = [0, 0];
    return this.options.heightRange && (t[0] = this.Ws(this.options.heightRange[0]), t[1] = this.Ws(this.options.heightRange[1])), t;
  }
  lr(t) {
    const e = t.getDefines();
    e.HAS_MASK_COLOR = 1, t.setDefines(e);
  }
}, jL = class extends fy {
  constructor(t, e) {
    super(t, e), this.Hs = "clip-inside";
  }
}, GL = class extends fy {
  constructor(t, e) {
    super(t, e), this.Hs = "clip-outside";
  }
}, dy = class extends Pl {
  constructor(t, e) {
    super(t, e);
  }
  setFlatheight(t) {
    this.options.flatHeight = t, this._fireEvent("flatheightchange");
  }
  ze(t) {
    const e = this.js(t), r = new tn(e);
    return this.lr(r), this.qs(r), r;
  }
  Gs(t) {
    const e = this.zs();
    t.setUniform("maskMode", e);
    const r = this.Vs();
    t.setUniform("maskColor", r);
    const n = this.Ws(this.options.flatHeight || 0);
    t.setUniform("flatHeight", n);
  }
  lr(t) {
    const e = t.getDefines();
    e.HAS_MASK_FLAT = 1, t.setDefines(e);
  }
  Ks() {
    const t = [0, this.options.flatHeight];
    return t[1] = this.Ws(t[1]), t;
  }
}, VL = class extends dy {
  constructor(t, e) {
    super(t, e), this.Hs = "flat-inside";
  }
}, UL = class extends dy {
  constructor(t, e) {
    super(t, e), this.Hs = "flat-outside";
  }
}, $L = class extends Pl {
  constructor(t, e) {
    super(t, e), this.Hs = "color";
  }
  setHeightRange(t) {
    this.options.heightRange = t, this._fireEvent("heightrangechange");
  }
  ze(t) {
    const e = this.js(t), r = new tn(e);
    return this.lr(r), this.qs(r), r;
  }
  Gs(t, e, r) {
    const n = this.zs();
    t.setUniform("maskMode", n);
    const s = this.Vs();
    if (t.setUniform("maskColor", s), Ud(e)) {
      const o = this.Ks();
      o[0] = (o[0] - r) * e, o[1] = (o[1] - r) * e, t.setUniform("heightRange", o);
    }
  }
  lr(t) {
    const e = t.getDefines();
    e.HAS_MASK_COLOR = 1, t.setDefines(e);
  }
  Ks() {
    const t = [0, 0];
    return this.options.heightRange && (t[0] = this.Ws(this.options.heightRange[0]), t[1] = this.Ws(this.options.heightRange[1])), t;
  }
}, WL = class extends Pl {
  constructor(t, e) {
    super(t, e), this.Hs = "video";
  }
  play() {
    this.ur && this.ur.play();
  }
  pause() {
    this.ur && this.ur.pause();
  }
  setAudio(t) {
    this.ur && (this.video.muted = t);
  }
  setUrl(t) {
    this.options.url = t, this.dr(t);
  }
  getState() {
    return this.pr;
  }
  ze(t) {
    const e = this.js(t), r = new tn(e), n = this.gr(t);
    return r.material = new Nr({
      maskTexture: n
    }), this.lr(r), this.qs(r), r;
  }
  Gs(t) {
    const e = this.zs();
    t.setUniform("maskMode", e);
    const r = this.Vs();
    t.setUniform("maskColor", r);
  }
  lr(t) {
    const e = t.getDefines();
    e.HAS_VIDEO = 1, t.setDefines(e);
  }
  gr(t) {
    return this.dr(), t.texture();
  }
  dr() {
    this.pr = "stop";
    const t = this.options.url, e = this.options.elementId;
    let r = document.getElementById(e);
    if (t && (r = document.createElement("video"), r.src = t), !r) throw new Error("there is no element or url setting for video mask");
    r.autoplay = this.options.autoplay || !0, r.loop = this.options.loop || !0, r.muted = this.options.muted || !0, r.play(), r.addEventListener("playing", () => {
      this.pr = "playing";
    }), r.addEventListener("pause", () => {
      this.pr = "pause";
    }), this.ur = r;
  }
  je() {
    const t = this.xt;
    if (t && t.material) {
      const e = t.material.get("maskTexture");
      e && this.ur && this.Be() && e(this.ur);
    }
  }
  Be() {
    return this.pr === "playing";
  }
}, ZL = class extends dy {
  constructor(t, e) {
    super(t, e), this.setElevation(e.elevation), this.Hs = "elevate";
  }
  setElevation(t) {
    this.options.elevation = t, this.setFlatheight(this.options.elevation);
  }
};
const XL = new Y(0, 0), qL = new Y(0, 0), YL = new Y(0, 0), $s = new Y(0, 0);
let YM = class extends fy {
  constructor(t, e) {
    super([], e), this.mr = t;
  }
  setPosition(t) {
    this.mr = t, this.Xs();
  }
  getPosition() {
    return this.mr;
  }
  setWidth(t) {
    this.options.width = t, this.Xs();
  }
  setLength(t) {
    this.options.length = t, this.Xs();
  }
  setHeight(t) {
    this.options.height = t, this.Xs();
  }
  setRotation(t) {
    this.options.rotation = t, this.Xs();
  }
  Xs() {
    const t = this.getLayer();
    if (!t) return;
    const e = t.getMap();
    if (e) {
      const { length: r, width: n, height: s } = this.options, o = this.mr, a = this.options.rotation || 0, { coordinates: l, heightRange: h } = this.vr(e, o, r, n, s, a);
      this.setCoordinates(l), this.setHeightRange(h);
    }
  }
  vr(t, e, r, n, s, o) {
    const a = t.getGLRes(), l = t.distanceToPointAtRes(n / 2, 0, a, XL), h = t.distanceToPointAtRes(0, r / 2, a, qL), u = t.coordinateToPointAtRes(e, a, YL), c = u.x - l.x, f = u.x + l.x, d = u.y + h.y, p = u.y - h.y, g = this.wr([[c, d], [f, d], [f, p], [c, p]], u, o);
    $s.set(g[0][0], g[0][1]);
    const m = t.pointAtResToCoordinate($s, a);
    $s.set(g[1][0], g[1][1]);
    const v = t.pointAtResToCoordinate($s, a);
    $s.set(g[2][0], g[2][1]);
    const _ = t.pointAtResToCoordinate($s, a);
    $s.set(g[3][0], g[3][1]);
    const y = t.pointAtResToCoordinate($s, a), x = e.z - s / 2, w = [x, e.z + s / 2];
    return {
      coordinates: [[m.x, m.y, x], [v.x, v.y, x], [_.x, _.y, x], [y.x, y.y, x], [m.x, m.y, x]],
      heightRange: w
    };
  }
  wr(t, e, r) {
    for (let n = 0; n < t.length; n++) jR(t[n], t[n], [e.x, e.y], r * Math.PI / 180);
    return t;
  }
}, JL = class extends YM {
  constructor(t, e) {
    super(t, e), this.Hs = "clip-inside";
  }
}, KL = class extends YM {
  constructor(t, e) {
    super(t, e), this.Hs = "clip-outside";
  }
};
typeof window < "u" && window.maptalks && (window.maptalks.GroupGLLayer = Ph, window.maptalks.ClipInsideMask = jL, window.maptalks.ClipOutsideMask = GL, window.maptalks.FlatInsideMask = VL, window.maptalks.FlatOutsideMask = UL, window.maptalks.ElevateMask = ZL, window.maptalks.ColorMask = $L, window.maptalks.VideoMask = WL, window.maptalks.BoxInsideClipMask = JL, window.maptalks.BoxOutsideClipMask = KL, window.maptalks.RayCaster = qM);
const JM = function() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw new Error("unable to locate global object");
}, cd = JM(), uo = cd.gl_trans__coders = cd.gl_trans__coders || {};
function QL(i) {
  const t = i.toString(), e = t.indexOf("{") + 1, r = t.substring(0, e), n = cd.gl_trans__coders = cd.gl_trans__coders || {};
  let s = `${r}
    const _____getGlobal = ${JM.toString()};
    const g___lobals = _____getGlobal()
    const tran_____scoders = g___lobals['gl_trans__coders'] = g___lobals['gl_trans__coders'] || {};`;
  for (const o in n)
    o === "inject" || o === "getTranscoder" || o === "registerTranscoder" || (s += 'tran_____scoders["' + o + '"] =' + n[o].toString() + `
;`);
  return s += `
` + t.substring(r.length), s;
}
uo.inject = QL;
function t6(i) {
  return uo[i];
}
function e6(i, t) {
  uo[i] = t;
}
uo.registerTranscoder = e6;
uo.getTranscoder = t6;
const So = "${", n6 = `function(t){var r="undefined"!=typeof Float32Array?Float32Array:Array;function e(){var t=new r(3);return r!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function i(t,e,i){var n=new r(3);return n[0]=t,n[1]=e,n[2]=i,n}function n(t,r){var e=r[0],i=r[1],n=r[2],s=e*e+i*i+n*n;return s>0&&(s=1/Math.sqrt(s),t[0]=r[0]*s,t[1]=r[1]*s,t[2]=r[2]*s),t}function s(t,r,e){var i=r[0],n=r[1],s=r[2],a=e[0],o=e[1],h=e[2];return t[0]=n*h-s*o,t[1]=s*a-i*h,t[2]=i*o-n*a,t}var a=function(t,r,e){return t[0]=r[0]-e[0],t[1]=r[1]-e[1],t[2]=r[2]-e[2],t};function o(){var t=new r(4);return r!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t[3]=1,t}e(),function(){var t,e=(t=new r(4),r!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t)}();var h;function c(t,r,e){return t[0]=r,t[1]=e,t}e(),i(1,0,0),i(0,1,0),o(),o(),h=new r(9),r!=Float32Array&&(h[1]=0,h[2]=0,h[3]=0,h[5]=0,h[6]=0,h[7]=0),h[0]=1,h[4]=1,h[8]=1,function(){var t=function(){var t=new r(2);return r!=Float32Array&&(t[0]=0,t[1]=0),t}()}();
/*!
   * @maptalks/gltf-loader v0.97.2
   * LICENSE : UNLICENSED
   * (c) 2016-2024 maptalks.org
   */
let f=0;!function(t){t[0]=0,t[1]=0,t[2]=0,t[3]=1}([]),"undefined"!=typeof TextDecoder&&new TextDecoder("utf-8");const u={get:function(t,r={},e){r||(r={});const i=new AbortController,n=i.signal,s=function(t){for(let r=1;r<arguments.length;r++){const e=arguments[r];for(const r in e)t[r]=e[r]}return t}({},r);s.signal=n,s.method||(s.method="GET"),s.referrerPolicy=s.referrerPolicy||"origin","undefined"==typeof window||s.referrer||(s.referrer=window.location.href),e&&(t=e(t));const a=fetch(t,s).then(t=>{const e=this.U(t,r.responseType);return e.message?e:e.then(e=>"arraybuffer"===r.responseType?{data:e,cacheControl:t.headers.get("Cache-Control"),expires:t.headers.get("Expires"),contentType:t.headers.get("Content-Type")}:e).catch(t=>{if(!t.code||t.code!==DOMException.ABORT_ERR)throw t})}).catch(t=>{if(!t.code||t.code!==DOMException.ABORT_ERR)throw t});return a.xhr=i,a},U:(t,r)=>200!==t.status?{status:t.status,statusText:t.statusText,message:\`incorrect http request with status code(${So}t.status}): ${So}t.statusText}\`}:"arraybuffer"===r?t.arrayBuffer():"json"===r?t.json():t.text(),getArrayBuffer:(t,r={},e)=>(r||(r={}),r.responseType="arraybuffer",u.get(t,r,e)),getJSON:function(t,r={},e){return r&&r.jsonp?u.jsonp(t):((r=r||{}).responseType="json",u.get(t,r,e))},jsonp:function(t){const r="_maptalks_jsonp_"+f++;t.match(/\\?/)?t+="&callback="+r:t+="?callback="+r;let e=document.createElement("script");return e.type="text/javascript",e.src=t,new Promise(t=>{window[r]=function(i){document.getElementsByTagName("head")[0].removeChild(e),e=null,delete window[r],t(i)},document.getElementsByTagName("head")[0].appendChild(e)})}};if("undefined"!=typeof TextDecoder&&new TextDecoder("utf-8"),"undefined"!=typeof OffscreenCanvas){let t;try{t=new OffscreenCanvas(2,2).getContext("2d")}catch(t){}}"undefined"!=typeof document&&document.createElement("canvas"),function(){function t(t){throw t}var r=void 0,e=!0,i=this;function n(t,e){var n,s=t.split("."),a=i;!(s[0]in a)&&a.execScript&&a.execScript("var "+s[0]);for(;s.length&&(n=s.shift());)s.length||e===r?a=a[n]?a[n]:a[n]={}:a[n]=e}var s="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array&&"undefined"!=typeof DataView;function a(r,e){this.index="number"==typeof e?e:0,this.i=0,this.buffer=r instanceof(s?Uint8Array:Array)?r:new(s?Uint8Array:Array)(32768),2*this.buffer.length<=this.index&&t(Error("invalid index")),this.buffer.length<=this.index&&this.f()}a.prototype.f=function(){var t,r=this.buffer,e=r.length,i=new(s?Uint8Array:Array)(e<<1);if(s)i.set(r);else for(t=0;t<e;++t)i[t]=r[t];return this.buffer=i},a.prototype.d=function(t,r,e){var i,n=this.buffer,s=this.index,a=this.i,o=n[s];if(e&&1<r&&(t=8<r?(l[255&t]<<24|l[t>>>8&255]<<16|l[t>>>16&255]<<8|l[t>>>24&255])>>32-r:l[t]>>8-r),8>r+a)o=o<<r|t,a+=r;else for(i=0;i<r;++i)o=o<<1|t>>r-i-1&1,8==++a&&(a=0,n[s++]=l[o],o=0,s===n.length&&(n=this.f()));n[s]=o,this.buffer=n,this.i=a,this.index=s},a.prototype.finish=function(){var t,r=this.buffer,e=this.index;return 0<this.i&&(r[e]<<=8-this.i,r[e]=l[r[e]],e++),s?t=r.subarray(0,e):(r.length=e,t=r),t};var o,h=new(s?Uint8Array:Array)(256);for(o=0;256>o;++o){for(var c=u=o,f=7,u=u>>>1;u;u>>>=1)c<<=1,c|=1&u,--f;h[o]=(c<<f&255)>>>0}var l=h;function d(t){this.buffer=new(s?Uint16Array:Array)(2*t),this.length=0}function y(t){var r,e,i,n,a,o,h,c,f,u,l=t.length,d=0,y=Number.POSITIVE_INFINITY;for(c=0;c<l;++c)t[c]>d&&(d=t[c]),t[c]<y&&(y=t[c]);for(r=1<<d,e=new(s?Uint32Array:Array)(r),i=1,n=0,a=2;i<=d;){for(c=0;c<l;++c)if(t[c]===i){for(o=0,h=n,f=0;f<i;++f)o=o<<1|1&h,h>>=1;for(u=i<<16|c,f=o;f<r;f+=a)e[f]=u;++n}++i,n<<=1,a<<=1}return[e,d,y]}function A(t,r){this.h=b,this.w=0,this.input=s&&t instanceof Array?new Uint8Array(t):t,this.b=0,r&&(r.lazy&&(this.w=r.lazy),"number"==typeof r.compressionType&&(this.h=r.compressionType),r.outputBuffer&&(this.a=s&&r.outputBuffer instanceof Array?new Uint8Array(r.outputBuffer):r.outputBuffer),"number"==typeof r.outputIndex&&(this.b=r.outputIndex)),this.a||(this.a=new(s?Uint8Array:Array)(32768))}d.prototype.getParent=function(t){return 2*((t-2)/4|0)},d.prototype.push=function(t,r){var e,i,n,s=this.buffer;for(e=this.length,s[this.length++]=r,s[this.length++]=t;0<e&&(i=this.getParent(e),s[e]>s[i]);)n=s[e],s[e]=s[i],s[i]=n,n=s[e+1],s[e+1]=s[i+1],s[i+1]=n,e=i;return this.length},d.prototype.pop=function(){var t,r,e,i,n,s=this.buffer;for(r=s[0],t=s[1],this.length-=2,s[0]=s[this.length],s[1]=s[this.length+1],n=0;!((i=2*n+2)>=this.length)&&(i+2<this.length&&s[i+2]>s[i]&&(i+=2),s[i]>s[n]);)e=s[n],s[n]=s[i],s[i]=e,e=s[n+1],s[n+1]=s[i+1],s[i+1]=e,n=i;return{index:t,value:r,length:this.length}};var w,b=2,p={NONE:0,r:1,k:b,N:3},v=[];for(w=0;288>w;w++)switch(!0){case 143>=w:v.push([w+48,8]);break;case 255>=w:v.push([w-144+400,9]);break;case 279>=w:v.push([w-256+0,7]);break;case 287>=w:v.push([w-280+192,8]);break;default:t("invalid literal: "+w)}function k(t,r){this.length=t,this.G=r}A.prototype.j=function(){var i,n,o,h,c=this.input;switch(this.h){case 0:for(o=0,h=c.length;o<h;){var f,u,l,d=n=s?c.subarray(o,o+65535):c.slice(o,o+65535),y=(o+=n.length)===h,A=r,w=r,p=this.a,k=this.b;if(s){for(p=new Uint8Array(this.a.buffer);p.length<=k+d.length+5;)p=new Uint8Array(p.length<<1);p.set(this.a)}if(f=y?1:0,p[k++]=0|f,l=65536+~(u=d.length)&65535,p[k++]=255&u,p[k++]=u>>>8&255,p[k++]=255&l,p[k++]=l>>>8&255,s)p.set(d,k),k+=d.length,p=p.subarray(0,k);else{for(A=0,w=d.length;A<w;++A)p[k++]=d[A];p.length=k}this.b=k,this.a=p}break;case 1:var m=new a(s?new Uint8Array(this.a.buffer):this.a,this.b);m.d(1,1,e),m.d(1,2,e);var U,x,M,S=g(this,c);for(U=0,x=S.length;U<x;U++)if(M=S[U],a.prototype.d.apply(m,v[M]),256<M)m.d(S[++U],S[++U],e),m.d(S[++U],5),m.d(S[++U],S[++U],e);else if(256===M)break;this.a=m.finish(),this.b=this.a.length;break;case b:var I,F,D,z,C,N,O,j,q,W,Z,V,$,_,B,H=new a(s?new Uint8Array(this.a.buffer):this.a,this.b),L=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],P=Array(19);for(I=b,H.d(1,1,e),H.d(I,2,e),F=g(this,c),O=T(N=E(this.L,15)),q=T(j=E(this.K,7)),D=286;257<D&&0===N[D-1];D--);for(z=30;1<z&&0===j[z-1];z--);var G,R,Y,J,K,X,Q=D,tt=z,rt=new(s?Uint32Array:Array)(Q+tt),et=new(s?Uint32Array:Array)(316),it=new(s?Uint8Array:Array)(19);for(G=R=0;G<Q;G++)rt[R++]=N[G];for(G=0;G<tt;G++)rt[R++]=j[G];if(!s)for(G=0,J=it.length;G<J;++G)it[G]=0;for(G=K=0,J=rt.length;G<J;G+=R){for(R=1;G+R<J&&rt[G+R]===rt[G];++R);if(Y=R,0===rt[G])if(3>Y)for(;0<Y--;)et[K++]=0,it[0]++;else for(;0<Y;)(X=138>Y?Y:138)>Y-3&&X<Y&&(X=Y-3),10>=X?(et[K++]=17,et[K++]=X-3,it[17]++):(et[K++]=18,et[K++]=X-11,it[18]++),Y-=X;else if(et[K++]=rt[G],it[rt[G]]++,3>--Y)for(;0<Y--;)et[K++]=rt[G],it[rt[G]]++;else for(;0<Y;)(X=6>Y?Y:6)>Y-3&&X<Y&&(X=Y-3),et[K++]=16,et[K++]=X-3,it[16]++,Y-=X}for(i=s?et.subarray(0,K):et.slice(0,K),W=E(it,7),_=0;19>_;_++)P[_]=W[L[_]];for(C=19;4<C&&0===P[C-1];C--);for(Z=T(W),H.d(D-257,5,e),H.d(z-1,5,e),H.d(C-4,4,e),_=0;_<C;_++)H.d(P[_],3,e);for(_=0,B=i.length;_<B;_++)if(V=i[_],H.d(Z[V],W[V],e),16<=V){switch(_++,V){case 16:$=2;break;case 17:$=3;break;case 18:$=7;break;default:t("invalid code: "+V)}H.d(i[_],$,e)}var nt,st,at,ot,ht,ct,ft,ut,lt=[O,N],dt=[q,j];for(ht=lt[0],ct=lt[1],ft=dt[0],ut=dt[1],nt=0,st=F.length;nt<st;++nt)if(at=F[nt],H.d(ht[at],ct[at],e),256<at)H.d(F[++nt],F[++nt],e),ot=F[++nt],H.d(ft[ot],ut[ot],e),H.d(F[++nt],F[++nt],e);else if(256===at)break;this.a=H.finish(),this.b=this.a.length;break;default:t("invalid compression type")}return this.a};var m=function(){function r(r){switch(!0){case 3===r:return[257,r-3,0];case 4===r:return[258,r-4,0];case 5===r:return[259,r-5,0];case 6===r:return[260,r-6,0];case 7===r:return[261,r-7,0];case 8===r:return[262,r-8,0];case 9===r:return[263,r-9,0];case 10===r:return[264,r-10,0];case 12>=r:return[265,r-11,1];case 14>=r:return[266,r-13,1];case 16>=r:return[267,r-15,1];case 18>=r:return[268,r-17,1];case 22>=r:return[269,r-19,2];case 26>=r:return[270,r-23,2];case 30>=r:return[271,r-27,2];case 34>=r:return[272,r-31,2];case 42>=r:return[273,r-35,3];case 50>=r:return[274,r-43,3];case 58>=r:return[275,r-51,3];case 66>=r:return[276,r-59,3];case 82>=r:return[277,r-67,4];case 98>=r:return[278,r-83,4];case 114>=r:return[279,r-99,4];case 130>=r:return[280,r-115,4];case 162>=r:return[281,r-131,5];case 194>=r:return[282,r-163,5];case 226>=r:return[283,r-195,5];case 257>=r:return[284,r-227,5];case 258===r:return[285,r-258,0];default:t("invalid length: "+r)}}var e,i,n=[];for(e=3;258>=e;e++)i=r(e),n[e]=i[2]<<24|i[1]<<16|i[0];return n}(),U=s?new Uint32Array(m):m;function g(e,i){function n(r,e){var i,n,s,a,o=r.G,h=[],c=0;switch(i=U[r.length],h[c++]=65535&i,h[c++]=i>>16&255,h[c++]=i>>24,!0){case 1===o:n=[0,o-1,0];break;case 2===o:n=[1,o-2,0];break;case 3===o:n=[2,o-3,0];break;case 4===o:n=[3,o-4,0];break;case 6>=o:n=[4,o-5,1];break;case 8>=o:n=[5,o-7,1];break;case 12>=o:n=[6,o-9,2];break;case 16>=o:n=[7,o-13,2];break;case 24>=o:n=[8,o-17,3];break;case 32>=o:n=[9,o-25,3];break;case 48>=o:n=[10,o-33,4];break;case 64>=o:n=[11,o-49,4];break;case 96>=o:n=[12,o-65,5];break;case 128>=o:n=[13,o-97,5];break;case 192>=o:n=[14,o-129,6];break;case 256>=o:n=[15,o-193,6];break;case 384>=o:n=[16,o-257,7];break;case 512>=o:n=[17,o-385,7];break;case 768>=o:n=[18,o-513,8];break;case 1024>=o:n=[19,o-769,8];break;case 1536>=o:n=[20,o-1025,9];break;case 2048>=o:n=[21,o-1537,9];break;case 3072>=o:n=[22,o-2049,10];break;case 4096>=o:n=[23,o-3073,10];break;case 6144>=o:n=[24,o-4097,11];break;case 8192>=o:n=[25,o-6145,11];break;case 12288>=o:n=[26,o-8193,12];break;case 16384>=o:n=[27,o-12289,12];break;case 24576>=o:n=[28,o-16385,13];break;case 32768>=o:n=[29,o-24577,13];break;default:t("invalid distance")}for(i=n,h[c++]=i[0],h[c++]=i[1],h[c++]=i[2],s=0,a=h.length;s<a;++s)w[b++]=h[s];v[h[0]]++,k[h[3]]++,p=r.length+e-1,d=null}var a,o,h,c,f,u,l,d,y,A={},w=s?new Uint16Array(2*i.length):[],b=0,p=0,v=new(s?Uint32Array:Array)(286),k=new(s?Uint32Array:Array)(30),m=e.w;if(!s){for(h=0;285>=h;)v[h++]=0;for(h=0;29>=h;)k[h++]=0}for(v[256]=1,a=0,o=i.length;a<o;++a){for(h=f=0,c=3;h<c&&a+h!==o;++h)f=f<<8|i[a+h];if(A[f]===r&&(A[f]=[]),u=A[f],!(0<p--)){for(;0<u.length&&32768<a-u[0];)u.shift();if(a+3>=o){for(d&&n(d,-1),h=0,c=o-a;h<c;++h)y=i[a+h],w[b++]=y,++v[y];break}0<u.length?(l=x(i,a,u),d?d.length<l.length?(y=i[a-1],w[b++]=y,++v[y],n(l,0)):n(d,-1):l.length<m?d=l:n(l,0)):d?n(d,-1):(y=i[a],w[b++]=y,++v[y])}u.push(a)}return w[b++]=256,v[256]++,e.L=v,e.K=k,s?w.subarray(0,b):w}function x(t,r,e){var i,n,s,a,o,h,c=0,f=t.length;a=0,h=e.length;t:for(;a<h;a++){if(i=e[h-a-1],s=3,3<c){for(o=c;3<o;o--)if(t[i+o-1]!==t[r+o-1])continue t;s=c}for(;258>s&&r+s<f&&t[i+s]===t[r+s];)++s;if(s>c&&(n=i,c=s),258===s)break}return new k(c,r-n)}function E(t,r){var e,i,n,a,o,h=t.length,c=new d(572),f=new(s?Uint8Array:Array)(h);if(!s)for(a=0;a<h;a++)f[a]=0;for(a=0;a<h;++a)0<t[a]&&c.push(a,t[a]);if(e=Array(c.length/2),i=new(s?Uint32Array:Array)(c.length/2),1===e.length)return f[c.pop().index]=1,f;for(a=0,o=c.length/2;a<o;++a)e[a]=c.pop(),i[a]=e[a].value;for(n=function(t,r,e){function i(t){var e=y[t][A[t]];e===r?(i(t+1),i(t+1)):--l[e],++A[t]}var n,a,o,h,c,f=new(s?Uint16Array:Array)(e),u=new(s?Uint8Array:Array)(e),l=new(s?Uint8Array:Array)(r),d=Array(e),y=Array(e),A=Array(e),w=(1<<e)-r,b=1<<e-1;for(f[e-1]=r,a=0;a<e;++a)w<b?u[a]=0:(u[a]=1,w-=b),w<<=1,f[e-2-a]=(f[e-1-a]/2|0)+r;for(f[0]=u[0],d[0]=Array(f[0]),y[0]=Array(f[0]),a=1;a<e;++a)f[a]>2*f[a-1]+u[a]&&(f[a]=2*f[a-1]+u[a]),d[a]=Array(f[a]),y[a]=Array(f[a]);for(n=0;n<r;++n)l[n]=e;for(o=0;o<f[e-1];++o)d[e-1][o]=t[o],y[e-1][o]=o;for(n=0;n<e;++n)A[n]=0;for(1===u[e-1]&&(--l[0],++A[e-1]),a=e-2;0<=a;--a){for(h=n=0,c=A[a+1],o=0;o<f[a];o++)(h=d[a+1][c]+d[a+1][c+1])>t[n]?(d[a][o]=h,y[a][o]=r,c+=2):(d[a][o]=t[n],y[a][o]=n,++n);A[a]=0,1===u[a]&&i(a)}return l}(i,i.length,r),a=0,o=e.length;a<o;++a)f[e[a].index]=n[a];return f}function T(t){var r,e,i,n,a=new(s?Uint16Array:Array)(t.length),o=[],h=[],c=0;for(r=0,e=t.length;r<e;r++)o[t[r]]=1+(0|o[t[r]]);for(r=1,e=16;r<=e;r++)h[r]=c,c+=0|o[r],c<<=1;for(r=0,e=t.length;r<e;r++)for(c=h[t[r]],h[t[r]]+=1,i=a[r]=0,n=t[r];i<n;i++)a[r]=a[r]<<1|1&c,c>>>=1;return a}function M(r,e){switch(this.l=[],this.m=32768,this.e=this.g=this.c=this.q=0,this.input=s?new Uint8Array(r):r,this.s=!1,this.n=I,this.B=!1,!e&&(e={})||(e.index&&(this.c=e.index),e.bufferSize&&(this.m=e.bufferSize),e.bufferType&&(this.n=e.bufferType),e.resize&&(this.B=e.resize)),this.n){case S:this.b=32768,this.a=new(s?Uint8Array:Array)(32768+this.m+258);break;case I:this.b=0,this.a=new(s?Uint8Array:Array)(this.m),this.f=this.J,this.t=this.H,this.o=this.I;break;default:t(Error("invalid inflate mode"))}}var S=0,I=1,F={D:S,C:I};M.prototype.p=function(){for(;!this.s;){var i=Y(this,3);switch(1&i&&(this.s=e),i>>>=1){case 0:var n=this.input,a=this.c,o=this.a,h=this.b,c=n.length,f=r,u=o.length,l=r;switch(this.e=this.g=0,a+1>=c&&t(Error("invalid uncompressed block header: LEN")),f=n[a++]|n[a++]<<8,a+1>=c&&t(Error("invalid uncompressed block header: NLEN")),f===~(n[a++]|n[a++]<<8)&&t(Error("invalid uncompressed block header: length verify")),a+f>n.length&&t(Error("input buffer is broken")),this.n){case S:for(;h+f>o.length;){if(f-=l=u-h,s)o.set(n.subarray(a,a+l),h),h+=l,a+=l;else for(;l--;)o[h++]=n[a++];this.b=h,o=this.f(),h=this.b}break;case I:for(;h+f>o.length;)o=this.f({v:2});break;default:t(Error("invalid inflate mode"))}if(s)o.set(n.subarray(a,a+f),h),h+=f,a+=f;else for(;f--;)o[h++]=n[a++];this.c=a,this.b=h,this.a=o;break;case 1:this.o(P,R);break;case 2:var d,A,w,b,p=Y(this,5)+257,v=Y(this,5)+1,k=Y(this,4)+4,m=new(s?Uint8Array:Array)(N.length),U=r,g=r,x=r,E=r,T=r;for(T=0;T<k;++T)m[N[T]]=Y(this,3);if(!s)for(T=k,k=m.length;T<k;++T)m[N[T]]=0;for(d=y(m),U=new(s?Uint8Array:Array)(p+v),T=0,b=p+v;T<b;)switch(g=J(this,d),g){case 16:for(E=3+Y(this,2);E--;)U[T++]=x;break;case 17:for(E=3+Y(this,3);E--;)U[T++]=0;x=0;break;case 18:for(E=11+Y(this,7);E--;)U[T++]=0;x=0;break;default:x=U[T++]=g}A=y(s?U.subarray(0,p):U.slice(0,p)),w=y(s?U.subarray(p):U.slice(p)),this.o(A,w);break;default:t(Error("unknown BTYPE: "+i))}}return this.t()};var D,z,C=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],N=s?new Uint16Array(C):C,O=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],j=s?new Uint16Array(O):O,q=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],W=s?new Uint8Array(q):q,Z=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],V=s?new Uint16Array(Z):Z,$=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],_=s?new Uint8Array($):$,B=new(s?Uint8Array:Array)(288);for(D=0,z=B.length;D<z;++D)B[D]=143>=D?8:255>=D?9:279>=D?7:8;var H,L,P=y(B),G=new(s?Uint8Array:Array)(30);for(H=0,L=G.length;H<L;++H)G[H]=5;var R=y(G);function Y(r,e){for(var i,n=r.g,s=r.e,a=r.input,o=r.c,h=a.length;s<e;)o>=h&&t(Error("input buffer is broken")),n|=a[o++]<<s,s+=8;return i=n&(1<<e)-1,r.g=n>>>e,r.e=s-e,r.c=o,i}function J(r,e){for(var i,n,s=r.g,a=r.e,o=r.input,h=r.c,c=o.length,f=e[0],u=e[1];a<u&&!(h>=c);)s|=o[h++]<<a,a+=8;return(n=(i=f[s&(1<<u)-1])>>>16)>a&&t(Error("invalid code length: "+n)),r.g=s>>n,r.e=a-n,r.c=h,65535&i}function K(t){if("string"==typeof t){var r,e,i=t.split("");for(r=0,e=i.length;r<e;r++)i[r]=(255&i[r].charCodeAt(0))>>>0;t=i}for(var n,s=1,a=0,o=t.length,h=0;0<o;){o-=n=1024<o?1024:o;do{a+=s+=t[h++]}while(--n);s%=65521,a%=65521}return(a<<16|s)>>>0}function X(r,e){var i,n;switch(this.input=r,this.c=0,!e&&(e={})||(e.index&&(this.c=e.index),e.verify&&(this.M=e.verify)),i=r[this.c++],n=r[this.c++],15&i){case Q:this.method=Q;break;default:t(Error("unsupported compression method"))}0!=((i<<8)+n)%31&&t(Error("invalid fcheck flag:"+((i<<8)+n)%31)),32&n&&t(Error("fdict flag is not supported")),this.A=new M(r,{index:this.c,bufferSize:e.bufferSize,bufferType:e.bufferType,resize:e.resize})}M.prototype.o=function(t,r){var e=this.a,i=this.b;this.u=t;for(var n,s,a,o,h=e.length-258;256!==(n=J(this,t));)if(256>n)i>=h&&(this.b=i,e=this.f(),i=this.b),e[i++]=n;else for(o=j[s=n-257],0<W[s]&&(o+=Y(this,W[s])),n=J(this,r),a=V[n],0<_[n]&&(a+=Y(this,_[n])),i>=h&&(this.b=i,e=this.f(),i=this.b);o--;)e[i]=e[i++-a];for(;8<=this.e;)this.e-=8,this.c--;this.b=i},M.prototype.I=function(t,r){var e=this.a,i=this.b;this.u=t;for(var n,s,a,o,h=e.length;256!==(n=J(this,t));)if(256>n)i>=h&&(h=(e=this.f()).length),e[i++]=n;else for(o=j[s=n-257],0<W[s]&&(o+=Y(this,W[s])),n=J(this,r),a=V[n],0<_[n]&&(a+=Y(this,_[n])),i+o>h&&(h=(e=this.f()).length);o--;)e[i]=e[i++-a];for(;8<=this.e;)this.e-=8,this.c--;this.b=i},M.prototype.f=function(){var t,r,e=new(s?Uint8Array:Array)(this.b-32768),i=this.b-32768,n=this.a;if(s)e.set(n.subarray(32768,e.length));else for(t=0,r=e.length;t<r;++t)e[t]=n[t+32768];if(this.l.push(e),this.q+=e.length,s)n.set(n.subarray(i,i+32768));else for(t=0;32768>t;++t)n[t]=n[i+t];return this.b=32768,n},M.prototype.J=function(t){var r,e,i,n=this.input.length/this.c+1|0,a=this.input,o=this.a;return t&&("number"==typeof t.v&&(n=t.v),"number"==typeof t.F&&(n+=t.F)),2>n?e=(i=(a.length-this.c)/this.u[2]/2*258|0)<o.length?o.length+i:o.length<<1:e=o.length*n,s?(r=new Uint8Array(e)).set(o):r=o,this.a=r},M.prototype.t=function(){var t,r,e,i,n,a=0,o=this.a,h=this.l,c=new(s?Uint8Array:Array)(this.q+(this.b-32768));if(0===h.length)return s?this.a.subarray(32768,this.b):this.a.slice(32768,this.b);for(r=0,e=h.length;r<e;++r)for(i=0,n=(t=h[r]).length;i<n;++i)c[a++]=t[i];for(r=32768,e=this.b;r<e;++r)c[a++]=o[r];return this.l=[],this.buffer=c},M.prototype.H=function(){var t,r=this.b;return s?this.B?(t=new Uint8Array(r)).set(this.a.subarray(0,r)):t=this.a.subarray(0,r):(this.a.length>r&&(this.a.length=r),t=this.a),this.buffer=t},X.prototype.p=function(){var r,e=this.input;return r=this.A.p(),this.c=this.A.c,this.M&&((e[this.c++]<<24|e[this.c++]<<16|e[this.c++]<<8|e[this.c++])>>>0!==K(r)&&t(Error("invalid adler-32 checksum"))),r};var Q=8;function tt(t,r){this.input=t,this.a=new(s?Uint8Array:Array)(32768),this.h=rt.k;var e,i={};for(e in!r&&(r={})||"number"!=typeof r.compressionType||(this.h=r.compressionType),r)i[e]=r[e];i.outputBuffer=this.a,this.z=new A(this.input,i)}var rt=p;function et(t,r){var e,i,s,a;if(Object.keys)e=Object.keys(r);else for(i in e=[],s=0,r)e[s++]=i;for(s=0,a=e.length;s<a;++s)n(t+"."+(i=e[s]),r[i])}tt.prototype.j=function(){var r,e,i,n,a,o,h,c=0;switch(h=this.a,r=Q){case Q:e=Math.LOG2E*Math.log(32768)-8;break;default:t(Error("invalid compression method"))}switch(i=e<<4|r,h[c++]=i,r){case Q:switch(this.h){case rt.NONE:a=0;break;case rt.r:a=1;break;case rt.k:a=2;break;default:t(Error("unsupported compression type"))}break;default:t(Error("invalid compression method"))}return n=a<<6|0,h[c++]=n|31-(256*i+n)%31,o=K(this.input),this.z.b=c,c=(h=this.z.j()).length,s&&((h=new Uint8Array(h.buffer)).length<=c+4&&(this.a=new Uint8Array(h.length+4),this.a.set(h),h=this.a),h=h.subarray(0,c+4)),h[c++]=o>>24&255,h[c++]=o>>16&255,h[c++]=o>>8&255,h[c++]=255&o,h},n("Zlib.Inflate",X),n("Zlib.Inflate.prototype.decompress",X.prototype.p),et("Zlib.Inflate.BufferType",{ADAPTIVE:F.C,BLOCK:F.D}),n("Zlib.Deflate",tt),n("Zlib.Deflate.compress",(function(t,r){return new tt(t,r).j()})),n("Zlib.Deflate.prototype.compress",tt.prototype.j),et("Zlib.Deflate.CompressionType",{NONE:rt.NONE,FIXED:rt.r,DYNAMIC:rt.k})}.call(self);class l{constructor(t=257){this.gridSize=t;const r=t-1;if(r&r-1)throw new Error(\`Expected grid size to be 2^n+1, got ${So}t}.\`);this.numTriangles=r*r*2-2,this.numParentTriangles=this.numTriangles-r*r,this.indices=new Uint32Array(this.gridSize*this.gridSize),this.coords=new Uint16Array(4*this.numTriangles);for(let t=0;t<this.numTriangles;t++){let e=t+2,i=0,n=0,s=0,a=0,o=0,h=0;for(1&e?s=a=o=r:i=n=h=r;(e>>=1)>1;){const t=i+s>>1,r=n+a>>1;1&e?(s=i,a=n,i=o,n=h):(i=s,n=a,s=o,a=h),o=t,h=r}const c=4*t;this.coords[c+0]=i,this.coords[c+1]=n,this.coords[c+2]=s,this.coords[c+3]=a}}createTile(t){return new d(t,this)}}class d{constructor(t,r){const e=r.gridSize;if(t.length!==e*e)throw new Error(\`Expected terrain data of length ${So}e*e} (${So}e} x ${So}e}), got ${So}t.length}.\`);this.terrain=t,this.martini=r,this.errors=new Float32Array(t.length),this.update()}update(){const{numTriangles:t,numParentTriangles:r,coords:e,gridSize:i}=this.martini,{terrain:n,errors:s}=this;for(let a=t-1;a>=0;a--){const t=4*a,o=e[t+0],h=e[t+1],c=e[t+2],f=e[t+3],u=o+c>>1,l=h+f>>1,d=u+l-h,y=l+o-u,A=(n[h*i+o]+n[f*i+c])/2,w=l*i+u,b=Math.abs(A-n[w]);if(s[w]=Math.max(s[w],b),a<r){const t=(h+y>>1)*i+(o+d>>1),r=(f+y>>1)*i+(c+d>>1);s[w]=Math.max(s[w],s[t],s[r])}}}getMesh(t=0){const{gridSize:r,indices:e}=this.martini,{errors:i}=this;let n=0,s=0;const a=r-1;function o(a,h,c,f,u,l){const d=a+c>>1,y=h+f>>1;Math.abs(a-u)+Math.abs(h-l)>1&&i[y*r+d]>t?(o(u,l,a,h,d,y),o(c,f,u,l,d,y)):(e[h*r+a]=e[h*r+a]||++n,e[f*r+c]=e[f*r+c]||++n,e[l*r+u]=e[l*r+u]||++n,s++)}e.fill(0),o(0,0,a,a,a,0),o(a,a,0,0,0,a);const h=new Uint16Array(2*n),c=new Uint32Array(3*s);let f=0;function u(n,s,a,o,l,d){const y=n+a>>1,A=s+o>>1;if(Math.abs(n-l)+Math.abs(s-d)>1&&i[A*r+y]>t)u(l,d,n,s,y,A),u(a,o,l,d,y,A);else{const t=e[s*r+n]-1,i=e[o*r+a]-1,u=e[d*r+l]-1;h[2*t]=n,h[2*t+1]=s,h[2*i]=a,h[2*i+1]=o,h[2*u]=l,h[2*u+1]=d,c[f++]=t,c[f++]=i,c[f++]=u}}return u(0,0,a,a,a,0),u(a,a,0,0,0,a),{vertices:h,triangles:c}}getMeshWithSkirts(t=0,r){const{gridSize:e,indices:i}=this.martini,{errors:n}=this;let s=0,a=0;const o=e-1;let h,c,f=0;const u=[],l=[],d=[],y=[];function A(r,w,b,p,v,k){const m=r+b>>1,U=w+p>>1;Math.abs(r-v)+Math.abs(w-k)>1&&n[U*e+m]>t?(A(v,k,r,w,m,U),A(b,p,v,k,m,U)):(h=w*e+r,c=p*e+b,f=k*e+v,0===i[h]&&(0===r?u.push(s):r===o&&l.push(s),0===w?d.push(s):w===o&&y.push(s),i[h]=++s),0===i[c]&&(0===b?u.push(s):b===o&&l.push(s),0===p?d.push(s):p===o&&y.push(s),i[c]=++s),0===i[f]&&(0===v?u.push(s):v===o&&l.push(s),0===k?d.push(s):k===o&&y.push(s),i[f]=++s),a++)}let w;i.fill(0),A(0,0,o,o,o,0),A(o,o,0,0,0,o),w=r?2*(s+3*u.length-2+3*l.length-2+3*d.length-2+3*y.length-2):2*(s+u.length+l.length+d.length+y.length);const b=3*(a+2*(u.length-1)+2*(l.length-1)+2*(d.length-1)+2*(y.length-1)),p=new Uint16Array(w),v=new Uint32Array(b);let k=0;function m(r,s,a,o,h,c){const f=r+a>>1,u=s+o>>1;if(Math.abs(r-h)+Math.abs(s-c)>1&&n[u*e+f]>t)m(h,c,r,s,f,u),m(a,o,h,c,f,u);else{const t=i[s*e+r]-1,n=i[o*e+a]-1,f=i[c*e+h]-1;p[2*t]=r,p[2*t+1]=s,p[2*n]=a,p[2*n+1]=o,p[2*f]=h,p[2*f+1]=c,v[k++]=t,v[k++]=n,v[k++]=f}}m(0,0,o,o,o,0),m(o,o,0,0,0,o),u.sort((t,r)=>p[2*t+1]-p[2*r+1]),l.sort((t,r)=>p[2*r+1]-p[2*t+1]),d.sort((t,r)=>p[2*r]-p[2*t]),y.sort((t,r)=>p[2*t]-p[2*r]);let U,g,x,E,T=2*s,M=0;function S(t){M=t.length;for(let e=0;e<M-1;e++)U=t[e],g=t[e+1],x=T/2,E=(T+(r?6:2))/2,p[T++]=2*U,p[T++]=2*U+1,r&&(p[T++]=2*U,p[T++]=2*U+1,p[T++]=2*g,p[T++]=2*g+1),r?(v[k++]=x+1,v[k++]=x,v[k++]=x+2,v[k++]=x,v[k++]=E,v[k++]=x+2):(v[k++]=U,v[k++]=x,v[k++]=g,v[k++]=x,v[k++]=E,v[k++]=g);p[T++]=2*t[M-1],p[T++]=2*t[M-1]+1}S(u);const I=T;S(l);const F=T;S(d);const D=T;S(y);return{vertices:p,triangles:v,numVerticesWithoutSkirts:s,numTrianglesWithoutSkirts:a,leftSkirtIndex:I,rightSkirtIndex:F,bottomSkirtIndex:D,topSkirtIndex:T}}}const y={};let A,w=null,b=null;const p={},v=64,k=64,m=3,U=-1e3,g=.001,x=256,E=4,T=.002,M={cesium_request_token:{Accept:"application/json,*/*;q=0.01","Accept-Encoding":"gzip, deflate, br"},tianditu:{"Accept-Encoding":"gzip, deflate, br"},cesium:{"Accept-Encoding":"gzip, deflate, br",Accept:"application/vnd.quantized-mesh,application/octet-stream;q=0.9,*/*;q=0.01"},mapbox:{Accept:"image/webp,*/*"}};M["cesium-ion"]=M.cesium;let S=null,I=null;function F(t,r){const e=function(t){if(t.length<1e3)return null;const r=new Zlib.Inflate(t);return r?r.decompress():null}(new Uint8Array(t));if(!e)throw new Error((i=new Uint8Array(t),D.decode(i)));var i;const n=function(t,r){const e=r,i=r,n=e+1,s=i+1,a=m,o=U,h=g,c=x,f=T,u=new Float32Array(n*s);let l=0,d=1/0,y=-1/0;for(let r=0;r<n;r++){const n=r>=i?i-1:r;for(let r=0;r<s;r++){let i=0;const s=n*(4*e)+4*(r>=e?e-1:r);for(let r=0;r<a;r++)i=i*c+t[s+r];i=1*(i*h+o),i-=f,u[l]=i,i<d&&(d=i),i>y&&(y=i),l++}}return{data:u,min:d,max:y}}(function(t){const r=t,e=v,i=k,n=new Uint8Array(e*i*E);let s,a,o,h,c;for(let t=0;t<i;t++)for(let f=0;f<e;f++){h=parseInt(149*t/(i-1)),c=parseInt(149*f/(e-1)),a=2*(150*h+c),s=r[a]+256*r[a+1],(s>1e4||s<-2e3)&&(s=0),o=4*(t*e+f);const u=(s+1e3)/g,l=x;n[o]=u/(l*l),n[o+1]=(u-n[o]*l*l)/l,n[o+2]=u-n[o]*l*l-n[o+1]*l,n[o+3]=255}return n}(e),r-1);return n.width=n.height=r,n}const D=new TextDecoder("utf-8");function z(t){return t>>1^-(1&t)}const C=[];function N(t){let r=0;const e=3*Float64Array.BYTES_PER_ELEMENT,i=3*Uint16Array.BYTES_PER_ELEMENT;let n=Uint16Array.BYTES_PER_ELEMENT;const s=new DataView(t);r+=e;const a=s.getFloat32(r,!0);r+=Float32Array.BYTES_PER_ELEMENT;const o=s.getFloat32(r,!0);r+=Float32Array.BYTES_PER_ELEMENT,r+=e;const h=s.getFloat64(r,!0);r+=Float64Array.BYTES_PER_ELEMENT,r+=e;const c=s.getUint32(r,!0);r+=Uint32Array.BYTES_PER_ELEMENT;const f=new Uint16Array(t,r,3*c);r+=c*i,c>65536&&(n=Uint32Array.BYTES_PER_ELEMENT);!function(t,r,e){const i=t.length;let n=0,s=0,a=0;for(let o=0;o<i;++o)n+=z(t[o]),s+=z(r[o]),t[o]=n,r[o]=s,e&&(a+=z(e[o]),e[o]=a)}(f.subarray(0,c),f.subarray(c,2*c),f.subarray(2*c,3*c)),r%n!=0&&(r+=n-r%n);const u=s.getUint32(r,!0);r+=Uint32Array.BYTES_PER_ELEMENT;const l=c>65536?new Uint32Array(t,r,3*u):new Uint16Array(t,r,3*u);let d=0;const y=l.length;for(let t=0;t<y;++t){const r=l[t];l[t]=d-r,0===r&&++d}const A={minimumHeight:a,maximumHeight:o,quantizedVertices:f,indices:l}.quantizedVertices,w=A.length/3,b=A.subarray(0,w),p=A.subarray(w,2*w),v=A.subarray(2*w,3*w),k=C;for(let t=0;t<w;++t){const r=b[t]/32767,e=p[t]/32767,i=(m=a,U=o,(1-(g=v[t]/32767))*m+g*U);k[3*t]=r,k[3*t+1]=1-e,k[3*t+2]=i}var m,U,g;return{positions:k,radius:h,min:a,max:o,indices:l}}const O=[],j=[],q=[],W=[],Z=[];class V{constructor(t,r,e,i,n){this.p0=[],this.p1=[],this.p2=[],this.normal=[],this.min=[],this.max=[],this.set(t,r,e,i,n)}set(t,r,e,i,o){this.radius=o;let h=3*r,c=3*r+1,f=3*r+2;this.p0[0]=t[h]*o,this.p0[1]=t[c]*o,this.p0[2]=t[f],h=3*e,c=3*e+1,f=3*e+2,this.p1[0]=t[h]*o,this.p1[1]=t[c]*o,this.p1[2]=t[f],h=3*i,c=3*i+1,f=3*i+2,this.p2[0]=t[h]*o,this.p2[1]=t[c]*o,this.p2[2]=t[f],this.min[0]=Math.min(this.p0[0],this.p1[0],this.p2[0]),this.min[1]=Math.min(this.p0[1],this.p1[1],this.p2[1]),this.max[0]=Math.max(this.p0[0],this.p1[0],this.p2[0]),this.max[1]=Math.max(this.p0[1],this.p1[1],this.p2[1]);const u=a(O,this.p1,this.p0),l=a(j,this.p2,this.p1);this.normal=n(this.normal,s(this.normal,u,l))}contains(t,r){if(t<this.min[0]||t>this.max[0]||r<this.min[1]||r>this.max[1])return!1;c(q,this.p0[0],this.p0[1]),c(W,this.p1[0],this.p1[1]),c(Z,this.p2[0],this.p2[1]);const e=H(q[0],q[1],W[0],W[1],Z[0],Z[1]);return H(t,r,q[0],q[1],Z[0],Z[1])+H(t,r,q[0],q[1],W[0],W[1])+H(t,r,W[0],W[1],Z[0],Z[1])-e<=1e-4}getHeight(t,r){const e=this.normal;return this.p0[2]-((t-this.p0[0])*e[0]+(r-this.p0[1])*e[1])/e[2]}}let $=null;function _(t,r,e){if($&&$.contains(r,e))return $.getHeight(r,e);for(let i=0;i<t.length;i++)if(t[i].contains(r,e))return $=t[i],t[i].getHeight(r,e);return 0}const B=[];function H(t,r,e,i,n,s){return.5*Math.abs(t*i+e*s+n*r-t*s-e*r-n*i)}function L(t,r,e,i,n,s){"cesium-ion"===e&&(r.Authorization="Bearer "+S),function(t,r,e){const i={method:"GET",referrer:e,headers:r},n=u.getArrayBuffer(t,i),s=n.xhr;return p[t]=s,n.then(r=>(delete p[t],r))}(t,r,origin).then(t=>{if(!t||t.message)s(t?{empty:!0,originalError:t}:{error:{canceled:!0}});else{const r=t.data;let a=null;if("tianditu"===e){const t=F(r,i);P(n,t,i,null,!0,s)}else if("cesium-ion"===e||"cesium"===e){a=N(r);const t=function(t,r){const{positions:e,min:i,max:n,indices:s,radius:a}=t,o=[];let h=0;for(let t=0;t<s.length;t+=3){let r=B[h];r?r.set(e,s[t],s[t+1],s[t+2],2*a):r=B[h]=new V(e,s[t],s[t+1],s[t+2],2*a),h++,o.push(r)}const c=new Float32Array(r*r);h=0;for(let t=0;t<r;t++)for(let e=0;e<r;e++)c[h++]=_(o,e/r*a*2,t/r*a*2);return{data:c,min:i,max:n,width:r,height:r}}(a,i);P(n,t,i,null,!0,s)}else"mapbox"===e&&(a=function(t){const r=new self.Blob([new Uint8Array(t)]);return self.createImageBitmap(r)}(r),a.then(t=>{const r=function(t,r){const{data:e,width:i}=t;let n=1/0,s=-1/0;const a=new Float32Array(r*r),o=Math.round(i/r);for(let t=0;t<r;t++)for(let h=0;h<r;h++){const c=t+h*r;let f=0,u=0;const l=t,d=h;for(let t=0;t<o;t++)for(let r=0;r<o;r++){let n=l*o+t,s=d*o+r;s>i-1&&(s=i-1),n>i-1&&(n=i-1);const a=n+s*i,h=e[4*a],c=e[4*a+1],y=e[4*a+2];0===e[4*a+3]?u+=1:f+=.1*(256*h*256+256*c+y)-1e4}f/=o*o-u||1,f>s&&(s=f),f<n&&(n=f),a[c]=f}return{data:a,width:r,height:r,min:n,max:s}}(function(t){const{width:r,height:e}=t;w||(w=new OffscreenCanvas(1,1),b=w.getContext("2d",{willReadFrequently:!0}));return w.width=r,w.height=e,b.drawImage(t,0,0,r,e),b.getImageData(0,0,r,e)}(t),i);P(n,r,i,t,!0,s)}))}}).catch(r=>{delete p[t],s({empty:!0,originalError:r})})}function P(t,r,e,i,n,s){const a=function(t,r,e,i){let n=y[e];n||(n=y[e]=new l(e));const s=n.createTile(r),a=i?s.getMeshWithSkirts(t,!0):s.getMesh(t),{triangles:o,vertices:h,leftSkirtIndex:c,rightSkirtIndex:f,bottomSkirtIndex:u,topSkirtIndex:d}=a;let{numVerticesWithoutSkirts:A,numTrianglesWithoutSkirts:w}=a;A||(A=h.legnth/3,w=o.length/3);const b=h.length/2,p=new Float32Array(3*b),v=new Float32Array(2*b);let k=1/0,m=-1/0;const U=e-1;for(let t=0;t<b;t++){const i=h[2*t],n=h[2*t+1];if(t>=A){const r=i/2*3;let e,n=.001;(t-(t<c/2?A:t<f/2?c/2:t<u/2?f/2:u/2))%3==0?(e=0,n=0):e=p[r+2];p[3*t]=p[r],p[3*t+1]=p[r+1],p[3*t+2]=e,v[2*t]=p[r]/U+n,v[2*t+1]=-p[r+1]/U+n}else p[3*t]=1*i,p[3*t+1]=1*-n,p[3*t+2]=r[n*e+i],v[2*t]=i/U,v[2*t+1]=n/U;const s=p[p.length-1];s<k&&(k=s),s>m&&(m=s)}return{positions:p,texcoords:v,triangles:o,leftSkirtIndex:c,rightSkirtIndex:f,bottomSkirtIndex:u,topSkirtIndex:d,numTrianglesWithoutSkirts:w,numVerticesWithoutSkirts:A,minHeight:k,maxHeight:m,terrainWidth:e}}(t,r.data,e,n),o=[a.positions.buffer,a.texcoords.buffer,a.triangles.buffer];i&&o.push(i);const h={mesh:a};h.image=i,h.data=r,o.push(r.data.buffer),s(h,o)}t.initialize=function(){},t.onmessage=function(t,r){const e=t.data;var i;"addLayer"===e.command||"removeLayer"===e.command?(A=t.workerId,self.postMessage({type:"<response>",actorId:e.actorId,workerId:A,params:"ok",callback:t.callback})):"fetchTerrain"===e.command?function(t,r){const{url:e,origin:i,type:n,accessToken:s,terrainWidth:a,error:o}=t,h=t.headers||M[n];if("tianditu"===n)L(e,h,n,a,o,r);else if("cesium-ion"===n){const c=t.cesiumIonTokenURL+s;S?L(e,h,n,a,o,r):(I||(I=fetch(c,{responseType:"json",method:"GET",referrer:i,headers:{Accept:"application/json,*/*;q=0.01","Accept-Encoding":"gzip, deflate, br"}}).then(t=>t.json()).then(t=>{S=t.accessToken,I=null})),I.then(()=>{L(e,h,n,a,o,r)}))}else("cesium"===n||"mapbox"===n)&&L(e,h,n,a,o,r)}(e.params,(t,e)=>{r(t.error,t,e)}):"abortTerrain"===e.command&&(i=e.params.url,p[i]&&(p[i].abort(),delete p[i]))}}`;
il("@maptalks/terrain", n6);
typeof console < "u" && console.log("@maptalks/gl v0.97.4");
let Sa;
const KM = {
  width: 100,
  height: 10
};
function r6() {
  if (!Sa) {
    const { width: i, height: t } = KM;
    OffscreenCanvas ? Sa = new OffscreenCanvas(i, t) : (Sa = document.createElement("canvas"), Sa.width = i, Sa.height = t);
  }
  return Sa;
}
class c2 {
  constructor(t, e = {}) {
    if (!Array.isArray(t)) {
      console.error("colors is not array");
      return;
    }
    if (t.length < 2) {
      console.error("colors.length should >1");
      return;
    }
    this.colors = t;
    let r = 1 / 0, n = -1 / 0;
    for (let s = 0, o = t.length; s < o; s++) {
      const a = t[s][0];
      r = Math.min(a, r), n = Math.max(a, n);
    }
    this.min = r, this.max = n, this.valueOffset = this.max - this.min, this.options = Object.assign({}, KM, e), this._initImgData();
  }
  getImageData() {
    return this.imgData;
  }
  _initImgData() {
    const t = r6(), { width: e, height: r } = this.options;
    t.width = e, t.height = r;
    const n = t.getContext("2d");
    n.clearRect(0, 0, t.width, t.height);
    const s = n.createLinearGradient(0, 0, t.width, 0), { colors: o, valueOffset: a } = this;
    for (let l = 0, h = o.length; l < h; l++) {
      const [u, c] = o[l], f = (u - this.min) / a;
      s.addColorStop(f, c);
    }
    n.fillStyle = s, n.fillRect(0, 0, t.width, t.height), this.imgData = n.getImageData(0, 0, t.width, t.height);
  }
  getColor(t) {
    t = Math.max(this.min, t), t = Math.min(t, this.max);
    const e = (t - this.min) / this.valueOffset;
    let r = Math.round(e * this.imgData.width);
    r = Math.min(r, this.imgData.width - 1);
    const n = r * 4, s = this.imgData.data[n], o = this.imgData.data[n + 1], a = this.imgData.data[n + 2], l = this.imgData.data[n + 3];
    return [s, o, a, l];
  }
}
var i6 = typeof Map == "function", Eh;
i6 && (Eh = /* @__PURE__ */ new Map());
function QM(i, t) {
  var e, r, n;
  if (!Ft(i))
    e = function() {
      return i;
    }, r = !0, n = !0;
  else {
    var s = i.stops && typeof i.stops[0][0] == "object", o = s || i.property !== void 0, a = s || !o, l = i.type || t || "exponential", h;
    if (l === "exponential")
      h = f2;
    else if (l === "interval")
      h = a6;
    else if (l === "categorical")
      h = o6;
    else if (l === "identity")
      h = h6;
    else if (l === "color-interpolate")
      h = l6;
    else
      throw new Error('Unknown function type "' + l + '"');
    if (s) {
      var u = {}, c = [];
      for (let d = 0; d < i.stops.length; d++) {
        var f = i.stops[d];
        u[f[0].zoom] === void 0 && (u[f[0].zoom] = {
          zoom: f[0].zoom,
          type: i.type,
          property: i.property,
          default: i.default,
          stops: []
        }), u[f[0].zoom].stops.push([f[0].value, f[1]]);
      }
      for (let d in u)
        c.push([u[d].zoom, QM(u[d])]);
      e = function(d, p) {
        const g = f2({ stops: c, base: i.base }, d)(d, p);
        return typeof g == "function" ? g(d, p) : g;
      }, r = !1, n = !1;
    } else a ? (e = function(d) {
      const p = h(i, d);
      return typeof p == "function" ? p(d) : p;
    }, r = !0, n = !1) : (e = function(d, p) {
      const g = h(i, p ? p[i.property] : null);
      return typeof g == "function" ? g(d, p) : g;
    }, r = !1, n = !0);
  }
  return e.isZoomConstant = n, e.isFeatureConstant = r, e;
}
function s6(i, t, e) {
  return i !== void 0 ? i : t !== void 0 ? t : null;
}
function o6(i, t) {
  for (let e = 0; e < i.stops.length; e++)
    if (t === i.stops[e][0])
      return i.stops[e][1];
  return i.default;
}
function a6(i, t) {
  for (var e = 0; e < i.stops.length && !(t < i.stops[e][0]); e++)
    ;
  return i.stops[Math.max(e - 1, 0)][1];
}
function f2(i, t) {
  for (var e = i.base !== void 0 ? i.base : 1, r = 0; !(r >= i.stops.length); ) {
    if (t <= i.stops[r][0]) break;
    r++;
  }
  return r === 0 ? i.stops[r][1] : r === i.stops.length ? i.stops[r - 1][1] : tS(
    t,
    e,
    i.stops[r - 1][0],
    i.stops[r][0],
    i.stops[r - 1][1],
    i.stops[r][1]
  );
}
const d2 = {
  width: 100,
  height: 1
};
function l6(i, t) {
  const e = i.stops;
  if (e && e.length > 1) {
    let r;
    if (Eh) {
      const l = JSON.stringify(e);
      if (!Eh.has(l)) {
        const h = new c2(e, d2);
        Eh.set(l, h);
      }
      r = Eh.get(l);
    } else
      r = new c2(e, d2);
    const [n, s, o, a] = r.getColor(t);
    return [n / 255, s / 255, o / 255, a / 255];
  } else if (e && e.length === 1)
    return e[0][1];
  return null;
}
function h6(i, t) {
  return s6(t, i.default);
}
function tS(i, t, e, r, n, s) {
  return typeof n == "function" ? function() {
    var o = n.apply(void 0, arguments), a = s.apply(void 0, arguments);
    return tS(i, t, e, r, o, a);
  } : n.length ? u6(i, t, e, r, n, s) : eS(i, t, e, r, n, s);
}
function eS(i, t, e, r, n, s) {
  var o = r - e, a = i - e, l;
  return t === 1 ? l = a / o : l = (Math.pow(t, a) - 1) / (Math.pow(t, o) - 1), n * (1 - l) + s * l;
}
function u6(i, t, e, r, n, s) {
  var o = [];
  for (let a = 0; a < n.length; a++)
    o[a] = eS(i, t, e, r, n[a], s[a]);
  return o;
}
function Ft(i) {
  return i && typeof i == "object" && (i.stops || i.property && i.type === "identity");
}
function he(i) {
  return py(i, "exponential");
}
function ln(i) {
  return py(i, "interval");
}
function vu(i, t) {
  if (!i)
    return null;
  var e = !1;
  if (Array.isArray(i)) {
    var r = [], n;
    for (let h = 0; h < i.length; h++)
      n = vu(i[h], t), n ? (r.push(n), e = !0) : r.push(i[h]);
    return e ? r : i;
  }
  var s = { __fn_types_loaded: !0 }, o = [], a;
  for (a in i)
    i.hasOwnProperty(a) && o.push(a);
  const l = function(h) {
    Object.defineProperty(s, h, {
      get: function() {
        return this["__fn_" + h] || (this["__fn_" + h] = he(this["_" + h])), this["__fn_" + h].apply(this, t());
      },
      set: function(u) {
        this["_" + h] = u;
      },
      configurable: !0,
      enumerable: !0
    });
  };
  for (let h = 0, u = o.length; h < u; h++)
    a = o[h], Ft(i[a]) ? (e = !0, s["_" + a] = i[a], l(a)) : s[a] = i[a];
  return e ? s : i;
}
function py(i, t) {
  if (!Ft(i))
    return function() {
      return i;
    };
  i = JSON.parse(JSON.stringify(i));
  let e = !0, r = !0;
  const n = i.stops;
  if (n) {
    for (let o = 0; o < n.length; o++)
      if (Ft(n[o][1])) {
        const a = py(n[o][1], t);
        e = e && a.isZoomConstant, r = r && a.isFeatureConstant, n[o] = [n[o][0], a];
      }
  }
  const s = QM(i, t);
  return s.isZoomConstant = e && s.isZoomConstant, s.isFeatureConstant = r && s.isFeatureConstant, s;
}
var c6 = gl;
function gl(i, t) {
  this.x = i, this.y = t;
}
gl.prototype = {
  /**
   * Clone this point, returning a new point that can be modified
   * without affecting the old one.
   * @return {Point} the clone
   */
  clone: function() {
    return new gl(this.x, this.y);
  },
  /**
   * Add this point's x & y coordinates to another point,
   * yielding a new point.
   * @param {Point} p the other point
   * @return {Point} output point
   */
  add: function(i) {
    return this.clone()._add(i);
  },
  /**
   * Subtract this point's x & y coordinates to from point,
   * yielding a new point.
   * @param {Point} p the other point
   * @return {Point} output point
   */
  sub: function(i) {
    return this.clone()._sub(i);
  },
  /**
   * Multiply this point's x & y coordinates by point,
   * yielding a new point.
   * @param {Point} p the other point
   * @return {Point} output point
   */
  multByPoint: function(i) {
    return this.clone()._multByPoint(i);
  },
  /**
   * Divide this point's x & y coordinates by point,
   * yielding a new point.
   * @param {Point} p the other point
   * @return {Point} output point
   */
  divByPoint: function(i) {
    return this.clone()._divByPoint(i);
  },
  /**
   * Multiply this point's x & y coordinates by a factor,
   * yielding a new point.
   * @param {Point} k factor
   * @return {Point} output point
   */
  mult: function(i) {
    return this.clone()._mult(i);
  },
  /**
   * Divide this point's x & y coordinates by a factor,
   * yielding a new point.
   * @param {Point} k factor
   * @return {Point} output point
   */
  div: function(i) {
    return this.clone()._div(i);
  },
  /**
   * Rotate this point around the 0, 0 origin by an angle a,
   * given in radians
   * @param {Number} a angle to rotate around, in radians
   * @return {Point} output point
   */
  rotate: function(i) {
    return this.clone()._rotate(i);
  },
  /**
   * Rotate this point around p point by an angle a,
   * given in radians
   * @param {Number} a angle to rotate around, in radians
   * @param {Point} p Point to rotate around
   * @return {Point} output point
   */
  rotateAround: function(i, t) {
    return this.clone()._rotateAround(i, t);
  },
  /**
   * Multiply this point by a 4x1 transformation matrix
   * @param {Array<Number>} m transformation matrix
   * @return {Point} output point
   */
  matMult: function(i) {
    return this.clone()._matMult(i);
  },
  /**
   * Calculate this point but as a unit vector from 0, 0, meaning
   * that the distance from the resulting point to the 0, 0
   * coordinate will be equal to 1 and the angle from the resulting
   * point to the 0, 0 coordinate will be the same as before.
   * @return {Point} unit vector point
   */
  unit: function() {
    return this.clone()._unit();
  },
  /**
   * Compute a perpendicular point, where the new y coordinate
   * is the old x coordinate and the new x coordinate is the old y
   * coordinate multiplied by -1
   * @return {Point} perpendicular point
   */
  perp: function() {
    return this.clone()._perp();
  },
  /**
   * Return a version of this point with the x & y coordinates
   * rounded to integers.
   * @return {Point} rounded point
   */
  round: function() {
    return this.clone()._round();
  },
  /**
   * Return the magitude of this point: this is the Euclidean
   * distance from the 0, 0 coordinate to this point's x and y
   * coordinates.
   * @return {Number} magnitude
   */
  mag: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  /**
   * Judge whether this point is equal to another point, returning
   * true or false.
   * @param {Point} other the other point
   * @return {boolean} whether the points are equal
   */
  equals: function(i) {
    return this.x === i.x && this.y === i.y;
  },
  /**
   * Calculate the distance from this point to another point
   * @param {Point} p the other point
   * @return {Number} distance
   */
  dist: function(i) {
    return Math.sqrt(this.distSqr(i));
  },
  /**
   * Calculate the distance from this point to another point,
   * without the square root step. Useful if you're comparing
   * relative distances.
   * @param {Point} p the other point
   * @return {Number} distance
   */
  distSqr: function(i) {
    var t = i.x - this.x, e = i.y - this.y;
    return t * t + e * e;
  },
  /**
   * Get the angle from the 0, 0 coordinate to this point, in radians
   * coordinates.
   * @return {Number} angle
   */
  angle: function() {
    return Math.atan2(this.y, this.x);
  },
  /**
   * Get the angle from this point to another point, in radians
   * @param {Point} b the other point
   * @return {Number} angle
   */
  angleTo: function(i) {
    return Math.atan2(this.y - i.y, this.x - i.x);
  },
  /**
   * Get the angle between this point and another point, in radians
   * @param {Point} b the other point
   * @return {Number} angle
   */
  angleWith: function(i) {
    return this.angleWithSep(i.x, i.y);
  },
  /*
   * Find the angle of the two vectors, solving the formula for
   * the cross product a x b = |a||b|sin(θ) for θ.
   * @param {Number} x the x-coordinate
   * @param {Number} y the y-coordinate
   * @return {Number} the angle in radians
   */
  angleWithSep: function(i, t) {
    return Math.atan2(
      this.x * t - this.y * i,
      this.x * i + this.y * t
    );
  },
  _matMult: function(i) {
    var t = i[0] * this.x + i[1] * this.y, e = i[2] * this.x + i[3] * this.y;
    return this.x = t, this.y = e, this;
  },
  _add: function(i) {
    return this.x += i.x, this.y += i.y, this;
  },
  _sub: function(i) {
    return this.x -= i.x, this.y -= i.y, this;
  },
  _mult: function(i) {
    return this.x *= i, this.y *= i, this;
  },
  _div: function(i) {
    return this.x /= i, this.y /= i, this;
  },
  _multByPoint: function(i) {
    return this.x *= i.x, this.y *= i.y, this;
  },
  _divByPoint: function(i) {
    return this.x /= i.x, this.y /= i.y, this;
  },
  _unit: function() {
    return this._div(this.mag()), this;
  },
  _perp: function() {
    var i = this.y;
    return this.y = this.x, this.x = -i, this;
  },
  _rotate: function(i) {
    var t = Math.cos(i), e = Math.sin(i), r = t * this.x - e * this.y, n = e * this.x + t * this.y;
    return this.x = r, this.y = n, this;
  },
  _rotateAround: function(i, t) {
    var e = Math.cos(i), r = Math.sin(i), n = t.x + e * (this.x - t.x) - r * (this.y - t.y), s = t.y + r * (this.x - t.x) + e * (this.y - t.y);
    return this.x = n, this.y = s, this;
  },
  _round: function() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
};
gl.convert = function(i) {
  return i instanceof gl ? i : Array.isArray(i) ? new gl(i[0], i[1]) : i;
};
const en = /* @__PURE__ */ Fs(c6);
function ki(i, t, e) {
  e = e || {}, this.w = i || 64, this.h = t || 64, this.autoResize = !!e.autoResize, this.shelves = [], this.freebins = [], this.stats = {}, this.bins = {}, this.maxId = 0;
}
ki.prototype.pack = function(i, t) {
  i = [].concat(i), t = t || {};
  for (var e = [], r, n, s, o, a = 0; a < i.length; a++)
    if (r = i[a].w || i[a].width, n = i[a].h || i[a].height, s = i[a].id, r && n) {
      if (o = this.packOne(r, n, s), !o)
        continue;
      t.inPlace && (i[a].x = o.x, i[a].y = o.y, i[a].id = o.id), e.push(o);
    }
  return this.shrink(), e;
};
ki.prototype.packOne = function(i, t, e) {
  var r = { freebin: -1, shelf: -1, waste: 1 / 0 }, n = 0, s, o, a, l;
  if (typeof e == "string" || typeof e == "number") {
    if (s = this.getBin(e), s)
      return this.ref(s), s;
    typeof e == "number" && (this.maxId = Math.max(e, this.maxId));
  } else
    e = ++this.maxId;
  for (l = 0; l < this.freebins.length; l++) {
    if (s = this.freebins[l], t === s.maxh && i === s.maxw)
      return this.allocFreebin(l, i, t, e);
    t > s.maxh || i > s.maxw || t <= s.maxh && i <= s.maxw && (a = s.maxw * s.maxh - i * t, a < r.waste && (r.waste = a, r.freebin = l));
  }
  for (l = 0; l < this.shelves.length; l++)
    if (o = this.shelves[l], n += o.h, !(i > o.free)) {
      if (t === o.h)
        return this.allocShelf(l, i, t, e);
      t > o.h || t < o.h && (a = (o.h - t) * i, a < r.waste && (r.freebin = -1, r.waste = a, r.shelf = l));
    }
  if (r.freebin !== -1)
    return this.allocFreebin(r.freebin, i, t, e);
  if (r.shelf !== -1)
    return this.allocShelf(r.shelf, i, t, e);
  if (t <= this.h - n && i <= this.w)
    return o = new gy(n, this.w, t), this.allocShelf(this.shelves.push(o) - 1, i, t, e);
  if (this.autoResize) {
    var h, u, c, f;
    return h = u = this.h, c = f = this.w, (c <= h || i > c) && (f = Math.max(i, c) * 2), (h < c || t > h) && (u = Math.max(t, h) * 2), this.resize(f, u), this.packOne(i, t, e);
  }
  return null;
};
ki.prototype.allocFreebin = function(i, t, e, r) {
  var n = this.freebins.splice(i, 1)[0];
  return n.id = r, n.w = t, n.h = e, n.refcount = 0, this.bins[r] = n, this.ref(n), n;
};
ki.prototype.allocShelf = function(i, t, e, r) {
  var n = this.shelves[i], s = n.alloc(t, e, r);
  return this.bins[r] = s, this.ref(s), s;
};
ki.prototype.shrink = function() {
  if (this.shelves.length > 0) {
    for (var i = 0, t = 0, e = 0; e < this.shelves.length; e++) {
      var r = this.shelves[e];
      t += r.h, i = Math.max(r.w - r.free, i);
    }
    this.resize(i, t);
  }
};
ki.prototype.getBin = function(i) {
  return this.bins[i];
};
ki.prototype.ref = function(i) {
  if (++i.refcount === 1) {
    var t = i.h;
    this.stats[t] = (this.stats[t] | 0) + 1;
  }
  return i.refcount;
};
ki.prototype.unref = function(i) {
  return i.refcount === 0 ? 0 : (--i.refcount === 0 && (this.stats[i.h]--, delete this.bins[i.id], this.freebins.push(i)), i.refcount);
};
ki.prototype.clear = function() {
  this.shelves = [], this.freebins = [], this.stats = {}, this.bins = {}, this.maxId = 0;
};
ki.prototype.resize = function(i, t) {
  this.w = i, this.h = t;
  for (var e = 0; e < this.shelves.length; e++)
    this.shelves[e].resize(i);
  return !0;
};
function gy(i, t, e) {
  this.x = 0, this.y = i, this.w = this.free = t, this.h = e;
}
gy.prototype.alloc = function(i, t, e) {
  if (i > this.free || t > this.h)
    return null;
  var r = this.x;
  return this.x += i, this.free -= i, new f6(e, r, this.y, i, t, i, this.h);
};
gy.prototype.resize = function(i) {
  return this.free += i - this.w, this.w = i, !0;
};
function f6(i, t, e, r, n, s, o) {
  this.id = i, this.x = t, this.y = e, this.w = r, this.h = n, this.maxw = s || r, this.maxh = o || n, this.refcount = 0;
}
var nS = { exports: {} }, d6 = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
}, rS = { exports: {} }, p6 = function(t) {
  return !t || typeof t == "string" ? !1 : t instanceof Array || Array.isArray(t) || t.length >= 0 && (t.splice instanceof Function || Object.getOwnPropertyDescriptor(t, t.length - 1) && t.constructor.name !== "String");
}, g6 = p6, m6 = Array.prototype.concat, v6 = Array.prototype.slice, p2 = rS.exports = function(t) {
  for (var e = [], r = 0, n = t.length; r < n; r++) {
    var s = t[r];
    g6(s) ? e = m6.call(e, v6.call(s)) : e.push(s);
  }
  return e;
};
p2.wrap = function(i) {
  return function() {
    return i(p2(arguments));
  };
};
var y6 = rS.exports, Wh = d6, Nu = y6, iS = Object.hasOwnProperty, sS = /* @__PURE__ */ Object.create(null);
for (var Ng in Wh)
  iS.call(Wh, Ng) && (sS[Wh[Ng]] = Ng);
var ci = nS.exports = {
  to: {},
  get: {}
};
ci.get = function(i) {
  var t = i.substring(0, 3).toLowerCase(), e, r;
  switch (t) {
    case "hsl":
      e = ci.get.hsl(i), r = "hsl";
      break;
    case "hwb":
      e = ci.get.hwb(i), r = "hwb";
      break;
    default:
      e = ci.get.rgb(i), r = "rgb";
      break;
  }
  return e ? { model: r, value: e } : null;
};
ci.get.rgb = function(i) {
  if (!i)
    return null;
  var t = /^#([a-f0-9]{3,4})$/i, e = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i, r = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/, n = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/, s = /^(\w+)$/, o = [0, 0, 0, 1], a, l, h;
  if (a = i.match(e)) {
    for (h = a[2], a = a[1], l = 0; l < 3; l++) {
      var u = l * 2;
      o[l] = parseInt(a.slice(u, u + 2), 16);
    }
    h && (o[3] = parseInt(h, 16) / 255);
  } else if (a = i.match(t)) {
    for (a = a[1], h = a[3], l = 0; l < 3; l++)
      o[l] = parseInt(a[l] + a[l], 16);
    h && (o[3] = parseInt(h + h, 16) / 255);
  } else if (a = i.match(r)) {
    for (l = 0; l < 3; l++)
      o[l] = parseInt(a[l + 1], 0);
    a[4] && (a[5] ? o[3] = parseFloat(a[4]) * 0.01 : o[3] = parseFloat(a[4]));
  } else if (a = i.match(n)) {
    for (l = 0; l < 3; l++)
      o[l] = Math.round(parseFloat(a[l + 1]) * 2.55);
    a[4] && (a[5] ? o[3] = parseFloat(a[4]) * 0.01 : o[3] = parseFloat(a[4]));
  } else return (a = i.match(s)) ? a[1] === "transparent" ? [0, 0, 0, 0] : iS.call(Wh, a[1]) ? (o = Wh[a[1]], o[3] = 1, o) : null : null;
  for (l = 0; l < 3; l++)
    o[l] = co(o[l], 0, 255);
  return o[3] = co(o[3], 0, 1), o;
};
ci.get.hsl = function(i) {
  if (!i)
    return null;
  var t = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/, e = i.match(t);
  if (e) {
    var r = parseFloat(e[4]), n = (parseFloat(e[1]) % 360 + 360) % 360, s = co(parseFloat(e[2]), 0, 100), o = co(parseFloat(e[3]), 0, 100), a = co(isNaN(r) ? 1 : r, 0, 1);
    return [n, s, o, a];
  }
  return null;
};
ci.get.hwb = function(i) {
  if (!i)
    return null;
  var t = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/, e = i.match(t);
  if (e) {
    var r = parseFloat(e[4]), n = (parseFloat(e[1]) % 360 + 360) % 360, s = co(parseFloat(e[2]), 0, 100), o = co(parseFloat(e[3]), 0, 100), a = co(isNaN(r) ? 1 : r, 0, 1);
    return [n, s, o, a];
  }
  return null;
};
ci.to.hex = function() {
  var i = Nu(arguments);
  return "#" + Fc(i[0]) + Fc(i[1]) + Fc(i[2]) + (i[3] < 1 ? Fc(Math.round(i[3] * 255)) : "");
};
ci.to.rgb = function() {
  var i = Nu(arguments);
  return i.length < 4 || i[3] === 1 ? "rgb(" + Math.round(i[0]) + ", " + Math.round(i[1]) + ", " + Math.round(i[2]) + ")" : "rgba(" + Math.round(i[0]) + ", " + Math.round(i[1]) + ", " + Math.round(i[2]) + ", " + i[3] + ")";
};
ci.to.rgb.percent = function() {
  var i = Nu(arguments), t = Math.round(i[0] / 255 * 100), e = Math.round(i[1] / 255 * 100), r = Math.round(i[2] / 255 * 100);
  return i.length < 4 || i[3] === 1 ? "rgb(" + t + "%, " + e + "%, " + r + "%)" : "rgba(" + t + "%, " + e + "%, " + r + "%, " + i[3] + ")";
};
ci.to.hsl = function() {
  var i = Nu(arguments);
  return i.length < 4 || i[3] === 1 ? "hsl(" + i[0] + ", " + i[1] + "%, " + i[2] + "%)" : "hsla(" + i[0] + ", " + i[1] + "%, " + i[2] + "%, " + i[3] + ")";
};
ci.to.hwb = function() {
  var i = Nu(arguments), t = "";
  return i.length >= 4 && i[3] !== 1 && (t = ", " + i[3]), "hwb(" + i[0] + ", " + i[1] + "%, " + i[2] + "%" + t + ")";
};
ci.to.keyword = function(i) {
  return sS[i.slice(0, 3)];
};
function co(i, t, e) {
  return Math.min(Math.max(t, i), e);
}
function Fc(i) {
  var t = Math.round(i).toString(16).toUpperCase();
  return t.length < 2 ? "0" + t : t;
}
var _6 = nS.exports, oS = { exports: {} }, x6 = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
}, Lo = x6, aS = {};
for (var Hg in Lo)
  Lo.hasOwnProperty(Hg) && (aS[Lo[Hg]] = Hg);
var me = oS.exports = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  lch: { channels: 3, labels: "lch" },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] }
};
for (var $r in me)
  if (me.hasOwnProperty($r)) {
    if (!("channels" in me[$r]))
      throw new Error("missing channels property: " + $r);
    if (!("labels" in me[$r]))
      throw new Error("missing channel labels property: " + $r);
    if (me[$r].labels.length !== me[$r].channels)
      throw new Error("channel and label counts mismatch: " + $r);
    var b6 = me[$r].channels, w6 = me[$r].labels;
    delete me[$r].channels, delete me[$r].labels, Object.defineProperty(me[$r], "channels", { value: b6 }), Object.defineProperty(me[$r], "labels", { value: w6 });
  }
me.rgb.hsl = function(i) {
  var t = i[0] / 255, e = i[1] / 255, r = i[2] / 255, n = Math.min(t, e, r), s = Math.max(t, e, r), o = s - n, a, l, h;
  return s === n ? a = 0 : t === s ? a = (e - r) / o : e === s ? a = 2 + (r - t) / o : r === s && (a = 4 + (t - e) / o), a = Math.min(a * 60, 360), a < 0 && (a += 360), h = (n + s) / 2, s === n ? l = 0 : h <= 0.5 ? l = o / (s + n) : l = o / (2 - s - n), [a, l * 100, h * 100];
};
me.rgb.hsv = function(i) {
  var t, e, r, n, s, o = i[0] / 255, a = i[1] / 255, l = i[2] / 255, h = Math.max(o, a, l), u = h - Math.min(o, a, l), c = function(f) {
    return (h - f) / 6 / u + 1 / 2;
  };
  return u === 0 ? n = s = 0 : (s = u / h, t = c(o), e = c(a), r = c(l), o === h ? n = r - e : a === h ? n = 1 / 3 + t - r : l === h && (n = 2 / 3 + e - t), n < 0 ? n += 1 : n > 1 && (n -= 1)), [
    n * 360,
    s * 100,
    h * 100
  ];
};
me.rgb.hwb = function(i) {
  var t = i[0], e = i[1], r = i[2], n = me.rgb.hsl(i)[0], s = 1 / 255 * Math.min(t, Math.min(e, r));
  return r = 1 - 1 / 255 * Math.max(t, Math.max(e, r)), [n, s * 100, r * 100];
};
me.rgb.cmyk = function(i) {
  var t = i[0] / 255, e = i[1] / 255, r = i[2] / 255, n, s, o, a;
  return a = Math.min(1 - t, 1 - e, 1 - r), n = (1 - t - a) / (1 - a) || 0, s = (1 - e - a) / (1 - a) || 0, o = (1 - r - a) / (1 - a) || 0, [n * 100, s * 100, o * 100, a * 100];
};
function T6(i, t) {
  return Math.pow(i[0] - t[0], 2) + Math.pow(i[1] - t[1], 2) + Math.pow(i[2] - t[2], 2);
}
me.rgb.keyword = function(i) {
  var t = aS[i];
  if (t)
    return t;
  var e = 1 / 0, r;
  for (var n in Lo)
    if (Lo.hasOwnProperty(n)) {
      var s = Lo[n], o = T6(i, s);
      o < e && (e = o, r = n);
    }
  return r;
};
me.keyword.rgb = function(i) {
  return Lo[i];
};
me.rgb.xyz = function(i) {
  var t = i[0] / 255, e = i[1] / 255, r = i[2] / 255;
  t = t > 0.04045 ? Math.pow((t + 0.055) / 1.055, 2.4) : t / 12.92, e = e > 0.04045 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92, r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
  var n = t * 0.4124 + e * 0.3576 + r * 0.1805, s = t * 0.2126 + e * 0.7152 + r * 0.0722, o = t * 0.0193 + e * 0.1192 + r * 0.9505;
  return [n * 100, s * 100, o * 100];
};
me.rgb.lab = function(i) {
  var t = me.rgb.xyz(i), e = t[0], r = t[1], n = t[2], s, o, a;
  return e /= 95.047, r /= 100, n /= 108.883, e = e > 8856e-6 ? Math.pow(e, 1 / 3) : 7.787 * e + 16 / 116, r = r > 8856e-6 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, n = n > 8856e-6 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116, s = 116 * r - 16, o = 500 * (e - r), a = 200 * (r - n), [s, o, a];
};
me.hsl.rgb = function(i) {
  var t = i[0] / 360, e = i[1] / 100, r = i[2] / 100, n, s, o, a, l;
  if (e === 0)
    return l = r * 255, [l, l, l];
  r < 0.5 ? s = r * (1 + e) : s = r + e - r * e, n = 2 * r - s, a = [0, 0, 0];
  for (var h = 0; h < 3; h++)
    o = t + 1 / 3 * -(h - 1), o < 0 && o++, o > 1 && o--, 6 * o < 1 ? l = n + (s - n) * 6 * o : 2 * o < 1 ? l = s : 3 * o < 2 ? l = n + (s - n) * (2 / 3 - o) * 6 : l = n, a[h] = l * 255;
  return a;
};
me.hsl.hsv = function(i) {
  var t = i[0], e = i[1] / 100, r = i[2] / 100, n = e, s = Math.max(r, 0.01), o, a;
  return r *= 2, e *= r <= 1 ? r : 2 - r, n *= s <= 1 ? s : 2 - s, a = (r + e) / 2, o = r === 0 ? 2 * n / (s + n) : 2 * e / (r + e), [t, o * 100, a * 100];
};
me.hsv.rgb = function(i) {
  var t = i[0] / 60, e = i[1] / 100, r = i[2] / 100, n = Math.floor(t) % 6, s = t - Math.floor(t), o = 255 * r * (1 - e), a = 255 * r * (1 - e * s), l = 255 * r * (1 - e * (1 - s));
  switch (r *= 255, n) {
    case 0:
      return [r, l, o];
    case 1:
      return [a, r, o];
    case 2:
      return [o, r, l];
    case 3:
      return [o, a, r];
    case 4:
      return [l, o, r];
    case 5:
      return [r, o, a];
  }
};
me.hsv.hsl = function(i) {
  var t = i[0], e = i[1] / 100, r = i[2] / 100, n = Math.max(r, 0.01), s, o, a;
  return a = (2 - e) * r, s = (2 - e) * n, o = e * n, o /= s <= 1 ? s : 2 - s, o = o || 0, a /= 2, [t, o * 100, a * 100];
};
me.hwb.rgb = function(i) {
  var t = i[0] / 360, e = i[1] / 100, r = i[2] / 100, n = e + r, s, o, a, l;
  n > 1 && (e /= n, r /= n), s = Math.floor(6 * t), o = 1 - r, a = 6 * t - s, s & 1 && (a = 1 - a), l = e + a * (o - e);
  var h, u, c;
  switch (s) {
    default:
    case 6:
    case 0:
      h = o, u = l, c = e;
      break;
    case 1:
      h = l, u = o, c = e;
      break;
    case 2:
      h = e, u = o, c = l;
      break;
    case 3:
      h = e, u = l, c = o;
      break;
    case 4:
      h = l, u = e, c = o;
      break;
    case 5:
      h = o, u = e, c = l;
      break;
  }
  return [h * 255, u * 255, c * 255];
};
me.cmyk.rgb = function(i) {
  var t = i[0] / 100, e = i[1] / 100, r = i[2] / 100, n = i[3] / 100, s, o, a;
  return s = 1 - Math.min(1, t * (1 - n) + n), o = 1 - Math.min(1, e * (1 - n) + n), a = 1 - Math.min(1, r * (1 - n) + n), [s * 255, o * 255, a * 255];
};
me.xyz.rgb = function(i) {
  var t = i[0] / 100, e = i[1] / 100, r = i[2] / 100, n, s, o;
  return n = t * 3.2406 + e * -1.5372 + r * -0.4986, s = t * -0.9689 + e * 1.8758 + r * 0.0415, o = t * 0.0557 + e * -0.204 + r * 1.057, n = n > 31308e-7 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : n * 12.92, s = s > 31308e-7 ? 1.055 * Math.pow(s, 1 / 2.4) - 0.055 : s * 12.92, o = o > 31308e-7 ? 1.055 * Math.pow(o, 1 / 2.4) - 0.055 : o * 12.92, n = Math.min(Math.max(0, n), 1), s = Math.min(Math.max(0, s), 1), o = Math.min(Math.max(0, o), 1), [n * 255, s * 255, o * 255];
};
me.xyz.lab = function(i) {
  var t = i[0], e = i[1], r = i[2], n, s, o;
  return t /= 95.047, e /= 100, r /= 108.883, t = t > 8856e-6 ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116, e = e > 8856e-6 ? Math.pow(e, 1 / 3) : 7.787 * e + 16 / 116, r = r > 8856e-6 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, n = 116 * e - 16, s = 500 * (t - e), o = 200 * (e - r), [n, s, o];
};
me.lab.xyz = function(i) {
  var t = i[0], e = i[1], r = i[2], n, s, o;
  s = (t + 16) / 116, n = e / 500 + s, o = s - r / 200;
  var a = Math.pow(s, 3), l = Math.pow(n, 3), h = Math.pow(o, 3);
  return s = a > 8856e-6 ? a : (s - 16 / 116) / 7.787, n = l > 8856e-6 ? l : (n - 16 / 116) / 7.787, o = h > 8856e-6 ? h : (o - 16 / 116) / 7.787, n *= 95.047, s *= 100, o *= 108.883, [n, s, o];
};
me.lab.lch = function(i) {
  var t = i[0], e = i[1], r = i[2], n, s, o;
  return n = Math.atan2(r, e), s = n * 360 / 2 / Math.PI, s < 0 && (s += 360), o = Math.sqrt(e * e + r * r), [t, o, s];
};
me.lch.lab = function(i) {
  var t = i[0], e = i[1], r = i[2], n, s, o;
  return o = r / 360 * 2 * Math.PI, n = e * Math.cos(o), s = e * Math.sin(o), [t, n, s];
};
me.rgb.ansi16 = function(i) {
  var t = i[0], e = i[1], r = i[2], n = 1 in arguments ? arguments[1] : me.rgb.hsv(i)[2];
  if (n = Math.round(n / 50), n === 0)
    return 30;
  var s = 30 + (Math.round(r / 255) << 2 | Math.round(e / 255) << 1 | Math.round(t / 255));
  return n === 2 && (s += 60), s;
};
me.hsv.ansi16 = function(i) {
  return me.rgb.ansi16(me.hsv.rgb(i), i[2]);
};
me.rgb.ansi256 = function(i) {
  var t = i[0], e = i[1], r = i[2];
  if (t === e && e === r)
    return t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232;
  var n = 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(e / 255 * 5) + Math.round(r / 255 * 5);
  return n;
};
me.ansi16.rgb = function(i) {
  var t = i % 10;
  if (t === 0 || t === 7)
    return i > 50 && (t += 3.5), t = t / 10.5 * 255, [t, t, t];
  var e = (~~(i > 50) + 1) * 0.5, r = (t & 1) * e * 255, n = (t >> 1 & 1) * e * 255, s = (t >> 2 & 1) * e * 255;
  return [r, n, s];
};
me.ansi256.rgb = function(i) {
  if (i >= 232) {
    var t = (i - 232) * 10 + 8;
    return [t, t, t];
  }
  i -= 16;
  var e, r = Math.floor(i / 36) / 5 * 255, n = Math.floor((e = i % 36) / 6) / 5 * 255, s = e % 6 / 5 * 255;
  return [r, n, s];
};
me.rgb.hex = function(i) {
  var t = ((Math.round(i[0]) & 255) << 16) + ((Math.round(i[1]) & 255) << 8) + (Math.round(i[2]) & 255), e = t.toString(16).toUpperCase();
  return "000000".substring(e.length) + e;
};
me.hex.rgb = function(i) {
  var t = i.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
  if (!t)
    return [0, 0, 0];
  var e = t[0];
  t[0].length === 3 && (e = e.split("").map(function(a) {
    return a + a;
  }).join(""));
  var r = parseInt(e, 16), n = r >> 16 & 255, s = r >> 8 & 255, o = r & 255;
  return [n, s, o];
};
me.rgb.hcg = function(i) {
  var t = i[0] / 255, e = i[1] / 255, r = i[2] / 255, n = Math.max(Math.max(t, e), r), s = Math.min(Math.min(t, e), r), o = n - s, a, l;
  return o < 1 ? a = s / (1 - o) : a = 0, o <= 0 ? l = 0 : n === t ? l = (e - r) / o % 6 : n === e ? l = 2 + (r - t) / o : l = 4 + (t - e) / o + 4, l /= 6, l %= 1, [l * 360, o * 100, a * 100];
};
me.hsl.hcg = function(i) {
  var t = i[1] / 100, e = i[2] / 100, r = 1, n = 0;
  return e < 0.5 ? r = 2 * t * e : r = 2 * t * (1 - e), r < 1 && (n = (e - 0.5 * r) / (1 - r)), [i[0], r * 100, n * 100];
};
me.hsv.hcg = function(i) {
  var t = i[1] / 100, e = i[2] / 100, r = t * e, n = 0;
  return r < 1 && (n = (e - r) / (1 - r)), [i[0], r * 100, n * 100];
};
me.hcg.rgb = function(i) {
  var t = i[0] / 360, e = i[1] / 100, r = i[2] / 100;
  if (e === 0)
    return [r * 255, r * 255, r * 255];
  var n = [0, 0, 0], s = t % 1 * 6, o = s % 1, a = 1 - o, l = 0;
  switch (Math.floor(s)) {
    case 0:
      n[0] = 1, n[1] = o, n[2] = 0;
      break;
    case 1:
      n[0] = a, n[1] = 1, n[2] = 0;
      break;
    case 2:
      n[0] = 0, n[1] = 1, n[2] = o;
      break;
    case 3:
      n[0] = 0, n[1] = a, n[2] = 1;
      break;
    case 4:
      n[0] = o, n[1] = 0, n[2] = 1;
      break;
    default:
      n[0] = 1, n[1] = 0, n[2] = a;
  }
  return l = (1 - e) * r, [
    (e * n[0] + l) * 255,
    (e * n[1] + l) * 255,
    (e * n[2] + l) * 255
  ];
};
me.hcg.hsv = function(i) {
  var t = i[1] / 100, e = i[2] / 100, r = t + e * (1 - t), n = 0;
  return r > 0 && (n = t / r), [i[0], n * 100, r * 100];
};
me.hcg.hsl = function(i) {
  var t = i[1] / 100, e = i[2] / 100, r = e * (1 - t) + 0.5 * t, n = 0;
  return r > 0 && r < 0.5 ? n = t / (2 * r) : r >= 0.5 && r < 1 && (n = t / (2 * (1 - r))), [i[0], n * 100, r * 100];
};
me.hcg.hwb = function(i) {
  var t = i[1] / 100, e = i[2] / 100, r = t + e * (1 - t);
  return [i[0], (r - t) * 100, (1 - r) * 100];
};
me.hwb.hcg = function(i) {
  var t = i[1] / 100, e = i[2] / 100, r = 1 - e, n = r - t, s = 0;
  return n < 1 && (s = (r - n) / (1 - n)), [i[0], n * 100, s * 100];
};
me.apple.rgb = function(i) {
  return [i[0] / 65535 * 255, i[1] / 65535 * 255, i[2] / 65535 * 255];
};
me.rgb.apple = function(i) {
  return [i[0] / 255 * 65535, i[1] / 255 * 65535, i[2] / 255 * 65535];
};
me.gray.rgb = function(i) {
  return [i[0] / 100 * 255, i[0] / 100 * 255, i[0] / 100 * 255];
};
me.gray.hsl = me.gray.hsv = function(i) {
  return [0, 0, i[0]];
};
me.gray.hwb = function(i) {
  return [0, 100, i[0]];
};
me.gray.cmyk = function(i) {
  return [0, 0, 0, i[0]];
};
me.gray.lab = function(i) {
  return [i[0], 0, 0];
};
me.gray.hex = function(i) {
  var t = Math.round(i[0] / 100 * 255) & 255, e = (t << 16) + (t << 8) + t, r = e.toString(16).toUpperCase();
  return "000000".substring(r.length) + r;
};
me.rgb.gray = function(i) {
  var t = (i[0] + i[1] + i[2]) / 3;
  return [t / 255 * 100];
};
var lS = oS.exports, fd = lS;
function A6() {
  for (var i = {}, t = Object.keys(fd), e = t.length, r = 0; r < e; r++)
    i[t[r]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  return i;
}
function M6(i) {
  var t = A6(), e = [i];
  for (t[i].distance = 0; e.length; )
    for (var r = e.pop(), n = Object.keys(fd[r]), s = n.length, o = 0; o < s; o++) {
      var a = n[o], l = t[a];
      l.distance === -1 && (l.distance = t[r].distance + 1, l.parent = r, e.unshift(a));
    }
  return t;
}
function S6(i, t) {
  return function(e) {
    return t(i(e));
  };
}
function C6(i, t) {
  for (var e = [t[i].parent, i], r = fd[t[i].parent][i], n = t[i].parent; t[n].parent; )
    e.unshift(t[n].parent), r = S6(fd[t[n].parent][n], r), n = t[n].parent;
  return r.conversion = e, r;
}
var P6 = function(i) {
  for (var t = M6(i), e = {}, r = Object.keys(t), n = r.length, s = 0; s < n; s++) {
    var o = r[s], a = t[o];
    a.parent !== null && (e[o] = C6(o, t));
  }
  return e;
}, P0 = lS, E6 = P6, Va = {}, O6 = Object.keys(P0);
function k6(i) {
  var t = function(e) {
    return e == null ? e : (arguments.length > 1 && (e = Array.prototype.slice.call(arguments)), i(e));
  };
  return "conversion" in i && (t.conversion = i.conversion), t;
}
function R6(i) {
  var t = function(e) {
    if (e == null)
      return e;
    arguments.length > 1 && (e = Array.prototype.slice.call(arguments));
    var r = i(e);
    if (typeof r == "object")
      for (var n = r.length, s = 0; s < n; s++)
        r[s] = Math.round(r[s]);
    return r;
  };
  return "conversion" in i && (t.conversion = i.conversion), t;
}
O6.forEach(function(i) {
  Va[i] = {}, Object.defineProperty(Va[i], "channels", { value: P0[i].channels }), Object.defineProperty(Va[i], "labels", { value: P0[i].labels });
  var t = E6(i), e = Object.keys(t);
  e.forEach(function(r) {
    var n = t[r];
    Va[i][r] = R6(n), Va[i][r].raw = k6(n);
  });
});
var I6 = Va, Oh = _6, oi = I6, my = [].slice, hS = [
  // to be honest, I don't really feel like keyword belongs in color convert, but eh.
  "keyword",
  // gray conflicts with some method names, and has its own method defined.
  "gray",
  // shouldn't really be in color-convert either...
  "hex"
], E0 = {};
Object.keys(oi).forEach(function(i) {
  E0[my.call(oi[i].labels).sort().join("")] = i;
});
var dd = {};
function Tr(i, t) {
  if (!(this instanceof Tr))
    return new Tr(i, t);
  if (t && t in hS && (t = null), t && !(t in oi))
    throw new Error("Unknown model: " + t);
  var e, r;
  if (i == null)
    this.model = "rgb", this.color = [0, 0, 0], this.valpha = 1;
  else if (i instanceof Tr)
    this.model = i.model, this.color = i.color.slice(), this.valpha = i.valpha;
  else if (typeof i == "string") {
    var n = Oh.get(i);
    if (n === null)
      throw new Error("Unable to parse color from string: " + i);
    this.model = n.model, r = oi[this.model].channels, this.color = n.value.slice(0, r), this.valpha = typeof n.value[r] == "number" ? n.value[r] : 1;
  } else if (i.length) {
    this.model = t || "rgb", r = oi[this.model].channels;
    var s = my.call(i, 0, r);
    this.color = O0(s, r), this.valpha = typeof i[r] == "number" ? i[r] : 1;
  } else if (typeof i == "number")
    i &= 16777215, this.model = "rgb", this.color = [
      i >> 16 & 255,
      i >> 8 & 255,
      i & 255
    ], this.valpha = 1;
  else {
    this.valpha = 1;
    var o = Object.keys(i);
    "alpha" in i && (o.splice(o.indexOf("alpha"), 1), this.valpha = typeof i.alpha == "number" ? i.alpha : 0);
    var a = o.sort().join("");
    if (!(a in E0))
      throw new Error("Unable to parse color from object: " + JSON.stringify(i));
    this.model = E0[a];
    var l = oi[this.model].labels, h = [];
    for (e = 0; e < l.length; e++)
      h.push(i[l[e]]);
    this.color = O0(h);
  }
  if (dd[this.model])
    for (r = oi[this.model].channels, e = 0; e < r; e++) {
      var u = dd[this.model][e];
      u && (this.color[e] = u(this.color[e]));
    }
  this.valpha = Math.max(0, Math.min(1, this.valpha)), Object.freeze && Object.freeze(this);
}
Tr.prototype = {
  toString: function() {
    return this.string();
  },
  toJSON: function() {
    return this[this.model]();
  },
  string: function(i) {
    var t = this.model in Oh.to ? this : this.rgb();
    t = t.round(typeof i == "number" ? i : 1);
    var e = t.valpha === 1 ? t.color : t.color.concat(this.valpha);
    return Oh.to[t.model](e);
  },
  percentString: function(i) {
    var t = this.rgb().round(typeof i == "number" ? i : 1), e = t.valpha === 1 ? t.color : t.color.concat(this.valpha);
    return Oh.to.rgb.percent(e);
  },
  array: function() {
    return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
  },
  object: function() {
    for (var i = {}, t = oi[this.model].channels, e = oi[this.model].labels, r = 0; r < t; r++)
      i[e[r]] = this.color[r];
    return this.valpha !== 1 && (i.alpha = this.valpha), i;
  },
  unitArray: function() {
    var i = this.rgb().color;
    return i[0] /= 255, i[1] /= 255, i[2] /= 255, this.valpha !== 1 && i.push(this.valpha), i;
  },
  unitObject: function() {
    var i = this.rgb().object();
    return i.r /= 255, i.g /= 255, i.b /= 255, this.valpha !== 1 && (i.alpha = this.valpha), i;
  },
  round: function(i) {
    return i = Math.max(i || 0, 0), new Tr(this.color.map(F6(i)).concat(this.valpha), this.model);
  },
  alpha: function(i) {
    return arguments.length ? new Tr(this.color.concat(Math.max(0, Math.min(1, i))), this.model) : this.valpha;
  },
  // rgb
  red: jn("rgb", 0, sr(255)),
  green: jn("rgb", 1, sr(255)),
  blue: jn("rgb", 2, sr(255)),
  hue: jn(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function(i) {
    return (i % 360 + 360) % 360;
  }),
  // eslint-disable-line brace-style
  saturationl: jn("hsl", 1, sr(100)),
  lightness: jn("hsl", 2, sr(100)),
  saturationv: jn("hsv", 1, sr(100)),
  value: jn("hsv", 2, sr(100)),
  chroma: jn("hcg", 1, sr(100)),
  gray: jn("hcg", 2, sr(100)),
  white: jn("hwb", 1, sr(100)),
  wblack: jn("hwb", 2, sr(100)),
  cyan: jn("cmyk", 0, sr(100)),
  magenta: jn("cmyk", 1, sr(100)),
  yellow: jn("cmyk", 2, sr(100)),
  black: jn("cmyk", 3, sr(100)),
  x: jn("xyz", 0, sr(100)),
  y: jn("xyz", 1, sr(100)),
  z: jn("xyz", 2, sr(100)),
  l: jn("lab", 0, sr(100)),
  a: jn("lab", 1),
  b: jn("lab", 2),
  keyword: function(i) {
    return arguments.length ? new Tr(i) : oi[this.model].keyword(this.color);
  },
  hex: function(i) {
    return arguments.length ? new Tr(i) : Oh.to.hex(this.rgb().round().color);
  },
  rgbNumber: function() {
    var i = this.rgb().color;
    return (i[0] & 255) << 16 | (i[1] & 255) << 8 | i[2] & 255;
  },
  luminosity: function() {
    for (var i = this.rgb().color, t = [], e = 0; e < i.length; e++) {
      var r = i[e] / 255;
      t[e] = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
    }
    return 0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2];
  },
  contrast: function(i) {
    var t = this.luminosity(), e = i.luminosity();
    return t > e ? (t + 0.05) / (e + 0.05) : (e + 0.05) / (t + 0.05);
  },
  level: function(i) {
    var t = this.contrast(i);
    return t >= 7.1 ? "AAA" : t >= 4.5 ? "AA" : "";
  },
  isDark: function() {
    var i = this.rgb().color, t = (i[0] * 299 + i[1] * 587 + i[2] * 114) / 1e3;
    return t < 128;
  },
  isLight: function() {
    return !this.isDark();
  },
  negate: function() {
    for (var i = this.rgb(), t = 0; t < 3; t++)
      i.color[t] = 255 - i.color[t];
    return i;
  },
  lighten: function(i) {
    var t = this.hsl();
    return t.color[2] += t.color[2] * i, t;
  },
  darken: function(i) {
    var t = this.hsl();
    return t.color[2] -= t.color[2] * i, t;
  },
  saturate: function(i) {
    var t = this.hsl();
    return t.color[1] += t.color[1] * i, t;
  },
  desaturate: function(i) {
    var t = this.hsl();
    return t.color[1] -= t.color[1] * i, t;
  },
  whiten: function(i) {
    var t = this.hwb();
    return t.color[1] += t.color[1] * i, t;
  },
  blacken: function(i) {
    var t = this.hwb();
    return t.color[2] += t.color[2] * i, t;
  },
  grayscale: function() {
    var i = this.rgb().color, t = i[0] * 0.3 + i[1] * 0.59 + i[2] * 0.11;
    return Tr.rgb(t, t, t);
  },
  fade: function(i) {
    return this.alpha(this.valpha - this.valpha * i);
  },
  opaquer: function(i) {
    return this.alpha(this.valpha + this.valpha * i);
  },
  rotate: function(i) {
    var t = this.hsl(), e = t.color[0];
    return e = (e + i) % 360, e = e < 0 ? 360 + e : e, t.color[0] = e, t;
  },
  mix: function(i, t) {
    if (!i || !i.rgb)
      throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof i);
    var e = i.rgb(), r = this.rgb(), n = t === void 0 ? 0.5 : t, s = 2 * n - 1, o = e.alpha() - r.alpha(), a = ((s * o === -1 ? s : (s + o) / (1 + s * o)) + 1) / 2, l = 1 - a;
    return Tr.rgb(
      a * e.red() + l * r.red(),
      a * e.green() + l * r.green(),
      a * e.blue() + l * r.blue(),
      e.alpha() * n + r.alpha() * (1 - n)
    );
  }
};
Object.keys(oi).forEach(function(i) {
  if (hS.indexOf(i) === -1) {
    var t = oi[i].channels;
    Tr.prototype[i] = function() {
      if (this.model === i)
        return new Tr(this);
      if (arguments.length)
        return new Tr(arguments, i);
      var e = typeof arguments[t] == "number" ? t : this.valpha;
      return new Tr(L6(oi[this.model][i].raw(this.color)).concat(e), i);
    }, Tr[i] = function(e) {
      return typeof e == "number" && (e = O0(my.call(arguments), t)), new Tr(e, i);
    };
  }
});
function D6(i, t) {
  return Number(i.toFixed(t));
}
function F6(i) {
  return function(t) {
    return D6(t, i);
  };
}
function jn(i, t, e) {
  return i = Array.isArray(i) ? i : [i], i.forEach(function(r) {
    (dd[r] || (dd[r] = []))[t] = e;
  }), i = i[0], function(r) {
    var n;
    return arguments.length ? (e && (r = e(r)), n = this[i](), n.color[t] = r, n) : (n = this[i]().color[t], e && (n = e(n)), n);
  };
}
function sr(i) {
  return function(t) {
    return Math.max(0, Math.min(i, t));
  };
}
function L6(i) {
  return Array.isArray(i) ? i : [i];
}
function O0(i, t) {
  for (var e = 0; e < t; e++)
    typeof i[e] != "number" && (i[e] = 0);
  return i;
}
var z6 = Tr;
const Zi = /* @__PURE__ */ Fs(z6);
/*!
    Feature Filter by

    (c) mapbox 2016 and maptalks 2018
    www.mapbox.com | www.maptalks.org
    License: MIT, header required.
*/
const uS = ["Unknown", "Point", "LineString", "Polygon", "MultiPoint", "MultiLineString", "MultiPolygon", "GeometryCollection"];
function N6(i) {
  return typeof i == "object" && !!i;
}
function cS(i) {
  return new Function("f", `var p = (f && f.properties || {}); return ${dS(i)}`);
}
function fS(i) {
  if (i === !0 || i === !1)
    return !0;
  if (!Array.isArray(i) || i.length === 0)
    return !1;
  switch (i[0]) {
    case "has":
    case "!has":
      return i.length === 2 && (typeof i[1] == "string" || i[1].property && i[1].op);
    case "in":
    case "!in":
      return i.length >= 2 && (typeof i[1] == "string" || i[1].property && i[1].op);
    case "==":
    case "!=":
    case ">":
    case ">=":
    case "<":
    case "<=":
      return i.length === 3 && (typeof i[1] == "string" || i[1].property && i[1].op);
    case "none":
    case "any":
    case "all":
      for (const t of i.slice(1))
        if (!fS(t) && typeof t != "boolean")
          return !1;
      return !0;
    case "contains":
      return !0;
    default:
      return !1;
  }
}
function dS(i) {
  if (!i) return "true";
  const t = i[0];
  return i.length <= 1 ? t === "any" ? "false" : "true" : `(${t === "==" ? Bg(i[1], i[2], "===", !1) : t === "!=" ? Bg(i[1], i[2], "!==", !1) : t === "<" || t === ">" || t === "<=" || t === ">=" ? Bg(i[1], i[2], t, !0) : t === "any" ? jg(i.slice(1), "||") : t === "all" ? jg(i.slice(1), "&&") : t === "none" ? Gg(jg(i.slice(1), "||")) : t === "in" ? g2(i[1], i.slice(2)) : t === "!in" ? Gg(g2(i[1], i.slice(2))) : t === "has" ? m2(i[1]) : t === "!has" ? Gg(m2(i[1])) : (
    // op === 'test' ? compileRegex(filter[1], filter[2]) :
    t === "contains" ? B6(i[1], i[2], i[3]) : "true"
  )})`;
}
function H6(i, t, e, r) {
  const n = i.property, s = i.op;
  let o = Zd(n);
  if (s === "length")
    o = `((${o}+='').length)`;
  else
    return console.error(`not support ${s} op`), "false";
  return pS(o, n, t, e, r);
}
function B6(i, t, e) {
  const r = Zd(i);
  return e !== void 0 ? `(${r} + '').indexOf("${t}") === ${e}` : `(${r} + '').indexOf("${t}") >= 0`;
}
function Zd(i) {
  return i[0] === "$" ? "f." + i.substring(1) : "p[" + JSON.stringify(i) + "]";
}
function Bg(i, t, e, r) {
  if (N6(i) && i.op)
    return H6(i, t, e, r);
  const n = Zd(i);
  return pS(n, i, t, e, r);
}
function pS(i, t, e, r, n) {
  const s = t === "$type" ? uS.indexOf(e) : JSON.stringify(e);
  return (n ? `typeof ${i}=== typeof ${s}&&` : "") + i + r + s;
}
function jg(i, t) {
  return i.map(dS).join(t);
}
function g2(i, t) {
  i === "$type" && (t = t.map((n) => uS.indexOf(n)));
  const e = JSON.stringify(t.sort(j6)), r = Zd(i);
  return t.length <= 200 ? `${e}.indexOf(${r}) !== -1` : `function(v, a, i, j) {
        while (i <= j) { var m = (i + j) >> 1;
            if (a[m] === v) return true; if (a[m] > v) j = m - 1; else i = m + 1;
        }
    return false; }(${r}, ${e},0,${t.length - 1})`;
}
function m2(i) {
  return i === "$id" ? '"id" in f' : `${JSON.stringify(i)} in p`;
}
function Gg(i) {
  return `!(${i})`;
}
function j6(i, t) {
  return i < t ? -1 : i > t ? 1 : 0;
}
class G6 {
  constructor(t = [], e = V6) {
    if (this.data = t, this.length = this.data.length, this.compare = e, this.length > 0)
      for (let r = (this.length >> 1) - 1; r >= 0; r--) this._down(r);
  }
  push(t) {
    this.data.push(t), this.length++, this._up(this.length - 1);
  }
  pop() {
    if (this.length === 0) return;
    const t = this.data[0], e = this.data.pop();
    return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), t;
  }
  peek() {
    return this.data[0];
  }
  _up(t) {
    const { data: e, compare: r } = this, n = e[t];
    for (; t > 0; ) {
      const s = t - 1 >> 1, o = e[s];
      if (r(n, o) >= 0) break;
      e[t] = o, t = s;
    }
    e[t] = n;
  }
  _down(t) {
    const { data: e, compare: r } = this, n = this.length >> 1, s = e[t];
    for (; t < n; ) {
      let o = (t << 1) + 1, a = e[o];
      const l = o + 1;
      if (l < this.length && r(e[l], a) < 0 && (o = l, a = e[l]), r(a, s) >= 0) break;
      e[t] = a, t = o;
    }
    e[t] = s;
  }
}
function V6(i, t) {
  return i < t ? -1 : i > t ? 1 : 0;
}
var vy = { exports: {} };
vy.exports = Xd;
vy.exports.default = Xd;
function Xd(i, t, e) {
  e = e || 2;
  var r = t && t.length, n = r ? t[0] * e : i.length, s = gS(i, 0, n, e, !0), o = [];
  if (!s || s.next === s.prev) return o;
  var a, l, h, u, c, f, d;
  if (r && (s = X6(i, t, s, e)), i.length > 80 * e) {
    a = h = i[0], l = u = i[1];
    for (var p = e; p < n; p += e)
      c = i[p], f = i[p + 1], c < a && (a = c), f < l && (l = f), c > h && (h = c), f > u && (u = f);
    d = Math.max(h - a, u - l), d = d !== 0 ? 32767 / d : 0;
  }
  return yu(s, o, e, a, l, d, 0), o;
}
function gS(i, t, e, r, n) {
  var s, o;
  if (n === I0(i, t, e, r) > 0)
    for (s = t; s < e; s += r) o = v2(s, i[s], i[s + 1], o);
  else
    for (s = e - r; s >= t; s -= r) o = v2(s, i[s], i[s + 1], o);
  return o && qd(o, o.next) && (xu(o), o = o.next), o;
}
function Xo(i, t) {
  if (!i) return i;
  t || (t = i);
  var e = i, r;
  do
    if (r = !1, !e.steiner && (qd(e, e.next) || Ln(e.prev, e, e.next) === 0)) {
      if (xu(e), e = t = e.prev, e === e.next) break;
      r = !0;
    } else
      e = e.next;
  while (r || e !== t);
  return t;
}
function yu(i, t, e, r, n, s, o) {
  if (i) {
    !o && s && Q6(i, r, n, s);
    for (var a = i, l, h; i.prev !== i.next; ) {
      if (l = i.prev, h = i.next, s ? $6(i, r, n, s) : U6(i)) {
        t.push(l.i / e | 0), t.push(i.i / e | 0), t.push(h.i / e | 0), xu(i), i = h.next, a = h.next;
        continue;
      }
      if (i = h, i === a) {
        o ? o === 1 ? (i = W6(Xo(i), t, e), yu(i, t, e, r, n, s, 2)) : o === 2 && Z6(i, t, e, r, n, s) : yu(Xo(i), t, e, r, n, s, 1);
        break;
      }
    }
  }
}
function U6(i) {
  var t = i.prev, e = i, r = i.next;
  if (Ln(t, e, r) >= 0) return !1;
  for (var n = t.x, s = e.x, o = r.x, a = t.y, l = e.y, h = r.y, u = n < s ? n < o ? n : o : s < o ? s : o, c = a < l ? a < h ? a : h : l < h ? l : h, f = n > s ? n > o ? n : o : s > o ? s : o, d = a > l ? a > h ? a : h : l > h ? l : h, p = r.next; p !== t; ) {
    if (p.x >= u && p.x <= f && p.y >= c && p.y <= d && Qa(n, a, s, l, o, h, p.x, p.y) && Ln(p.prev, p, p.next) >= 0) return !1;
    p = p.next;
  }
  return !0;
}
function $6(i, t, e, r) {
  var n = i.prev, s = i, o = i.next;
  if (Ln(n, s, o) >= 0) return !1;
  for (var a = n.x, l = s.x, h = o.x, u = n.y, c = s.y, f = o.y, d = a < l ? a < h ? a : h : l < h ? l : h, p = u < c ? u < f ? u : f : c < f ? c : f, g = a > l ? a > h ? a : h : l > h ? l : h, m = u > c ? u > f ? u : f : c > f ? c : f, v = k0(d, p, t, e, r), _ = k0(g, m, t, e, r), y = i.prevZ, x = i.nextZ; y && y.z >= v && x && x.z <= _; ) {
    if (y.x >= d && y.x <= g && y.y >= p && y.y <= m && y !== n && y !== o && Qa(a, u, l, c, h, f, y.x, y.y) && Ln(y.prev, y, y.next) >= 0 || (y = y.prevZ, x.x >= d && x.x <= g && x.y >= p && x.y <= m && x !== n && x !== o && Qa(a, u, l, c, h, f, x.x, x.y) && Ln(x.prev, x, x.next) >= 0)) return !1;
    x = x.nextZ;
  }
  for (; y && y.z >= v; ) {
    if (y.x >= d && y.x <= g && y.y >= p && y.y <= m && y !== n && y !== o && Qa(a, u, l, c, h, f, y.x, y.y) && Ln(y.prev, y, y.next) >= 0) return !1;
    y = y.prevZ;
  }
  for (; x && x.z <= _; ) {
    if (x.x >= d && x.x <= g && x.y >= p && x.y <= m && x !== n && x !== o && Qa(a, u, l, c, h, f, x.x, x.y) && Ln(x.prev, x, x.next) >= 0) return !1;
    x = x.nextZ;
  }
  return !0;
}
function W6(i, t, e) {
  var r = i;
  do {
    var n = r.prev, s = r.next.next;
    !qd(n, s) && mS(n, r, r.next, s) && _u(n, s) && _u(s, n) && (t.push(n.i / e | 0), t.push(r.i / e | 0), t.push(s.i / e | 0), xu(r), xu(r.next), r = i = s), r = r.next;
  } while (r !== i);
  return Xo(r);
}
function Z6(i, t, e, r, n, s) {
  var o = i;
  do {
    for (var a = o.next.next; a !== o.prev; ) {
      if (o.i !== a.i && nz(o, a)) {
        var l = vS(o, a);
        o = Xo(o, o.next), l = Xo(l, l.next), yu(o, t, e, r, n, s, 0), yu(l, t, e, r, n, s, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== i);
}
function X6(i, t, e, r) {
  var n = [], s, o, a, l, h;
  for (s = 0, o = t.length; s < o; s++)
    a = t[s] * r, l = s < o - 1 ? t[s + 1] * r : i.length, h = gS(i, a, l, r, !1), h === h.next && (h.steiner = !0), n.push(ez(h));
  for (n.sort(q6), s = 0; s < n.length; s++)
    e = Y6(n[s], e);
  return e;
}
function q6(i, t) {
  return i.x - t.x;
}
function Y6(i, t) {
  var e = J6(i, t);
  if (!e)
    return t;
  var r = vS(e, i);
  return Xo(r, r.next), Xo(e, e.next);
}
function J6(i, t) {
  var e = t, r = i.x, n = i.y, s = -1 / 0, o;
  do {
    if (n <= e.y && n >= e.next.y && e.next.y !== e.y) {
      var a = e.x + (n - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
      if (a <= r && a > s && (s = a, o = e.x < e.next.x ? e : e.next, a === r))
        return o;
    }
    e = e.next;
  } while (e !== t);
  if (!o) return null;
  var l = o, h = o.x, u = o.y, c = 1 / 0, f;
  e = o;
  do
    r >= e.x && e.x >= h && r !== e.x && Qa(n < u ? r : s, n, h, u, n < u ? s : r, n, e.x, e.y) && (f = Math.abs(n - e.y) / (r - e.x), _u(e, i) && (f < c || f === c && (e.x > o.x || e.x === o.x && K6(o, e))) && (o = e, c = f)), e = e.next;
  while (e !== l);
  return o;
}
function K6(i, t) {
  return Ln(i.prev, i, t.prev) < 0 && Ln(t.next, i, i.next) < 0;
}
function Q6(i, t, e, r) {
  var n = i;
  do
    n.z === 0 && (n.z = k0(n.x, n.y, t, e, r)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
  while (n !== i);
  n.prevZ.nextZ = null, n.prevZ = null, tz(n);
}
function tz(i) {
  var t, e, r, n, s, o, a, l, h = 1;
  do {
    for (e = i, i = null, s = null, o = 0; e; ) {
      for (o++, r = e, a = 0, t = 0; t < h && (a++, r = r.nextZ, !!r); t++)
        ;
      for (l = h; a > 0 || l > 0 && r; )
        a !== 0 && (l === 0 || !r || e.z <= r.z) ? (n = e, e = e.nextZ, a--) : (n = r, r = r.nextZ, l--), s ? s.nextZ = n : i = n, n.prevZ = s, s = n;
      e = r;
    }
    s.nextZ = null, h *= 2;
  } while (o > 1);
  return i;
}
function k0(i, t, e, r, n) {
  return i = (i - e) * n | 0, t = (t - r) * n | 0, i = (i | i << 8) & 16711935, i = (i | i << 4) & 252645135, i = (i | i << 2) & 858993459, i = (i | i << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, i | t << 1;
}
function ez(i) {
  var t = i, e = i;
  do
    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
  while (t !== i);
  return e;
}
function Qa(i, t, e, r, n, s, o, a) {
  return (n - o) * (t - a) >= (i - o) * (s - a) && (i - o) * (r - a) >= (e - o) * (t - a) && (e - o) * (s - a) >= (n - o) * (r - a);
}
function nz(i, t) {
  return i.next.i !== t.i && i.prev.i !== t.i && !rz(i, t) && // dones't intersect other edges
  (_u(i, t) && _u(t, i) && iz(i, t) && // locally visible
  (Ln(i.prev, i, t.prev) || Ln(i, t.prev, t)) || // does not create opposite-facing sectors
  qd(i, t) && Ln(i.prev, i, i.next) > 0 && Ln(t.prev, t, t.next) > 0);
}
function Ln(i, t, e) {
  return (t.y - i.y) * (e.x - t.x) - (t.x - i.x) * (e.y - t.y);
}
function qd(i, t) {
  return i.x === t.x && i.y === t.y;
}
function mS(i, t, e, r) {
  var n = zc(Ln(i, t, e)), s = zc(Ln(i, t, r)), o = zc(Ln(e, r, i)), a = zc(Ln(e, r, t));
  return !!(n !== s && o !== a || n === 0 && Lc(i, e, t) || s === 0 && Lc(i, r, t) || o === 0 && Lc(e, i, r) || a === 0 && Lc(e, t, r));
}
function Lc(i, t, e) {
  return t.x <= Math.max(i.x, e.x) && t.x >= Math.min(i.x, e.x) && t.y <= Math.max(i.y, e.y) && t.y >= Math.min(i.y, e.y);
}
function zc(i) {
  return i > 0 ? 1 : i < 0 ? -1 : 0;
}
function rz(i, t) {
  var e = i;
  do {
    if (e.i !== i.i && e.next.i !== i.i && e.i !== t.i && e.next.i !== t.i && mS(e, e.next, i, t)) return !0;
    e = e.next;
  } while (e !== i);
  return !1;
}
function _u(i, t) {
  return Ln(i.prev, i, i.next) < 0 ? Ln(i, t, i.next) >= 0 && Ln(i, i.prev, t) >= 0 : Ln(i, t, i.prev) < 0 || Ln(i, i.next, t) < 0;
}
function iz(i, t) {
  var e = i, r = !1, n = (i.x + t.x) / 2, s = (i.y + t.y) / 2;
  do
    e.y > s != e.next.y > s && e.next.y !== e.y && n < (e.next.x - e.x) * (s - e.y) / (e.next.y - e.y) + e.x && (r = !r), e = e.next;
  while (e !== i);
  return r;
}
function vS(i, t) {
  var e = new R0(i.i, i.x, i.y), r = new R0(t.i, t.x, t.y), n = i.next, s = t.prev;
  return i.next = t, t.prev = i, e.next = n, n.prev = e, r.next = e, e.prev = r, s.next = r, r.prev = s, r;
}
function v2(i, t, e, r) {
  var n = new R0(i, t, e);
  return r ? (n.next = r.next, n.prev = r, r.next.prev = n, r.next = n) : (n.prev = n, n.next = n), n;
}
function xu(i) {
  i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
}
function R0(i, t, e) {
  this.i = i, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
Xd.deviation = function(i, t, e, r) {
  var n = t && t.length, s = n ? t[0] * e : i.length, o = Math.abs(I0(i, 0, s, e));
  if (n)
    for (var a = 0, l = t.length; a < l; a++) {
      var h = t[a] * e, u = a < l - 1 ? t[a + 1] * e : i.length;
      o -= Math.abs(I0(i, h, u, e));
    }
  var c = 0;
  for (a = 0; a < r.length; a += 3) {
    var f = r[a] * e, d = r[a + 1] * e, p = r[a + 2] * e;
    c += Math.abs(
      (i[f] - i[p]) * (i[d + 1] - i[f + 1]) - (i[f] - i[d]) * (i[p + 1] - i[f + 1])
    );
  }
  return o === 0 && c === 0 ? 0 : Math.abs((c - o) / o);
};
function I0(i, t, e, r) {
  for (var n = 0, s = t, o = e - r; s < e; s += r)
    n += (i[o] - i[s]) * (i[s + 1] + i[o + 1]), o = s;
  return n;
}
Xd.flatten = function(i) {
  for (var t = i[0][0].length, e = { vertices: [], holes: [], dimensions: t }, r = 0, n = 0; n < i.length; n++) {
    for (var s = 0; s < i[n].length; s++)
      for (var o = 0; o < t; o++) e.vertices.push(i[n][s][o]);
    n > 0 && (r += i[n - 1].length, e.holes.push(r));
  }
  return e;
};
var sz = vy.exports;
const Pf = /* @__PURE__ */ Fs(sz);
/*!
 * @maptalks/vector-packer v0.95.0
 * LICENSE : UNLICENSED
 * (c) 2016-2024 maptalks.com
 */
const oz = {
  Point: 1,
  LineString: 2,
  Polygon: 3,
  MultiPoint: 4,
  MultiLineString: 5,
  MultiPolygon: 6
};
function az(i, t = {}) {
  var e = [];
  if (i.type === "FeatureCollection") for (var r = 0; r < i.features.length; r++) D0(e, i.features[r], t, r);
  else D0(e, i.type === "Feature" ? i : {
    geometry: i
  }, t);
  return e;
}
function D0(i, t, e, r) {
  if (t.geometry && t.geometry.geometry) {
    var n = t.geometry.coordinates, s = t.geometry.type, o = [], a = t.id;
    if (e.promoteId ? a = t.properties[e.promoteId] : e.generateId && (a = r || 0), s === "Point") F0(n, o);
    else if (s === "MultiPoint") for (var l = 0; l < n.length; l++) F0(n[l], o);
    else if (s === "LineString") oo([n], o);
    else if (s === "MultiLineString") {
      if (e.lineMetrics) {
        for (l = 0; l < n.length; l++) yS(n[l], o = []), i.push(y2(a, "LineString", o, t.properties));
        return;
      }
      oo(n, o);
    } else if (s === "Polygon") oo(n, o);
    else {
      if (s !== "MultiPolygon") {
        if (s === "GeometryCollection") {
          for (l = 0; l < t.geometry.geometries.length; l++) D0(i, {
            id: a,
            geometry: t.geometry.geometries[l],
            properties: t.properties
          }, e, r);
          return;
        }
        return void console.warn(`Input data type(${s}) is not a valid GeoJSON geometry type.`);
      }
      for (l = 0; l < n.length; l++) {
        var h = [];
        oo(n[l], h), o.push(h);
      }
    }
    i.push(y2(a, s, o, t.properties));
  }
}
function F0(i, t) {
  const e = new en(i[0], i[1]);
  e.z = 100 * (i[2] || 0), t.push([e]);
}
function yS(i, t) {
  for (let e = 0; e < i.length; e++) {
    const r = new en(i[e][0], i[e][1]);
    r.z = 100 * (i[e][2] || 0), t.push(r);
  }
}
function oo(i, t, e, r) {
  for (var n = 0; n < i.length; n++) {
    var s = [];
    yS(i[n], s), t.push(s);
  }
}
function y2(i, t, e, r) {
  return {
    id: i === void 0 ? null : i,
    type: oz[t],
    geometry: e,
    properties: r
  };
}
/*!
 * Codes from mapbox-gl-js
 * github.com/mapbox/mapbox-gl-js
 * MIT License
 */
function yy(i, { width: t, height: e }, r, n) {
  if (n) {
    if (n.length !== t * e * r) throw new RangeError("mismatched image size");
  } else n = new Uint8Array(t * e * r);
  return i.width = t, i.height = e, i.data = n, i;
}
function _S(i, { width: t, height: e }, r) {
  if (t === i.width && e === i.height) return;
  const n = yy({}, {
    width: t,
    height: e
  }, r);
  _y(i, n, {
    x: 0,
    y: 0
  }, {
    x: 0,
    y: 0
  }, {
    width: Math.min(i.width, t),
    height: Math.min(i.height, e)
  }, r), i.width = t, i.height = e, i.data = n.data;
}
function _y(i, t, e, r, n, s) {
  if (n.width === 0 || n.height === 0) return t;
  if (n.width > i.width || n.height > i.height || e.x > i.width - n.width || e.y > i.height - n.height) throw new RangeError("out of range source coordinates for image copy");
  if (n.width > t.width || n.height > t.height || r.x > t.width - n.width || r.y > t.height - n.height) throw new RangeError("out of range destination coordinates for image copy");
  const o = i.data, a = t.data;
  if (o === a) return t;
  for (let l = 0; l < n.height; l++) {
    const h = ((e.y + l) * i.width + e.x) * s, u = ((r.y + l) * t.width + r.x) * s;
    for (let c = 0; c < n.width * s; c++) a[u + c] = o[h + c];
  }
  return t;
}
class bu {
  constructor(t, e) {
    yy(this, t, 1, e);
  }
  resize(t) {
    _S(this, t, 1);
  }
  clone() {
    return new bu({
      width: this.width,
      height: this.height
    }, new Uint8Array(this.data));
  }
  static copy(t, e, r, n, s) {
    _y(t, e, r, n, s, 1);
  }
}
class wu {
  constructor(t, e) {
    yy(this, t, 4, e);
  }
  resize(t) {
    _S(this, t, 4);
  }
  clone() {
    return new wu({
      width: this.width,
      height: this.height
    }, new Uint8Array(this.data));
  }
  static copy(t, e, r, n, s) {
    _y(t, e, r, n, s, 4);
  }
}
function xS(i) {
  let t = 0;
  for (let e, r, n = 0, s = i.length, o = s - 1; n < s; o = n++) if (e = i[n], r = i[o], e.x !== void 0) {
    if (e.z || r.z) return 1;
    t += (r.x - e.x) * (e.y + r.y);
  } else {
    if (e[2] || r[2]) return 1;
    t += (r[0] - e[0]) * (e[1] + r[1]);
  }
  return t;
}
function Ef(i, t, e) {
  let r = e;
  return t && i && (r = +i[t]), isNaN(r) && (r = e || 0), 100 * r;
}
function bS(i, t, e, r, n, s, o) {
  t || t === 0 || (t = 1);
  const a = Ef(i.properties, e, r), l = a * t;
  let h = (s ? 100 * s : 0) || a;
  return n ? h = Ef(i.properties, n, s) : o && (h = a - Ef(i.properties, o, s)), h *= t, {
    altitude: l,
    height: h
  };
}
function Fi(i, t) {
  return t < 1 / 0 && (i.x < 0 || i.x > t || i.y < 0 || i.y > t);
}
function Ca(i) {
  return i == null;
}
function _2(i, t, e) {
  if (i === e || i === t) return i;
  const r = e - t;
  return ((i - t) % r + r) % r + t;
}
function wS(i, t) {
  if (!t) return null;
  const e = /* @__PURE__ */ new Map();
  for (let r = 0; r < t.length; r++) {
    const n = t[r], s = i[n];
    let o = e.get(s);
    o || (o = [], e.set(s, o)), o.push(n);
  }
  return e;
}
function pd(i) {
  return (i & i - 1) == 0 && i !== 0;
}
/*!
 * Codes from mapbox-gl-js
 * github.com/mapbox/mapbox-gl-js
 * MIT License
 */
class lz {
  constructor(t, e, { pixelRatio: r }) {
    this.paddedRect = t, this.pixelRatio = r || 1, this.padding = e;
  }
  get tl() {
    return [this.paddedRect.x + this.padding, this.paddedRect.y + this.padding];
  }
  get br() {
    return [this.paddedRect.x + this.paddedRect.w - this.padding, this.paddedRect.y + this.paddedRect.h - this.padding];
  }
  get displaySize() {
    return [(this.paddedRect.w - 2 * this.padding) / this.pixelRatio, (this.paddedRect.h - 2 * this.padding) / this.pixelRatio];
  }
}
class TS {
  constructor(t) {
    this.glyphMap = t, this.build();
  }
  build() {
    const t = this.glyphMap, e = Object.keys(t).length, r = {}, n = new ki(0, 0, {
      autoResize: !0
    }), s = [], o = e > 1 ? 1 : 0;
    for (const l in t) {
      const h = t[l], u = {
        x: 0,
        y: 0,
        w: h.data.width + 2 * o,
        h: h.data.height + 2 * o
      };
      s.push(u), r[l] = new lz(u, o, h);
    }
    if (n.pack(s, {
      inPlace: !0
    }), !pd(n.w) || !pd(n.h)) {
      const l = x2(n.w), h = x2(n.h);
      n.resize(l, h);
    }
    const a = new wu({
      width: n.w,
      height: n.h
    });
    for (const l in t) {
      const h = t[l], u = r[l].paddedRect;
      wu.copy(h.data, a, {
        x: 0,
        y: 0
      }, {
        x: u.x + o,
        y: u.y + o
      }, h.data);
    }
    this.image = a, this.positions = r;
  }
}
function x2(i) {
  return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
}
/*!
 * Codes from mapbox-gl-js
 * github.com/mapbox/mapbox-gl-js
 * MIT License
 * TODO 升级为potpack
 */
class hz {
  constructor(t) {
    this.glyphMap = t, this.build();
  }
  build() {
    const t = this.glyphMap, e = {}, r = new ki(0, 0, {
      autoResize: !0
    }), n = [];
    for (const o in t) {
      const a = t[o], l = e[o] = {};
      for (const h in a) {
        const u = a[+h];
        if (!u || u.bitmap.width === 0 || u.bitmap.height === 0) continue;
        const c = {
          x: 0,
          y: 0,
          w: u.bitmap.width + 2,
          h: u.bitmap.height + 2
        };
        n.push(c), l[h] = {
          rect: c,
          metrics: u.metrics
        };
      }
    }
    r.pack(n, {
      inPlace: !0
    });
    const s = new bu({
      width: r.w,
      height: r.h
    });
    for (const o in t) {
      const a = t[o];
      for (const l in a) {
        const h = a[+l];
        if (!h || h.bitmap.width === 0 || h.bitmap.height === 0) continue;
        const u = e[o][l].rect;
        bu.copy(h.bitmap, s, {
          x: 0,
          y: 0
        }, {
          x: u.x + 1,
          y: u.y + 1
        }, h.bitmap);
      }
    }
    this.image = s, this.positions = e;
  }
}
function AS(i) {
  return i < 65536 ? Uint16Array : Uint32Array;
}
function L0(i) {
  return (i = Math.abs(i)) < 128 ? Int8Array : i < 32768 ? Int16Array : Float32Array;
}
function z0(i) {
  return i < 256 ? Uint8Array : i < 65536 ? Uint16Array : Float32Array;
}
function MS(i, t) {
  const e = i.length;
  i = i._origin || i;
  const r = new t(e);
  for (let n = 0; n < e; n++) r[n] = i[n];
  return r;
}
function SS(i) {
  const t = i.type, e = [];
  if (t === 1 || t === 4) for (let r = 0; r < i.geometry.length; r++) F0(i.geometry[r], e);
  else if (t === 2) oo(i.geometry, e);
  else if (t === 3) oo(i.geometry, e);
  else if (t === 5) oo(i.geometry, e);
  else if (t === 6) for (let r = 0; r < i.geometry.length; r++) {
    const n = [];
    oo(i.geometry[r], n), e.push(n);
  }
  return i.geometry = e, i;
}
function El(i) {
  for (let t = 1; t < arguments.length; t++) {
    const e = arguments[t];
    for (const r in e) i[r] = e[r];
  }
  return i;
}
function Qe(i) {
  return i == null;
}
function fo(i) {
  return typeof i == "number" && !isNaN(i);
}
function tl(i) {
  return typeof i == "object" && !!i;
}
function xy(i) {
  return !Qe(i) && (typeof i == "string" || i.constructor !== null && i.constructor === String);
}
function N0(i) {
  return !Qe(i) && (typeof i == "function" || i.constructor !== null && i.constructor === Function);
}
const uz = Object.prototype.hasOwnProperty;
function ml(i, t) {
  return uz.call(i, t);
}
const b2 = Math.PI / 180;
function kh(i) {
  return i && Ft(i) && i.property;
}
function CS(i) {
  const { verticalCentimeterToPoint: t, tileRatio: e } = i;
  return t * e;
}
function cz(i) {
  return i === "centimeter" || i === "cm" ? 1 : i === "millimeter" || i === "mm" ? 0.1 : 100;
}
const w2 = {};
function zo(i, t) {
  if (!Array.isArray(t)) {
    if (t && t.r !== void 0 && t.g !== void 0 && t.b !== void 0) return i[0] = 255 * t.r, i[1] = 255 * t.g, i[2] = 255 * t.b, i[3] = t.a !== void 0 ? 255 * t.a : 255, i;
    t = w2[t] = w2[t] || Zi(t).unitArray();
  }
  for (let e = 0; e < t.length; e++) i[e] = 255 * t[e];
  return t.length === 3 && (i[3] = 255), i;
}
const T2 = {
  textFill: 1,
  textSize: 1,
  textOpacity: 1,
  textDx: 1,
  textDy: 1,
  markerWidth: 1,
  markerHeight: 1,
  markerOpacity: 1,
  markerDx: 1,
  markerDy: 1,
  lineWidth: 1,
  lineColor: 1,
  lineOpacity: 1,
  polygonFill: 1,
  polygonOpacity: 1,
  polygonPatternFileWidth: 1,
  polygonPatternFileOrigin: 1
}, fz = {
  textName: 1,
  markerTextFitPadding: 1,
  markerTextFit: 1,
  lineGradientProperty: 1
};
var Ol = Object.freeze({
  __proto__: null,
  now: function() {
    return Date.now();
  },
  extend: El,
  isNil: Qe,
  isNumber: fo,
  isInteger: function(i) {
    return (0 | i) === i;
  },
  isObject: tl,
  isString: xy,
  isFunction: N0,
  hasOwn: ml,
  join: function(i, t) {
    return i.join ? i.join(t || ",") : Array.prototype.join.call(i, t || ",");
  },
  toRadian: function(i) {
    return i * b2;
  },
  toDegree: function(i) {
    return i / b2;
  },
  evaluate: function(i, t, e) {
    return N0(i) ? i(e !== void 0 ? e : null, t) : i;
  },
  isFnTypeSymbol: kh,
  getAltitudeToLocal: CS,
  getTubeSizeScale: cz,
  normalizeColor: zo,
  checkIfIdentityZoomDependent: function(i, t, e) {
    if (Array.isArray(e) || (e = Object.values(e)), !e || !e.length || !T2[i]) return !1;
    for (let r = 0; r < e.length; r++) {
      const n = e[r] && (e[r].feature || e[r]);
      if (!n) continue;
      const s = n.properties && n.properties[t];
      if (s && Ft(s) && !he(s).isZoomConstant) return !0;
    }
    return !1;
  },
  checkIfZoomFnTypeSymbol: function(i) {
    return !!T2[i] || !!fz[i];
  }
});
let Yd = class {
  constructor(t, e, r, n) {
    this.feature = t, this.symbol = e, this.fnTypes = r, this.options = n;
  }
  getPolygonResource() {
    let t = this.symbol.polygonPatternFile;
    const { polygonPatternFileFn: e } = this.fnTypes;
    return this._getResource(t, e);
  }
  getLineResource() {
    let t = this.symbol.linePatternFile;
    const { linePatternFileFn: e } = this.fnTypes;
    return this._getResource(t, e);
  }
  _getResource(t, e) {
    return e && (t = e(this.options.zoom, this.feature.properties)), t;
  }
};
function PS(i, t, e, r) {
  const n = Math.abs(r) >> 15, s = n >> 1, o = n % 2;
  let a = r % Math.pow(2, 15);
  const l = t + (s << 14) * Math.sign(t), h = e + (o << 14) * Math.sign(e);
  return i[0] = l, i[1] = h, a = Math.round(a), i[2] = a === 0 ? r < 0 ? -1 : 0 : a, i;
}
const Nc = Math.pow(2, 14), dz = Math.pow(2, 15);
/*!
 * a compact version of mapbox-gl-style-spec
 * based on mapbox-gl-style-spec@13.28.0
 * https://github.com/mapbox/mapbox-gl-js/tree/main/src/style-spec
 * LICENSE : ISC
 */
var ah, Hc, Vg = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, A2 = {
  exports: {}
};
function M2(i, ...t) {
  for (const e of t) for (const r in e) i[r] = e[r];
  return i;
}
/*! https://mths.be/punycode v1.3.2 by @mathias */
ah = A2, Hc = A2.exports, function(i) {
  var t = Hc && !Hc.nodeType && Hc, e = ah && !ah.nodeType && ah, r = typeof Vg == "object" && Vg;
  r.global !== r && r.window !== r && r.self !== r || (i = r);
  var n, s, o = 2147483647, a = /^xn--/, l = /[^\x20-\x7E]/, h = /[\x2E\u3002\uFF0E\uFF61]/g, u = {
    overflow: "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
  }, c = Math.floor, f = String.fromCharCode;
  function d(b) {
    throw RangeError(u[b]);
  }
  function p(b, T) {
    for (var A = b.length, M = []; A--; ) M[A] = T(b[A]);
    return M;
  }
  function g(b, T) {
    var A = b.split("@"), M = "";
    return A.length > 1 && (M = A[0] + "@", b = A[1]), M + p((b = b.replace(h, ".")).split("."), T).join(".");
  }
  function m(b) {
    for (var T, A, M = [], S = 0, P = b.length; S < P; ) (T = b.charCodeAt(S++)) >= 55296 && T <= 56319 && S < P ? (64512 & (A = b.charCodeAt(S++))) == 56320 ? M.push(((1023 & T) << 10) + (1023 & A) + 65536) : (M.push(T), S--) : M.push(T);
    return M;
  }
  function v(b) {
    return p(b, function(T) {
      var A = "";
      return T > 65535 && (A += f((T -= 65536) >>> 10 & 1023 | 55296), T = 56320 | 1023 & T), A += f(T);
    }).join("");
  }
  function _(b, T) {
    return b + 22 + 75 * (b < 26) - ((T != 0) << 5);
  }
  function y(b, T, A) {
    var M = 0;
    for (b = A ? c(b / 700) : b >> 1, b += c(b / T); b > 455; M += 36) b = c(b / 35);
    return c(M + 36 * b / (b + 38));
  }
  function x(b) {
    var T, A, M, S, P, C, k, O, R, I, D, z = [], H = b.length, G = 0, $ = 128, K = 72;
    for ((A = b.lastIndexOf("-")) < 0 && (A = 0), M = 0; M < A; ++M) b.charCodeAt(M) >= 128 && d("not-basic"), z.push(b.charCodeAt(M));
    for (S = A > 0 ? A + 1 : 0; S < H; ) {
      for (P = G, C = 1, k = 36; S >= H && d("invalid-input"), ((O = (D = b.charCodeAt(S++)) - 48 < 10 ? D - 22 : D - 65 < 26 ? D - 65 : D - 97 < 26 ? D - 97 : 36) >= 36 || O > c((o - G) / C)) && d("overflow"), G += O * C, !(O < (R = k <= K ? 1 : k >= K + 26 ? 26 : k - K)); k += 36) C > c(o / (I = 36 - R)) && d("overflow"), C *= I;
      K = y(G - P, T = z.length + 1, P == 0), c(G / T) > o - $ && d("overflow"), $ += c(G / T), G %= T, z.splice(G++, 0, $);
    }
    return v(z);
  }
  function w(b) {
    var T, A, M, S, P, C, k, O, R, I, D, z, H, G, $, K = [];
    for (z = (b = m(b)).length, T = 128, A = 0, P = 72, C = 0; C < z; ++C) (D = b[C]) < 128 && K.push(f(D));
    for (M = S = K.length, S && K.push("-"); M < z; ) {
      for (k = o, C = 0; C < z; ++C) (D = b[C]) >= T && D < k && (k = D);
      for (k - T > c((o - A) / (H = M + 1)) && d("overflow"), A += (k - T) * H, T = k, C = 0; C < z; ++C) if ((D = b[C]) < T && ++A > o && d("overflow"), D == T) {
        for (O = A, R = 36; !(O < (I = R <= P ? 1 : R >= P + 26 ? 26 : R - P)); R += 36) K.push(f(_(I + ($ = O - I) % (G = 36 - I), 0))), O = c($ / G);
        K.push(f(_(O, 0))), P = y(A, H, M == S), A = 0, ++M;
      }
      ++A, ++T;
    }
    return K.join("");
  }
  if (n = {
    version: "1.3.2",
    ucs2: {
      decode: m,
      encode: v
    },
    decode: x,
    encode: w,
    toASCII: function(b) {
      return g(b, function(T) {
        return l.test(T) ? "xn--" + w(T) : T;
      });
    },
    toUnicode: function(b) {
      return g(b, function(T) {
        return a.test(T) ? x(T.slice(4).toLowerCase()) : T;
      });
    }
  }, t && e) if (ah.exports == t) e.exports = n;
  else for (s in n) n.hasOwnProperty(s) && (t[s] = n[s]);
  else i.punycode = n;
}(Vg);
let pz = class extends Error {
  constructor(t, e) {
    super(e), this.message = e, this.key = t;
  }
};
var es = pz;
let gz = class ES {
  constructor(t, e = []) {
    this.parent = t, this.bindings = {};
    for (const [r, n] of e) this.bindings[r] = n;
  }
  concat(t) {
    return new ES(this, t);
  }
  get(t) {
    if (this.bindings[t]) return this.bindings[t];
    if (this.parent) return this.parent.get(t);
    throw new Error(t + " not found in scope.");
  }
  has(t) {
    return !!this.bindings[t] || !!this.parent && this.parent.has(t);
  }
};
var mz = gz;
const Jd = {
  kind: "null"
}, qt = {
  kind: "number"
}, Ge = {
  kind: "string"
}, Ne = {
  kind: "boolean"
}, As = {
  kind: "color"
}, vl = {
  kind: "object"
}, He = {
  kind: "value"
}, Kd = {
  kind: "collator"
}, Qd = {
  kind: "formatted"
}, Hu = {
  kind: "resolvedImage"
};
function Si(i, t) {
  return {
    kind: "array",
    itemType: i,
    N: t
  };
}
function En(i) {
  if (i.kind === "array") {
    const t = En(i.itemType);
    return typeof i.N == "number" ? `array<${t}, ${i.N}>` : i.itemType.kind === "value" ? "array" : `array<${t}>`;
  }
  return i.kind;
}
const vz = [Jd, qt, Ge, Ne, As, Qd, vl, Si(He), Hu];
function Tu(i, t) {
  if (t.kind === "error") return null;
  if (i.kind === "array") {
    if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !Tu(i.itemType, t.itemType)) && (typeof i.N != "number" || i.N === t.N)) return null;
  } else {
    if (i.kind === t.kind) return null;
    if (i.kind === "value") {
      for (const e of vz) if (!Tu(e, t)) return null;
    }
  }
  return `Expected ${En(i)} but found ${En(t)} instead.`;
}
function by(i, t) {
  return t.some((e) => e.kind === i.kind);
}
function Au(i, t) {
  return t.some((e) => e === "null" ? i === null : e === "array" ? Array.isArray(i) : e === "object" ? i && !Array.isArray(i) && typeof i == "object" : e === typeof i);
}
var OS, S2 = {
  transparent: [0, 0, 0, 0],
  aliceblue: [240, 248, 255, 1],
  antiquewhite: [250, 235, 215, 1],
  aqua: [0, 255, 255, 1],
  aquamarine: [127, 255, 212, 1],
  azure: [240, 255, 255, 1],
  beige: [245, 245, 220, 1],
  bisque: [255, 228, 196, 1],
  black: [0, 0, 0, 1],
  blanchedalmond: [255, 235, 205, 1],
  blue: [0, 0, 255, 1],
  blueviolet: [138, 43, 226, 1],
  brown: [165, 42, 42, 1],
  burlywood: [222, 184, 135, 1],
  cadetblue: [95, 158, 160, 1],
  chartreuse: [127, 255, 0, 1],
  chocolate: [210, 105, 30, 1],
  coral: [255, 127, 80, 1],
  cornflowerblue: [100, 149, 237, 1],
  cornsilk: [255, 248, 220, 1],
  crimson: [220, 20, 60, 1],
  cyan: [0, 255, 255, 1],
  darkblue: [0, 0, 139, 1],
  darkcyan: [0, 139, 139, 1],
  darkgoldenrod: [184, 134, 11, 1],
  darkgray: [169, 169, 169, 1],
  darkgreen: [0, 100, 0, 1],
  darkgrey: [169, 169, 169, 1],
  darkkhaki: [189, 183, 107, 1],
  darkmagenta: [139, 0, 139, 1],
  darkolivegreen: [85, 107, 47, 1],
  darkorange: [255, 140, 0, 1],
  darkorchid: [153, 50, 204, 1],
  darkred: [139, 0, 0, 1],
  darksalmon: [233, 150, 122, 1],
  darkseagreen: [143, 188, 143, 1],
  darkslateblue: [72, 61, 139, 1],
  darkslategray: [47, 79, 79, 1],
  darkslategrey: [47, 79, 79, 1],
  darkturquoise: [0, 206, 209, 1],
  darkviolet: [148, 0, 211, 1],
  deeppink: [255, 20, 147, 1],
  deepskyblue: [0, 191, 255, 1],
  dimgray: [105, 105, 105, 1],
  dimgrey: [105, 105, 105, 1],
  dodgerblue: [30, 144, 255, 1],
  firebrick: [178, 34, 34, 1],
  floralwhite: [255, 250, 240, 1],
  forestgreen: [34, 139, 34, 1],
  fuchsia: [255, 0, 255, 1],
  gainsboro: [220, 220, 220, 1],
  ghostwhite: [248, 248, 255, 1],
  gold: [255, 215, 0, 1],
  goldenrod: [218, 165, 32, 1],
  gray: [128, 128, 128, 1],
  green: [0, 128, 0, 1],
  greenyellow: [173, 255, 47, 1],
  grey: [128, 128, 128, 1],
  honeydew: [240, 255, 240, 1],
  hotpink: [255, 105, 180, 1],
  indianred: [205, 92, 92, 1],
  indigo: [75, 0, 130, 1],
  ivory: [255, 255, 240, 1],
  khaki: [240, 230, 140, 1],
  lavender: [230, 230, 250, 1],
  lavenderblush: [255, 240, 245, 1],
  lawngreen: [124, 252, 0, 1],
  lemonchiffon: [255, 250, 205, 1],
  lightblue: [173, 216, 230, 1],
  lightcoral: [240, 128, 128, 1],
  lightcyan: [224, 255, 255, 1],
  lightgoldenrodyellow: [250, 250, 210, 1],
  lightgray: [211, 211, 211, 1],
  lightgreen: [144, 238, 144, 1],
  lightgrey: [211, 211, 211, 1],
  lightpink: [255, 182, 193, 1],
  lightsalmon: [255, 160, 122, 1],
  lightseagreen: [32, 178, 170, 1],
  lightskyblue: [135, 206, 250, 1],
  lightslategray: [119, 136, 153, 1],
  lightslategrey: [119, 136, 153, 1],
  lightsteelblue: [176, 196, 222, 1],
  lightyellow: [255, 255, 224, 1],
  lime: [0, 255, 0, 1],
  limegreen: [50, 205, 50, 1],
  linen: [250, 240, 230, 1],
  magenta: [255, 0, 255, 1],
  maroon: [128, 0, 0, 1],
  mediumaquamarine: [102, 205, 170, 1],
  mediumblue: [0, 0, 205, 1],
  mediumorchid: [186, 85, 211, 1],
  mediumpurple: [147, 112, 219, 1],
  mediumseagreen: [60, 179, 113, 1],
  mediumslateblue: [123, 104, 238, 1],
  mediumspringgreen: [0, 250, 154, 1],
  mediumturquoise: [72, 209, 204, 1],
  mediumvioletred: [199, 21, 133, 1],
  midnightblue: [25, 25, 112, 1],
  mintcream: [245, 255, 250, 1],
  mistyrose: [255, 228, 225, 1],
  moccasin: [255, 228, 181, 1],
  navajowhite: [255, 222, 173, 1],
  navy: [0, 0, 128, 1],
  oldlace: [253, 245, 230, 1],
  olive: [128, 128, 0, 1],
  olivedrab: [107, 142, 35, 1],
  orange: [255, 165, 0, 1],
  orangered: [255, 69, 0, 1],
  orchid: [218, 112, 214, 1],
  palegoldenrod: [238, 232, 170, 1],
  palegreen: [152, 251, 152, 1],
  paleturquoise: [175, 238, 238, 1],
  palevioletred: [219, 112, 147, 1],
  papayawhip: [255, 239, 213, 1],
  peachpuff: [255, 218, 185, 1],
  peru: [205, 133, 63, 1],
  pink: [255, 192, 203, 1],
  plum: [221, 160, 221, 1],
  powderblue: [176, 224, 230, 1],
  purple: [128, 0, 128, 1],
  rebeccapurple: [102, 51, 153, 1],
  red: [255, 0, 0, 1],
  rosybrown: [188, 143, 143, 1],
  royalblue: [65, 105, 225, 1],
  saddlebrown: [139, 69, 19, 1],
  salmon: [250, 128, 114, 1],
  sandybrown: [244, 164, 96, 1],
  seagreen: [46, 139, 87, 1],
  seashell: [255, 245, 238, 1],
  sienna: [160, 82, 45, 1],
  silver: [192, 192, 192, 1],
  skyblue: [135, 206, 235, 1],
  slateblue: [106, 90, 205, 1],
  slategray: [112, 128, 144, 1],
  slategrey: [112, 128, 144, 1],
  snow: [255, 250, 250, 1],
  springgreen: [0, 255, 127, 1],
  steelblue: [70, 130, 180, 1],
  tan: [210, 180, 140, 1],
  teal: [0, 128, 128, 1],
  thistle: [216, 191, 216, 1],
  tomato: [255, 99, 71, 1],
  turquoise: [64, 224, 208, 1],
  violet: [238, 130, 238, 1],
  wheat: [245, 222, 179, 1],
  white: [255, 255, 255, 1],
  whitesmoke: [245, 245, 245, 1],
  yellow: [255, 255, 0, 1],
  yellowgreen: [154, 205, 50, 1]
};
function Of(i) {
  return (i = Math.round(i)) < 0 ? 0 : i > 255 ? 255 : i;
}
function yz(i) {
  return i < 0 ? 0 : i > 1 ? 1 : i;
}
function Ug(i) {
  return Of(i[i.length - 1] === "%" ? parseFloat(i) / 100 * 255 : parseInt(i));
}
function Bc(i) {
  return yz(i[i.length - 1] === "%" ? parseFloat(i) / 100 : parseFloat(i));
}
function $g(i, t, e) {
  return e < 0 ? e += 1 : e > 1 && (e -= 1), 6 * e < 1 ? i + (t - i) * e * 6 : 2 * e < 1 ? t : 3 * e < 2 ? i + (t - i) * (2 / 3 - e) * 6 : i;
}
try {
  OS = {}.parseCSSColor = function(i) {
    var t, e = i.replace(/ /g, "").toLowerCase();
    if (e in S2) return S2[e].slice();
    if (e[0] === "#") return e.length === 4 ? (t = parseInt(e.substr(1), 16)) >= 0 && t <= 4095 ? [(3840 & t) >> 4 | (3840 & t) >> 8, 240 & t | (240 & t) >> 4, 15 & t | (15 & t) << 4, 1] : null : e.length === 7 && (t = parseInt(e.substr(1), 16)) >= 0 && t <= 16777215 ? [(16711680 & t) >> 16, (65280 & t) >> 8, 255 & t, 1] : null;
    var r = e.indexOf("("), n = e.indexOf(")");
    if (r !== -1 && n + 1 === e.length) {
      var s = e.substr(0, r), o = e.substr(r + 1, n - (r + 1)).split(","), a = 1;
      switch (s) {
        case "rgba":
          if (o.length !== 4) return null;
          a = Bc(o.pop());
        case "rgb":
          return o.length !== 3 ? null : [Ug(o[0]), Ug(o[1]), Ug(o[2]), a];
        case "hsla":
          if (o.length !== 4) return null;
          a = Bc(o.pop());
        case "hsl":
          if (o.length !== 3) return null;
          var l = (parseFloat(o[0]) % 360 + 360) % 360 / 360, h = Bc(o[1]), u = Bc(o[2]), c = u <= 0.5 ? u * (h + 1) : u + h - u * h, f = 2 * u - c;
          return [Of(255 * $g(f, c, l + 1 / 3)), Of(255 * $g(f, c, l)), Of(255 * $g(f, c, l - 1 / 3)), a];
        default:
          return null;
      }
    }
    return null;
  };
} catch {
}
let Li = class H0 {
  constructor(t, e, r, n = 1) {
    this.r = t, this.g = e, this.b = r, this.a = n;
  }
  static parse(t) {
    if (!t) return;
    if (t instanceof H0) return t;
    if (typeof t != "string") return;
    const e = OS(t);
    return e ? new H0(e[0] / 255 * e[3], e[1] / 255 * e[3], e[2] / 255 * e[3], e[3]) : void 0;
  }
  toString() {
    const [t, e, r, n] = this.toArray();
    return `rgba(${Math.round(t)},${Math.round(e)},${Math.round(r)},${n})`;
  }
  toArray() {
    const { r: t, g: e, b: r, a: n } = this;
    return n === 0 ? [0, 0, 0, 0] : [255 * t / n, 255 * e / n, 255 * r / n, n];
  }
  toArray01() {
    const { r: t, g: e, b: r, a: n } = this;
    return n === 0 ? [0, 0, 0, 0] : [t / n, e / n, r / n, n];
  }
  toArray01PremultipliedAlpha() {
    const { r: t, g: e, b: r, a: n } = this;
    return [t, e, r, n];
  }
};
Li.black = new Li(0, 0, 0, 1), Li.white = new Li(1, 1, 1, 1), Li.transparent = new Li(0, 0, 0, 0), Li.red = new Li(1, 0, 0, 1), Li.blue = new Li(0, 0, 1, 1);
var kr = Li;
let wy = class {
  constructor(t, e, r) {
    this.sensitivity = t ? e ? "variant" : "case" : e ? "accent" : "base", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
      sensitivity: this.sensitivity,
      usage: "search"
    });
  }
  compare(t, e) {
    return this.collator.compare(t, e);
  }
  resolvedLocale() {
    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
  }
}, B0 = class {
  constructor(t, e, r, n, s) {
    this.text = t.normalize ? t.normalize() : t, this.image = e, this.scale = r, this.fontStack = n, this.textColor = s;
  }
}, ta = class kf {
  constructor(t) {
    this.sections = t;
  }
  static fromString(t) {
    return new kf([new B0(t, null, null, null, null)]);
  }
  isEmpty() {
    return this.sections.length === 0 || !this.sections.some((t) => t.text.length !== 0 || t.image && t.image.name.length !== 0);
  }
  static factory(t) {
    return t instanceof kf ? t : kf.fromString(t);
  }
  toString() {
    return this.sections.length === 0 ? "" : this.sections.map((t) => t.text).join("");
  }
  serialize() {
    const t = ["format"];
    for (const e of this.sections) {
      if (e.image) {
        t.push(["image", e.image.name]);
        continue;
      }
      t.push(e.text);
      const r = {};
      e.fontStack && (r["text-font"] = ["literal", e.fontStack.split(",")]), e.scale && (r["font-scale"] = e.scale), e.textColor && (r["text-color"] = ["rgba"].concat(e.textColor.toArray())), t.push(r);
    }
    return t;
  }
}, ea = class kS {
  constructor(t) {
    this.name = t.name, this.available = t.available;
  }
  toString() {
    return this.name;
  }
  static fromString(t) {
    return t ? new kS({
      name: t,
      available: !1
    }) : null;
  }
  serialize() {
    return ["image", this.name];
  }
};
function RS(i, t, e, r) {
  return typeof i == "number" && i >= 0 && i <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof e == "number" && e >= 0 && e <= 255 ? r === void 0 || typeof r == "number" && r >= 0 && r <= 1 ? null : `Invalid rgba value [${[i, t, e, r].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof r == "number" ? [i, t, e, r] : [i, t, e]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
}
function gd(i) {
  if (i === null || typeof i == "string" || typeof i == "boolean" || typeof i == "number" || i instanceof kr || i instanceof wy || i instanceof ta || i instanceof ea) return !0;
  if (Array.isArray(i)) {
    for (const t of i) if (!gd(t)) return !1;
    return !0;
  }
  if (typeof i == "object") {
    for (const t in i) if (!gd(i[t])) return !1;
    return !0;
  }
  return !1;
}
function hr(i) {
  if (i === null) return Jd;
  if (typeof i == "string") return Ge;
  if (typeof i == "boolean") return Ne;
  if (typeof i == "number") return qt;
  if (i instanceof kr) return As;
  if (i instanceof wy) return Kd;
  if (i instanceof ta) return Qd;
  if (i instanceof ea) return Hu;
  if (Array.isArray(i)) {
    const t = i.length;
    let e;
    for (const r of i) {
      const n = hr(r);
      if (e) {
        if (e === n) continue;
        e = He;
        break;
      }
      e = n;
    }
    return Si(e || He, t);
  }
  return vl;
}
function Zh(i) {
  const t = typeof i;
  return i === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(i) : i instanceof kr || i instanceof ta || i instanceof ea ? i.toString() : JSON.stringify(i);
}
let _z = class IS {
  constructor(t, e) {
    this.type = t, this.value = e;
  }
  static parse(t, e) {
    if (t.length !== 2) return e.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
    if (!gd(t[1])) return e.error("invalid value");
    const r = t[1];
    let n = hr(r);
    const s = e.expectedType;
    return n.kind !== "array" || n.N !== 0 || !s || s.kind !== "array" || typeof s.N == "number" && s.N !== 0 || (n = s), new IS(n, r);
  }
  evaluate() {
    return this.value;
  }
  eachChild() {
  }
  outputDefined() {
    return !0;
  }
  serialize() {
    return this.type.kind === "array" || this.type.kind === "object" ? ["literal", this.value] : this.value instanceof kr ? ["rgba"].concat(this.value.toArray()) : this.value instanceof ta ? this.value.serialize() : this.value;
  }
};
var Rf = _z, Mr = class {
  constructor(t) {
    this.name = "ExpressionEvaluationError", this.message = t;
  }
  toJSON() {
    return this.message;
  }
};
const Wg = {
  string: Ge,
  number: qt,
  boolean: Ne,
  object: vl
};
let xz = class DS {
  constructor(t, e) {
    this.type = t, this.args = e;
  }
  static parse(t, e) {
    if (t.length < 2) return e.error("Expected at least one argument.");
    let r, n = 1;
    const s = t[0];
    if (s === "array") {
      let a, l;
      if (t.length > 2) {
        const h = t[1];
        if (typeof h != "string" || !(h in Wg) || h === "object") return e.error('The item type argument of "array" must be one of string, number, boolean', 1);
        a = Wg[h], n++;
      } else a = He;
      if (t.length > 3) {
        if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return e.error('The length argument to "array" must be a positive integer literal', 2);
        l = t[2], n++;
      }
      r = Si(a, l);
    } else r = Wg[s];
    const o = [];
    for (; n < t.length; n++) {
      const a = e.parse(t[n], n, He);
      if (!a) return null;
      o.push(a);
    }
    return new DS(r, o);
  }
  evaluate(t) {
    for (let e = 0; e < this.args.length; e++) {
      const r = this.args[e].evaluate(t);
      if (!Tu(this.type, hr(r))) return r;
      if (e === this.args.length - 1) throw new Mr(`Expected value to be of type ${En(this.type)}, but found ${En(hr(r))} instead.`);
    }
    return null;
  }
  eachChild(t) {
    this.args.forEach(t);
  }
  outputDefined() {
    return this.args.every((t) => t.outputDefined());
  }
  serialize() {
    const t = this.type, e = [t.kind];
    if (t.kind === "array") {
      const r = t.itemType;
      if (r.kind === "string" || r.kind === "number" || r.kind === "boolean") {
        e.push(r.kind);
        const n = t.N;
        (typeof n == "number" || this.args.length > 1) && e.push(n);
      }
    }
    return e.concat(this.args.map((r) => r.serialize()));
  }
};
var ys = xz;
let FS = class LS {
  constructor(t) {
    this.type = Qd, this.sections = t;
  }
  static parse(t, e) {
    if (t.length < 2) return e.error("Expected at least one argument.");
    const r = t[1];
    if (!Array.isArray(r) && typeof r == "object") return e.error("First argument must be an image or text section.");
    const n = [];
    let s = !1;
    for (let o = 1; o <= t.length - 1; ++o) {
      const a = t[o];
      if (s && typeof a == "object" && !Array.isArray(a)) {
        s = !1;
        let l = null;
        if (a["font-scale"] && (l = e.parse(a["font-scale"], 1, qt), !l)) return null;
        let h = null;
        if (a["text-font"] && (h = e.parse(a["text-font"], 1, Si(Ge)), !h)) return null;
        let u = null;
        if (a["text-color"] && (u = e.parse(a["text-color"], 1, As), !u)) return null;
        const c = n[n.length - 1];
        c.scale = l, c.font = h, c.textColor = u;
      } else {
        const l = e.parse(t[o], 1, He);
        if (!l) return null;
        const h = l.type.kind;
        if (h !== "string" && h !== "value" && h !== "null" && h !== "resolvedImage") return e.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
        s = !0, n.push({
          content: l,
          scale: null,
          font: null,
          textColor: null
        });
      }
    }
    return new LS(n);
  }
  evaluate(t) {
    return new ta(this.sections.map((e) => {
      const r = e.content.evaluate(t);
      return hr(r) === Hu ? new B0("", r, null, null, null) : new B0(Zh(r), null, e.scale ? e.scale.evaluate(t) : null, e.font ? e.font.evaluate(t).join(",") : null, e.textColor ? e.textColor.evaluate(t) : null);
    }));
  }
  eachChild(t) {
    for (const e of this.sections) t(e.content), e.scale && t(e.scale), e.font && t(e.font), e.textColor && t(e.textColor);
  }
  outputDefined() {
    return !1;
  }
  serialize() {
    const t = ["format"];
    for (const e of this.sections) {
      t.push(e.content.serialize());
      const r = {};
      e.scale && (r["font-scale"] = e.scale.serialize()), e.font && (r["text-font"] = e.font.serialize()), e.textColor && (r["text-color"] = e.textColor.serialize()), t.push(r);
    }
    return t;
  }
}, zS = class NS {
  constructor(t) {
    this.type = Hu, this.input = t;
  }
  static parse(t, e) {
    if (t.length !== 2) return e.error("Expected two arguments.");
    const r = e.parse(t[1], 1, Ge);
    return r ? new NS(r) : e.error("No image name provided.");
  }
  evaluate(t) {
    const e = this.input.evaluate(t), r = ea.fromString(e);
    return r && t.availableImages && (r.available = t.availableImages.indexOf(e) > -1), r;
  }
  eachChild(t) {
    t(this.input);
  }
  outputDefined() {
    return !1;
  }
  serialize() {
    return ["image", this.input.serialize()];
  }
};
const bz = {
  "to-boolean": Ne,
  "to-color": As,
  "to-number": qt,
  "to-string": Ge
};
let wz = class HS {
  constructor(t, e) {
    this.type = t, this.args = e;
  }
  static parse(t, e) {
    if (t.length < 2) return e.error("Expected at least one argument.");
    const r = t[0];
    if ((r === "to-boolean" || r === "to-string") && t.length !== 2) return e.error("Expected one argument.");
    const n = bz[r], s = [];
    for (let o = 1; o < t.length; o++) {
      const a = e.parse(t[o], o, He);
      if (!a) return null;
      s.push(a);
    }
    return new HS(n, s);
  }
  evaluate(t) {
    if (this.type.kind === "boolean") return !!this.args[0].evaluate(t);
    if (this.type.kind === "color") {
      let e, r;
      for (const n of this.args) {
        if (e = n.evaluate(t), r = null, e instanceof kr) return e;
        if (typeof e == "string") {
          const s = t.parseColor(e);
          if (s) return s;
        } else if (Array.isArray(e) && (r = e.length < 3 || e.length > 4 ? `Invalid rbga value ${JSON.stringify(e)}: expected an array containing either three or four numeric values.` : RS(e[0], e[1], e[2], e[3]), !r)) return new kr(e[0] / 255, e[1] / 255, e[2] / 255, e[3]);
      }
      throw new Mr(r || `Could not parse color from value '${typeof e == "string" ? e : String(JSON.stringify(e))}'`);
    }
    if (this.type.kind === "number") {
      let e = null;
      for (const r of this.args) {
        if (e = r.evaluate(t), e === null) return 0;
        const n = Number(e);
        if (!isNaN(n)) return n;
      }
      throw new Mr(`Could not convert ${JSON.stringify(e)} to number.`);
    }
    return this.type.kind === "formatted" ? ta.fromString(Zh(this.args[0].evaluate(t))) : this.type.kind === "resolvedImage" ? ea.fromString(Zh(this.args[0].evaluate(t))) : Zh(this.args[0].evaluate(t));
  }
  eachChild(t) {
    this.args.forEach(t);
  }
  outputDefined() {
    return this.args.every((t) => t.outputDefined());
  }
  serialize() {
    if (this.type.kind === "formatted") return new FS([{
      content: this.args[0],
      scale: null,
      font: null,
      textColor: null
    }]).serialize();
    if (this.type.kind === "resolvedImage") return new zS(this.args[0]).serialize();
    const t = ["to-" + this.type.kind];
    return this.eachChild((e) => {
      t.push(e.serialize());
    }), t;
  }
};
var el = wz;
const Tz = ["Unknown", "Point", "LineString", "Polygon"];
var BS = class {
  constructor() {
    this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null;
  }
  id() {
    return this.feature && this.feature.id !== void 0 ? this.feature.id : null;
  }
  geometryType() {
    return this.feature ? typeof this.feature.type == "number" ? Tz[this.feature.type] : this.feature.type : null;
  }
  geometry() {
    return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
  }
  canonicalID() {
    return this.canonical;
  }
  properties() {
    return this.feature && this.feature.properties || {};
  }
  distanceFromCenter() {
    if (this.featureTileCoord && this.featureDistanceData) {
      const t = this.featureDistanceData.center, e = this.featureDistanceData.scale, { x: r, y: n } = this.featureTileCoord;
      return this.featureDistanceData.bearing[0] * (r * e - t[0]) + this.featureDistanceData.bearing[1] * (n * e - t[1]);
    }
    return 0;
  }
  parseColor(t) {
    let e = this._parseColorCache[t];
    return e || (e = this._parseColorCache[t] = kr.parse(t)), e;
  }
};
let Az = class Rh {
  constructor(t, e, r, n) {
    this.name = t, this.type = e, this._evaluate = r, this.args = n;
  }
  evaluate(t) {
    return this._evaluate(t, this.args);
  }
  eachChild(t) {
    this.args.forEach(t);
  }
  outputDefined() {
    return !1;
  }
  serialize() {
    return [this.name].concat(this.args.map((t) => t.serialize()));
  }
  static parse(t, e) {
    const r = t[0], n = Rh.definitions[r];
    if (!n) return e.error(`Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`, 0);
    const s = Array.isArray(n) ? n[0] : n.type, o = Array.isArray(n) ? [[n[1], n[2]]] : n.overloads, a = o.filter(([h]) => !Array.isArray(h) || h.length === t.length - 1);
    let l = null;
    for (const [h, u] of a) {
      l = new XS(e.registry, e.path, null, e.scope);
      const c = [];
      let f = !1;
      for (let d = 1; d < t.length; d++) {
        const p = t[d], g = Array.isArray(h) ? h[d - 1] : h.type, m = l.parse(p, 1 + c.length, g);
        if (!m) {
          f = !0;
          break;
        }
        c.push(m);
      }
      if (!f) if (Array.isArray(h) && h.length !== c.length) l.error(`Expected ${h.length} arguments, but found ${c.length} instead.`);
      else {
        for (let d = 0; d < c.length; d++) {
          const p = Array.isArray(h) ? h[d] : h.type, g = c[d];
          l.concat(d + 1).checkSubtype(p, g.type);
        }
        if (l.errors.length === 0) return new Rh(r, s, u, c);
      }
    }
    if (a.length === 1) e.errors.push(...l.errors);
    else {
      const h = (a.length ? a : o).map(([c]) => {
        return f = c, Array.isArray(f) ? `(${f.map(En).join(", ")})` : `(${En(f.type)}...)`;
        var f;
      }).join(" | "), u = [];
      for (let c = 1; c < t.length; c++) {
        const f = e.parse(t[c], 1 + u.length);
        if (!f) return null;
        u.push(En(f.type));
      }
      e.error(`Expected arguments of type ${h}, but found (${u.join(", ")}) instead.`);
    }
    return null;
  }
  static register(t, e) {
    Rh.definitions = e;
    for (const r in e) t[r] = Rh;
  }
};
var Hl = Az;
let jS = class GS {
  constructor(t, e, r) {
    this.type = Kd, this.locale = r, this.caseSensitive = t, this.diacriticSensitive = e;
  }
  static parse(t, e) {
    if (t.length !== 2) return e.error("Expected one argument.");
    const r = t[1];
    if (typeof r != "object" || Array.isArray(r)) return e.error("Collator options argument must be an object.");
    const n = e.parse(r["case-sensitive"] !== void 0 && r["case-sensitive"], 1, Ne);
    if (!n) return null;
    const s = e.parse(r["diacritic-sensitive"] !== void 0 && r["diacritic-sensitive"], 1, Ne);
    if (!s) return null;
    let o = null;
    return r.locale && (o = e.parse(r.locale, 1, Ge), !o) ? null : new GS(n, s, o);
  }
  evaluate(t) {
    return new wy(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);
  }
  eachChild(t) {
    t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);
  }
  outputDefined() {
    return !1;
  }
  serialize() {
    const t = {};
    return t["case-sensitive"] = this.caseSensitive.serialize(), t["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t.locale = this.locale.serialize()), ["collator", t];
  }
};
function Ty(i, t) {
  i[0] = Math.min(i[0], t[0]), i[1] = Math.min(i[1], t[1]), i[2] = Math.max(i[2], t[0]), i[3] = Math.max(i[3], t[1]);
}
function jc(i, t) {
  return !(i[0] <= t[0]) && !(i[2] >= t[2]) && !(i[1] <= t[1]) && !(i[3] >= t[3]);
}
function Mz(i, t) {
  const e = (180 + i[0]) / 360, r = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i[1] * Math.PI / 360))) / 360, n = Math.pow(2, t.z);
  return [Math.round(e * n * 8192), Math.round(r * n * 8192)];
}
function Sz(i, t, e) {
  const r = i[0] - t[0], n = i[1] - t[1], s = i[0] - e[0], o = i[1] - e[1];
  return r * o - s * n == 0 && r * s <= 0 && n * o <= 0;
}
function Ay(i, t) {
  let e = !1;
  for (let o = 0, a = t.length; o < a; o++) {
    const l = t[o];
    for (let h = 0, u = l.length; h < u - 1; h++) {
      if (Sz(i, l[h], l[h + 1])) return !1;
      (n = l[h])[1] > (r = i)[1] != (s = l[h + 1])[1] > r[1] && r[0] < (s[0] - n[0]) * (r[1] - n[1]) / (s[1] - n[1]) + n[0] && (e = !e);
    }
  }
  var r, n, s;
  return e;
}
function Cz(i, t) {
  for (let e = 0; e < t.length; e++) if (Ay(i, t[e])) return !0;
  return !1;
}
function C2(i, t, e, r) {
  const n = r[0] - e[0], s = r[1] - e[1], o = (i[0] - e[0]) * s - n * (i[1] - e[1]), a = (t[0] - e[0]) * s - n * (t[1] - e[1]);
  return o > 0 && a < 0 || o < 0 && a > 0;
}
function Pz(i, t, e) {
  for (const h of e) for (let u = 0; u < h.length - 1; ++u) if (a = void 0, l = void 0, (a = [(o = h[u + 1])[0] - (s = h[u])[0], o[1] - s[1]])[0] * (l = [(n = t)[0] - (r = i)[0], n[1] - r[1]])[1] - a[1] * l[0] != 0 && C2(r, n, s, o) && C2(s, o, r, n)) return !0;
  var r, n, s, o, a, l;
  return !1;
}
function VS(i, t) {
  for (let e = 0; e < i.length; ++e) if (!Ay(i[e], t)) return !1;
  for (let e = 0; e < i.length - 1; ++e) if (Pz(i[e], i[e + 1], t)) return !1;
  return !0;
}
function Ez(i, t) {
  for (let e = 0; e < t.length; e++) if (VS(i, t[e])) return !0;
  return !1;
}
function j0(i, t, e) {
  const r = [];
  for (let n = 0; n < i.length; n++) {
    const s = [];
    for (let o = 0; o < i[n].length; o++) {
      const a = Mz(i[n][o], e);
      Ty(t, a), s.push(a);
    }
    r.push(s);
  }
  return r;
}
function P2(i, t, e) {
  const r = [];
  for (let n = 0; n < i.length; n++) {
    const s = j0(i[n], t, e);
    r.push(s);
  }
  return r;
}
function US(i, t, e, r) {
  if (i[0] < e[0] || i[0] > e[2]) {
    const n = 0.5 * r;
    let s = i[0] - e[0] > n ? -r : e[0] - i[0] > n ? r : 0;
    s === 0 && (s = i[0] - e[2] > n ? -r : e[2] - i[0] > n ? r : 0), i[0] += s;
  }
  Ty(t, i);
}
function E2(i, t, e, r) {
  const n = 8192 * Math.pow(2, r.z), s = [8192 * r.x, 8192 * r.y], o = [];
  if (!i) return o;
  for (const a of i) for (const l of a) {
    const h = [l.x + s[0], l.y + s[1]];
    US(h, t, e, n), o.push(h);
  }
  return o;
}
function O2(i, t, e, r) {
  const n = 8192 * Math.pow(2, r.z), s = [8192 * r.x, 8192 * r.y], o = [];
  if (!i) return o;
  for (const l of i) {
    const h = [];
    for (const u of l) {
      const c = [u.x + s[0], u.y + s[1]];
      Ty(t, c), h.push(c);
    }
    o.push(h);
  }
  if (t[2] - t[0] <= n / 2) {
    (a = t)[0] = a[1] = 1 / 0, a[2] = a[3] = -1 / 0;
    for (const l of o) for (const h of l) US(h, t, e, n);
  }
  var a;
  return o;
}
let Oz = class If {
  constructor(t, e) {
    this.type = Ne, this.geojson = t, this.geometries = e;
  }
  static parse(t, e) {
    if (t.length !== 2) return e.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);
    if (gd(t[1])) {
      const r = t[1];
      if (r.type === "FeatureCollection") for (let n = 0; n < r.features.length; ++n) {
        const s = r.features[n].geometry.type;
        if (s === "Polygon" || s === "MultiPolygon") return new If(r, r.features[n].geometry);
      }
      else if (r.type === "Feature") {
        const n = r.geometry.type;
        if (n === "Polygon" || n === "MultiPolygon") return new If(r, r.geometry);
      } else if (r.type === "Polygon" || r.type === "MultiPolygon") return new If(r, r);
    }
    return e.error("'within' expression requires valid geojson object that contains polygon geometry type.");
  }
  evaluate(t) {
    if (t.geometry() != null && t.canonicalID() != null) {
      if (t.geometryType() === "Point") return function(e, r) {
        const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], s = [1 / 0, 1 / 0, -1 / 0, -1 / 0], o = e.canonicalID();
        if (!o) return !1;
        if (r.type === "Polygon") {
          const a = j0(r.coordinates, s, o), l = E2(e.geometry(), n, s, o);
          if (!jc(n, s)) return !1;
          for (const h of l) if (!Ay(h, a)) return !1;
        }
        if (r.type === "MultiPolygon") {
          const a = P2(r.coordinates, s, o), l = E2(e.geometry(), n, s, o);
          if (!jc(n, s)) return !1;
          for (const h of l) if (!Cz(h, a)) return !1;
        }
        return !0;
      }(t, this.geometries);
      if (t.geometryType() === "LineString") return function(e, r) {
        const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], s = [1 / 0, 1 / 0, -1 / 0, -1 / 0], o = e.canonicalID();
        if (!o) return !1;
        if (r.type === "Polygon") {
          const a = j0(r.coordinates, s, o), l = O2(e.geometry(), n, s, o);
          if (!jc(n, s)) return !1;
          for (const h of l) if (!VS(h, a)) return !1;
        }
        if (r.type === "MultiPolygon") {
          const a = P2(r.coordinates, s, o), l = O2(e.geometry(), n, s, o);
          if (!jc(n, s)) return !1;
          for (const h of l) if (!Ez(h, a)) return !1;
        }
        return !0;
      }(t, this.geometries);
    }
    return !1;
  }
  eachChild() {
  }
  outputDefined() {
    return !0;
  }
  serialize() {
    return ["within", this.geojson];
  }
};
var My = Oz;
function tp(i) {
  if (i instanceof Hl && (i.name === "get" && i.args.length === 1 || i.name === "feature-state" || i.name === "has" && i.args.length === 1 || i.name === "properties" || i.name === "geometry-type" || i.name === "id" || /^filter-/.test(i.name)) || i instanceof My) return !1;
  let t = !0;
  return i.eachChild((e) => {
    t && !tp(e) && (t = !1);
  }), t;
}
function Sy(i) {
  if (i instanceof Hl && i.name === "feature-state") return !1;
  let t = !0;
  return i.eachChild((e) => {
    t && !Sy(e) && (t = !1);
  }), t;
}
function Cy(i, t) {
  if (i instanceof Hl && t.indexOf(i.name) >= 0) return !1;
  let e = !0;
  return i.eachChild((r) => {
    e && !Cy(r, t) && (e = !1);
  }), e;
}
let kz = class $S {
  constructor(t, e) {
    this.type = e.type, this.name = t, this.boundExpression = e;
  }
  static parse(t, e) {
    if (t.length !== 2 || typeof t[1] != "string") return e.error("'var' expression requires exactly one string literal argument.");
    const r = t[1];
    return e.scope.has(r) ? new $S(r, e.scope.get(r)) : e.error(`Unknown variable "${r}". Make sure "${r}" has been bound in an enclosing "let" expression before using it.`, 1);
  }
  evaluate(t) {
    return this.boundExpression.evaluate(t);
  }
  eachChild() {
  }
  outputDefined() {
    return !1;
  }
  serialize() {
    return ["var", this.name];
  }
};
var WS = kz;
let Rz = class ZS {
  constructor(t, e = [], r, n = new mz(), s = []) {
    this.registry = t, this.path = e, this.key = e.map((o) => `[${o}]`).join(""), this.scope = n, this.errors = s, this.expectedType = r;
  }
  parse(t, e, r, n, s = {}) {
    return e ? this.concat(e, r, n)._parse(t, s) : this._parse(t, s);
  }
  _parse(t, e) {
    function r(n, s, o) {
      return o === "assert" ? new ys(s, [n]) : o === "coerce" ? new el(s, [n]) : n;
    }
    if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
      if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
      const n = t[0];
      if (typeof n != "string") return this.error(`Expression name must be a string, but found ${typeof n} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
      const s = this.registry[n];
      if (s) {
        let o = s.parse(t, this);
        if (!o) return null;
        if (this.expectedType) {
          const a = this.expectedType, l = o.type;
          if (a.kind !== "string" && a.kind !== "number" && a.kind !== "boolean" && a.kind !== "object" && a.kind !== "array" || l.kind !== "value") if (a.kind !== "color" && a.kind !== "formatted" && a.kind !== "resolvedImage" || l.kind !== "value" && l.kind !== "string") {
            if (this.checkSubtype(a, l)) return null;
          } else o = r(o, a, e.typeAnnotation || "coerce");
          else o = r(o, a, e.typeAnnotation || "assert");
        }
        if (!(o instanceof Rf) && o.type.kind !== "resolvedImage" && function a(l) {
          if (l instanceof WS) return a(l.boundExpression);
          if (l instanceof Hl && l.name === "error" || l instanceof jS || l instanceof My) return !1;
          const h = l instanceof el || l instanceof ys;
          let u = !0;
          return l.eachChild((c) => {
            u = h ? u && a(c) : u && c instanceof Rf;
          }), u ? tp(l) && Cy(l, ["zoom", "heatmap-density", "line-progress", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center"]) : !1;
        }(o)) {
          const a = new BS();
          try {
            o = new Rf(o.type, o.evaluate(a));
          } catch (l) {
            return this.error(l.message), null;
          }
        }
        return o;
      }
      return this.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0);
    }
    return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);
  }
  concat(t, e, r) {
    const n = typeof t == "number" ? this.path.concat(t) : this.path, s = r ? this.scope.concat(r) : this.scope;
    return new ZS(this.registry, n, e || null, s, this.errors);
  }
  error(t, ...e) {
    const r = `${this.key}${e.map((n) => `[${n}]`).join("")}`;
    this.errors.push(new es(r, t));
  }
  checkSubtype(t, e) {
    const r = Tu(t, e);
    return r && this.error(r), r;
  }
};
var XS = Rz;
function ep(i, t) {
  const e = i.length - 1;
  let r, n, s = 0, o = e, a = 0;
  for (; s <= o; ) if (a = Math.floor((s + o) / 2), r = i[a], n = i[a + 1], r <= t) {
    if (a === e || t < n) return a;
    s = a + 1;
  } else {
    if (!(r > t)) throw new Mr("Input is not a number.");
    o = a - 1;
  }
  return 0;
}
let Iz = class qS {
  constructor(t, e, r) {
    this.type = t, this.input = e, this.labels = [], this.outputs = [];
    for (const [n, s] of r) this.labels.push(n), this.outputs.push(s);
  }
  static parse(t, e) {
    if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
    if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");
    const r = e.parse(t[1], 1, qt);
    if (!r) return null;
    const n = [];
    let s = null;
    e.expectedType && e.expectedType.kind !== "value" && (s = e.expectedType);
    for (let o = 1; o < t.length; o += 2) {
      const a = o === 1 ? -1 / 0 : t[o], l = t[o + 1], h = o, u = o + 1;
      if (typeof a != "number") return e.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', h);
      if (n.length && n[n.length - 1][0] >= a) return e.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', h);
      const c = e.parse(l, u, s);
      if (!c) return null;
      s = s || c.type, n.push([a, c]);
    }
    return new qS(s, r, n);
  }
  evaluate(t) {
    const e = this.labels, r = this.outputs;
    if (e.length === 1) return r[0].evaluate(t);
    const n = this.input.evaluate(t);
    if (n <= e[0]) return r[0].evaluate(t);
    const s = e.length;
    return n >= e[s - 1] ? r[s - 1].evaluate(t) : r[ep(e, n)].evaluate(t);
  }
  eachChild(t) {
    t(this.input);
    for (const e of this.outputs) t(e);
  }
  outputDefined() {
    return this.outputs.every((t) => t.outputDefined());
  }
  serialize() {
    const t = ["step", this.input.serialize()];
    for (let e = 0; e < this.labels.length; e++) e > 0 && t.push(this.labels[e]), t.push(this.outputs[e].serialize());
    return t;
  }
};
var YS = Iz, Dz = JS;
function JS(i, t, e, r) {
  this.cx = 3 * i, this.bx = 3 * (e - i) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (r - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = i, this.p1y = t, this.p2x = e, this.p2y = r;
}
function si(i, t, e) {
  return i * (1 - e) + t * e;
}
JS.prototype = {
  sampleCurveX: function(i) {
    return ((this.ax * i + this.bx) * i + this.cx) * i;
  },
  sampleCurveY: function(i) {
    return ((this.ay * i + this.by) * i + this.cy) * i;
  },
  sampleCurveDerivativeX: function(i) {
    return (3 * this.ax * i + 2 * this.bx) * i + this.cx;
  },
  solveCurveX: function(i, t) {
    if (t === void 0 && (t = 1e-6), i < 0) return 0;
    if (i > 1) return 1;
    for (var e = i, r = 0; r < 8; r++) {
      var n = this.sampleCurveX(e) - i;
      if (Math.abs(n) < t) return e;
      var s = this.sampleCurveDerivativeX(e);
      if (Math.abs(s) < 1e-6) break;
      e -= n / s;
    }
    var o = 0, a = 1;
    for (e = i, r = 0; r < 20 && (n = this.sampleCurveX(e), !(Math.abs(n - i) < t)); r++) i > n ? o = e : a = e, e = 0.5 * (a - o) + o;
    return e;
  },
  solve: function(i, t) {
    return this.sampleCurveY(this.solveCurveX(i, t));
  }
};
var KS = Object.freeze({
  __proto__: null,
  number: si,
  color: function(i, t, e) {
    return new kr(si(i.r, t.r, e), si(i.g, t.g, e), si(i.b, t.b, e), si(i.a, t.a, e));
  },
  array: function(i, t, e) {
    return i.map((r, n) => si(r, t[n], e));
  }
});
const G0 = 6 / 29, QS = 3 * G0 * G0, Fz = Math.PI / 180, Lz = 180 / Math.PI;
function Zg(i) {
  return i > 0.008856451679035631 ? Math.pow(i, 1 / 3) : i / QS + 4 / 29;
}
function Xg(i) {
  return i > G0 ? i * i * i : QS * (i - 4 / 29);
}
function qg(i) {
  return 255 * (i <= 31308e-7 ? 12.92 * i : 1.055 * Math.pow(i, 1 / 2.4) - 0.055);
}
function Yg(i) {
  return (i /= 255) <= 0.04045 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4);
}
function tC(i) {
  const t = Yg(i.r), e = Yg(i.g), r = Yg(i.b), n = Zg((0.4124564 * t + 0.3575761 * e + 0.1804375 * r) / 0.95047), s = Zg((0.2126729 * t + 0.7151522 * e + 0.072175 * r) / 1);
  return {
    l: 116 * s - 16,
    a: 500 * (n - s),
    b: 200 * (s - Zg((0.0193339 * t + 0.119192 * e + 0.9503041 * r) / 1.08883)),
    alpha: i.a
  };
}
function eC(i) {
  let t = (i.l + 16) / 116, e = isNaN(i.a) ? t : t + i.a / 500, r = isNaN(i.b) ? t : t - i.b / 200;
  return t = 1 * Xg(t), e = 0.95047 * Xg(e), r = 1.08883 * Xg(r), new kr(qg(3.2404542 * e - 1.5371385 * t - 0.4985314 * r), qg(-0.969266 * e + 1.8760108 * t + 0.041556 * r), qg(0.0556434 * e - 0.2040259 * t + 1.0572252 * r), i.alpha);
}
function zz(i, t, e) {
  const r = t - i;
  return i + e * (r > 180 || r < -180 ? r - 360 * Math.round(r / 360) : r);
}
const Ih = {
  forward: tC,
  reverse: eC,
  interpolate: function(i, t, e) {
    return {
      l: si(i.l, t.l, e),
      a: si(i.a, t.a, e),
      b: si(i.b, t.b, e),
      alpha: si(i.alpha, t.alpha, e)
    };
  }
}, Dh = {
  forward: function(i) {
    const { l: t, a: e, b: r } = tC(i), n = Math.atan2(r, e) * Lz;
    return {
      h: n < 0 ? n + 360 : n,
      c: Math.sqrt(e * e + r * r),
      l: t,
      alpha: i.a
    };
  },
  reverse: function(i) {
    const t = i.h * Fz, e = i.c;
    return eC({
      l: i.l,
      a: Math.cos(t) * e,
      b: Math.sin(t) * e,
      alpha: i.alpha
    });
  },
  interpolate: function(i, t, e) {
    return {
      h: zz(i.h, t.h, e),
      c: si(i.c, t.c, e),
      l: si(i.l, t.l, e),
      alpha: si(i.alpha, t.alpha, e)
    };
  }
};
var nC = Object.freeze({
  __proto__: null,
  lab: Ih,
  hcl: Dh
});
let Nz = class V0 {
  constructor(t, e, r, n, s) {
    this.type = t, this.operator = e, this.interpolation = r, this.input = n, this.labels = [], this.outputs = [];
    for (const [o, a] of s) this.labels.push(o), this.outputs.push(a);
  }
  static interpolationFactor(t, e, r, n) {
    let s = 0;
    if (t.name === "exponential") s = Jg(e, t.base, r, n);
    else if (t.name === "linear") s = Jg(e, 1, r, n);
    else if (t.name === "cubic-bezier") {
      const o = t.controlPoints;
      s = new Dz(o[0], o[1], o[2], o[3]).solve(Jg(e, 1, r, n));
    }
    return s;
  }
  static parse(t, e) {
    let [r, n, s, ...o] = t;
    if (!Array.isArray(n) || n.length === 0) return e.error("Expected an interpolation type expression.", 1);
    if (n[0] === "linear") n = {
      name: "linear"
    };
    else if (n[0] === "exponential") {
      const h = n[1];
      if (typeof h != "number") return e.error("Exponential interpolation requires a numeric base.", 1, 1);
      n = {
        name: "exponential",
        base: h
      };
    } else {
      if (n[0] !== "cubic-bezier") return e.error("Unknown interpolation type " + String(n[0]), 1, 0);
      {
        const h = n.slice(1);
        if (h.length !== 4 || h.some((u) => typeof u != "number" || u < 0 || u > 1)) return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
        n = {
          name: "cubic-bezier",
          controlPoints: h
        };
      }
    }
    if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
    if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");
    if (s = e.parse(s, 2, qt), !s) return null;
    const a = [];
    let l = null;
    r === "interpolate-hcl" || r === "interpolate-lab" ? l = As : e.expectedType && e.expectedType.kind !== "value" && (l = e.expectedType);
    for (let h = 0; h < o.length; h += 2) {
      const u = o[h], c = o[h + 1], f = h + 3, d = h + 4;
      if (typeof u != "number") return e.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', f);
      if (a.length && a[a.length - 1][0] >= u) return e.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', f);
      const p = e.parse(c, d, l);
      if (!p) return null;
      l = l || p.type, a.push([u, p]);
    }
    return l.kind === "number" || l.kind === "color" || l.kind === "array" && l.itemType.kind === "number" && typeof l.N == "number" ? new V0(l, r, n, s, a) : e.error(`Type ${En(l)} is not interpolatable.`);
  }
  evaluate(t) {
    const e = this.labels, r = this.outputs;
    if (e.length === 1) return r[0].evaluate(t);
    const n = this.input.evaluate(t);
    if (n <= e[0]) return r[0].evaluate(t);
    const s = e.length;
    if (n >= e[s - 1]) return r[s - 1].evaluate(t);
    const o = ep(e, n), a = V0.interpolationFactor(this.interpolation, n, e[o], e[o + 1]), l = r[o].evaluate(t), h = r[o + 1].evaluate(t);
    return this.operator === "interpolate" ? KS[this.type.kind.toLowerCase()](l, h, a) : this.operator === "interpolate-hcl" ? Dh.reverse(Dh.interpolate(Dh.forward(l), Dh.forward(h), a)) : Ih.reverse(Ih.interpolate(Ih.forward(l), Ih.forward(h), a));
  }
  eachChild(t) {
    t(this.input);
    for (const e of this.outputs) t(e);
  }
  outputDefined() {
    return this.outputs.every((t) => t.outputDefined());
  }
  serialize() {
    let t;
    t = this.interpolation.name === "linear" ? ["linear"] : this.interpolation.name === "exponential" ? this.interpolation.base === 1 ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
    const e = [this.operator, t, this.input.serialize()];
    for (let r = 0; r < this.labels.length; r++) e.push(this.labels[r], this.outputs[r].serialize());
    return e;
  }
};
function Jg(i, t, e, r) {
  const n = r - e, s = i - e;
  return n === 0 ? 0 : t === 1 ? s / n : (Math.pow(t, s) - 1) / (Math.pow(t, n) - 1);
}
var Ms = Nz;
let Hz = class rC {
  constructor(t, e) {
    this.type = t, this.args = e;
  }
  static parse(t, e) {
    if (t.length < 2) return e.error("Expectected at least one argument.");
    let r = null;
    const n = e.expectedType;
    n && n.kind !== "value" && (r = n);
    const s = [];
    for (const a of t.slice(1)) {
      const l = e.parse(a, 1 + s.length, r, void 0, {
        typeAnnotation: "omit"
      });
      if (!l) return null;
      r = r || l.type, s.push(l);
    }
    const o = n && s.some((a) => Tu(n, a.type));
    return new rC(o ? He : r, s);
  }
  evaluate(t) {
    let e, r = null, n = 0;
    for (const s of this.args) {
      if (n++, r = s.evaluate(t), r && r instanceof ea && !r.available && (e || (e = r), r = null, n === this.args.length)) return e;
      if (r !== null) break;
    }
    return r;
  }
  eachChild(t) {
    this.args.forEach(t);
  }
  outputDefined() {
    return this.args.every((t) => t.outputDefined());
  }
  serialize() {
    const t = ["coalesce"];
    return this.eachChild((e) => {
      t.push(e.serialize());
    }), t;
  }
};
var iC = Hz;
let Bz = class sC {
  constructor(t, e) {
    this.type = e.type, this.bindings = [].concat(t), this.result = e;
  }
  evaluate(t) {
    return this.result.evaluate(t);
  }
  eachChild(t) {
    for (const e of this.bindings) t(e[1]);
    t(this.result);
  }
  static parse(t, e) {
    if (t.length < 4) return e.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
    const r = [];
    for (let s = 1; s < t.length - 1; s += 2) {
      const o = t[s];
      if (typeof o != "string") return e.error(`Expected string, but found ${typeof o} instead.`, s);
      if (/[^a-zA-Z0-9_]/.test(o)) return e.error("Variable names must contain only alphanumeric characters or '_'.", s);
      const a = e.parse(t[s + 1], s + 1);
      if (!a) return null;
      r.push([o, a]);
    }
    const n = e.parse(t[t.length - 1], t.length - 1, e.expectedType, r);
    return n ? new sC(r, n) : null;
  }
  outputDefined() {
    return this.result.outputDefined();
  }
  serialize() {
    const t = ["let"];
    for (const [e, r] of this.bindings) t.push(e, r.serialize());
    return t.push(this.result.serialize()), t;
  }
};
var oC = Bz;
let jz = class aC {
  constructor(t, e, r) {
    this.type = t, this.index = e, this.input = r;
  }
  static parse(t, e) {
    if (t.length !== 3) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
    const r = e.parse(t[1], 1, qt), n = e.parse(t[2], 2, Si(e.expectedType || He));
    return !r || !n ? null : new aC(n.type.itemType, r, n);
  }
  evaluate(t) {
    const e = this.index.evaluate(t), r = this.input.evaluate(t);
    if (e < 0) throw new Mr(`Array index out of bounds: ${e} < 0.`);
    if (e >= r.length) throw new Mr(`Array index out of bounds: ${e} > ${r.length - 1}.`);
    if (e !== Math.floor(e)) throw new Mr(`Array index must be an integer, but found ${e} instead.`);
    return r[e];
  }
  eachChild(t) {
    t(this.index), t(this.input);
  }
  outputDefined() {
    return !1;
  }
  serialize() {
    return ["at", this.index.serialize(), this.input.serialize()];
  }
};
var Gz = jz;
let Vz = class lC {
  constructor(t, e) {
    this.type = Ne, this.needle = t, this.haystack = e;
  }
  static parse(t, e) {
    if (t.length !== 3) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
    const r = e.parse(t[1], 1, He), n = e.parse(t[2], 2, He);
    return r && n ? by(r.type, [Ne, Ge, qt, Jd, He]) ? new lC(r, n) : e.error(`Expected first argument to be of type boolean, string, number or null, but found ${En(r.type)} instead`) : null;
  }
  evaluate(t) {
    const e = this.needle.evaluate(t), r = this.haystack.evaluate(t);
    if (r == null) return !1;
    if (!Au(e, ["boolean", "string", "number", "null"])) throw new Mr(`Expected first argument to be of type boolean, string, number or null, but found ${En(hr(e))} instead.`);
    if (!Au(r, ["string", "array"])) throw new Mr(`Expected second argument to be of type array or string, but found ${En(hr(r))} instead.`);
    return r.indexOf(e) >= 0;
  }
  eachChild(t) {
    t(this.needle), t(this.haystack);
  }
  outputDefined() {
    return !0;
  }
  serialize() {
    return ["in", this.needle.serialize(), this.haystack.serialize()];
  }
};
var Uz = Vz;
let $z = class U0 {
  constructor(t, e, r) {
    this.type = qt, this.needle = t, this.haystack = e, this.fromIndex = r;
  }
  static parse(t, e) {
    if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
    const r = e.parse(t[1], 1, He), n = e.parse(t[2], 2, He);
    if (!r || !n) return null;
    if (!by(r.type, [Ne, Ge, qt, Jd, He])) return e.error(`Expected first argument to be of type boolean, string, number or null, but found ${En(r.type)} instead`);
    if (t.length === 4) {
      const s = e.parse(t[3], 3, qt);
      return s ? new U0(r, n, s) : null;
    }
    return new U0(r, n);
  }
  evaluate(t) {
    const e = this.needle.evaluate(t), r = this.haystack.evaluate(t);
    if (!Au(e, ["boolean", "string", "number", "null"])) throw new Mr(`Expected first argument to be of type boolean, string, number or null, but found ${En(hr(e))} instead.`);
    if (!Au(r, ["string", "array"])) throw new Mr(`Expected second argument to be of type array or string, but found ${En(hr(r))} instead.`);
    if (this.fromIndex) {
      const n = this.fromIndex.evaluate(t);
      return r.indexOf(e, n);
    }
    return r.indexOf(e);
  }
  eachChild(t) {
    t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);
  }
  outputDefined() {
    return !1;
  }
  serialize() {
    if (this.fromIndex != null && this.fromIndex !== void 0) {
      const t = this.fromIndex.serialize();
      return ["index-of", this.needle.serialize(), this.haystack.serialize(), t];
    }
    return ["index-of", this.needle.serialize(), this.haystack.serialize()];
  }
};
var Wz = $z;
let Zz = class hC {
  constructor(t, e, r, n, s, o) {
    this.inputType = t, this.type = e, this.input = r, this.cases = n, this.outputs = s, this.otherwise = o;
  }
  static parse(t, e) {
    if (t.length < 5) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
    if (t.length % 2 != 1) return e.error("Expected an even number of arguments.");
    let r, n;
    e.expectedType && e.expectedType.kind !== "value" && (n = e.expectedType);
    const s = {}, o = [];
    for (let h = 2; h < t.length - 1; h += 2) {
      let u = t[h];
      const c = t[h + 1];
      Array.isArray(u) || (u = [u]);
      const f = e.concat(h);
      if (u.length === 0) return f.error("Expected at least one branch label.");
      for (const p of u) {
        if (typeof p != "number" && typeof p != "string") return f.error("Branch labels must be numbers or strings.");
        if (typeof p == "number" && Math.abs(p) > Number.MAX_SAFE_INTEGER) return f.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
        if (typeof p == "number" && Math.floor(p) !== p) return f.error("Numeric branch labels must be integer values.");
        if (r) {
          if (f.checkSubtype(r, hr(p))) return null;
        } else r = hr(p);
        if (s[String(p)] !== void 0) return f.error("Branch labels must be unique.");
        s[String(p)] = o.length;
      }
      const d = e.parse(c, h, n);
      if (!d) return null;
      n = n || d.type, o.push(d);
    }
    const a = e.parse(t[1], 1, He);
    if (!a) return null;
    const l = e.parse(t[t.length - 1], t.length - 1, n);
    return l ? a.type.kind !== "value" && e.concat(1).checkSubtype(r, a.type) ? null : new hC(r, n, a, s, o, l) : null;
  }
  evaluate(t) {
    const e = this.input.evaluate(t);
    return (hr(e) === this.inputType && this.outputs[this.cases[e]] || this.otherwise).evaluate(t);
  }
  eachChild(t) {
    t(this.input), this.outputs.forEach(t), t(this.otherwise);
  }
  outputDefined() {
    return this.outputs.every((t) => t.outputDefined()) && this.otherwise.outputDefined();
  }
  serialize() {
    const t = ["match", this.input.serialize()], e = Object.keys(this.cases).sort(), r = [], n = {};
    for (const o of e) {
      const a = n[this.cases[o]];
      a === void 0 ? (n[this.cases[o]] = r.length, r.push([this.cases[o], [o]])) : r[a][1].push(o);
    }
    const s = (o) => this.inputType.kind === "number" ? Number(o) : o;
    for (const [o, a] of r) t.push(a.length === 1 ? s(a[0]) : a.map(s)), t.push(this.outputs[o].serialize());
    return t.push(this.otherwise.serialize()), t;
  }
};
var Xz = Zz;
let qz = class uC {
  constructor(t, e, r) {
    this.type = t, this.branches = e, this.otherwise = r;
  }
  static parse(t, e) {
    if (t.length < 4) return e.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
    if (t.length % 2 != 0) return e.error("Expected an odd number of arguments.");
    let r;
    e.expectedType && e.expectedType.kind !== "value" && (r = e.expectedType);
    const n = [];
    for (let o = 1; o < t.length - 1; o += 2) {
      const a = e.parse(t[o], o, Ne);
      if (!a) return null;
      const l = e.parse(t[o + 1], o + 1, r);
      if (!l) return null;
      n.push([a, l]), r = r || l.type;
    }
    const s = e.parse(t[t.length - 1], t.length - 1, r);
    return s ? new uC(r, n, s) : null;
  }
  evaluate(t) {
    for (const [e, r] of this.branches) if (e.evaluate(t)) return r.evaluate(t);
    return this.otherwise.evaluate(t);
  }
  eachChild(t) {
    for (const [e, r] of this.branches) t(e), t(r);
    t(this.otherwise);
  }
  outputDefined() {
    return this.branches.every(([t, e]) => e.outputDefined()) && this.otherwise.outputDefined();
  }
  serialize() {
    const t = ["case"];
    return this.eachChild((e) => {
      t.push(e.serialize());
    }), t;
  }
};
var Yz = qz;
let Jz = class $0 {
  constructor(t, e, r, n) {
    this.type = t, this.input = e, this.beginIndex = r, this.endIndex = n;
  }
  static parse(t, e) {
    if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
    const r = e.parse(t[1], 1, He), n = e.parse(t[2], 2, qt);
    if (!r || !n) return null;
    if (!by(r.type, [Si(He), Ge, He])) return e.error(`Expected first argument to be of type array or string, but found ${En(r.type)} instead`);
    if (t.length === 4) {
      const s = e.parse(t[3], 3, qt);
      return s ? new $0(r.type, r, n, s) : null;
    }
    return new $0(r.type, r, n);
  }
  evaluate(t) {
    const e = this.input.evaluate(t), r = this.beginIndex.evaluate(t);
    if (!Au(e, ["string", "array"])) throw new Mr(`Expected first argument to be of type array or string, but found ${En(hr(e))} instead.`);
    if (this.endIndex) {
      const n = this.endIndex.evaluate(t);
      return e.slice(r, n);
    }
    return e.slice(r);
  }
  eachChild(t) {
    t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);
  }
  outputDefined() {
    return !1;
  }
  serialize() {
    if (this.endIndex != null && this.endIndex !== void 0) {
      const t = this.endIndex.serialize();
      return ["slice", this.input.serialize(), this.beginIndex.serialize(), t];
    }
    return ["slice", this.input.serialize(), this.beginIndex.serialize()];
  }
};
var Kz = Jz;
function k2(i, t) {
  return i === "==" || i === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value";
}
function cC(i, t, e, r) {
  return r.compare(t, e) === 0;
}
function Bl(i, t, e) {
  const r = i !== "==" && i !== "!=";
  return class fC {
    constructor(s, o, a) {
      this.type = Ne, this.lhs = s, this.rhs = o, this.collator = a, this.hasUntypedArgument = s.type.kind === "value" || o.type.kind === "value";
    }
    static parse(s, o) {
      if (s.length !== 3 && s.length !== 4) return o.error("Expected two or three arguments.");
      const a = s[0];
      let l = o.parse(s[1], 1, He);
      if (!l) return null;
      if (!k2(a, l.type)) return o.concat(1).error(`"${a}" comparisons are not supported for type '${En(l.type)}'.`);
      let h = o.parse(s[2], 2, He);
      if (!h) return null;
      if (!k2(a, h.type)) return o.concat(2).error(`"${a}" comparisons are not supported for type '${En(h.type)}'.`);
      if (l.type.kind !== h.type.kind && l.type.kind !== "value" && h.type.kind !== "value") return o.error(`Cannot compare types '${En(l.type)}' and '${En(h.type)}'.`);
      r && (l.type.kind === "value" && h.type.kind !== "value" ? l = new ys(h.type, [l]) : l.type.kind !== "value" && h.type.kind === "value" && (h = new ys(l.type, [h])));
      let u = null;
      if (s.length === 4) {
        if (l.type.kind !== "string" && h.type.kind !== "string" && l.type.kind !== "value" && h.type.kind !== "value") return o.error("Cannot use collator to compare non-string types.");
        if (u = o.parse(s[3], 3, Kd), !u) return null;
      }
      return new fC(l, h, u);
    }
    evaluate(s) {
      const o = this.lhs.evaluate(s), a = this.rhs.evaluate(s);
      if (r && this.hasUntypedArgument) {
        const l = hr(o), h = hr(a);
        if (l.kind !== h.kind || l.kind !== "string" && l.kind !== "number") throw new Mr(`Expected arguments for "${i}" to be (string, string) or (number, number), but found (${l.kind}, ${h.kind}) instead.`);
      }
      if (this.collator && !r && this.hasUntypedArgument) {
        const l = hr(o), h = hr(a);
        if (l.kind !== "string" || h.kind !== "string") return t(s, o, a);
      }
      return this.collator ? e(s, o, a, this.collator.evaluate(s)) : t(s, o, a);
    }
    eachChild(s) {
      s(this.lhs), s(this.rhs), this.collator && s(this.collator);
    }
    outputDefined() {
      return !0;
    }
    serialize() {
      const s = [i];
      return this.eachChild((o) => {
        s.push(o.serialize());
      }), s;
    }
  };
}
const Qz = Bl("==", function(i, t, e) {
  return t === e;
}, cC), tN = Bl("!=", function(i, t, e) {
  return t !== e;
}, function(i, t, e, r) {
  return !cC(0, t, e, r);
}), eN = Bl("<", function(i, t, e) {
  return t < e;
}, function(i, t, e, r) {
  return r.compare(t, e) < 0;
}), nN = Bl(">", function(i, t, e) {
  return t > e;
}, function(i, t, e, r) {
  return r.compare(t, e) > 0;
}), rN = Bl("<=", function(i, t, e) {
  return t <= e;
}, function(i, t, e, r) {
  return r.compare(t, e) <= 0;
}), iN = Bl(">=", function(i, t, e) {
  return t >= e;
}, function(i, t, e, r) {
  return r.compare(t, e) >= 0;
});
let sN = class dC {
  constructor(t, e, r, n, s, o) {
    this.type = Ge, this.number = t, this.locale = e, this.currency = r, this.unit = n, this.minFractionDigits = s, this.maxFractionDigits = o;
  }
  static parse(t, e) {
    if (t.length !== 3) return e.error("Expected two arguments.");
    const r = e.parse(t[1], 1, qt);
    if (!r) return null;
    const n = t[2];
    if (typeof n != "object" || Array.isArray(n)) return e.error("NumberFormat options argument must be an object.");
    let s = null;
    if (n.locale && (s = e.parse(n.locale, 1, Ge), !s)) return null;
    let o = null;
    if (n.currency && (o = e.parse(n.currency, 1, Ge), !o)) return null;
    let a = null;
    if (n.unit && (a = e.parse(n.unit, 1, Ge), !a)) return null;
    let l = null;
    if (n["min-fraction-digits"] && (l = e.parse(n["min-fraction-digits"], 1, qt), !l)) return null;
    let h = null;
    return n["max-fraction-digits"] && (h = e.parse(n["max-fraction-digits"], 1, qt), !h) ? null : new dC(r, s, o, a, l, h);
  }
  evaluate(t) {
    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {
      style: (this.currency ? "currency" : this.unit && "unit") || "decimal",
      currency: this.currency ? this.currency.evaluate(t) : void 0,
      unit: this.unit ? this.unit.evaluate(t) : void 0,
      minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,
      maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0
    }).format(this.number.evaluate(t));
  }
  eachChild(t) {
    t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.unit && t(this.unit), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);
  }
  outputDefined() {
    return !1;
  }
  serialize() {
    const t = {};
    return this.locale && (t.locale = this.locale.serialize()), this.currency && (t.currency = this.currency.serialize()), this.unit && (t.unit = this.unit.serialize()), this.minFractionDigits && (t["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t];
  }
}, oN = class pC {
  constructor(t) {
    this.type = qt, this.input = t;
  }
  static parse(t, e) {
    if (t.length !== 2) return e.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
    const r = e.parse(t[1], 1);
    return r ? r.type.kind !== "array" && r.type.kind !== "string" && r.type.kind !== "value" ? e.error(`Expected argument of type string or array, but found ${En(r.type)} instead.`) : new pC(r) : null;
  }
  evaluate(t) {
    const e = this.input.evaluate(t);
    if (typeof e == "string" || Array.isArray(e)) return e.length;
    throw new Mr(`Expected value to be of type string or array, but found ${En(hr(e))} instead.`);
  }
  eachChild(t) {
    t(this.input);
  }
  outputDefined() {
    return !1;
  }
  serialize() {
    const t = ["length"];
    return this.eachChild((e) => {
      t.push(e.serialize());
    }), t;
  }
};
const gC = {
  "==": Qz,
  "!=": tN,
  ">": nN,
  "<": eN,
  ">=": iN,
  "<=": rN,
  array: ys,
  at: Gz,
  boolean: ys,
  case: Yz,
  coalesce: iC,
  collator: jS,
  format: FS,
  image: zS,
  in: Uz,
  "index-of": Wz,
  interpolate: Ms,
  "interpolate-hcl": Ms,
  "interpolate-lab": Ms,
  length: oN,
  let: oC,
  literal: Rf,
  match: Xz,
  number: ys,
  "number-format": sN,
  object: ys,
  slice: Kz,
  step: YS,
  string: ys,
  "to-boolean": el,
  "to-color": el,
  "to-number": el,
  "to-string": el,
  var: WS,
  within: My
};
function R2(i, [t, e, r, n]) {
  t = t.evaluate(i), e = e.evaluate(i), r = r.evaluate(i);
  const s = n ? n.evaluate(i) : 1, o = RS(t, e, r, s);
  if (o) throw new Mr(o);
  return new kr(t / 255 * s, e / 255 * s, r / 255 * s, s);
}
function I2(i, t) {
  return i in t;
}
function Kg(i, t) {
  const e = t[i];
  return e === void 0 ? null : e;
}
function Co(i) {
  return {
    type: i
  };
}
Hl.register(gC, {
  error: [{
    kind: "error"
  }, [Ge], (i, [t]) => {
    throw new Mr(t.evaluate(i));
  }],
  typeof: [Ge, [He], (i, [t]) => En(hr(t.evaluate(i)))],
  "to-rgba": [Si(qt, 4), [As], (i, [t]) => t.evaluate(i).toArray()],
  rgb: [As, [qt, qt, qt], R2],
  rgba: [As, [qt, qt, qt, qt], R2],
  has: {
    type: Ne,
    overloads: [[[Ge], (i, [t]) => I2(t.evaluate(i), i.properties())], [[Ge, vl], (i, [t, e]) => I2(t.evaluate(i), e.evaluate(i))]]
  },
  get: {
    type: He,
    overloads: [[[Ge], (i, [t]) => Kg(t.evaluate(i), i.properties())], [[Ge, vl], (i, [t, e]) => Kg(t.evaluate(i), e.evaluate(i))]]
  },
  "feature-state": [He, [Ge], (i, [t]) => Kg(t.evaluate(i), i.featureState || {})],
  properties: [vl, [], (i) => i.properties()],
  "geometry-type": [Ge, [], (i) => i.geometryType()],
  id: [He, [], (i) => i.id()],
  zoom: [qt, [], (i) => i.globals.zoom],
  pitch: [qt, [], (i) => i.globals.pitch || 0],
  "distance-from-center": [qt, [], (i) => i.distanceFromCenter()],
  "heatmap-density": [qt, [], (i) => i.globals.heatmapDensity || 0],
  "line-progress": [qt, [], (i) => i.globals.lineProgress || 0],
  "sky-radial-progress": [qt, [], (i) => i.globals.skyRadialProgress || 0],
  accumulated: [He, [], (i) => i.globals.accumulated === void 0 ? null : i.globals.accumulated],
  "+": [qt, Co(qt), (i, t) => {
    let e = 0;
    for (const r of t) e += r.evaluate(i);
    return e;
  }],
  "*": [qt, Co(qt), (i, t) => {
    let e = 1;
    for (const r of t) e *= r.evaluate(i);
    return e;
  }],
  "-": {
    type: qt,
    overloads: [[[qt, qt], (i, [t, e]) => t.evaluate(i) - e.evaluate(i)], [[qt], (i, [t]) => -t.evaluate(i)]]
  },
  "/": [qt, [qt, qt], (i, [t, e]) => t.evaluate(i) / e.evaluate(i)],
  "%": [qt, [qt, qt], (i, [t, e]) => t.evaluate(i) % e.evaluate(i)],
  ln2: [qt, [], () => Math.LN2],
  pi: [qt, [], () => Math.PI],
  e: [qt, [], () => Math.E],
  "^": [qt, [qt, qt], (i, [t, e]) => Math.pow(t.evaluate(i), e.evaluate(i))],
  sqrt: [qt, [qt], (i, [t]) => Math.sqrt(t.evaluate(i))],
  log10: [qt, [qt], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN10],
  ln: [qt, [qt], (i, [t]) => Math.log(t.evaluate(i))],
  log2: [qt, [qt], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN2],
  sin: [qt, [qt], (i, [t]) => Math.sin(t.evaluate(i))],
  cos: [qt, [qt], (i, [t]) => Math.cos(t.evaluate(i))],
  tan: [qt, [qt], (i, [t]) => Math.tan(t.evaluate(i))],
  asin: [qt, [qt], (i, [t]) => Math.asin(t.evaluate(i))],
  acos: [qt, [qt], (i, [t]) => Math.acos(t.evaluate(i))],
  atan: [qt, [qt], (i, [t]) => Math.atan(t.evaluate(i))],
  min: [qt, Co(qt), (i, t) => Math.min(...t.map((e) => e.evaluate(i)))],
  max: [qt, Co(qt), (i, t) => Math.max(...t.map((e) => e.evaluate(i)))],
  abs: [qt, [qt], (i, [t]) => Math.abs(t.evaluate(i))],
  round: [qt, [qt], (i, [t]) => {
    const e = t.evaluate(i);
    return e < 0 ? -Math.round(-e) : Math.round(e);
  }],
  floor: [qt, [qt], (i, [t]) => Math.floor(t.evaluate(i))],
  ceil: [qt, [qt], (i, [t]) => Math.ceil(t.evaluate(i))],
  "filter-==": [Ne, [Ge, He], (i, [t, e]) => i.properties()[t.value] === e.value],
  "filter-id-==": [Ne, [He], (i, [t]) => i.id() === t.value],
  "filter-type-==": [Ne, [Ge], (i, [t]) => i.geometryType() === t.value],
  "filter-<": [Ne, [Ge, He], (i, [t, e]) => {
    const r = i.properties()[t.value], n = e.value;
    return typeof r == typeof n && r < n;
  }],
  "filter-id-<": [Ne, [He], (i, [t]) => {
    const e = i.id(), r = t.value;
    return typeof e == typeof r && e < r;
  }],
  "filter->": [Ne, [Ge, He], (i, [t, e]) => {
    const r = i.properties()[t.value], n = e.value;
    return typeof r == typeof n && r > n;
  }],
  "filter-id->": [Ne, [He], (i, [t]) => {
    const e = i.id(), r = t.value;
    return typeof e == typeof r && e > r;
  }],
  "filter-<=": [Ne, [Ge, He], (i, [t, e]) => {
    const r = i.properties()[t.value], n = e.value;
    return typeof r == typeof n && r <= n;
  }],
  "filter-id-<=": [Ne, [He], (i, [t]) => {
    const e = i.id(), r = t.value;
    return typeof e == typeof r && e <= r;
  }],
  "filter->=": [Ne, [Ge, He], (i, [t, e]) => {
    const r = i.properties()[t.value], n = e.value;
    return typeof r == typeof n && r >= n;
  }],
  "filter-id->=": [Ne, [He], (i, [t]) => {
    const e = i.id(), r = t.value;
    return typeof e == typeof r && e >= r;
  }],
  "filter-has": [Ne, [He], (i, [t]) => t.value in i.properties()],
  "filter-has-id": [Ne, [], (i) => i.id() !== null && i.id() !== void 0],
  "filter-type-in": [Ne, [Si(Ge)], (i, [t]) => t.value.indexOf(i.geometryType()) >= 0],
  "filter-id-in": [Ne, [Si(He)], (i, [t]) => t.value.indexOf(i.id()) >= 0],
  "filter-in-small": [Ne, [Ge, Si(He)], (i, [t, e]) => e.value.indexOf(i.properties()[t.value]) >= 0],
  "filter-in-large": [Ne, [Ge, Si(He)], (i, [t, e]) => function(r, n, s, o) {
    for (; s <= o; ) {
      const a = s + o >> 1;
      if (n[a] === r) return !0;
      n[a] > r ? o = a - 1 : s = a + 1;
    }
    return !1;
  }(i.properties()[t.value], e.value, 0, e.value.length - 1)],
  all: {
    type: Ne,
    overloads: [[[Ne, Ne], (i, [t, e]) => t.evaluate(i) && e.evaluate(i)], [Co(Ne), (i, t) => {
      for (const e of t) if (!e.evaluate(i)) return !1;
      return !0;
    }]]
  },
  any: {
    type: Ne,
    overloads: [[[Ne, Ne], (i, [t, e]) => t.evaluate(i) || e.evaluate(i)], [Co(Ne), (i, t) => {
      for (const e of t) if (e.evaluate(i)) return !0;
      return !1;
    }]]
  },
  "!": [Ne, [Ne], (i, [t]) => !t.evaluate(i)],
  "is-supported-script": [Ne, [Ge], (i, [t]) => {
    const e = i.globals && i.globals.isSupportedScript;
    return !e || e(t.evaluate(i));
  }],
  upcase: [Ge, [Ge], (i, [t]) => t.evaluate(i).toUpperCase()],
  downcase: [Ge, [Ge], (i, [t]) => t.evaluate(i).toLowerCase()],
  concat: [Ge, Co(He), (i, t) => t.map((e) => Zh(e.evaluate(i))).join("")],
  "resolved-locale": [Ge, [Kd], (i, [t]) => t.evaluate(i).resolvedLocale()]
});
var mC = gC;
function W0(i) {
  return {
    result: "success",
    value: i
  };
}
function Ua(i) {
  return {
    result: "error",
    value: i
  };
}
function vC(i) {
  return !!i.expression && i.expression.interpolated;
}
function Py(i) {
  return i instanceof Number ? "number" : i instanceof String ? "string" : i instanceof Boolean ? "boolean" : Array.isArray(i) ? "array" : i === null ? "null" : typeof i;
}
function yC(i) {
  return typeof i == "object" && i !== null && !Array.isArray(i);
}
function aN(i) {
  return i;
}
function Bu(i, t, e) {
  return i !== void 0 ? i : t !== void 0 ? t : e !== void 0 ? e : void 0;
}
function lN(i, t, e, r, n) {
  return Bu(typeof e === n ? r[e] : void 0, i.default, t.default);
}
function hN(i, t, e) {
  if (Py(e) !== "number") return Bu(i.default, t.default);
  const r = i.stops.length;
  if (r === 1 || e <= i.stops[0][0]) return i.stops[0][1];
  if (e >= i.stops[r - 1][0]) return i.stops[r - 1][1];
  const n = ep(i.stops.map((s) => s[0]), e);
  return i.stops[n][1];
}
function D2(i, t, e) {
  const r = i.base !== void 0 ? i.base : 1;
  if (Py(e) !== "number") return Bu(i.default, t.default);
  const n = i.stops.length;
  if (n === 1 || e <= i.stops[0][0]) return i.stops[0][1];
  if (e >= i.stops[n - 1][0]) return i.stops[n - 1][1];
  const s = ep(i.stops.map((u) => u[0]), e), o = function(u, c, f, d) {
    const p = d - f, g = u - f;
    return p === 0 ? 0 : c === 1 ? g / p : (Math.pow(c, g) - 1) / (Math.pow(c, p) - 1);
  }(e, r, i.stops[s][0], i.stops[s + 1][0]), a = i.stops[s][1], l = i.stops[s + 1][1];
  let h = KS[t.type] || aN;
  if (i.colorSpace && i.colorSpace !== "rgb") {
    const u = nC[i.colorSpace];
    h = (c, f) => u.reverse(u.interpolate(u.forward(c), u.forward(f), o));
  }
  return typeof a.evaluate == "function" ? {
    evaluate(...u) {
      const c = a.evaluate.apply(void 0, u), f = l.evaluate.apply(void 0, u);
      if (c !== void 0 && f !== void 0) return h(c, f, o);
    }
  } : h(a, l, o);
}
function uN(i, t, e) {
  return t.type === "color" ? e = kr.parse(e) : t.type === "formatted" ? e = ta.fromString(e.toString()) : t.type === "resolvedImage" ? e = ea.fromString(e.toString()) : Py(e) === t.type || t.type === "enum" && t.values[e] || (e = void 0), Bu(e, i.default, t.default);
}
let _C = class {
  constructor(t, e) {
    this.expression = t, this._warningHistory = {}, this._evaluator = new BS(), this._defaultValue = e ? function(r) {
      return r.type === "color" && (yC(r.default) || Array.isArray(r.default)) ? new kr(0, 0, 0, 0) : r.type === "color" ? kr.parse(r.default) || null : r.default === void 0 ? null : r.default;
    }(e) : null, this._enumValues = e && e.type === "enum" ? e.values : null;
  }
  evaluateWithoutErrorHandling(t, e, r, n, s, o, a, l) {
    return this._evaluator.globals = t, this._evaluator.feature = e, this._evaluator.featureState = r, this._evaluator.canonical = n || null, this._evaluator.availableImages = s || null, this._evaluator.formattedSection = o, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = l || null, this.expression.evaluate(this._evaluator);
  }
  evaluate(t, e, r, n, s, o, a, l) {
    this._evaluator.globals = t, this._evaluator.feature = e || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n || null, this._evaluator.availableImages = s || null, this._evaluator.formattedSection = o || null, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = l || null;
    try {
      const h = this.expression.evaluate(this._evaluator);
      if (h == null || typeof h == "number" && h != h) return this._defaultValue;
      if (this._enumValues && !(h in this._enumValues)) throw new Mr(`Expected value to be one of ${Object.keys(this._enumValues).map((u) => JSON.stringify(u)).join(", ")}, but found ${JSON.stringify(h)} instead.`);
      return h;
    } catch (h) {
      return this._warningHistory[h.message] || (this._warningHistory[h.message] = !0, typeof console < "u" && console.warn(h.message)), this._defaultValue;
    }
  }
};
function F2(i) {
  return Array.isArray(i) && i.length > 0 && typeof i[0] == "string" && i[0] in mC;
}
function md(i, t) {
  const e = new XS(mC, [], t ? function(n) {
    const s = {
      color: As,
      string: Ge,
      number: qt,
      enum: Ge,
      boolean: Ne,
      formatted: Qd,
      resolvedImage: Hu
    };
    return n.type === "array" ? Si(s[n.value] || He, n.length) : s[n.type];
  }(t) : void 0), r = e.parse(i, void 0, void 0, void 0, t && t.type === "string" ? {
    typeAnnotation: "coerce"
  } : void 0);
  return r ? W0(new _C(r, t)) : Ua(e.errors);
}
let xC = class {
  constructor(t, e) {
    this.kind = t, this._styleExpression = e, this.isStateDependent = t !== "constant" && !Sy(e.expression);
  }
  evaluateWithoutErrorHandling(t, e, r, n, s, o) {
    return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, s, o);
  }
  evaluate(t, e, r, n, s, o) {
    return this._styleExpression.evaluate(t, e, r, n, s, o);
  }
}, bC = class {
  constructor(t, e, r, n) {
    this.kind = t, this.zoomStops = r, this._styleExpression = e, this.isStateDependent = t !== "camera" && !Sy(e.expression), this.interpolationType = n;
  }
  evaluateWithoutErrorHandling(t, e, r, n, s, o) {
    return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, s, o);
  }
  evaluate(t, e, r, n, s, o) {
    return this._styleExpression.evaluate(t, e, r, n, s, o);
  }
  interpolationFactor(t, e, r) {
    return this.interpolationType ? Ms.interpolationFactor(this.interpolationType, t, e, r) : 0;
  }
};
function L2(i, t) {
  if ((i = md(i, t)).result === "error") return i;
  const e = i.value.expression, r = tp(e);
  if (!r && !function(a) {
    return a["property-type"] === "data-driven";
  }(t)) return Ua([new es("", "data expressions not supported")]);
  const n = Cy(e, ["zoom", "pitch", "distance-from-center"]);
  if (!n && !function(a) {
    return !!a.expression && a.expression.parameters.indexOf("zoom") > -1;
  }(t)) return Ua([new es("", "zoom expressions not supported")]);
  const s = function a(l) {
    let h = null;
    if (l instanceof oC) h = a(l.result);
    else if (l instanceof iC) {
      for (const u of l.args) if (h = a(u), h) break;
    } else (l instanceof YS || l instanceof Ms) && l.input instanceof Hl && l.input.name === "zoom" && (h = l);
    return h instanceof es || l.eachChild((u) => {
      const c = a(u);
      c instanceof es ? h = c : !h && c ? h = new es("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : h && c && h !== c && (h = new es("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
    }), h;
  }(e);
  if (!s && !n) return Ua([new es("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
  if (s instanceof es) return Ua([s]);
  if (s instanceof Ms && !vC(t)) return Ua([new es("", '"interpolate" expressions cannot be used with this property')]);
  if (!s) return W0(new xC(r ? "constant" : "source", i.value));
  const o = s instanceof Ms ? s.interpolation : void 0;
  return W0(new bC(r ? "camera" : "composite", i.value, s.labels, o));
}
let z2 = class wC {
  constructor(t, e) {
    this._parameters = t, this._specification = e, M2(this, function r(n, s) {
      const o = s.type === "color", a = n.stops && typeof n.stops[0][0] == "object", l = a || !(a || n.property !== void 0), h = n.type || (vC(s) ? "exponential" : "interval");
      if (o && ((n = M2({}, n)).stops && (n.stops = n.stops.map((d) => [d[0], kr.parse(d[1])])), n.default = kr.parse(n.default ? n.default : s.default)), n.colorSpace && n.colorSpace !== "rgb" && !nC[n.colorSpace]) throw new Error("Unknown color space: " + n.colorSpace);
      let u, c, f;
      if (h === "exponential") u = D2;
      else if (h === "interval") u = hN;
      else if (h === "categorical") {
        u = lN, c = /* @__PURE__ */ Object.create(null);
        for (const d of n.stops) c[d[0]] = d[1];
        f = typeof n.stops[0][0];
      } else {
        if (h !== "identity") throw new Error(`Unknown function type "${h}"`);
        u = uN;
      }
      if (a) {
        const d = {}, p = [];
        for (let v = 0; v < n.stops.length; v++) {
          const _ = n.stops[v], y = _[0].zoom;
          d[y] === void 0 && (d[y] = {
            zoom: y,
            type: n.type,
            property: n.property,
            default: n.default,
            stops: []
          }, p.push(y)), d[y].stops.push([_[0].value, _[1]]);
        }
        const g = [];
        for (const v of p) g.push([d[v].zoom, r(d[v], s)]);
        const m = {
          name: "linear"
        };
        return {
          kind: "composite",
          interpolationType: m,
          interpolationFactor: Ms.interpolationFactor.bind(void 0, m),
          zoomStops: g.map((v) => v[0]),
          evaluate: ({ zoom: v }, _) => D2({
            stops: g,
            base: n.base
          }, s, v).evaluate(v, _)
        };
      }
      if (l) {
        const d = h === "exponential" ? {
          name: "exponential",
          base: n.base !== void 0 ? n.base : 1
        } : null;
        return {
          kind: "camera",
          interpolationType: d,
          interpolationFactor: Ms.interpolationFactor.bind(void 0, d),
          zoomStops: n.stops.map((p) => p[0]),
          evaluate: ({ zoom: p }) => u(n, s, p, c, f)
        };
      }
      return {
        kind: "source",
        evaluate(d, p) {
          const g = p && p.properties ? p.properties[n.property] : void 0;
          return g === void 0 ? Bu(n.default, s.default) : u(n, s, g, c, f);
        }
      };
    }(this._parameters, this._specification));
  }
  static deserialize(t) {
    return new wC(t._parameters, t._specification);
  }
  static serialize(t) {
    return {
      _parameters: t._parameters,
      _specification: t._specification
    };
  }
};
function Z0(i) {
  if (Array.isArray(i)) return i.map(Z0);
  if (i instanceof Object && !(i instanceof Number || i instanceof String || i instanceof Boolean)) {
    const t = {};
    for (const e in i) t[e] = Z0(i[e]);
    return t;
  }
  return function(t) {
    return t instanceof Number || t instanceof String || t instanceof Boolean ? t.valueOf() : t;
  }(i);
}
function cN(i, t = "fill") {
  if (i == null) return {
    filter: () => !0,
    needGeometry: !1,
    needFeature: !1
  };
  const e = i;
  let r = !0;
  try {
    r = function(l) {
      if (!$a(l)) return l;
      let h = Z0(l);
      return function u(c) {
        let f = !1;
        const d = [];
        if (c[0] === "case") {
          for (let p = 1; p < c.length - 1; p += 2) f = f || $a(c[p]), d.push(c[p + 1]);
          d.push(c[c.length - 1]);
        } else if (c[0] === "match") {
          f = f || $a(c[1]);
          for (let p = 2; p < c.length - 1; p += 2) d.push(c[p + 1]);
          d.push(c[c.length - 1]);
        } else if (c[0] === "step") {
          f = f || $a(c[1]);
          for (let p = 1; p < c.length - 1; p += 2) d.push(c[p + 1]);
        }
        f && (c.length = 0, c.push("any", ...d));
        for (let p = 1; p < c.length; p++) u(c[p]);
      }(h), h = function u(c) {
        if (!Array.isArray(c)) return c;
        const f = function(d) {
          if (fN.has(d[0])) {
            for (let p = 1; p < d.length; p++)
              if ($a(d[p])) return !0;
          }
          return d;
        }(c);
        return f === !0 ? f : f.map((d) => u(d));
      }(h), h;
    }(e);
  } catch {
    console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(e, null, 2)}
        `);
  }
  const n = md(r, null);
  let s = null;
  if (n.result === "error") throw new Error(n.value.map((l) => `${l.key}: ${l.message}`).join(", "));
  s = (l, h, u) => n.value.evaluate(l, h, {}, u);
  let o = null, a = null;
  if (r !== e) {
    const l = md(e, null);
    if (l.result === "error") throw new Error(l.value.map((h) => `${h.key}: ${h.message}`).join(", "));
    o = (h, u, c, f, d) => l.value.evaluate(h, u, {}, c, void 0, void 0, f, d), a = !tp(l.value.expression);
  }
  return s = s, {
    filter: s,
    dynamicFilter: o || void 0,
    needGeometry: function l(h) {
      if (!Array.isArray(h)) return !1;
      if (h[0] === "within") return !0;
      for (let u = 1; u < h.length; u++) if (l(h[u])) return !0;
      return !1;
    }(r),
    needFeature: !!a
  };
}
function $a(i) {
  if (!Array.isArray(i)) return !1;
  if (/* @__PURE__ */ function(t) {
    return t === "pitch" || t === "distance-from-center";
  }(i[0])) return !0;
  for (let t = 1; t < i.length; t++)
    if ($a(i[t])) return !0;
  return !1;
}
const fN = /* @__PURE__ */ new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]), dN = {
  StyleExpression: _C,
  isExpression: F2,
  isExpressionFilter: function i(t) {
    if (t === !0 || t === !1) return !0;
    if (!Array.isArray(t) || t.length === 0) return !1;
    switch (t[0]) {
      case "has":
        return t.length >= 2 && t[1] !== "$id" && t[1] !== "$type";
      case "in":
        return t.length >= 3 && (typeof t[1] != "string" || Array.isArray(t[2]));
      case "!in":
      case "!has":
      case "none":
        return !1;
      case "==":
      case "!=":
      case ">":
      case ">=":
      case "<":
      case "<=":
        return t.length !== 3 || Array.isArray(t[1]) || Array.isArray(t[2]);
      case "any":
      case "all":
        for (const e of t.slice(1)) if (!i(e) && typeof e != "boolean") return !1;
        return !0;
      default:
        return !0;
    }
  },
  createExpression: md,
  createPropertyExpression: L2,
  normalizePropertyExpression: function(i, t) {
    if (yC(i)) return new z2(i, t);
    if (F2(i)) {
      const e = L2(i, t);
      if (e.result === "error") throw new Error(e.value.map((r) => `${r.key}: ${r.message}`).join(", "));
      return e.value;
    }
    {
      let e = i;
      return typeof i == "string" && t.type === "color" && (e = kr.parse(i)), {
        kind: "constant",
        evaluate: () => e
      };
    }
  },
  ZoomConstantExpression: xC,
  ZoomDependentExpression: bC,
  StylePropertyFunction: z2
}, { isExpression: pN, createExpression: gN } = dN, N2 = {};
function Mu(i) {
  if (i === !0) return function() {
    return !0;
  };
  if (i && i.condition) {
    if (i.type === "any") {
      const r = i.condition, n = [];
      for (let s = 0; s < r.length; s++) n.push(Mu(r[s]));
      return (s, o) => {
        for (let a = 0; a < n.length; a++) if (n[a](s, o)) return !0;
        return !1;
      };
    }
    const t = Mu(i.condition);
    if (Qe(i.layer)) return t;
    const e = (r) => r.layer === i.layer;
    return (r, n) => e(r) && t(r, n);
  }
  if (fS(i)) return cS(i);
  {
    let t = cN(i);
    return t = t && t.filter, (e, r) => (N2.zoom = r, t && t(N2, e));
  }
}
const H2 = {
  type: "number",
  "property-type": "data-driven",
  expression: {
    parameters: ["zoom", "feature"]
  }
};
function Ey(i, t) {
  H2.type = t || "number";
  const e = gN(i, H2);
  if (e.result !== "success") throw new Error(`Invalid maplibre spec expression: ${JSON.stringify(i)} (${e.value})`);
  return e.value;
}
function Oy(i) {
  return pN(i);
}
const mN = {
  lineWidth: 1,
  lineStrokeWidth: 1,
  lineDx: 1,
  lineDy: 1,
  lineOpacity: 1,
  linePatternAnimSpeed: 1,
  markerWidth: 1,
  markerHeight: 1,
  markerDx: 1,
  markerDy: 1,
  markerSpacing: 1,
  markerOpacity: 1,
  markerRotation: 1,
  textWrapWidth: 1,
  textSpacing: 1,
  textSize: 1,
  textHaloRadius: 1,
  textHaloOpacity: 1,
  textDx: 1,
  textDy: 1,
  textOpacity: 1,
  textRotation: 1,
  polygonOpacity: 1
};
function ky(i) {
  return mN[i];
}
const vN = {
  markerPlacement: 1,
  markerFile: 1,
  mergeOnProperty: 1,
  markerTextFit: 1,
  markerType: 1,
  markerHorizontalAlignment: 1,
  markerVerticalAlignment: 1,
  markerRotationAlignment: 1,
  markerPitchAlignment: 1,
  markerFillPatternFile: 1,
  markerLinePatternFile: 1,
  textName: 1,
  textPlacement: 1,
  textFaceName: 1,
  textStyle: 1,
  textHorizontalAlignment: 1,
  textVerticalAlignment: 1,
  textRotationAlignment: 1,
  textPitchAlignment: 1,
  lineJoin: 1,
  lineCap: 1,
  linePatternFile: 1,
  polygonPatternFile: 1
}, yN = {
  lineDasharray: 1,
  markerLineDasharray: 1,
  uvScale: 1,
  uvOffset: 1
};
function Ry(i) {
  return vN[i] ? "string" : ky(i) ? "number" : yN[i] ? "array" : "color";
}
var Xh = Object.freeze({
  __proto__: null,
  compileStyle: function(i = []) {
    return function t(e) {
      if (!Array.isArray(e)) return t([e]);
      const r = [];
      for (let n = 0; n < e.length; n++) {
        let s;
        s = e[n].filter === !0 ? function() {
          return !0;
        } : Mu(e[n].filter), r.push(El({}, e[n], {
          filter: s
        }));
      }
      return r;
    }(i = i.map((t) => {
      const e = El({}, t);
      return e.filter && e.filter.value && (e.filter = e.filter.value), e;
    }));
  },
  compileFilter: Mu,
  createExpression: Ey,
  isExpression: Oy,
  isInterpolated: ky,
  getExpressionType: Ry
});
const _N = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope;
let xN = class extends Array {
  pushIn(...t) {
    const e = t.length;
    for (let r = 0; r < e; r++) this[this._index++] = t[r];
  }
  fill(t, e, r) {
    super.fill(t, e, r), r > this._index && (this._index = r);
  }
  set(t, e) {
    t >= this._index && (this._index = t + 1), this[t] = e;
  }
  getLength() {
    return this._index;
  }
  setLength(t) {
    this._index = t, super.length < t && (super.length = t);
  }
  trySetLength(t) {
    t > this._index && this.setLength(t);
  }
  reset() {
    this._index = 0;
  }
};
const bN = {
  get: function(i, t) {
    return t === "length" ? i.getLength() : i[t];
  }
};
let wN = class extends Array {
  setLength(t) {
    super.length = t;
  }
  trySetLength(t) {
    super.length = t;
  }
  getLength() {
    return super.length;
  }
}, TC, Xr = class AC {
  static createTypedArray(t, e) {
    return MS(t, e);
  }
  static getInstance() {
    return TC;
  }
  static getArray() {
    const t = new xN(), e = new Proxy(t, bN);
    return e.push = (...r) => {
      t.pushIn(...r);
    }, e._origin = t, e;
  }
  constructor() {
    this._arrays = [], this._index = 0;
  }
  get() {
    if (!_N) return new wN();
    const t = this._arrays[this._index] = this._arrays[this._index] || AC.getArray();
    return t.reset(), this._index++, t;
  }
  reset() {
    this._index = 0;
  }
};
TC = new Xr();
const Gc = [], B2 = {}, lh = {}, TN = {}, AN = [], Pa = Xr.getInstance(), MN = Math.pow(2, 17);
let ao = class MC {
  static isAtlasLoaded(t, e = {}) {
    const { iconAtlas: r } = e;
    return !!(!t || r && r.positions[t]);
  }
  static genFnTypes(t) {
    const e = {};
    for (const r in t) if (Oy(t[r])) {
      const n = (r + "_Fn_0").trim(), s = (r + "Fn").trim(), o = Ry(r);
      e[n] = Ey(t[r], o), e[s] = (a, l) => {
        let h;
        B2.zoom = a, lh.properties = l;
        try {
          h = e[n].evaluateWithoutErrorHandling(B2, lh, TN, null, AN);
        } catch {
          return null;
        }
        return h;
      };
    } else if (kh(t[r])) {
      const n = (r + "_Fn_0").trim(), s = (r + "Fn").trim();
      ky(r) ? (e[n] = he(t[r]), e[s] = (o, a) => {
        const l = e[n](o, a);
        return kh(l) ? he(l)(o, a) : l;
      }) : (e[n] = ln(t[r]), e[s] = (o, a) => {
        const l = e[n](o, a);
        return kh(l) ? ln(l)(o, a) : l;
      });
    }
    return e;
  }
  constructor(t, e, r) {
    this.options = r;
    const n = [];
    this.symbolDef = e, this.symbol = vu(e, () => (n[0] = r.zoom, n)), this.styledVectors = [], this.properties = {}, this._fnTypes = r.fnTypes || MC.genFnTypes(this.symbolDef), kh(this.symbolDef.visible) && (this._visibleFn = he(this.symbolDef.visible)), r.atlas && (this.iconAtlas = r.atlas.iconAtlas, this.glyphAtlas = r.atlas.glyphAtlas), this.features = this._check(t);
  }
  needAltitudeAttribute() {
    return this.options.forceAltitudeAttribute || this.maxPosZ >= MN || this.options.positionType === Float32Array;
  }
  getPositionFormat() {
    return this.needAltitudeAttribute() ? [{
      type: Int16Array,
      width: 2,
      name: "aPosition"
    }, {
      type: Float32Array,
      width: 1,
      name: "aAltitude"
    }] : [{
      type: Int16Array,
      width: 3,
      name: "aPosition"
    }];
  }
  fillPosition(t, e, r, n) {
    e < this._minX && (this._minX = e), e > this._maxX && (this._maxX = e), r < this._minY && (this._minY = r), r > this._maxY && (this._maxY = r), this.needAltitudeAttribute() ? (t.aPosition.push(e, r), t.aAltitude.push(n)) : (PS(Gc, e, r, n), t.aPosition.push(Gc[0], Gc[1], Gc[2]));
  }
  _check(t) {
    if (!t.length) return t;
    const e = "__fea_idx".trim();
    let r, n = 0, s = t[n];
    for (; !s.geometry; ) n++, s = t[n];
    if (Array.isArray(s.geometry) && s.properties) {
      let a = s.geometry[0];
      for (; Array.isArray(a); ) a = a[0];
      a instanceof en && (r = t);
    }
    if (!r) if (r = [], Array.isArray(s.geometry)) for (let a = 0; a < t.length; a++) {
      const l = El({}, t[a]);
      r.push(SS(l));
    }
    else for (let a = 0; a < t.length; a++) {
      const l = t[a], h = az(l);
      for (let u = 0; u < h.length; u++) {
        const c = h[u];
        c[e] = l[e], r.push(c);
      }
    }
    if (this.maxPosZ = 0, !this.options.forceAltitudeAttribute) {
      const a = this.symbolDef.textPlacement === "line";
      let l = 0, h = !1;
      const { textPitchAlignmentFn: u } = this._fnTypes;
      !u && a && this.symbolDef.textPitchAlignment === "map" && (h = !0);
      for (let c = 0; c < r.length; c++) {
        const f = SC(r[c] && r[c].geometry);
        if (f > l && (l = f), a && !h && u && r[c].properties) {
          const d = u(null, r[c].properties);
          d === "map" && (h = d);
        }
      }
      this.hasMapPitchAlign = h, this.maxPosZ = l;
    }
    const o = this.options.order;
    if (o) {
      const a = [];
      for (let l = 0; l < o.length; l++) o[l] && a.push(Mu(o[l]));
      r = r.sort((l, h) => {
        const u = a.length;
        let c = -1, f = -1;
        for (let d = 0; d < u && (a[d](l) && (c = d), a[d](h) && (f = d), !(c >= 0 && c < u && f >= 0 && f < u)); d++) ;
        return c - f;
      });
    }
    return r;
  }
  load(t = 1) {
    const e = "__fea_idx".trim(), r = "_debug_info".trim(), n = this._fnTypes, s = this.styledVectors;
    this.count = 0;
    const o = this.features;
    if (!o || !o.length) return Promise.resolve(null);
    const a = {}, l = {}, h = {
      zoom: this.options.zoom,
      isVector3D: !!this.options.center
    }, u = [], c = vu(this.symbolDef, () => (u[0] = h.zoom, u));
    let f = 0, d = o.length;
    const p = this.options.debugIndex;
    try {
      for (; f < d; f++) {
        const g = o[f];
        if (!g || !g.geometry || fo(p) && g[r].index !== p) continue;
        g.properties || (g.properties = {}), g.properties.$layer = g.layer, g.properties.$type = g.type;
        const m = this.createStyledVector(g, c, n, h, a, l);
        m && m.feature.geometry && (m.featureIdx = g[e] === void 0 ? f : g[e], this.count++, s.push(m));
      }
    } catch (g) {
      return Promise.reject(g);
    }
    return this.options.atlas ? Promise.resolve(this.pack(t)) : this.loadAtlas(a, l).then(() => this.pack(t));
  }
  loadAtlas(t, e) {
    return new Promise((r, n) => {
      this.fetchAtlas(t, e, (s, o) => {
        if (s) n(s);
        else {
          if (o) {
            const { icons: a, glyphs: l } = o;
            if (a && Object.keys(a).length) {
              for (const h in a) {
                const u = a[h], { width: c, height: f, data: d } = u.data;
                u.data = new wu({
                  width: c,
                  height: f
                }, d);
              }
              this.iconAtlas = new TS(a);
            }
            if (l && Object.keys(l).length) {
              for (const h in l) {
                const u = l[h];
                for (const c in u) {
                  const f = u[c], { width: d, height: p, data: g } = f.bitmap;
                  f.bitmap = new bu({
                    width: d,
                    height: p
                  }, g);
                }
              }
              this.glyphAtlas = new hz(l);
            }
          }
          r({
            glyphAtlas: this.glyphAtlas,
            iconAtlas: this.iconAtlas
          });
        }
      });
    });
  }
  fetchAtlas(t, e, r) {
    Object.keys(t).length > 0 || Object.keys(e).length > 0 ? this.options.requestor(t, e, r) : r();
  }
  pack(t) {
    if (!this.count) return null;
    if (t == null) throw new Error("layout scale is undefined");
    const e = this.createDataPack(this.styledVectors, t);
    if (!e) return null;
    e.properties = this.properties, this.empty && (e.empty = !0);
    const r = e.buffers;
    delete e.buffers;
    const n = {
      data: e,
      buffers: r
    };
    if (this.iconAtlas) {
      const s = n.data.iconAtlas = j2(this.iconAtlas);
      if (s.glyphMap) for (const o in s.glyphMap)
        r.push(s.glyphMap[o].data.data.buffer);
      r.push(n.data.iconAtlas.image.data.buffer);
    }
    return this.glyphAtlas && (n.data.glyphAtlas = j2(this.glyphAtlas), r.push(n.data.glyphAtlas.image.data.buffer)), n;
  }
  createStyledVector(t, e, r, n) {
    return new Yd(t, e, r, n);
  }
  createDataPack(t, e) {
    if (!t || !t.length) return null;
    this.maxIndex = 0, this.maxPos = 0, this._minX = this._minY = 1 / 0, this._maxX = this._maxY = -1 / 0, this.maxAltitude = 0, this.dynamicAttrs = {};
    const r = this.data = {};
    this._arrayPool = Pa, Pa.reset();
    let n = this.elements = Pa.get();
    const s = this.getFormat(Array.isArray(t[0]) ? t[0][0].symbol : t[0].symbol), o = this.needAltitudeAttribute() ? 2 : 3;
    for (let x = 0; x < s.length; x++) r[s[x].name] = Pa.get();
    let a = Pa.get(), l = 0;
    const h = Pa.get();
    let u = 0, c = !1, f = !0;
    const d = /* @__PURE__ */ new Set();
    for (let x = 0, w = t.length; x < w; x++) {
      if (!t[x].feature.geometry) continue;
      const b = Array.isArray(t[x]) ? t[x][0].feature.id : t[x].feature.id;
      f && (lh.id !== void 0 ? d && (d.has(lh.id) ? f = !1 : d.add(lh.id)) : f = !1), fo(b) && (Math.abs(b) > u && (u = Math.abs(b)), b < 0 && (c = !0));
      const T = this.data.aPosition.length;
      if (Array.isArray(t[x])) for (let M = 0; M < t[x].length; M++) this._placeVector(t[x][M], e);
      else this._placeVector(t[x], e);
      const A = (r.aPosition.length - T) / o;
      for (let M = 0; M < A; M++) a.push(t[x].featureIdx), fo(b) && h.push(b);
      l = Math.max(l, t[x].featureIdx);
    }
    if (this.countOutOfAngle > 0 && console.warn("text anchor along line is ignored as anchor's line angle is bigger than textMaxAngle."), this.hasElements() && !n.length) return null;
    const p = this.options.center ? Float32Array : z0(l);
    a = Xr.createTypedArray(a, p), s[0].type = this.options.positionType ? this.options.positionType : L0(this.maxPos);
    const g = this.options.center;
    if (g && (g[0] || g[1])) {
      const x = r.aPosition;
      for (let w = 0; w < x.length; w += o) x[w] -= g[0], x[w + 1] -= g[1];
    }
    const m = function(x, w) {
      const b = {};
      for (let T = 0; T < x.length; T++) {
        const A = x[T], M = A.type, S = A.name;
        b[S] = M === Array ? w[S] : MS(w[S], M);
      }
      return b;
    }(s, r);
    m.aPickingId = a;
    const v = [];
    for (const x in m) v.push(m[x].buffer);
    const _ = AS(this.maxIndex);
    n = Xr.createTypedArray(n, _), v.push(n.buffer);
    const y = {
      data: m,
      isIdUnique: f,
      is2D: this.maxPosZ === 0,
      indices: this.hasElements() ? n : null,
      positionSize: o,
      positionBounding: [this._minX, this._minY, this._maxX, this._maxY],
      buffers: v,
      symbolIndex: this.symbolDef.index || {
        index: 0
      },
      dynamicAttributes: this.dynamicAttrs
    };
    if (this._packMarkerPlacement && (y.markerPlacement = this._packMarkerPlacement), this._packTextPlacement && (y.textPlacement = this._packTextPlacement), h.length) {
      const x = c ? L0(u) : z0(u);
      y.featureIds = Xr.createTypedArray(h, x), v.push(y.featureIds.buffer);
    } else y.featureIds = [];
    return y.pickingIdIndiceMap = wS(a, y.indices), y;
  }
  _placeVector(t, e) {
    this._visibleFn && !this._visibleFn(this.options.zoom, t.feature.properties) || this.placeVector(t, e, this.formatWidth);
  }
  addElements(...t) {
    this.maxIndex = Math.max(this.maxIndex, ...t), this.elements.push(...t);
  }
  hasElements() {
    return !0;
  }
  getAltitude(t) {
    const { altitudeProperty: e, defaultAltitude: r, altitudeScale: n } = this.options;
    let s = Ef(t, e, r);
    return n && (s *= n), this.maxAltitude = Math.max(this.maxAltitude, Math.abs(s)), s;
  }
  getIconAtlasMaxValue() {
    const t = this.iconAtlas.positions;
    let e = 0;
    for (const r in t) if (ml(t, r)) {
      const { tl: n, displaySize: s } = t[r], o = Math.max(n[0], n[1], s[0] - 1, s[1] - 1);
      o > e && (e = o);
    }
    return e;
  }
};
function j2(i) {
  let t = i.positions, e = i.image && i.image.format || "alpha";
  if (i instanceof TS) {
    t = {};
    for (const n in i.positions) {
      const s = i.positions[n];
      t[n] = {
        paddedRect: s.paddedRect,
        pixelRatio: s.pixelRatio,
        tl: s.tl,
        br: s.br,
        displaySize: s.displaySize
      };
    }
    e = "rgba";
  }
  const r = i.image;
  return {
    image: {
      width: r.width,
      height: r.height,
      data: r.data,
      format: e
    },
    glyphMap: i.glyphMap,
    positions: t
  };
}
function SC(i) {
  if (!i) return 0;
  let t = 0;
  if (Array.isArray(i)) for (let e = 0; e < i.length; e++) if (Array.isArray(i[e])) {
    const r = SC(i[e]);
    r > t && (t = r);
  } else {
    const r = Math.abs(i[e].z || 0);
    r > t && (t = r);
  }
  else {
    const e = Math.abs(i.z || 0);
    e > t && (t = e);
  }
  return t;
}
function G2(i, t, e, r) {
  const n = "__fn_textSize".trim();
  let s = i.textSize;
  if (Qe(t.textSize)) return [16, 16];
  i[n] && (s = i[n]);
  const o = [];
  if (o[0] = N0(s) ? s(r, e) : s, Ft(o[0])) {
    const a = o[0].__fn_key = o[0].__fn_key || JSON.stringify(o[0]);
    i.___fn_in_stops || (i.___fn_in_stops = {}), i.___fn_in_stops[a] || (i.___fn_in_stops[a] = he(o[0])), o[0] = (0, i.___fn_in_stops[a])(r, e);
  }
  return o[1] = o[0], o;
}
function Fh(i) {
  const t = i.stops;
  let e = -1 / 0;
  for (let r = 0; r < t.length; r++) {
    let n = t[r][1];
    tl(t[r][1]) && (n = Fh(t[r][1])), n > e && (e = n);
  }
  return e;
}
function CC(i, t, e) {
  return [t || "normal", e || "normal", "24px", i || "Open Sans Regular"].join(" ");
}
const PC = /\{[\w-]+(?:\|[\w-]+)*\}/g;
function X0(i, t) {
  return xy(i) ? i.replace(PC, function(e) {
    if (!t) return "";
    if ((e = e.substring(1, e.length - 1)).indexOf("|") > 0) {
      const n = e.split("|");
      for (let s = 0; s < n.length; s++) {
        const o = t[n[s]];
        if (!Qe(o)) return o;
      }
      return "";
    }
    const r = t[e];
    return Qe(r) ? "" : Array.isArray(r) ? r.join() : r;
  }) : i;
}
var SN = Object.freeze({
  __proto__: null,
  getSDFFont: CC,
  resolveText: X0,
  resolveVarNames: function(i) {
    return i.match(PC);
  },
  resolveExpVarNames: function i(t, e) {
    if (e.length !== 2 || e[0] !== "get") for (let r = 0; r < e.length; r++) e[r].length === 2 && e[r][0] === "get" ? t.push(e[r][1]) : Array.isArray(e[r]) && i(t, e[r]);
    else t.push(e[1]);
  }
});
const CN = (i) => i >= 128 && i <= 255, PN = (i) => i >= 1536 && i <= 1791, EN = (i) => i >= 1872 && i <= 1919, ON = (i) => i >= 2208 && i <= 2303, kN = (i) => i >= 4352 && i <= 4607, RN = (i) => i >= 5120 && i <= 5759, IN = (i) => i >= 6320 && i <= 6399, DN = (i) => i >= 8192 && i <= 8303, FN = (i) => i >= 8448 && i <= 8527, LN = (i) => i >= 8528 && i <= 8591, zN = (i) => i >= 8960 && i <= 9215, NN = (i) => i >= 9216 && i <= 9279, HN = (i) => i >= 9280 && i <= 9311, BN = (i) => i >= 9312 && i <= 9471, jN = (i) => i >= 9632 && i <= 9727, GN = (i) => i >= 9728 && i <= 9983, VN = (i) => i >= 11008 && i <= 11263, EC = (i) => i >= 11904 && i <= 12031, OC = (i) => i >= 12032 && i <= 12255, kC = (i) => i >= 12272 && i <= 12287, Iy = (i) => i >= 12288 && i <= 12351, RC = (i) => i >= 12352 && i <= 12447, Dy = (i) => i >= 12448 && i <= 12543, IC = (i) => i >= 12544 && i <= 12591, UN = (i) => i >= 12592 && i <= 12687, $N = (i) => i >= 12688 && i <= 12703, DC = (i) => i >= 12704 && i <= 12735, FC = (i) => i >= 12736 && i <= 12783, LC = (i) => i >= 12784 && i <= 12799, zC = (i) => i >= 12800 && i <= 13055, NC = (i) => i >= 13056 && i <= 13311, HC = (i) => i >= 13312 && i <= 19903, WN = (i) => i >= 19904 && i <= 19967, BC = (i) => i >= 19968 && i <= 40959, jC = (i) => i >= 40960 && i <= 42127, GC = (i) => i >= 42128 && i <= 42191, ZN = (i) => i >= 43360 && i <= 43391, XN = (i) => i >= 44032 && i <= 55215, qN = (i) => i >= 55216 && i <= 55295, YN = (i) => i >= 57344 && i <= 63743, VC = (i) => i >= 63744 && i <= 64255, UC = (i) => i >= 64336 && i <= 65023, $C = (i) => i >= 65040 && i <= 65055, Fy = (i) => i >= 65072 && i <= 65103, WC = (i) => i >= 65104 && i <= 65135, ZC = (i) => i >= 65136 && i <= 65279, Ly = (i) => i >= 65280 && i <= 65519;
function JN(i) {
  return !PN(i) && !EN(i) && !ON(i) && !UC(i) && !ZC(i);
}
function np(i) {
  return i === 746 || i === 747 || !(i < 4352) && (!!DC(i) || !!IC(i) || !(!Fy(i) || i >= 65097 && i <= 65103) || !!VC(i) || !!NC(i) || !!EC(i) || !!FC(i) || !(!Iy(i) || i >= 12296 && i <= 12305 || i >= 12308 && i <= 12319 || i === 12336) || !!HC(i) || !!BC(i) || !!zC(i) || !!UN(i) || !!ZN(i) || !!qN(i) || !!kN(i) || !!XN(i) || !!RC(i) || !!kC(i) || !!$N(i) || !!OC(i) || !!LC(i) || !(!Dy(i) || i === 12540) || !(!Ly(i) || i === 65288 || i === 65289 || i === 65293 || i >= 65306 && i <= 65310 || i === 65339 || i === 65341 || i === 65343 || i >= 65371 && i <= 65503 || i === 65507 || i >= 65512 && i <= 65519) || !(!WC(i) || i >= 65112 && i <= 65118 || i >= 65123 && i <= 65126) || !!RN(i) || !!IN(i) || !!$C(i) || !!WN(i) || !!jC(i) || !!GC(i));
}
function V2(i) {
  return !(np(i) || function(t) {
    return !(!CN(t) || t !== 167 && t !== 169 && t !== 174 && t !== 177 && t !== 188 && t !== 189 && t !== 190 && t !== 215 && t !== 247) || !(!DN(t) || t !== 8214 && t !== 8224 && t !== 8225 && t !== 8240 && t !== 8241 && t !== 8251 && t !== 8252 && t !== 8258 && t !== 8263 && t !== 8264 && t !== 8265 && t !== 8273) || !!FN(t) || !!LN(t) || !(!zN(t) || !(t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215)) || !(!NN(t) || t === 9251) || !!HN(t) || !!BN(t) || !!jN(t) || !(!GN(t) || t >= 9754 && t <= 9759) || !(!VN(t) || !(t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243)) || !!Iy(t) || !!Dy(t) || !!YN(t) || !!Fy(t) || !!WC(t) || !!Ly(t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533;
  }(i));
}
function U2(i) {
  return i >= 1424 && i <= 2303 || UC(i) || ZC(i);
}
const KN = [[9, 9], [32, 32], [5760, 5760], [8192, 8198], [8200, 8202], [8287, 12288], [6158, 6158], [8203, 8205]];
function QN(i) {
  for (const t of KN) if (i >= t[0] && i <= t[1]) return !0;
  return !1;
}
const Vc = {
  "!": "︕",
  "#": "＃",
  $: "＄",
  "%": "％",
  "&": "＆",
  "(": "︵",
  ")": "︶",
  "*": "＊",
  "+": "＋",
  ",": "︐",
  "-": "︲",
  ".": "・",
  "/": "／",
  ":": "︓",
  ";": "︔",
  "<": "︿",
  "=": "＝",
  ">": "﹀",
  "?": "︖",
  "@": "＠",
  "[": "﹇",
  "\\": "＼",
  "]": "﹈",
  "^": "＾",
  _: "︳",
  "`": "｀",
  "{": "︷",
  "|": "―",
  "}": "︸",
  "~": "～",
  "¢": "￠",
  "£": "￡",
  "¥": "￥",
  "¦": "￤",
  "¬": "￢",
  "¯": "￣",
  "–": "︲",
  "—": "︱",
  "‘": "﹃",
  "’": "﹄",
  "“": "﹁",
  "”": "﹂",
  "…": "︙",
  "‧": "・",
  "₩": "￦",
  "、": "︑",
  "。": "︒",
  "〈": "︿",
  "〉": "﹀",
  "《": "︽",
  "》": "︾",
  "「": "﹁",
  "」": "﹂",
  "『": "﹃",
  "』": "﹄",
  "【": "︻",
  "】": "︼",
  "〔": "︹",
  "〕": "︺",
  "〖": "︗",
  "〗": "︘",
  "！": "︕",
  "（": "︵",
  "）": "︶",
  "，": "︐",
  "－": "︲",
  "．": "・",
  "：": "︓",
  "；": "︔",
  "＜": "︿",
  "＞": "﹀",
  "？": "︖",
  "［": "﹇",
  "］": "﹈",
  "＿": "︳",
  "｛": "︷",
  "｜": "―",
  "｝": "︸",
  "｟": "︵",
  "｠": "︶",
  "｡": "︒",
  "｢": "﹁",
  "｣": "﹂"
}, XC = 1, qC = 2;
function $2(i, t, e, r, n, s, o, a, l, h) {
  let u = i.trim();
  h === qC && (u = function(p) {
    let g = "";
    const m = Array.from(p);
    for (let v = 0; v < m.length; v++) {
      const _ = m[v + 1].codePointAt(0) || null, y = m[v - 1].codePointAt(0) || null;
      g += (!_ || !V2(_) || Vc[m[v + 1]]) && (!y || !V2(y) || Vc[m[v - 1]]) && Vc[m[v]] ? Vc[m[v]] : m[v];
    }
    return g;
  }(u));
  const c = [], f = {
    positionedGlyphs: c,
    text: u,
    top: a[1],
    bottom: a[1],
    left: a[0],
    right: a[0],
    writingMode: h
  };
  let d;
  return d = function(p, g) {
    const m = [];
    let v = 0;
    for (let _ = 0; _ < g.length; _++) {
      const y = g[_];
      m.push(p.substring(v, y)), v = y;
    }
    return v < p.length && m.push(p.substring(v, p.length)), m;
  }(u, function(p, g, m, v) {
    if (!m) return [];
    if (!p) return [];
    const _ = [], y = function(b, T, A, M) {
      let S = 0;
      for (let C = 0; C < b.length; C++) {
        const k = M[b.codePointAt(C)];
        k && (S += k.metrics.advance + T);
      }
      const P = Math.max(1, Math.ceil(S / A));
      return S / P;
    }(p, g, m, v);
    let x = 0;
    for (let b = 0; b < p.length; b++) {
      const T = p.codePointAt(b), A = v[T];
      A && (A && !tH[T] && (x += A.metrics.advance + g), b < p.length - 1 && (eH[T] || !((w = T) < 11904) && (DC(w) || IC(w) || Fy(w) || VC(w) || NC(w) || EC(w) || FC(w) || Iy(w) || HC(w) || BC(w) || zC(w) || Ly(w) || RC(w) || kC(w) || OC(w) || LC(w) || Dy(w) || $C(w) || GC(w) || jC(w))) && _.push(Z2(b + 1, x, y, _, nH(T, p.codePointAt(b + 1)), !1)));
    }
    var w;
    return function b(T) {
      return T ? b(T.priorBreak).concat(T.index) : [];
    }(Z2(p.length, x, y, _, 0, !0));
  }(u, o, e, t)), function(p, g, m, v, _, y, x, w, b, T) {
    let A = 0, M = 0, S = 0;
    const P = p.positionedGlyphs, C = 0.5;
    for (let I = 0; I < m.length; I++) {
      let D = m[I];
      if (D = D.trim(), !D.length) {
        M -= v;
        continue;
      }
      const z = P.length;
      for (let H = 0; H < D.length; H++) {
        const G = D.codePointAt(H), $ = g[G];
        $ && (np(G) && x !== XC ? (G !== 32 && P.push({
          glyph: G,
          x: A,
          y: 0,
          vertical: !0
        }), A += b + w) : (G !== 32 && P.push({
          glyph: G,
          x: A,
          y: M,
          vertical: !1
        }), A += $.metrics.advance + w));
      }
      P.length !== z && (S = Math.max(A - w, S), rH(P, g, z, P.length - 1, C)), A = 0, M -= v;
    }
    const { horizontalAlign: k, verticalAlign: O } = YC(_, T);
    (function(I, D, z, H, G, $, K) {
      const dt = (D - z) * G, it = -(-H * K + 0.5) * $;
      if (!(!dt && !it))
        for (let st = 0; st < I.length; st++) I[st].x += dt, I[st].y += it;
    })(P, C, k, O, S, v, m.length);
    const R = m.length * v;
    p.top += -O * R, p.bottom = p.top + R, p.left += -k * S, p.right = p.left + S;
  }(f, t, d, r, n, s, h, o, l), !!c.length && f;
}
const tH = {
  9: !0,
  10: !0,
  11: !0,
  12: !0,
  13: !0,
  32: !0
}, eH = {
  10: !0,
  32: !0,
  38: !0,
  40: !0,
  41: !0,
  43: !0,
  45: !0,
  47: !0,
  173: !0,
  183: !0,
  8203: !0,
  8208: !0,
  8211: !0,
  8231: !0
};
function W2(i, t, e, r) {
  const n = Math.pow(i - t, 2);
  return r ? i < t ? n / 2 : 2 * n : n + Math.abs(e) * e;
}
function nH(i, t) {
  let e = 0;
  return i === 10 && (e -= 1e4), i !== 40 && i !== 65288 || (e += 50), t !== 41 && t !== 65289 || (e += 50), e;
}
function Z2(i, t, e, r, n, s) {
  let o = null, a = W2(t, e, n, s);
  for (let l = 0; l < r.length; l++) {
    const h = r[l], u = W2(t - h.x, e, n, s) + h.badness;
    u <= a && (o = h, a = u);
  }
  return {
    index: i,
    x: t,
    priorBreak: o,
    badness: a
  };
}
function YC(i, t) {
  let e = 0.5, r = 0.5;
  switch (i) {
    case "right":
    case "top-right":
    case "bottom-right":
      e = t ? 1 : 0;
      break;
    case "left":
    case "top-left":
    case "bottom-left":
      e = t ? 0 : 1;
  }
  switch (i) {
    case "bottom":
    case "bottom-right":
    case "bottom-left":
      r = t ? 1 : 0;
      break;
    case "top":
    case "top-right":
    case "top-left":
      r = t ? 0 : 1;
  }
  return {
    horizontalAlign: e,
    verticalAlign: r
  };
}
function rH(i, t, e, r, n) {
  const s = t[i[r].glyph];
  if (s) {
    const o = (i[r].x + s.metrics.advance) * n;
    if (!o) return;
    for (let a = e; a <= r; a++) i[a].x -= o;
  }
}
function JC(i) {
  if (!function(l) {
    for (const h of l) if (U2(h.charCodeAt(0))) return !0;
    return !1;
  }(i)) return i;
  const t = [], e = [], r = [];
  let n = 0, s = 0, o = 1, a = 1;
  for (const l of i) {
    const h = l.codePointAt(0);
    QN(h) ? (r.push(l), n++) : (o = U2(h) ? -1 : 1, a !== o ? (s = n, e.length && (a > 0 && e.reverse(), t.push(...e)), r.length && (t.splice(s, 0, ...r), r.length = 0), a = o, e.length = 0) : r.length && (e.push(...r), r.length = 0), e.push(l), n++);
  }
  return r.length && e.push(...r), e.length && (a > 0 && e.reverse(), t.push(...e)), t.reverse().join("");
}
const iH = /\{ *([\w_]+) *\}/g;
let KC = class {
  constructor(t, e, r, n, s) {
    this.feature = t, this.symbolDef = e, this.symbol = r, this.options = s, this._thisReplacer = this._replacer.bind(this), this._fnTypes = n;
  }
  _replacer(t, e) {
    return this.feature.properties[e] || "";
  }
  getShape(t, e) {
    if (this._shape) return this._shape;
    const { textHorizontalAlignmentFn: r, textVerticalAlignmentFn: n, markerHorizontalAlignmentFn: s, markerVerticalAlignmentFn: o, textWrapWidthFn: a } = this._fnTypes;
    let l;
    const h = this.symbol, u = this.getIconAndGlyph(), c = this.feature.properties;
    if (u && u.glyph) {
      const { font: f, text: d } = u.glyph;
      if (d === "") return null;
      const p = this.size[0] / 24, g = 24, m = h.textKeepUpright, v = h.textRotationAlignment === "map" && h.textPlacement === "line" && !h.isIconText, _ = e.glyphMap[f], y = X2(r ? r(null, c) : h.textHorizontalAlignment, n ? n(null, c) : h.textVerticalAlignment), x = 1.2 * g, w = function(M) {
        for (let S = 0; S < M.length; S++)
          if (!JN(M.charAt(S).charCodeAt(0))) return !1;
        return !0;
      }(d), b = w && h.textLetterSpacing / p || 0, T = [h.textDx / p || 0, h.textDy / p || 0], A = ((a ? a(null, c) : h.textWrapWidth) || 10 * g) / p;
      l = {}, l.horizontal = $2(d, _, A, x, y, "center", b, T, g, XC), w && v && m && (l.vertical = $2(d, _, A, x, y, "center", b, T, g, qC));
    } else if (u && u.icon) {
      if (!t.positions[u.icon.url]) return null;
      const f = X2(s ? s(null, c) : h.markerHorizontalAlignment, o ? o(null, c) : h.markerVerticalAlignment);
      l = function(d, p, g) {
        let { horizontalAlign: m, verticalAlign: v } = YC(p, g);
        g ? m = 1 - m : v = 1 - v;
        const _ = -2048 * m, y = -2048 * v;
        return {
          image: d,
          top: y,
          bottom: y + 2048,
          left: _,
          right: _ + 2048
        };
      }(t.positions[u.icon.url], f, this.options.isVector3D), this.size || (this.size = l.image.displaySize);
    }
    return this._shape = l, l;
  }
  getIconAndGlyph() {
    if (this.iconGlyph) return this.iconGlyph;
    const { markerFileFn: t, markerTypeFn: e, markerPathFn: r, markerWidthFn: n, markerHeightFn: s, markerFillFn: o, markerFillPatternFileFn: a, markerFillOpacityFn: l, markerTextFitFn: h, markerTextFitPaddingFn: u, markerLineColorFn: c, markerLineWidthFn: f, markerLineOpacityFn: d, markerLineDasharrayFn: p, markerLinePatternFileFn: g, markerPathWidthFn: m, markerPathHeightFn: v, textNameFn: _, textFaceNameFn: y, textStyleFn: x, textWeightFn: w } = this._fnTypes, { zoom: b } = this.options, T = {}, A = this.symbol, M = this.feature.properties, S = t ? t(null, M) : A.markerFile, P = e ? e(null, M) : A.markerType, C = S || P || A.markerPath, k = !Qe(this.symbolDef.textName);
    let O;
    if (C) {
      O = function(I, D, z, H, G, $) {
        if (Qe(D.markerWidth) && Qe(D.markerHeight)) return null;
        const K = "__fn_markerWidth".trim(), dt = "__fn_markerHeight".trim();
        let it = D.markerWidth || 0, st = D.markerHeight || 0;
        return tl(it) && (it.type !== "identity" ? it = Fh(it) : (it = I.markerWidth, I[K] && (it = I[K](H, z)), tl(it) && (it = it.type === "identity" ? G(H, z) : Fh(it)))), tl(st) && (st.type !== "identity" ? st = Fh(st) : (st = I.markerHeight, I[dt] && (st = I[dt](H, z)), tl(st) && (st = st.type === "identity" ? $(H, z) : Fh(st)))), [it, st];
      }(A, this.symbolDef, M, b, n, s) || [0, 0];
      let R = A.markerTextFit;
      if (h && (R = h(b, M)), R && A.text && R !== "none") {
        const I = A.text.textSize;
        let D = A.text.textName;
        Ft(D) && (D = he(D)(b, M));
        const z = X0(D, M);
        if (z) {
          const H = "__fn_textSize".trim(), G = "__fn_textSize_0".trim();
          Ft(I) && !A.text[H] && (A.text[G] = he(I), A.text[H] = (K, dt) => {
            const it = A.text[G](K, dt);
            return Ft(it) ? he(it)(K, dt) : it;
          });
          const $ = G2(A.text, A.text, M, b);
          if (R !== "width" && R !== "both" || (O[0] = $[0] * z.length), R !== "height" && R !== "both" || (O[1] = $[1]), $[0] && $[1]) {
            let K = A.markerTextFitPadding || [0, 0, 0, 0];
            u && (K = u(b, M)), O[0] += K[1] + K[3], O[1] += K[0] + K[2];
          }
        } else O[0] = O[1] = -1;
      }
    }
    if (k && (O = G2(A, this.symbolDef, M, b)), !O) return T;
    if (O[0] = Math.ceil(O[0]), O[1] = Math.ceil(O[1]), this.size = O, C && O[0] >= 0 && O[1] >= 0) {
      let R;
      if (P) {
        const I = {};
        if (I.markerType = P, P === "path" && (I.markerPath = r ? r(null, M) : A.markerPath, I.markerPathWidth = m ? m(null, M) : A.markerPathWidth, I.markerPathHeight = v ? v(null, M) : A.markerPathHeight), n) {
          const D = n(null, M);
          Qe(D) || (I.markerWidth = D);
        } else A.markerWidth >= 0 && (I.markerWidth = A.markerWidth);
        if (s) {
          const D = s(null, M);
          Qe(D) || (I.markerHeight = D);
        } else A.markerHeight >= 0 && (I.markerHeight = A.markerHeight);
        if (o) {
          const D = o(null, M);
          Qe(D) || (I.markerFill = D);
        } else A.markerFill && (I.markerFill = A.markerFill);
        if (a) {
          const D = a(null, M);
          Qe(D) || (I.markerFillPatternFile = D);
        } else A.markerFillPatternFile && (I.markerFillPatternFile = A.markerFillPatternFile);
        if (l) {
          const D = l(null, M);
          Qe(D) || (I.markerFillOpacity = D);
        } else A.markerFillOpacity >= 0 && (I.markerFillOpacity = A.markerFillOpacity);
        if (c) {
          const D = c(null, M);
          Qe(D) || (I.markerLineColor = D);
        } else A.markerLineColor && (I.markerLineColor = A.markerLineColor);
        if (f) {
          const D = f(null, M);
          Qe(D) || (I.markerLineWidth = D);
        } else A.markerLineWidth >= 0 && (I.markerLineWidth = A.markerLineWidth);
        if (d) {
          const D = d(null, M);
          Qe(D) || (I.markerLineOpacity = D);
        } else A.markerLineOpacity >= 0 && (I.markerLineOpacity = A.markerLineOpacity);
        if (p) {
          const D = p(null, M);
          Qe(D) || (I.markerLineDasharray = D);
        } else A.markerLineDasharray && (I.markerLineDasharray = A.markerLineDasharray);
        if (g) {
          const D = g(null, M);
          Qe(D) || (I.markerLinePatternFile = D);
        } else A.markerLinePatternFile && (I.markerLinePatternFile = A.markerLinePatternFile);
        R = "vector://" + JSON.stringify(I);
      } else R = S ? S.replace(iH, this._thisReplacer) : A.markerPath ? function(I, D, z) {
        if (!I.markerPath) return null;
        let H = 1;
        const G = function(pt) {
          const Ht = {
            stroke: {
              stroke: pt.markerLineColor,
              "stroke-width": pt.markerLineWidth,
              "stroke-opacity": pt.markerLineOpacity,
              "stroke-dasharray": null,
              "stroke-linecap": "butt",
              "stroke-linejoin": "round"
            },
            fill: {
              fill: pt.markerFill,
              "fill-opacity": pt.markerFillOpacity
            }
          };
          return Ht.stroke["stroke-width"] === 0 && (Ht.stroke["stroke-opacity"] = 0), Ht;
        }(I);
        fo(I.markerOpacity) && (H = I.markerOpacity), fo(I.opacity) && (H *= I.opacity);
        const $ = {};
        if (G) {
          for (const pt in G.stroke) ml(G.stroke, pt) && (Qe(G.stroke[pt]) || ($[pt] = G.stroke[pt]));
          for (const pt in G.fill) ml(G.fill, pt) && (Qe(G.fill[pt]) || ($[pt] = G.fill[pt]));
        }
        const K = Array.isArray(I.markerPath) ? I.markerPath : [I.markerPath];
        let dt;
        const it = [];
        for (let pt = 0; pt < K.length; pt++) dt = xy(K[pt]) ? {
          path: K[pt]
        } : K[pt], dt = El({}, dt, $), dt.d = dt.path, delete dt.path, it.push(dt);
        const st = ['<svg version="1.1"', 'xmlns="http://www.w3.org/2000/svg"'];
        H < 1 && st.push('opacity="' + H + '"'), I.markerPathWidth && I.markerPathHeight && st.push('viewBox="0 0 ' + I.markerPathWidth + " " + I.markerPathHeight + '"'), st.push('preserveAspectRatio="none"'), D && st.push('width="' + D + '"'), z && st.push('height="' + z + '"'), st.push("><defs></defs>");
        for (let pt = 0; pt < it.length; pt++) {
          let Ht = "<path ";
          for (const Rt in it[pt]) ml(it[pt], Rt) && (Ht += " " + Rt + '="' + it[pt][Rt] + '"');
          Ht += "></path>", st.push(Ht);
        }
        return st.push("</svg>"), "data:image/svg+xml;base64," + btoa(st.join(" "));
      }(A, O[0], O[1]) : null;
      T.icon = {
        url: R,
        size: O
      };
    }
    if (k) {
      const R = _ ? _(this.options.zoom, M) : A.textName;
      if (R || R === 0) {
        const I = CC(y ? y(null, M) : A.textFaceName, x ? x(null, M) : A.textStyle, w ? w(null, M) : A.textWeight);
        let D = X0(R, M);
        D && D.length && (D = JC(D), T.glyph = {
          font: I,
          text: D
        });
      }
    }
    return this.iconGlyph = T, T;
  }
};
function X2(i, t) {
  t && t !== "middle" || (t = "center"), i && i !== "middle" || (i = "center");
  let e = t !== "center" ? t : "";
  return e += i !== "center" ? (e.length ? "-" : "") + i : "", e;
}
/*!
 * From mapbox-gl-js
 * MIT License
 * https://github.com/mapbox/mapbox-gl-js
 */
function QC(i, t, e, r, n) {
  const s = [];
  let o;
  for (let a = 0; a < i.length; a++) {
    const l = i[a];
    let h, u = !1;
    for (let c = 0; c < l.length - 1; c++) {
      let f = l[c], d = l[c + 1];
      f.x < t && d.x < t || (f.x < t ? (o = f, f = new en(t, f.y + (t - f.x) / (d.x - f.x) * (d.y - f.y))._round(), f.z = o.z + (t - o.x) / (d.x - o.x) * (d.z - o.z), u = !0) : d.x < t && (o = d, d = new en(t, f.y + (t - f.x) / (d.x - f.x) * (d.y - f.y))._round(), d.z = f.z + (t - f.x) / (o.x - f.x) * (o.z - f.z), u = !0), f.y < e && d.y < e || (f.y < e ? (o = f, f = new en(f.x + (e - f.y) / (d.y - f.y) * (d.x - f.x), e)._round(), f.z = o.z + (e - o.y) / (d.y - o.y) * (d.z - o.z), u = !0) : d.y < e && (o = d, d = new en(f.x + (e - f.y) / (d.y - f.y) * (d.x - f.x), e)._round(), d.z = f.z + (e - f.y) / (o.y - f.y) * (o.z - f.z), u = !0), f.x >= r && d.x >= r || (f.x >= r ? (o = f, f = new en(r, f.y + (r - f.x) / (d.x - f.x) * (d.y - f.y))._round(), f.z = o.z + (r - o.x) / (d.x - o.x) * (d.z - o.z), u = !0) : d.x >= r && (o = d, d = new en(r, f.y + (r - f.x) / (d.x - f.x) * (d.y - f.y))._round(), d.z = f.z + (r - f.x) / (o.x - f.x) * (o.z - f.z), u = !0), f.y >= n && d.y >= n || (f.y >= n ? (o = f, f = new en(f.x + (n - f.y) / (d.y - f.y) * (d.x - f.x), n)._round(), f.z = o.z + (n - o.y) / (d.y - o.y) * (d.z - o.z), u = !0) : d.y >= n && (o = d, d = new en(f.x + (n - f.y) / (d.y - f.y) * (d.x - f.x), n)._round(), d.z = f.z + (n - f.y) / (o.y - f.y) * (o.z - f.z), u = !0), h && f.equals(h[h.length - 1]) || (h = [f], s.push(h)), u && (h.clipped = !0), h.push(d)))));
    }
  }
  return s;
}
let sH = class tP extends en {
  constructor(t, e, r, n) {
    super(t, e), this.angle = r, n !== void 0 && (this.segment = n);
  }
  clone() {
    return new tP(this.x, this.y, this.angle, this.segment);
  }
};
/*!
 * From mapbox-gl-js
 * MIT License
 * https://github.com/mapbox/mapbox-gl-js
 */
function oH(i, t, e, r, n) {
  if (t.segment === void 0) return !0;
  let s = t, o = t.segment + 1, a = 0;
  for (; a > -e / 2; ) {
    if (o--, o < 0) return !1;
    a -= i[o].dist(s), s = i[o];
  }
  a += i[o].dist(i[o + 1]), o++;
  const l = [];
  let h = 0;
  for (; a < e / 2; ) {
    const u = i[o], c = i[o + 1];
    if (!c) return !1;
    let f = i[o - 1].angleTo(u) - u.angleTo(c);
    for (f = Math.abs((f + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({
      distance: a,
      angleDelta: f
    }), h += f; a - l[0].distance > r; ) h -= l.shift().angleDelta;
    if (h > n) return !1;
    o++, a += u.dist(c);
  }
  return !0;
}
function aH(i, t, e, r, n, s, o, a, l, h, u) {
  const c = function(p, g, m) {
    return p ? 0.6 * g * m : 0;
  }(r, s, o), f = function(p, g) {
    return Math.max(p ? p.right - p.left : 0, 0);
  }(r), d = i[0].x === 0 || i[0].x === l || i[0].y === 0 || i[0].y === l;
  return t - f * o < t / 4 && (t = f * o + t / 4), function p(g, m, v, _, y, x, w, b, T, A, M) {
    let S = 0;
    const P = x / 2, C = function(I) {
      let D = 0;
      for (let z = 0; z < I.length - 1; z++) D += I[z].dist(I[z + 1]);
      return D;
    }(g);
    let k = 0, O = m - v, R = [];
    for (let I = 0; I < g.length - 1; I++) {
      const D = g[I], z = g[I + 1], H = D.dist(z), G = z.angleTo(D);
      for (; O + v < k + H; ) {
        O += v;
        const $ = (O - k) / H, K = Qg(D.x, z.x, $), dt = Qg(D.y, z.y, $), it = Qg(D.z || 0, z.z || 0, $);
        if (K >= 0 && K < T && dt >= 0 && dt < T && O - P >= 0 && O + P <= C) {
          const st = new sH(K, dt, G, I);
          st.z = it, A && (st.axis = [D.y - dt, K - D.x], st.angleR = it === (D.z || 0) ? 0 : Math.atan(0.9 * (it - (D.z || 0)) * M / D.dist(st))), st.line = g, st._round(), !_ || oH(g, st, x, _, y) ? R.push(st) : _ && S++;
        }
      }
      k += H;
    }
    return b || R.length || w || (R = p(g, k / 2, v, _, y, x, w, !0, T, A, M)), R.countOutOfAngle = S, R;
  }(i, d ? t / 2 * a % t : (f / 2 + 2 * s) * o * a % t, t, c, e, f * o, d, !1, l, h, u);
}
function Qg(i, t, e) {
  return i * (1 - e) + t * e;
}
function eP(i, t) {
  const e = i.length;
  if (e <= 1) return [i];
  const r = [];
  let n, s;
  for (let o = 0; o < e; o++) {
    const a = xS(i[o]);
    a !== 0 && (i[o].area = Math.abs(a), s === void 0 && (s = a < 0), s === a < 0 ? (n && r.push(n), n = [i[o]]) : n.push(i[o]));
  }
  if (n && r.push(n), t > 1) for (let o = 0; o < r.length; o++) r[o].length <= t || (n3(r[o], t, 1, r[o].length - 1, lH), r[o] = r[o].slice(0, t));
  return r;
}
function lH(i, t) {
  return t.area - i.area;
}
function hH(i, t, e) {
  const r = t.distSqr(e);
  if (r === 0) return i.distSqr(t);
  const n = ((i.x - t.x) * (e.x - t.x) + (i.y - t.y) * (e.y - t.y)) / r;
  return i.distSqr(n < 0 ? t : n > 1 ? e : e.sub(t)._mult(n)._add(t));
}
function uH(i, t = 1, e = !1) {
  let r = 1 / 0, n = 1 / 0, s = -1 / 0, o = -1 / 0;
  const a = i[0];
  for (let d = 0; d < a.length; d++) {
    const p = a[d];
    (!d || p.x < r) && (r = p.x), (!d || p.y < n) && (n = p.y), (!d || p.x > s) && (s = p.x), (!d || p.y > o) && (o = p.y);
  }
  const l = Math.min(s - r, o - n);
  let h = l / 2;
  const u = new G6([], cH);
  if (l === 0) return new en(r, n);
  for (let d = r; d < s; d += l) for (let p = n; p < o; p += l) u.push(new Ea(d + h, p + h, h, i));
  let c = function(d) {
    let p = 0, g = 0, m = 0;
    const v = d[0];
    for (let _ = 0, y = v.length, x = y - 1; _ < y; x = _++) {
      const w = v[_], b = v[x], T = w.x * b.y - b.x * w.y;
      g += (w.x + b.x) * T, m += (w.y + b.y) * T, p += 3 * T;
    }
    return new Ea(g / p, m / p, 0, d);
  }(i), f = u.length;
  for (; u.length; ) {
    const d = u.pop();
    (d.d > c.d || !c.d) && (c = d, e && console.log("found best %d after %d probes", Math.round(1e4 * d.d) / 1e4, f)), d.max - c.d <= t || (h = d.h / 2, u.push(new Ea(d.p.x - h, d.p.y - h, h, i)), u.push(new Ea(d.p.x + h, d.p.y - h, h, i)), u.push(new Ea(d.p.x - h, d.p.y + h, h, i)), u.push(new Ea(d.p.x + h, d.p.y + h, h, i)), f += 4);
  }
  return e && (console.log("num probes: " + f), console.log("best distance: " + c.d)), c.p;
}
function cH(i, t) {
  return t.max - i.max;
}
function Ea(i, t, e, r) {
  this.p = new en(i, t), this.h = e, this.d = function(n, s) {
    let o = !1, a = 1 / 0;
    for (let l = 0; l < s.length; l++) {
      const h = s[l];
      for (let u = 0, c = h.length, f = c - 1; u < c; f = u++) {
        const d = h[u], p = h[f];
        d.y > n.y != p.y > n.y && n.x < (p.x - d.x) * (n.y - d.y) / (p.y - d.y) + d.x && (o = !o), a = Math.min(a, hH(n, d, p));
      }
    }
    return (o ? 1 : -1) * Math.sqrt(a);
  }(this.p, r), this.max = this.d + this.h * Math.SQRT2;
}
function fH(i, t, e, r, n, s, o, a, l, h) {
  const { feature: u, size: c, symbol: f } = i, d = c ? 24 : 0, p = n * (c ? c[0] / d : 1);
  if (o === "line") {
    const g = [];
    g.countOutOfAngle = 0;
    let m = u.geometry;
    s && (m = QC(u.geometry, 0, 0, s, s));
    for (let v = 0; v < m.length; v++) {
      const _ = aH(m[v], a, e, f.isIconText ? null : r && r.vertical || r && r.horizontal || r, null, d, f.isIconText ? 1 : p, 1, s || 1 / 0, l, h);
      if (f.textPlacement && !f.isIconText) for (let y = 0; y < _.length; y++) _[y].startIndex = t.length / 3;
      if (g.push.apply(g, _), f.textPlacement && !f.isIconText) for (let y = 0; y < m[v].length; y++) t.push(m[v][y].x, m[v][y].y, m[v][y].z || 0);
      g.countOutOfAngle += _.countOutOfAngle || 0;
    }
    return g;
  }
  return dH(u, o, s);
}
function dH(i, t, e, r, n) {
  const s = [];
  if (i.type === 3) {
    const o = eP(i.geometry, 0);
    for (let a = 0; a < o.length; a++) {
      const l = o[a];
      if (t === "vertex") for (let h = 0; h < l.length; h++) {
        const u = l[h];
        for (let c = 0; c < u.length; c++) Fi(u[c], e) || s.push(u[c]);
      }
      else if (t === "vertex-first") {
        const h = l[0];
        h && h[0] && !Fi(h[0], e) && s.push(h[0]);
      } else if (t === "vertex-last" || t === "vertex-firstlast") {
        const h = l[0];
        if (t === "vertex-firstlast" && h && h[0] && !Fi(h[0], e) && s.push(h[0]), h && h[h.length - 1] && !Fi(h[h.length - 1], e)) {
          const u = h.length - 1;
          s.push(h[u]);
        }
      } else {
        const h = uH(l, 16);
        Fi(h, e) || s.push(h);
      }
    }
  } else if (i.type === 2) for (let o = 0; o < i.geometry.length; o++) {
    const a = i.geometry[o];
    if (t === "vertex") for (let l = 0; l < a.length; l++) Fi(a[l], e) || s.push(a[l]);
    else if (t === "vertex-last" || t === "vertex-firstlast") {
      if (t !== "vertex-firstlast" || Fi(a[0], e) || s.push(a[0]), a && a[a.length - 1] && !Fi(a[a.length - 1], e)) {
        const l = a.length - 1;
        s.push(a[l]);
      }
    } else Fi(a[0], e) || s.push(a[0]);
  }
  else if (i.type === 1) for (let o = 0; o < i.geometry.length; o++) {
    const a = i.geometry[o];
    for (let l = 0; l < a.length; l++) {
      const h = a[l];
      Fi(h, e) || s.push(h);
    }
  }
  return s;
}
function pH(i, t) {
  const e = {}, r = {}, n = [];
  let s = 0;
  function o(u) {
    n.push(i[u]), s++;
  }
  function a(u, c, f) {
    const d = r[u];
    return delete r[u], r[c] = d, n[d].geometry[0].pop(), n[d].geometry[0] = n[d].geometry[0].concat(f[0]), d;
  }
  function l(u, c, f) {
    const d = e[c];
    return delete e[c], e[u] = d, n[d].geometry[0].shift(), n[d].geometry[0] = f[0].concat(n[d].geometry[0]), d;
  }
  function h(u, c, f) {
    const d = f ? c[0][c[0].length - 1] : c[0][0];
    return `${u}:${d.x}:${d.y}`;
  }
  for (let u = 0; u < i.length; u++) {
    const c = i[u], f = c.geometry;
    if (!f) continue;
    const d = c.properties[t] ? c.properties[t].toString() : null;
    if (!d) {
      o(u);
      continue;
    }
    const p = h(d, f), g = h(d, f, !0);
    if (p in r && g in e && r[p] !== e[g]) {
      const m = l(p, g, f), v = a(p, g, n[m].geometry);
      delete e[p], delete r[g], r[h(d, n[v].geometry, !0)] = v, n[m].geometry = null;
    } else p in r ? a(p, g, f) : g in e ? l(p, g, f) : (o(u), e[p] = s - 1, r[g] = s - 1);
  }
  return n.filter((u) => u.geometry);
}
const gH = 14;
let tm = class nP extends ao {
  static needMerge(t, e, r) {
    if (!t) return !1;
    let n = t.textPlacement === "line" || t.markerPlacement === "line";
    return n || (e.textPlacementFn && (n = e.textPlacementFn(r) === "line"), e.markerPlacementFn && (n = e.markerPlacementFn(r) === "line")), t.mergeOnProperty && n;
  }
  static mergeLineFeatures(t, e, r, n) {
    const s = "__index".trim();
    let o = e.textPlacement, a = e.markerPlacement;
    r.textPlacementFn && (o = r.textPlacementFn(n)), r.markerPlacementFn && (a = r.markerPlacementFn(n));
    const l = function(h, u, c, f, d) {
      const p = "__index".trim(), g = ao.genFnTypes(u), { mergeOnPropertyFn: m } = g;
      if (!u.mergeOnProperty || f !== "line" && c !== "line") return [];
      if (v = u.mergeOnProperty, !(Ca(v) || typeof v != "string" && (v.constructor === null || v.constructor !== String) || f !== "line" && c !== "line")) return [{
        features: h,
        property: u.mergeOnProperty
      }];
      var v;
      const _ = [], y = {}, x = [];
      for (let w = 0; w < h.length; w++) {
        h[w][p] = w;
        const b = h[w].properties = h[w].properties || {};
        b.$layer = h[w].layer, b.$type = h[w].type;
        let T = c;
        T !== "line" && (T = f);
        const A = m ? m(d, b) : u.mergeOnProperty;
        T !== "line" || Ca(A) ? x.push(h[w]) : (y[A] === void 0 && (y[A] = _.length, _.push({
          features: [],
          property: A
        })), _[y[A]].features.push(h[w]));
      }
      return x.length && _.push({
        features: x
      }), _;
    }(t, e, a, o, n);
    if (l.length) {
      const h = [];
      for (let u = 0; u < l.length; u++) h.push(l[u].property ? pH(l[u].features, l[u].property) : t);
      if (h.length === 1) return h[0];
      {
        let u = [];
        for (let c = 0; c < h.length; c++) u = u.concat(h[c]);
        return u.sort((c, f) => c[s] - f[s]), u;
      }
    }
  }
  static splitPointSymbol(t, e = 0) {
    const r = [];
    if (Array.isArray(t)) {
      const o = t;
      for (let a = 0; a < o.length; a++) o[a] && r.push(...nP.splitPointSymbol(o[a], a));
      return r;
    }
    let n = null, s = null;
    for (const o in t) o.indexOf("marker") === 0 ? (n = n || {}, n[o] = t[o]) : o.indexOf("text") === 0 && (s = s || {}, s[o] = t[o]);
    return n && (n.isIconText = !0, t.mergeOnProperty && (n.mergeOnProperty = t.mergeOnProperty), r.push(n)), s && (n && (s.textPlacement = n.markerPlacement, s.textSpacing = n.markerSpacing, s.isIconText = !0), t.mergeOnProperty && (s.mergeOnProperty = t.mergeOnProperty), r.push(s)), t.visible !== void 0 && (n && (n.visible = t.visible), s && (s.visible = t.visible)), n && (n.markerTextFit && s && (n.text = {}, n.text.textName = s.textName, n.text.textSize = s.textSize), n.index = {
      index: e,
      type: 0
    }), s && (s.index = {
      index: e,
      type: 1
    }), r;
  }
  static isAtlasLoaded(t, e) {
    const { icon: r, glyph: n } = t, { iconAtlas: s, glyphAtlas: o } = e;
    if (r && (!s || !s.positions[r.url])) return !1;
    if (n) {
      if (!o || !o.positions[n.font]) return !1;
      const a = o.positions[n.font], { text: l } = n;
      for (const h of l) if (!a[h.codePointAt(0)]) return !1;
    }
    return !0;
  }
  constructor(t, e, r) {
    super(t, e, r), this._textPlacement = e.textPlacement, this._fnTypes.textPlacementFn && (this._textPlacement = this._fnTypes.textPlacementFn(this.options.zoom));
  }
  createStyledVector(t, e, r, n, s, o) {
    const a = new KC(t, this.symbolDef, e, r, n), l = a.getIconAndGlyph();
    if (l.icon && !this.options.atlas) {
      const { url: h, size: u } = l.icon;
      s[h] || (s[h] = l.icon.size), s[h][0] < u[0] && (s[h][0] = u[0]), s[h][1] < u[1] && (s[h][1] = u[1]);
    }
    if (l.glyph && !this.options.atlas) {
      const { font: h, text: u } = l.glyph, c = o[h] = o[h] || {};
      for (const f of u) c[f.codePointAt(0)] = 1;
      this._textPlacement === "line" && (o.options = {
        isCharsCompact: !1
      });
    }
    return this.options.allowEmptyPack || l.icon || l.glyph ? a : null;
  }
  getFormat(t) {
    const e = t.textName !== void 0, r = e ? this.getPackSDFFormat(t) : this.getPackMarkerFormat();
    e ? r.push(...this._getTextFnTypeFormats()) : r.push(...this._getMarkerFnTypeFormats());
    const { markerOpacityFn: n, textOpacityFn: s, markerPitchAlignmentFn: o, textPitchAlignmentFn: a, markerRotationAlignmentFn: l, textRotationAlignmentFn: h, markerRotationFn: u, textRotationFn: c, markerAllowOverlapFn: f, textAllowOverlapFn: d, markerIgnorePlacementFn: p, textIgnorePlacementFn: g } = this._fnTypes;
    return (n || s) && r.push({
      type: Uint8Array,
      width: 1,
      name: "aColorOpacity"
    }), (o || a) && r.push({
      type: Uint8Array,
      width: 1,
      name: "aPitchAlign"
    }), (l || h) && r.push({
      type: Uint8Array,
      width: 1,
      name: "aRotationAlign"
    }), (u || c) && r.push({
      type: Uint16Array,
      width: 1,
      name: "aRotation"
    }), (f || d || p || g) && r.push({
      type: Uint8Array,
      width: 1,
      name: "aOverlap"
    }), r;
  }
  _is3DPitchText() {
    return this.hasMapPitchAlign;
  }
  _getTextFnTypeFormats() {
    const { textFillFn: t, textSizeFn: e, textHaloFillFn: r, textHaloRadiusFn: n, textHaloOpacityFn: s, textDxFn: o, textDyFn: a } = this._fnTypes, l = [];
    return t && l.push({
      type: Uint8Array,
      width: 4,
      name: "aTextFill"
    }), e && l.push({
      type: Uint8Array,
      width: 1,
      name: "aTextSize"
    }), r && l.push({
      type: Uint8Array,
      width: 4,
      name: "aTextHaloFill"
    }), n && l.push({
      type: Uint8Array,
      width: 1,
      name: "aTextHaloRadius"
    }), s && l.push({
      type: Uint8Array,
      width: 1,
      name: "aTextHaloOpacity"
    }), o && l.push({
      type: Int8Array,
      width: 1,
      name: "aTextDx"
    }), a && l.push({
      type: Int8Array,
      width: 1,
      name: "aTextDy"
    }), l;
  }
  _getMarkerFnTypeFormats() {
    const { markerWidthFn: t, markerHeightFn: e, markerDxFn: r, markerDyFn: n } = this._fnTypes, s = [];
    return t && s.push({
      type: this.options.markerWidthType || Uint8Array,
      width: 1,
      name: "aMarkerWidth"
    }), e && s.push({
      type: this.options.markerHeightType || Uint8Array,
      width: 1,
      name: "aMarkerHeight"
    }), r && s.push({
      type: Int8Array,
      width: 1,
      name: "aMarkerDx"
    }), n && s.push({
      type: Int8Array,
      width: 1,
      name: "aMarkerDy"
    }), s;
  }
  createDataPack() {
    if (!this.iconAtlas && !this.glyphAtlas) {
      if (!this.options.allowEmptyPack) return null;
      this.empty = !0;
    }
    this.countOutOfAngle = 0, this.lineVertex = [];
    const t = super.createDataPack.apply(this, arguments);
    return t ? (t.lineVertex = new Int16Array(this.lineVertex), t.buffers.push(t.lineVertex.buffer), t) : null;
  }
  placeVector(t, e) {
    const r = t.getShape(this.iconAtlas, this.glyphAtlas);
    if (!this.options.allowEmptyPack && (!r || !r.image) && (!r || !r.horizontal && !r.vertical)) return;
    const n = this._getAnchors(t, r, e);
    if (this.countOutOfAngle += n.countOutOfAngle || 0, n.length === 0) return;
    const s = this.data, o = this.needAltitudeAttribute() ? 2 : 3;
    let a = this.data.aPosition.length / o;
    const l = t.symbol, h = t.feature.properties, u = this._textPlacement === "line" && !l.isIconText, c = l.textName !== void 0, f = c && u && function($e) {
      let be = 0;
      for (let Ee = 0; Ee < $e.length; Ee++)
        if (np($e.charAt(Ee).charCodeAt(0))) be = 0;
        else if (be++, be >= 1) return !1;
      return !0;
    }(t.getIconAndGlyph().glyph.text) ? 1 : 0, { textFillFn: d, textSizeFn: p, textHaloFillFn: g, textHaloRadiusFn: m, textHaloOpacityFn: v, textDxFn: _, textDyFn: y, textPitchAlignmentFn: x, textRotationAlignmentFn: w, textRotationFn: b, textAllowOverlapFn: T, textIgnorePlacementFn: A, textOpacityFn: M, markerWidthFn: S, markerHeightFn: P, markerDxFn: C, markerDyFn: k, markerPitchAlignmentFn: O, markerRotationAlignmentFn: R, markerRotationFn: I, markerAllowOverlapFn: D, markerIgnorePlacementFn: z, markerOpacityFn: H } = this._fnTypes;
    let G, $, K, dt, it, st, pt, Ht, Rt, Tt, $t, Wt, re, ie, Kt, fe, Xt;
    if (c) {
      const $e = t.getIconAndGlyph().glyph.font;
      G = function(be, Ee, Ze) {
        const yn = be.positionedGlyphs, Cr = [];
        for (let vr = 0; vr < yn.length; vr++) {
          const an = yn[vr], Ve = Ze[an.glyph];
          if (!Ve) continue;
          const Qn = Ve.rect;
          if (!Qn) continue;
          const Kr = 4, Br = Ve.metrics.advance / 2, An = Ve.metrics.height / 2, Ri = Ee ? [an.x + Br, 0] : [0, 0], yr = Ee ? [0, an.y - An] : [an.x + Br, an.y - An], jr = Ve.metrics.left - Kr - Br + yr[0], Rr = Ve.metrics.top - Kr + yr[1], un = jr + Qn.w, Wn = Rr + Qn.h, yo = new en(jr, Rr), hs = new en(un, Rr), Gr = new en(jr, Wn), Qr = new en(un, Wn);
          if (Ee && an.vertical) {
            const qi = new en(-Br, Br), rr = -Math.PI / 2, Ir = new en(5, 0);
            yo._rotateAround(rr, qi)._add(Ir), hs._rotateAround(rr, qi)._add(Ir), Gr._rotateAround(rr, qi)._add(Ir), Qr._rotateAround(rr, qi)._add(Ir);
          }
          Cr.push({
            tl: yo,
            tr: hs,
            bl: Gr,
            br: Qr,
            tex: Qn,
            writingMode: be.writingMode,
            glyphOffset: Ri
          });
        }
        return Cr;
      }(r.horizontal, u, this.glyphAtlas.positions[$e]), d && ($ = d(null, h), Ft($) ? (this.dynamicAttrs.aTextFill = 1, $ = [0, 0, 0, 0]) : $ = zo([], $)), p && (K = p(this.options.zoom, h), Ca(K) && (K = gH)), g && (dt = g(null, h), Ft(dt) ? (this.dynamicAttrs.aTextHaloFill = 1, dt = [0, 0, 0, 0]) : dt = zo([], dt)), m && (it = m(null, h)), v && (st = 255 * v(null, h)), _ && (pt = _(null, h) || 0), y && (Ht = y(null, h) || 0), x && (re = +(x(null, h) === "map")), w && (ie = +(w(null, h) === "map")), b && (Kt = _2(b(null, h), 0, 360) * Math.PI / 180);
    } else G = r ? function($e) {
      const be = $e.image, Ee = $e.top - 1 / be.pixelRatio, Ze = $e.left - 1 / be.pixelRatio, yn = $e.bottom + 1 / be.pixelRatio, Cr = $e.right + 1 / be.pixelRatio;
      let vr, an, Ve, Qn;
      return vr = new en(Ze, Ee), an = new en(Cr, Ee), Ve = new en(Cr, yn), Qn = new en(Ze, yn), [{
        tl: vr,
        tr: an,
        bl: Qn,
        br: Ve,
        tex: {
          x: be.tl[0],
          y: be.tl[1],
          w: be.displaySize[0],
          h: be.displaySize[1]
        },
        writingMode: void 0,
        glyphOffset: [0, 0]
      }];
    }(r) : function() {
      const $e = new en(0, 0), be = new en(0, 0), Ee = new en(0, 0);
      return [{
        tl: $e,
        tr: be,
        bl: new en(0, 0),
        br: Ee,
        tex: {
          x: 0,
          y: 0,
          w: 0,
          h: 0
        },
        writingMode: void 0,
        glyphOffset: [0, 0]
      }];
    }(), S && (Rt = S(null, h)), Ca(Rt) && (Rt = G[0].tex.w), P && (Tt = P(null, h)), Ca(Tt) && (Tt = G[0].tex.h), C && ($t = C(null, h)), k && (Wt = k(null, h)), O && (re = +(O(null, h) === "map")), R && (ie = +(R(null, h) === "map")), I && (Kt = _2(I(null, h), 0, 360) * Math.PI / 180);
    Ft(K) && (this.dynamicAttrs.aTextSize = 1), Ft(it) && (this.dynamicAttrs.aTextHaloRadius = 1), Ft(st) && (this.dynamicAttrs.aTextHaloOpacity = 1), Ft(pt) && (this.dynamicAttrs.aTextDx = 1), Ft(Ht) && (this.dynamicAttrs.aTextDy = 1), Ft(Rt) && (this.dynamicAttrs.aMarkerWidth = 1), Ft(Tt) && (this.dynamicAttrs.aMarkerHeight = 1), Ft($t) && (this.dynamicAttrs.aMarkerDx = 1), Ft(Wt) && (this.dynamicAttrs.aMarkerDy = 1), Ft(re) && (this.dynamicAttrs.aPitchAlign = 1), Ft(ie) && (this.dynamicAttrs.aRotationAlign = 1), Ft(Kt) && (this.dynamicAttrs.aRotation = 1);
    const Re = D || T;
    Re && (fe = Re(null, h) || 0);
    const Oe = z || A;
    let oe;
    Oe && (Xt = Oe(null, h) || 0);
    const nr = M || H;
    nr && (oe = 255 * nr(this.options.zoom, h));
    const Ke = this.options.EXTENT, Ye = G.length, { altitudeScale: We, altitudeProperty: bn, defaultAltitude: wn } = this.options, { altitude: On } = bS(t.feature, We, bn, wn);
    for (let $e = 0; $e < n.length; $e++) {
      const be = n[$e], Ee = be.z || On || 0;
      if (Ke !== 1 / 0 && Fi(be, Ke)) continue;
      const Ze = be.x, yn = be.y, Cr = G.length;
      for (let vr = 0; vr < Cr; vr++) {
        const an = G[vr], { tl: Ve, tr: Qn, bl: Kr, br: Br, tex: An } = an;
        this._fillPos(s, Ze, yn, Ee, 10 * Ve.x, 10 * Ve.y, An.x, An.y + An.h), c && this._fillData(s, u, Ye, an.glyphOffset, be, f, be.axis, be.angleR), this._fillFnTypeData(s, $, K, dt, it, st, pt, Ht, Rt, Tt, $t, Wt, oe, re, ie, Kt, fe, Xt), this._fillPos(s, Ze, yn, Ee, 10 * Qn.x, 10 * Qn.y, An.x + An.w, An.y + An.h), c && this._fillData(s, u, Ye, an.glyphOffset, be, f, be.axis, be.angleR), this._fillFnTypeData(s, $, K, dt, it, st, pt, Ht, Rt, Tt, $t, Wt, oe, re, ie, Kt, fe, Xt), this._fillPos(s, Ze, yn, Ee, 10 * Kr.x, 10 * Kr.y, An.x, An.y), c && this._fillData(s, u, Ye, an.glyphOffset, be, f, be.axis, be.angleR), this._fillFnTypeData(s, $, K, dt, it, st, pt, Ht, Rt, Tt, $t, Wt, oe, re, ie, Kt, fe, Xt), this._fillPos(s, Ze, yn, Ee, 10 * Br.x, 10 * Br.y, An.x + An.w, An.y), c && this._fillData(s, u, Ye, an.glyphOffset, be, f, be.axis, be.angleR), this._fillFnTypeData(s, $, K, dt, it, st, pt, Ht, Rt, Tt, $t, Wt, oe, re, ie, Kt, fe, Xt), this.addElements(a, a + 1, a + 2), this.addElements(a + 1, a + 2, a + 3), a += 4;
        const Ri = Math.max(Math.abs(Ze), Math.abs(yn), Math.abs(Ee));
        Ri > this.maxPos && (this.maxPos = Ri);
      }
    }
  }
  _fillPos(t, e, r, n, s, o, a, l) {
    this.fillPosition(t, e, r, n), t.aShape.push(s, o), t.aTexCoord.push(a, l);
  }
  _fillData(t, e, r, n, s, o, a, l) {
    if (t.aCount.push(r), e) {
      t.aGlyphOffset.push(n[0], n[1]), this._is3DPitchText() && t.aPitchRotation.push(a[0], a[1], l);
      const h = s.startIndex;
      t.aSegment.push(s.segment + h, h, s.line.length), t.aVertical.push(o);
    }
  }
  _fillFnTypeData(t, e, r, n, s, o, a, l, h, u, c, f, d, p, g, m, v, _) {
    const { textFillFn: y, textSizeFn: x, textHaloFillFn: w, textHaloRadiusFn: b, textHaloOpacityFn: T, textDxFn: A, textDyFn: M, textPitchAlignmentFn: S, textRotationAlignmentFn: P, textRotationFn: C, textAllowOverlapFn: k, textIgnorePlacementFn: O, textOpacityFn: R, markerWidthFn: I, markerHeightFn: D, markerDxFn: z, markerDyFn: H, markerPitchAlignmentFn: G, markerRotationAlignmentFn: $, markerRotationFn: K, markerAllowOverlapFn: dt, markerIgnorePlacementFn: it, markerOpacityFn: st } = this._fnTypes;
    y && t.aTextFill.push(...e), x && t.aTextSize.push(r), w && t.aTextHaloFill.push(...n), b && t.aTextHaloRadius.push(s), T && t.aTextHaloOpacity.push(o), A && t.aTextDx.push(a), M && t.aTextDy.push(l), I && t.aMarkerWidth.push(h), D && t.aMarkerHeight.push(u), z && t.aMarkerDx.push(c), H && t.aMarkerDy.push(f), (st || R) && t.aColorOpacity.push(d), (S || G) && t.aPitchAlign.push(p), ($ || P) && t.aRotationAlign.push(g), (K || C) && t.aRotation.push(9362 * m);
    const pt = dt || k, Ht = it || O;
    (pt || Ht) && t.aOverlap.push((pt ? 8 : 0) + 4 * v + ((Ht ? 2 : 0) + _)), s > 0 && (this.properties.hasHalo = 1);
  }
  _getAnchors(t, e, r) {
    const { feature: n, symbol: s } = t, o = this._getPlacement(t, s), a = n.properties, { markerSpacingFn: l, textSpacingFn: h, textMaxAngleFn: u } = this._fnTypes, c = ((l ? l(null, a) : s.markerSpacing) || (h ? h(null, a) : s.textSpacing) || 250) * r;
    let f = u ? u(this.options.zoom, a) : s.textMaxAngle;
    Ca(f) && (f = 80), f *= Math.PI / 180;
    const d = this.options.EXTENT, p = this.options.altitudeToTileScale, g = this._is3DPitchText();
    return fH(t, this.lineVertex, f, e, r, d, o, c, g, p);
  }
  _getPlacement(t, e) {
    let r;
    return r = this._fnTypes.markerPlacementFn ? this._fnTypes.markerPlacementFn(this.options.zoom, t.feature.properties) : e.markerPlacement || this._textPlacement, this._packMarkerPlacement || !e.markerPlacement && !e.isIconText || (this._packMarkerPlacement = r), !this._textPlacement || e.isIconText || this._packTextPlacement || (this._packTextPlacement = r), r;
  }
  getPackSDFFormat(t) {
    if (this._textPlacement !== "line" || t.isIconText) return [...this.getPositionFormat(), {
      type: Int16Array,
      width: 2,
      name: "aShape"
    }, {
      type: Uint16Array,
      width: 2,
      name: "aTexCoord"
    }, {
      type: Uint8Array,
      width: 1,
      name: "aCount"
    }];
    {
      const e = [...this.getPositionFormat(), {
        type: Int16Array,
        width: 2,
        name: "aShape"
      }, {
        type: Uint16Array,
        width: 2,
        name: "aTexCoord"
      }, {
        type: Uint8Array,
        width: 1,
        name: "aCount"
      }, {
        type: Int16Array,
        width: 2,
        name: "aGlyphOffset"
      }, {
        type: Uint16Array,
        width: 3,
        name: "aSegment"
      }, {
        type: Uint8Array,
        width: 1,
        name: "aVertical"
      }];
      return this._is3DPitchText() && e.push({
        type: Float32Array,
        width: 3,
        name: "aPitchRotation"
      }), e;
    }
  }
  getPackMarkerFormat() {
    return [...this.getPositionFormat(), {
      type: Int16Array,
      width: 2,
      name: "aShape"
    }, {
      type: Uint16Array,
      width: 2,
      name: "aTexCoord"
    }];
  }
}, mH = class rP {
  constructor(t) {
    this.x = t.x, this.y = t.y, this.z = t.z || 0;
  }
  clone() {
    return new rP(this);
  }
  _unit() {
    return this._div(this.mag()), this;
  }
  _div(t) {
    return this.x /= t, this.y /= t, this.z /= t, this;
  }
  _perp() {
    var t = this.y;
    return this.y = this.x, this.x = -t, this;
  }
  mag() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  add(t) {
    return this.clone()._add(t);
  }
  sub(t) {
    return this.clone()._sub(t);
  }
  _add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this;
  }
  _sub(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;
  }
  equals(t) {
    return this.x === t.x && this.y === t.y && this.z === t.z;
  }
  mult(t) {
    return this.clone()._mult(t);
  }
  _mult(t) {
    return this.x *= t, this.y *= t, this.z *= t, this;
  }
  dist(t) {
    return Math.sqrt(this.distSqr(t));
  }
  distSqr(t) {
    var e = t.x - this.x, r = t.y - this.y, n = t.z - this.z;
    return e * e + r * r + n * n;
  }
  _round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  angleTo(t) {
    return Math.atan2(this.y - t.y, this.x - t.x);
  }
};
const vH = Math.cos(Math.PI / 180 * 37.5), q2 = Math.pow(2, 16) / 1, em = new en(), nm = new en(), yH = new en();
let Df = class extends ao {
  constructor(t, e, r) {
    super(t, e, r);
    let n = !1;
    const { lineDasharrayFn: s, lineDashColorFn: o } = this._fnTypes;
    this.hasGradient = this.symbol.lineGradientProperty, s && (n = function(a, l, h) {
      for (let u = 0; u < a.length; u++)
        if (h(l, a[u].properties)) return !0;
      return !1;
    }(t, this.options.zoom, s), n && (this.dasharrayFn = s)), this.hasDasharray = rm(this.symbol.lineDasharray) || n, this.hasDasharray && o && (this.dashColorFn = o);
  }
  createStyledVector(t, e, r, n, s) {
    const o = new Yd(t, e, r, n), a = o.getLineResource();
    return !this.options.atlas && a && (s[a] = [0, 0]), o;
  }
  getFormat() {
    const { lineWidthFn: t, lineStrokeWidthFn: e, lineStrokeColorFn: r, lineColorFn: n, lineOpacityFn: s, lineDxFn: o, lineDyFn: a, linePatternAnimSpeedFn: l, linePatternGapFn: h } = this._fnTypes, u = [...this.getPositionFormat()];
    if (u.push(this.iconAtlas || this.hasDasharray ? {
      type: Int8Array,
      width: 3,
      name: "aExtrude"
    } : {
      type: Int8Array,
      width: 2,
      name: "aExtrude"
    }), u.push({
      type: this.options.positionType || Uint16Array,
      width: 1,
      name: "aLinesofar"
    }), t && u.push({
      type: Uint8Array,
      width: 1,
      name: "aLineWidth"
    }), e && u.push({
      type: Uint8Array,
      width: 1,
      name: "aLineStrokeWidth"
    }), n && u.push({
      type: Uint8Array,
      width: 4,
      name: "aColor"
    }), r && u.push({
      type: Uint8Array,
      width: 4,
      name: "aStrokeColor"
    }), s && u.push({
      type: Uint8Array,
      width: 1,
      name: "aOpacity"
    }), this.dasharrayFn && u.push({
      type: Uint8Array,
      width: 4,
      name: "aDasharray"
    }), this.dashColorFn && u.push({
      type: Uint8Array,
      width: 4,
      name: "aDashColor"
    }), this.iconAtlas) {
      const c = this.getIconAtlasMaxValue();
      u.push({
        type: c > 255 ? Uint16Array : Uint8Array,
        width: 4,
        name: "aTexInfo"
      });
    }
    return (o || a) && u.push({
      type: Int8Array,
      width: 2,
      name: "aLineDxDy"
    }), (l || h) && u.push({
      type: Int8Array,
      width: 2,
      name: "aLinePattern"
    }), u;
  }
  placeVector(t) {
    const { lineJoinFn: e, lineCapFn: r, lineWidthFn: n, lineHeightFn: s, lineStrokeWidthFn: o, lineStrokeColorFn: a, lineColorFn: l, lineOpacityFn: h, lineDxFn: u, lineDyFn: c, linePatternAnimSpeedFn: f, linePatternGapFn: d } = this._fnTypes, p = this.symbol, g = t.feature, m = g.properties;
    let v = p.lineJoin || "miter", _ = p.lineCap || "butt";
    if (e && (v = e(this.options.zoom, m) || "miter"), r && (_ = r(this.options.zoom, m) || "butt"), n) {
      let b = n(this.options.zoom, m);
      Ft(b) && (this.dynamicAttrs.aLineWidth = 1, b = 4), Qe(b) && (b = 4), this.feaLineWidth = +b;
    } else this.feaLineWidth = +p.lineWidth;
    if (s) {
      let b = s(this.options.zoom, m);
      Ft(b) && (this.dynamicAttrs.aLineHeight = 1), Qe(b) && (b = this.feaLineWidth), this.feaLineHeight = +b;
    } else this.feaLineHeight = +p.lineHeight || this.feaLineWidth;
    if (o) {
      let b = o(this.options.zoom, m);
      Ft(b) && (this.dynamicAttrs.aLineStrokeWidth = 1, b = 0), Qe(b) && (b = 0), this.feaLineStrokeWidth = b;
    } else this.feaLineStrokeWidth = p.lineStrokeWidth || 0;
    if (l && (this.feaColor = l(this.options.zoom, m) || [255, 255, 255, 255], Ft(this.feaColor) ? (this.dynamicAttrs.aColor = 1, this.feaColor = [0, 0, 0, 0]) : this.feaColor = zo([], this.feaColor)), a && (this.feaStrokeColor = a(this.options.zoom, m) || [0, 0, 0, 255], Ft(this.feaStrokeColor) ? (this.dynamicAttrs.aStrokeColor = 1, this.feaStrokeColor = [0, 0, 0, 0]) : this.feaStrokeColor = zo([], this.feaStrokeColor)), h) {
      let b = h(this.options.zoom, m);
      Ft(b) && (this.dynamicAttrs.aOpacity = 1, b = 1), Qe(b) && (b = 1), this.feaOpacity = 255 * b;
    }
    if (this.dasharrayFn) {
      let b = this.dasharrayFn(this.options.zoom, m) || [0, 0, 0, 0];
      if (Ft(b) && (this.dynamicAttrs.aDasharray = 1, b = [0, 0, 0, 0]), b.length < 4) {
        const T = b;
        b.length === 1 ? b = [T[0], T[0], T[0], T[0]] : b.length === 2 ? b = [T[0], T[1], T[0], T[1]] : b.length === 3 && (b = [T[0], T[1], T[2], T[2]]);
      }
      this.feaDash = b;
    }
    if (this.dashColorFn) {
      let b = (this.dashColorFn ? this.dashColorFn(this.options.zoom, m) : this.symbol.lineDashColor) || [0, 0, 0, 0];
      Ft(b) && (this.dynamicAttrs.aDashColor = 1, b = [0, 0, 0, 0]), b = zo([], b), this.feaDashColor = b;
    }
    if (this.iconAtlas) {
      const b = t.getLineResource(), T = this.iconAtlas.glyphMap[b];
      if (this.feaTexInfo = this.feaTexInfo || [0, 0, 0, 0], T) {
        const { tl: A, displaySize: M } = this.iconAtlas.positions[b];
        this.feaTexInfo[0] = A[0] + 1, this.feaTexInfo[1] = A[1] + 1, this.feaTexInfo[2] = M[0] - 3, this.feaTexInfo[3] = M[1] - 3;
      } else this.feaTexInfo[0] = this.feaTexInfo[1] = this.feaTexInfo[2] = this.feaTexInfo[3] = 0;
    }
    if (u) {
      let b = u(this.options.zoom, m);
      Ft(b) && (this.dynamicAttrs.aLineDxDy = 1, b = 0), Qe(b) && (b = 0), this.feaLineDx = b;
    }
    if (c) {
      let b = c(this.options.zoom, m);
      Ft(b) && (this.dynamicAttrs.aLineDxDy = 1, b = 0), Qe(b) && (b = 0), this.feaLineDy = b;
    }
    if (f) {
      let b = f(this.options.zoom, m);
      Ft(b) && (this.dynamicAttrs.aLinePatternAnimSpeed = 1, b = 0), Qe(b) && (b = 0), b !== 0 && (this.properties.hasPatternAnim = 1), this.feaPatternAnimSpeed = b;
    }
    if (d) {
      let b = d(this.options.zoom, m);
      Ft(b) && (this.dynamicAttrs.aLinePatternGap = 1, b = 0), Qe(b) && (b = 0), this.feaLinePatternGap = b;
    }
    const y = this.options.EXTENT;
    let x = g.geometry;
    if (y !== 1 / 0) {
      x = [];
      const b = [];
      for (let T = 0; T < g.geometry.length; T++) {
        b[0] = g.geometry[T];
        const A = QC(b, -1, -1, y + 1, y + 1);
        if (g.type === 3 && A.length > 1) {
          const M = A[0], S = A[A.length - 1];
          hh(M[0], S[S.length - 1]) && (A[0] = S.concat(M.slice(1)), A.length = A.length - 1);
        }
        x.push(...A);
      }
    }
    const w = this.needAltitudeAttribute() ? 2 : 3;
    for (let b = 0; b < x.length; b++)
      this.offset = this.data.aPosition.length / w, this._addLine(x[b], g, v, _, 2, 1.05);
  }
  _hasPattern() {
    return this.iconAtlas && this.feaTexInfo[2] && this.feaTexInfo[3];
  }
  _addLine(t, e, r, n, s, o) {
    const a = this._hasPattern() || rm(this.feaDash) || rm(this.symbol.lineDasharray), l = this.options.isTube;
    l && (t = t.map((x) => new mH(x))), this.overscaling = 1;
    const h = this.options.EXTENT;
    if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.prevVertex = null, this.symbol.lineGradientProperty && e.properties && fo(e.properties.mapbox_clip_start) && fo(e.properties.mapbox_clip_end)) {
      this.clipStart = +e.properties.mapbox_clip_start, this.clipEnd = +e.properties.mapbox_clip_end;
      for (let x = 0; x < t.length - 1; x++) this.totalDistance += t[x].dist(t[x + 1]);
      this.updateScaledDistance();
    }
    const u = e.type === 3 && !t.clipped;
    let c = t.length;
    for (; c >= 2 && hh(t[c - 1], t[c - 2]); ) c--;
    let f = 0;
    for (; f < c - 1 && hh(t[f], t[f + 1]); ) f++;
    if (c < (u ? 3 : 2)) return;
    r === "bevel" && (s = 1.05);
    const d = this.overscaling <= 16 ? 15 * h / (512 * this.overscaling) : 0, p = {
      vertexLength: 0,
      primitiveLength: 0,
      currentNormal: null
    };
    let g, m, v, _, y;
    this.e1 = this.e2 = -1, u && (g = t[c - 2], y = t[f].sub(g)._unit()._perp());
    for (let x = f; x < c; x++) {
      if (v = x === c - 1 ? u ? t[f + 1] : void 0 : t[x + 1], v && hh(t[x], v)) continue;
      y && (_ = y), g && (m = g), g = t[x], v && g.x === v.x && g.y === v.y && (g.x += 1e-4), y = v ? v.sub(g)._unit()._perp() : _, p.dir = m ? g.sub(m)._unit() : v.sub(g)._unit(), _ = _ || y, p.currentNormal = _;
      let w = _.add(y);
      w.x === 0 && w.y === 0 || w._unit();
      const b = _.x * y.x + _.y * y.y, T = w.x * y.x + w.y * y.y, A = T !== 0 ? 1 / T : 1 / 0, M = 2 * Math.sqrt(2 - 2 * T), S = T < vH && m && v, P = _.x * y.y - _.y * y.x > 0;
      if (!l && S && x > f) {
        const O = g.dist(m);
        if (O > 2 * d) {
          const R = g.sub(g.sub(m)._mult(d / O)._round());
          R.z = g.z, this.updateDistance(m, R), this.addCurrentVertex(R, _, 0, 0, p), m = R;
        }
      }
      const C = m && v;
      p.middleVertex = C;
      let k = C ? r : u ? "butt" : n;
      if (C && k === "round" && (A < o ? k = "miter" : A <= 2 && (k = "fakeround")), k === "miter" && A > s && !l && (k = "bevel"), k === "bevel" && (A > 2 && (k = "flipbevel"), A < s && (k = "miter")), m && this.updateDistance(m, g), k === "miter") l ? (this.addCurrentVertex(g, _, 0, 0, p), p.dir = v.sub(g)._unit(), this.addCurrentVertex(g, y, 0, 0, p)) : (w._mult(A), this.addCurrentVertex(g, w, 0, 0, p), a && (p.currentNormal = y, this.addCurrentVertex(g, w, 0, 0, p)));
      else if (k === "flipbevel") {
        if (A > 100) w = y.mult(-1);
        else {
          const O = A * _.add(y).mag() / _.sub(y).mag();
          w._perp()._mult(O * (P ? -1 : 1));
        }
        this.addCurrentVertex(g, w, 0, 0, p), this.addCurrentVertex(g, w.mult(-1), 0, 0, p);
      } else if (k === "bevel" || k === "fakeround") {
        const O = -Math.sqrt(A * A - 1), R = P ? O : 0, I = P ? 0 : O;
        if (m && this.addCurrentVertex(g, _, R, I, p), k === "fakeround") {
          const D = Math.round(180 * M / Math.PI / 20);
          for (let z = 1; z < D; z++) {
            let H = z / D;
            if (H !== 0.5) {
              const $ = H - 0.5;
              H += H * $ * (H - 1) * ((1.0904 + b * (b * (3.55645 - 1.43519 * b) - 3.2452)) * $ * $ + (0.848013 + b * (0.215638 * b - 1.06021)));
            }
            const G = y.sub(_)._mult(H)._add(_)._unit()._mult(P ? -1 : 1);
            this.addHalfVertex(g, G.x, G.y, !1, P, 0, p);
          }
        }
        v && (p.currentNormal = y, this.addCurrentVertex(g, y, -R, -I, p));
      } else if (k === "butt") this.addCurrentVertex(g, w, 0, 0, p);
      else if (k === "square") {
        const O = m ? 1 : -1;
        this.addCurrentVertex(g, w, O, O, p);
      } else k === "round" && (m && (this.addCurrentVertex(g, _, 0, 0, p), this.addCurrentVertex(g, _, 1, 1, p, !0)), v && (this.addCurrentVertex(g, y, -1, -1, p, !0), this.addCurrentVertex(g, y, 0, 0, p)));
      if (!l && S && x < c - 1) {
        const O = g.dist(v);
        if (O > 2 * d) {
          const R = g.add(v.sub(g)._mult(d / O)._round());
          R.z = g.z, this.updateDistance(g, R), this.addCurrentVertex(R, y, 0, 0, p), g = R;
        }
      }
    }
  }
  addCurrentVertex(t, e, r, n, s, o = !1) {
    const a = e.x + e.y * r, l = e.y - e.x * r, h = e.y * n - e.x, u = -e.y - e.x * n;
    let c = 0, f = 0;
    if (s.middleVertex) {
      em.x = a, em.y = l, nm.x = h, nm.y = u;
      const d = s.currentNormal;
      if (c = Q2(d, em), r === 0 && n === 0) f = -c;
      else {
        const p = yH;
        p.x = d.x, p.y = d.y, p._mult(-1), f = Q2(p, nm);
      }
    }
    this.addHalfVertex(t, a, l, o, !1, r, s, c), this.addHalfVertex(t, h, u, o, !0, -n, s, f), this.prevVertex && hh(t, this.prevVertex) || (this.prevVertex = t), this.distance > q2 / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, e, r, n, s, o));
  }
  addHalfVertex({ x: t, y: e, z: r }, n, s, o, a, l, h, u) {
    this.fillData(this.data, t, e, r || 0, n, s, o, a, 1 * this.scaledDistance, u);
    const c = h.vertexLength++;
    this.e1 >= 0 && this.e2 >= 0 && (this.addElements(this.e1, this.e2, c), h.primitiveLength++), a ? this.e2 = c : this.e1 = c;
  }
  fillData(t, e, r, n, s, o, a, l, h, u) {
    const { lineWidthFn: c, lineStrokeWidthFn: f, lineStrokeColorFn: d, lineColorFn: p, lineOpacityFn: g, lineDxFn: m, lineDyFn: v, linePatternAnimSpeedFn: _, linePatternGapFn: y } = this._fnTypes;
    this.fillPosition(t, e, r, n);
    let x = 63 * s;
    x = (Math.sign(x) || 1) * ((Math.floor(Math.abs(x)) >> 1 << 1) + +a);
    let w = 63 * o;
    w = (Math.sign(w) || 1) * ((Math.floor(Math.abs(w)) >> 1 << 1) + +l), t.aExtrude.push(x, w), (this.iconAtlas || this.hasDasharray) && t.aExtrude.push(63 * u), t.aLinesofar.push(h), c && t.aLineWidth.push(Math.round(2 * this.feaLineWidth)), f && t.aLineStrokeWidth.push(Math.round(2 * this.feaLineStrokeWidth)), p && t.aColor.push(...this.feaColor), d && t.aStrokeColor.push(...this.feaStrokeColor), g && t.aOpacity.push(this.feaOpacity), this.dasharrayFn && t.aDasharray.push(...this.feaDash), this.dashColorFn && t.aDashColor.push(...this.feaDashColor), this.iconAtlas && t.aTexInfo.push(...this.feaTexInfo), (m || v) && t.aLineDxDy.push(this.feaLineDx || 0, this.feaLineDy || 0), (_ || y) && t.aLinePattern.push(127 * (this.feaPatternAnimSpeed || 0), 10 * (this.feaLinePatternGap || 0)), this.maxPos = Math.max(this.maxPos, Math.abs(e) + 1, Math.abs(r) + 1);
  }
  addElements(t, e, r) {
    super.addElements(this.offset + t, this.offset + e, this.offset + r);
  }
  _filterPolygonEdges(t) {
    const e = this.options.EXTENT, r = this.elements;
    for (let n = 0; n < r.length; n += 3) e !== 1 / 0 && (Y2(this.data.aPosition, r[n], r[n + 1], 3, e) || Y2(this.data.aPosition, r[n + 1], r[n + 2], 3, e)) || t.push(r[n], r[n + 1], r[n + 2]);
  }
  _filterLine(t) {
    if (t.length <= 1) return t;
    const e = [], r = this.options.EXTENT;
    let n, s = !0;
    for (n = 0; n < t.length - 1; n++) {
      const o = _H(t[n], t[n + 1], r);
      o && s || (e.push(t[n]), s = o);
    }
    return s || e.push(t[n]), e;
  }
  updateDistance(t, e) {
    if (this.options.isTube) {
      const r = t.dist(e), n = CS(this.options) * (e.z - t.z);
      this.distance += Math.sqrt(r * r + n * n);
    } else this.distance += t.dist(e);
    this.updateScaledDistance();
  }
  updateScaledDistance() {
    this.scaledDistance = this.totalDistance > 0 ? (this.clipStart + (this.clipEnd - this.clipStart) * this.distance / this.totalDistance) * (q2 - 1) : this.distance;
  }
};
function _H(i, t, e) {
  return e !== 1 / 0 && (i.x < 0 && t.x < 0 || i.x > e && t.x > e || i.y < 0 && t.y < 0 || i.y > e && t.y > e);
}
function Y2(i, t, e, r, n) {
  if (n === 1 / 0) return !1;
  const s = Math.floor(0.5 * i[t * r]), o = Math.floor(0.5 * i[t * r + 1]), a = Math.floor(0.5 * i[e * r]), l = Math.floor(0.5 * i[e * r + 1]);
  return s === a && (s < 0 || s > n) && o !== l || o === l && (o < 0 || o > n) && s !== a;
}
function rm(i) {
  if (!Array.isArray(i)) return !1;
  for (let t = 0; t < i.length; t++) if (i[t]) return !0;
  return !1;
}
const J2 = new en(0, 0), K2 = new en(0, 0);
function Q2(i, t) {
  const e = i.mag(), r = t.mag();
  J2.x = t.x, J2.y = t.y;
  const n = i.angleTo(K2), s = t.angleTo(K2);
  return Math.sign(s - n) * Math.sqrt(r * r - e * e);
}
function hh(i, t) {
  return i.equals(t) && i.z === t.z;
}
/*!
 * from @turf/bboxClip
 * https://github.com/Turfjs/turf
 * MIT LICENSE
 */
const yl = [], im = [];
function iP(i, t) {
  var e, r, n, s, o, a, l;
  for (r = 1; r <= 8; r *= 2) {
    for (e = [], s = !(tb(n = i[i.length - 1], t) & r), o = 0; o < i.length; o++) {
      if ((l = !(tb(a = i[o], t) & r)) !== s) {
        const h = xH(n, a, r, t);
        e.push(a.x !== void 0 ? new en(h[0], h[1]) : h);
      }
      l && e.push(a), n = a, s = l;
    }
    if (!(i = e).length) break;
  }
  return e;
}
function xH(i, t, e, r) {
  return yl[0] = i.x === void 0 ? i[0] : i.x, yl[1] = i.y === void 0 ? i[1] : i.y, i = yl, im[0] = t.x === void 0 ? t[0] : t.x, im[1] = t.y === void 0 ? t[1] : t.y, t = im, 8 & e ? [i[0] + (t[0] - i[0]) * (r[3] - i[1]) / (t[1] - i[1]), r[3]] : 4 & e ? [i[0] + (t[0] - i[0]) * (r[1] - i[1]) / (t[1] - i[1]), r[1]] : 2 & e ? [r[2], i[1] + (t[1] - i[1]) * (r[2] - i[0]) / (t[0] - i[0])] : 1 & e ? [r[0], i[1] + (t[1] - i[1]) * (r[0] - i[0]) / (t[0] - i[0])] : null;
}
function tb(i, t) {
  yl[0] = i.x === void 0 ? i[0] : i.x, yl[1] = i.y === void 0 ? i[1] : i.y;
  var e = 0;
  return (i = yl)[0] < t[0] ? e |= 1 : i[0] > t[2] && (e |= 2), i[1] < t[1] ? e |= 4 : i[1] > t[3] && (e |= 8), e;
}
const bH = [0, 0, 0, 0], wH = -9999999;
let eb = class extends ao {
  constructor(...t) {
    super(...t), this.lineElements = [];
  }
  createStyledVector(t, e, r, n, s) {
    const o = new Yd(t, e, r, n), a = o.getPolygonResource();
    return !this.options.atlas && a && (s[a] = [0, 0]), o;
  }
  getFormat() {
    const t = [...this.getPositionFormat()], { polygonFillFn: e, polygonOpacityFn: r, uvScaleFn: n, uvOffsetFn: s, polygonPatternUVFn: o } = this._fnTypes;
    if (this.iconAtlas) {
      const a = this.getIconAtlasMaxValue();
      t.push({
        type: a > 255 ? Uint16Array : Uint8Array,
        width: 4,
        name: "aTexInfo"
      });
    }
    return e && t.push({
      type: Uint8Array,
      width: 4,
      name: "aColor"
    }), r && t.push({
      type: Uint8Array,
      width: 1,
      name: "aOpacity"
    }), n && t.push({
      type: Uint16Array,
      width: 2,
      name: "aUVScale"
    }), s && t.push({
      type: Uint8Array,
      width: 2,
      name: "aUVOffset"
    }), o && t.push({
      type: Float32Array,
      width: 2,
      name: "aTexCoord"
    }), t;
  }
  placeVector(t, e) {
    const r = t.feature;
    this._addPolygon(r.geometry, r, e);
  }
  _addPolygon(t, e) {
    let r, n, s, o;
    const { polygonFillFn: a, polygonOpacityFn: l, uvScaleFn: h, uvOffsetFn: u, uvOffsetInMeterFn: c, polygonPatternUVFn: f } = this._fnTypes, d = e.properties;
    a && (r = a(this.options.zoom, d) || Sr([], 255, 255, 255, 255), Ft(r) ? (this.dynamicAttrs.aColor = 1, r = bH) : r = zo([], r)), l && (n = l(this.options.zoom, d), Ft(n) ? (this.dynamicAttrs.aOpacity = 1, n = 255) : (Qe(n) && (n = 1), n *= 255)), h && (s = h(this.options.zoom, d), Ft(s) ? (s = [255, 255], this.dynamicAttrs.aUVScale = 1) : (Qe(s) && (s = [1, 1]), s = [255 * s[0], 255 * s[1]])), u && (c && c(null, d) ? o = [0, 0] : (o = u(this.options.zoom, d), Ft(o) ? (o = [0, 0], this.dynamicAttrs.aUVOffset = 1) : (Qe(o) && (o = [0, 0]), o = [255 * o[0], 255 * o[1]])));
    const p = !!this.iconAtlas, g = eP(t, 500), m = [0, 0], v = [0, 0];
    if (p) {
      const { polygonPatternFileFn: A } = this._fnTypes, M = A ? A(null, d) : this.symbol.polygonPatternFile;
      if (this.iconAtlas.glyphMap[M]) {
        const S = this.iconAtlas.positions[M], P = !pd(S.displaySize[0]) || !pd(S.displaySize[1]);
        m[0] = S.tl[0] + (P ? 1 : 0), m[1] = S.tl[1] + (P ? 1 : 0), v[0] = S.displaySize[0] - 1 - (P ? 2 : 0), v[1] = S.displaySize[1] - 1 - (P ? 2 : 0);
      }
    }
    let _, y = 0;
    f && (_ = f(this.options.zoom, d));
    const x = this.needAltitudeAttribute() ? 2 : 3, w = [-1, -1, e.extent + 1, e.extent + 1], b = this._flattened = this._flattened || this._arrayPool.get(), T = this._holeIndices = this._holeIndices || this._arrayPool.get();
    for (let A = 0; A < g.length; A++) {
      const M = g[A], S = this.data.aPosition.length / x;
      b.setLength(0), T.setLength(0);
      for (let C = 0; C < M.length; C++) {
        let k = M[C];
        if (this.options.EXTENT !== 1 / 0 && this.maxPosZ === 0 && (k = iP(k, w)), k.length !== 0) {
          C !== 0 && T.push(b.length / 3);
          for (let O = 0; O < k.length; O++) {
            const R = k[O].x, I = k[O].y, D = k[O].z || 0;
            if (this.fillPosition(this.data, R, I, D), p && this.data.aTexInfo.push(m[0], m[1], v[0], v[1]), r !== void 0 && this.data.aColor.push(r[0], r[1], r[2], r[3]), n !== void 0 && this.data.aOpacity.push(n), s !== void 0 && this.data.aUVScale.push(s[0], s[1]), o !== void 0 && this.data.aUVOffset.push(o[0], o[1]), f) {
              if (_) {
                const G = Qe(_[2 * y]) ? _[0] : _[2 * y], $ = Qe(_[2 * y] + 1) ? _[1] : _[2 * y + 1];
                this.data.aTexCoord.push(G, $);
              } else this.data.aTexCoord.push(-9999999, -9999999);
              y++;
            }
            const z = Math.abs(R), H = Math.abs(I);
            z > this.maxPos && (this.maxPos = z), H > this.maxPos && (this.maxPos = H), b.push(R, I, D);
          }
        }
      }
      let P = Pf(b, T, 3);
      if (b.length && !P.length) {
        const C = [];
        for (let k = 0; k < b.length; k += 3) C[k] = b[k], C[k + 1] = b[k + 2], C[k + 2] = b[k + 1];
        if (P = Pf(C, T, 3), !P.length) {
          for (let k = 0; k < b.length; k += 3) C[k] = b[k + 1], C[k + 1] = b[k + 2], C[k + 2] = b[k];
          P = Pf(C, T, 3);
        }
      }
      for (let C = 0; C < P.length; C += 3) this.addElements(S + P[C], S + P[C + 1], S + P[C + 2]);
    }
  }
}, sP = class {
  constructor(t) {
    this.max = t, this.reset();
  }
  reset() {
    return this.data = {}, this.order = [], this;
  }
  clear() {
    this.reset();
  }
  add(t, e) {
    return this.has(t) ? (this.order.splice(this.order.indexOf(t), 1), this.data[t] = e, this.order.push(t)) : (this.data[t] = e, this.order.push(t), this.order.length > this.max && this.getAndRemove(this.order[0])), this;
  }
  has(t) {
    return t in this.data;
  }
  keys() {
    return this.order;
  }
  getAndRemove(t) {
    if (!this.has(t)) return null;
    const e = this.data[t];
    return delete this.data[t], this.order.splice(this.order.indexOf(t), 1), e;
  }
  get(t) {
    return this.has(t) ? this.data[t] : null;
  }
  remove(t) {
    return this.has(t) ? (delete this.data[t], this.order.splice(this.order.indexOf(t), 1), this) : this;
  }
  setMaxSize(t) {
    for (this.max = t; this.order.length > this.max; ) this.getAndRemove(this.order[0]);
    return this;
  }
};
/*!
 * based on @mapbox/tiny-sdf
 * https://github.com/mapbox/tiny-sdf
 * @License BSD 2-Clause
 */
var qh = 1e20;
function oP(i, t, e, r, n, s, o) {
  this.fontSize = i || 24, this.buffer = t === void 0 ? 3 : t, this.cutoff = r || 0.25, this.fontFamily = n || "sans-serif", this.fontWeight = s || "normal", this.fontStyle = o || "normal", this.radius = e || 8;
  var a = this.size = this.fontSize + 2 * this.buffer;
  this.canvas = typeof document > "u" ? new OffscreenCanvas(a, a) : document.createElement("canvas"), this.canvas.width = this.canvas.height = a, this.ctx = this.canvas.getContext("2d", {
    willReadFrequently: !0
  }), this.ctx.font = this.fontStyle + " " + this.fontWeight + " " + this.fontSize + "px " + this.fontFamily, this.ctx.textBaseline = "middle", this.ctx.fillStyle = "black", this.gridOuter = new Float64Array(a * a), this.gridInner = new Float64Array(a * a), this.f = new Float64Array(a), this.z = new Float64Array(a + 1), this.v = new Uint16Array(a), this.middle = Math.round(a / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1));
}
function nb(i, t, e, r, n, s) {
  for (var o = 0; o < t; o++) rb(i, o, t, e, r, n, s);
  for (var a = 0; a < e; a++) rb(i, a * t, 1, t, r, n, s);
}
function rb(i, t, e, r, n, s, o) {
  var a, l, h, u;
  for (s[0] = 0, o[0] = -qh, o[1] = qh, a = 0; a < r; a++) n[a] = i[t + a * e];
  for (a = 1, l = 0, h = 0; a < r; a++) {
    do
      h = (n[a] - n[u = s[l]] + a * a - u * u) / (a - u) / 2;
    while (h <= o[l] && --l > -1);
    s[++l] = a, o[l] = h, o[l + 1] = qh;
  }
  for (a = 0, l = 0; a < r; a++) {
    for (; o[l + 1] < a; ) l++;
    i[t + a * e] = n[u = s[l]] + (a - u) * (a - u);
  }
}
oP.prototype.draw = function(i, t, e) {
  this.ctx.clearRect(0, 0, this.size, this.size), this.ctx.textBaseline = "top", this.ctx.fillText(i, this.buffer, this.buffer);
  for (var r = this.ctx.getImageData(0, 0, t, e), n = new Uint8ClampedArray(t * e), s = 0; s < t * e; s++) {
    var o = r.data[4 * s + 3] / 255;
    this.gridOuter[s] = o === 1 ? 0 : o === 0 ? qh : Math.pow(Math.max(0, 0.5 - o), 2), this.gridInner[s] = o === 1 ? qh : o === 0 ? 0 : Math.pow(Math.max(0, o - 0.5), 2);
  }
  for (nb(this.gridOuter, t, e, this.f, this.v, this.z), nb(this.gridInner, t, e, this.f, this.v, this.z), s = 0; s < t * e; s++) {
    var a = Math.sqrt(this.gridOuter[s]) - Math.sqrt(this.gridInner[s]);
    n[s] = Math.round(255 - 255 * (a / this.radius + this.cutoff));
  }
  return n;
};
let ib = 0, aP = class {
  constructor(t, e = 15, r) {
    this.entries = {}, this._cachedFont = {}, this._cache = new sP(2048, function() {
    }), this._framer = t, this._limit = e, this._isCompactChars = r;
  }
  getGlyphs(t, e) {
    if (!t || !Object.keys(t).length) return void e(null, {
      glyphs: null
    });
    const r = this.entries, n = t.options;
    let s = !0;
    n && (s = n.isCharsCompact !== !1), s = s || this._isCompactChars;
    const o = (l, h, u) => {
      let c = 0, f = 0;
      for (const d in t) if (d !== "options") {
        r[d] = r[d] || {}, h[d] = h[d] || {};
        for (const p in t[d]) {
          if (f++, f <= l) continue;
          const g = d.split(" "), m = s && g[0] === "normal" && !np(+p), v = d + ":" + p + ":" + m;
          let _;
          if (this._cache.has(v) ? _ = this._cache.get(v) : (_ = this._tinySDF(r[d], g, p, m), this._cache.add(v, _), c++), _ = TH(_), h[d][p] = _, u.push(_.bitmap.data.buffer), this._framer && c > this._limit) return void this._framer(a(f, h, u));
        }
      }
      e(null, {
        glyphs: h,
        buffers: u
      });
    };
    function a(l, h, u) {
      return () => {
        o(l, h, u);
      };
    }
    o(0, {}, []);
  }
  _tinySDF(t, e, r, n) {
    const s = e[0], o = e[1], a = e.slice(3).join(" ");
    let l = t.tinySDF, h = s !== "normal" ? 5 : 2;
    const u = n ? -1 : 2;
    if (!l) {
      let g = "400";
      /bolder/i.test(o) ? g = "1000" : /bold/i.test(o) ? g = "900" : /medium/i.test(o) ? g = "500" : /light/i.test(o) && (g = "200"), l = t.tinySDF = new oP(24, h, 8, 0.25, a, g, s);
    }
    const c = String.fromCodePoint(r), f = l.ctx.measureText(c), d = Math.round(f.width), p = l.draw(c, d + 2 * h, 24 + 2 * h);
    if (ib < 4) {
      const g = typeof document < "u" && document.getElementById("sdf-debug-" + ib++);
      g && (g.width = d + 2 * h, g.height = l.canvas.height, g.getContext("2d").drawImage(l.canvas, 0, 0));
    }
    return {
      charCode: r,
      bitmap: {
        width: d + 2 * h,
        height: 24 + 2 * h,
        data: p
      },
      metrics: {
        width: d,
        height: 24,
        left: 1,
        top: -h,
        advance: d + h + u
      }
    };
  }
};
function TH(i) {
  const t = {
    width: i.bitmap.width,
    height: i.bitmap.height,
    data: new Uint8ClampedArray(i.bitmap.data)
  };
  return {
    charCode: i.charCode,
    bitmap: t,
    metrics: El({}, i.metrics)
  };
}
let lP = class {
  constructor(t) {
    this.options = t || {}, this._requesting = {}, this._cache = new sP(256, function() {
    });
    const e = document.createElement("canvas");
    this.ctx = e.getContext("2d", {
      willReadFrequently: !0
    });
  }
  getIcons(t, e) {
    if (!t || !Object.keys(t).length) return void e(null, {
      icons: null
    });
    const r = Object.keys(t), n = {}, s = [];
    let o = 0, a = 0;
    const l = this;
    function h(m, v) {
      n[m] = l._getCache(m, v), n[m] && n[m] !== "error" ? s.push(n[m].data.data.buffer) : delete n[m], a++, a === o && e(null, {
        icons: n,
        buffers: s
      });
    }
    function u(m) {
      const v = l._requesting[m.url];
      for (let _ = 0; _ < v.length; _++) v[_].call(m, m.url, m.size);
      delete l._requesting[m.url];
    }
    function c() {
      const m = l.ctx;
      let v, _;
      try {
        v = this.width, _ = this.height, this.size[0] = v, this.size[1] = _, l._ensureMaxSize(null, this.size), v = this.size[0], _ = this.size[1];
        const y = m.canvas;
        y.width = v, y.height = _, m.imageSmoothingEnabled = !1, m.drawImage(this, 0, 0, v, _);
        const x = m.getImageData(0, 0, y.width, y.height).data;
        l._addCache(this.url, x, y.width, y.height);
      } catch (y) {
        console.warn(y);
      }
      u(this);
    }
    function f(m) {
      console.warn(`failed loading icon(${this.index}) at "${this.url}"`), console.warn(m), l.options.iconErrorUrl ? this.src = l.options.iconErrorUrl : (l._addCache(this.url), u(this));
    }
    const d = this.options.urlModifier;
    let p, g = !1;
    for (let m = 0; m < r.length; m++) {
      const v = r[m], _ = t[v];
      this._ensureMaxSize(v, _);
      const y = this._getCache(v, _);
      if (y && y !== "error") {
        n[v] = this._getCache(v, _);
        continue;
      }
      if (y === "error") continue;
      let x, w = v;
      if (v.indexOf("vector://") === 0 && (x = JSON.parse(v.substring(9)), x.markerType === "path" && (w = Yr.getMarkerPathBase64(x, x.markerWidth, x.markerHeight))), v.indexOf("vector://") === 0 && x.markerType !== "path") {
        p = p || new xn([0, 0]);
        const { markerFill: b, markerLineColor: T } = x;
        b && Array.isArray(b) && (x.markerFill = sb(b)), T && Array.isArray(T) && (x.markerLineColor = sb(T)), delete x.markerHorizontalAlignment, delete x.markerVerticalAlignment, delete x.markerDx, delete x.markerDy, delete x.markerPlacement, delete x.markerFile, x.markerWidth = _[0], x.markerHeight = _[1], p.setSymbol(x);
        const A = p["_getSprite".trim()]();
        if (A) {
          const M = A.canvas, S = M.width, P = M.height, C = M.getContext("2d").getImageData(0, 0, S, P).data;
          n[v] = {
            data: {
              data: new Uint8ClampedArray(C),
              width: S,
              height: P
            },
            url: v
          }, s.push(n[v].data.data.buffer), this._addCache(v, C, S, P);
        }
      } else {
        if (this._requesting[v]) {
          g = !0, o++, this._requesting[v].push(h);
          continue;
        }
        this._requesting[v] = [], this._requesting[v].push(h);
        const b = new Image();
        b.index = m, b.size = _, b.onload = c, b.onerror = f, b.onabort = f, b.url = v, b.crossOrigin = "Anonymous", g = !0, o++, b.src = d && d(w) || w;
      }
    }
    g || e(null, {
      icons: n,
      buffers: s
    });
  }
  _hasCache(t, e, r) {
    const n = this._cache.get(t);
    return n && n !== "error" && n.data.width >= e && n.data.height >= r;
  }
  _addCache(t, e, r, n) {
    this._hasCache(t, r, n) || this._cache.add(t, e ? {
      data: {
        data: e,
        width: r,
        height: n
      },
      url: t
    } : "error");
  }
  _getCache(t, e) {
    if (!this._hasCache(t, e[0], e[1])) return null;
    const r = this._cache.get(t);
    return r ? r === "error" ? r : {
      data: {
        data: new Uint8ClampedArray(r.data.data),
        width: r.data.width,
        height: r.data.height
      },
      url: r.url
    } : null;
  }
  _ensureMaxSize(t, e) {
    if (!e[0] || !e[1]) return;
    const r = this.options.maxSize || 2048;
    let [n, s] = e;
    const o = n / s;
    if (t) {
      const a = this._cache.get(t);
      if (a && a !== "error") {
        const { width: l, height: h } = a.data;
        l > n && (n = l), h > s && (s = h);
      }
    }
    n > r && (s = r / o, n = r), s > r && (n = r * o, s = r), e[0] = Math.floor(n), e[1] = Math.floor(s);
  }
};
function sb(i) {
  return i.length === 3 && i.push(1), i.reduce((t, e, r) => t += r < 3 ? 255 * e + "," : e + ")", "rgba(");
}
var Er = Object.freeze({
  __proto__: null,
  clipPolygon: iP,
  calculateSignedArea: xS,
  getFeaAltitudeAndHeight: bS,
  generatePickingIndiceIndex: wS,
  convertRTLText: JC,
  packPosition: PS,
  unpackPosition: function(i, t, e, r) {
    const n = (Math.sign(t) || 1) * (Math.abs(t) % Nc), s = (Math.sign(e) || 1) * (Math.abs(e) % Nc), o = Math.floor(Math.abs(t) / Nc), a = Math.floor(Math.abs(e) / Nc);
    return i[0] = n, i[1] = s, i[2] = Math.sign(r + 1e-5) * (2 * o + a) * dz + r, i;
  },
  convertGeometry: SS,
  getPosArrayType: L0,
  getUnsignedArrayType: z0,
  getIndexArrayType: AS
});
const AH = {}, MH = {}, SH = [];
var ob = Object.freeze({
  __proto__: null,
  loadSymbolFnTypes: function i(t, e) {
    if (!t) return null;
    var r = !1;
    if (Array.isArray(t)) {
      var n, s = [];
      for (let c = 0; c < t.length; c++) (n = i(t[c], e)) ? (s.push(n), r = !0) : s.push(t[c]);
      return r ? s : t;
    }
    var o = {
      __fn_types_loaded: !0
    };
    const a = [];
    for (const c in t) ml(t, c) && a.push(c);
    const l = function(c) {
      Object.defineProperty(o, c, {
        get: function() {
          return this["__fn_" + c] || (this["__fn_" + c] = he(this["_" + c])), this["__fn_" + c].apply(this, e());
        },
        set: function(f) {
          this["_" + c] = f;
        },
        configurable: !0,
        enumerable: !0
      });
    }, h = {}, u = function(c, f) {
      Object.defineProperty(o, c, {
        get: function() {
          this["__fn_" + c] || (this["__fn_" + c] = Ey(this["_" + c], f));
          const d = e()[0];
          h.zoom = d;
          try {
            return this["__fn_" + c].evaluateWithoutErrorHandling(h, AH, MH, null, SH);
          } catch {
            return null;
          }
        },
        set: function(d) {
          this["_" + c] = d;
        },
        configurable: !0,
        enumerable: !0
      });
    };
    for (let c = 0, f = a.length; c < f; c++) {
      const d = a[c];
      if (Ft(t[d])) r = !0, o["_" + d] = t[d], l(d);
      else if (Oy(t[d])) {
        r = !0;
        const p = Ry(d);
        o["_" + d] = t[d], u(d, p);
      } else o[d] = t[d];
    }
    return r ? o : t;
  }
});
const hP = 23.25, ab = {
  polygonPatternFile: 1,
  markerFile: 1,
  markerPlacement: 1,
  markerSpacing: 1,
  textName: 1,
  textStyle: 1,
  textFaceName: 1,
  textWeight: 1,
  textPlacement: 1,
  textSpacing: 1,
  lineJoin: 1,
  lineCap: 1,
  linePatternFile: 1
}, uP = {
  visible: 1,
  textHorizontalAlignment: 1,
  textVerticalAlignment: 1,
  textWrapWidth: 1,
  markerHorizontalAlignment: 1,
  markerVerticalAlignment: 1
}, cP = {
  lineDasharray: 1,
  topPolygonFill: 1,
  bottomPolygonFill: 1
};
Object.assign(uP, ab), Object.assign(cP, ab);
function CH(i, t, e, r, n) {
  fP(i, t, e || 0, r || i.length - 1, n || PH);
}
function fP(i, t, e, r, n) {
  for (; r > e; ) {
    if (r - e > 600) {
      var s = r - e + 1, o = t - e + 1, a = Math.log(s), l = 0.5 * Math.exp(2 * a / 3), h = 0.5 * Math.sqrt(a * l * (s - l) / s) * (o - s / 2 < 0 ? -1 : 1), u = Math.max(e, Math.floor(t - o * l / s + h)), c = Math.min(r, Math.floor(t + (s - o) * l / s + h));
      fP(i, t, u, c, n);
    }
    var f = i[t], d = e, p = r;
    for (uh(i, e, t), n(i[r], f) > 0 && uh(i, e, r); d < p; ) {
      for (uh(i, d, p), d++, p--; n(i[d], f) < 0; ) d++;
      for (; n(i[p], f) > 0; ) p--;
    }
    n(i[e], f) === 0 ? uh(i, e, p) : (p++, uh(i, p, r)), p <= t && (e = p + 1), t <= p && (r = p - 1);
  }
}
function uh(i, t, e) {
  var r = i[t];
  i[t] = i[e], i[e] = r;
}
function PH(i, t) {
  return i < t ? -1 : i > t ? 1 : 0;
}
class lb {
  constructor(t = 9) {
    this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(t) {
    let e = this.data;
    const r = [];
    if (!$c(t, e)) return r;
    const n = this.toBBox, s = [];
    for (; e; ) {
      for (let o = 0; o < e.children.length; o++) {
        const a = e.children[o], l = e.leaf ? n(a) : a;
        $c(t, l) && (e.leaf ? r.push(a) : om(t, l) ? this._all(a, r) : s.push(a));
      }
      e = s.pop();
    }
    return r;
  }
  collides(t) {
    let e = this.data;
    if (!$c(t, e)) return !1;
    const r = [];
    for (; e; ) {
      for (let n = 0; n < e.children.length; n++) {
        const s = e.children[n], o = e.leaf ? this.toBBox(s) : s;
        if ($c(t, o)) {
          if (e.leaf || om(t, o)) return !0;
          r.push(s);
        }
      }
      e = r.pop();
    }
    return !1;
  }
  load(t) {
    if (!(t && t.length)) return this;
    if (t.length < this._minEntries) {
      for (let r = 0; r < t.length; r++)
        this.insert(t[r]);
      return this;
    }
    let e = this._build(t.slice(), 0, t.length - 1, 0);
    if (!this.data.children.length)
      this.data = e;
    else if (this.data.height === e.height)
      this._splitRoot(this.data, e);
    else {
      if (this.data.height < e.height) {
        const r = this.data;
        this.data = e, e = r;
      }
      this._insert(e, this.data.height - e.height - 1, !0);
    }
    return this;
  }
  insert(t) {
    return t && this._insert(t, this.data.height - 1), this;
  }
  clear() {
    return this.data = Wa([]), this;
  }
  remove(t, e) {
    if (!t) return this;
    let r = this.data;
    const n = this.toBBox(t), s = [], o = [];
    let a, l, h;
    for (; r || s.length; ) {
      if (r || (r = s.pop(), l = s[s.length - 1], a = o.pop(), h = !0), r.leaf) {
        const u = EH(t, r.children, e);
        if (u !== -1)
          return r.children.splice(u, 1), s.push(r), this._condense(s), this;
      }
      !h && !r.leaf && om(r, n) ? (s.push(r), o.push(a), a = 0, l = r, r = r.children[0]) : l ? (a++, r = l.children[a], h = !1) : r = null;
    }
    return this;
  }
  toBBox(t) {
    return t;
  }
  compareMinX(t, e) {
    return t.minX - e.minX;
  }
  compareMinY(t, e) {
    return t.minY - e.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(t) {
    return this.data = t, this;
  }
  _all(t, e) {
    const r = [];
    for (; t; )
      t.leaf ? e.push(...t.children) : r.push(...t.children), t = r.pop();
    return e;
  }
  _build(t, e, r, n) {
    const s = r - e + 1;
    let o = this._maxEntries, a;
    if (s <= o)
      return a = Wa(t.slice(e, r + 1)), Oa(a, this.toBBox), a;
    n || (n = Math.ceil(Math.log(s) / Math.log(o)), o = Math.ceil(s / Math.pow(o, n - 1))), a = Wa([]), a.leaf = !1, a.height = n;
    const l = Math.ceil(s / o), h = l * Math.ceil(Math.sqrt(o));
    hb(t, e, r, h, this.compareMinX);
    for (let u = e; u <= r; u += h) {
      const c = Math.min(u + h - 1, r);
      hb(t, u, c, l, this.compareMinY);
      for (let f = u; f <= c; f += l) {
        const d = Math.min(f + l - 1, c);
        a.children.push(this._build(t, f, d, n - 1));
      }
    }
    return Oa(a, this.toBBox), a;
  }
  _chooseSubtree(t, e, r, n) {
    for (; n.push(e), !(e.leaf || n.length - 1 === r); ) {
      let s = 1 / 0, o = 1 / 0, a;
      for (let l = 0; l < e.children.length; l++) {
        const h = e.children[l], u = sm(h), c = RH(t, h) - u;
        c < o ? (o = c, s = u < s ? u : s, a = h) : c === o && u < s && (s = u, a = h);
      }
      e = a || e.children[0];
    }
    return e;
  }
  _insert(t, e, r) {
    const n = r ? t : this.toBBox(t), s = [], o = this._chooseSubtree(n, this.data, e, s);
    for (o.children.push(t), zh(o, n); e >= 0 && s[e].children.length > this._maxEntries; )
      this._split(s, e), e--;
    this._adjustParentBBoxes(n, s, e);
  }
  // split overflowed node into two
  _split(t, e) {
    const r = t[e], n = r.children.length, s = this._minEntries;
    this._chooseSplitAxis(r, s, n);
    const o = this._chooseSplitIndex(r, s, n), a = Wa(r.children.splice(o, r.children.length - o));
    a.height = r.height, a.leaf = r.leaf, Oa(r, this.toBBox), Oa(a, this.toBBox), e ? t[e - 1].children.push(a) : this._splitRoot(r, a);
  }
  _splitRoot(t, e) {
    this.data = Wa([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, Oa(this.data, this.toBBox);
  }
  _chooseSplitIndex(t, e, r) {
    let n, s = 1 / 0, o = 1 / 0;
    for (let a = e; a <= r - e; a++) {
      const l = Lh(t, 0, a, this.toBBox), h = Lh(t, a, r, this.toBBox), u = IH(l, h), c = sm(l) + sm(h);
      u < s ? (s = u, n = a, o = c < o ? c : o) : u === s && c < o && (o = c, n = a);
    }
    return n || r - e;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(t, e, r) {
    const n = t.leaf ? this.compareMinX : OH, s = t.leaf ? this.compareMinY : kH, o = this._allDistMargin(t, e, r, n), a = this._allDistMargin(t, e, r, s);
    o < a && t.children.sort(n);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(t, e, r, n) {
    t.children.sort(n);
    const s = this.toBBox, o = Lh(t, 0, e, s), a = Lh(t, r - e, r, s);
    let l = Uc(o) + Uc(a);
    for (let h = e; h < r - e; h++) {
      const u = t.children[h];
      zh(o, t.leaf ? s(u) : u), l += Uc(o);
    }
    for (let h = r - e - 1; h >= e; h--) {
      const u = t.children[h];
      zh(a, t.leaf ? s(u) : u), l += Uc(a);
    }
    return l;
  }
  _adjustParentBBoxes(t, e, r) {
    for (let n = r; n >= 0; n--)
      zh(e[n], t);
  }
  _condense(t) {
    for (let e = t.length - 1, r; e >= 0; e--)
      t[e].children.length === 0 ? e > 0 ? (r = t[e - 1].children, r.splice(r.indexOf(t[e]), 1)) : this.clear() : Oa(t[e], this.toBBox);
  }
}
function EH(i, t, e) {
  if (!e) return t.indexOf(i);
  for (let r = 0; r < t.length; r++)
    if (e(i, t[r])) return r;
  return -1;
}
function Oa(i, t) {
  Lh(i, 0, i.children.length, t, i);
}
function Lh(i, t, e, r, n) {
  n || (n = Wa(null)), n.minX = 1 / 0, n.minY = 1 / 0, n.maxX = -1 / 0, n.maxY = -1 / 0;
  for (let s = t; s < e; s++) {
    const o = i.children[s];
    zh(n, i.leaf ? r(o) : o);
  }
  return n;
}
function zh(i, t) {
  return i.minX = Math.min(i.minX, t.minX), i.minY = Math.min(i.minY, t.minY), i.maxX = Math.max(i.maxX, t.maxX), i.maxY = Math.max(i.maxY, t.maxY), i;
}
function OH(i, t) {
  return i.minX - t.minX;
}
function kH(i, t) {
  return i.minY - t.minY;
}
function sm(i) {
  return (i.maxX - i.minX) * (i.maxY - i.minY);
}
function Uc(i) {
  return i.maxX - i.minX + (i.maxY - i.minY);
}
function RH(i, t) {
  return (Math.max(t.maxX, i.maxX) - Math.min(t.minX, i.minX)) * (Math.max(t.maxY, i.maxY) - Math.min(t.minY, i.minY));
}
function IH(i, t) {
  const e = Math.max(i.minX, t.minX), r = Math.max(i.minY, t.minY), n = Math.min(i.maxX, t.maxX), s = Math.min(i.maxY, t.maxY);
  return Math.max(0, n - e) * Math.max(0, s - r);
}
function om(i, t) {
  return i.minX <= t.minX && i.minY <= t.minY && t.maxX <= i.maxX && t.maxY <= i.maxY;
}
function $c(i, t) {
  return t.minX <= i.maxX && t.minY <= i.maxY && t.maxX >= i.minX && t.maxY >= i.minY;
}
function Wa(i) {
  return {
    children: i,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function hb(i, t, e, r, n) {
  const s = [t, e];
  for (; s.length; ) {
    if (e = s.pop(), t = s.pop(), e - t <= r) continue;
    const o = t + Math.ceil((e - t) / r / 2) * r;
    CH(i, o, t, e, n), s.push(t, o, o, e);
  }
}
/*!
* Contains code from jquery.easing
* BSD License
* https://github.com/gdsmith/jquery.easing/
*/
var Nn = Math.pow, vd = Math.sqrt, Su = Math.sin, dP = Math.cos, ju = Math.PI, rp = 1.70158, Wc = rp * 1.525, pP = rp + 1, gP = 2 * ju / 3, ub = 2 * ju / 4.5;
function yd(i) {
  var t = 7.5625, e = 2.75;
  return i < 1 / e ? t * i * i : i < 2 / e ? t * (i -= 1.5 / e) * i + 0.75 : i < 2.5 / e ? t * (i -= 2.25 / e) * i + 0.9375 : t * (i -= 2.625 / e) * i + 0.984375;
}
function DH(i, t) {
  switch (i = i.toLowerCase(), i) {
    case "swing":
      return FH(t);
    case "easeinquad":
      return mP(t);
    case "easeoutquad":
      return LH(t);
    case "easeinoutquad":
      return zH(t);
    case "easeincubic":
      return NH(t);
    case "easeoutcubic":
      return HH(t);
    case "easeinoutcubic":
      return BH(t);
    case "easeinquart":
      return jH(t);
    case "easeoutquart":
      return GH(t);
    case "easeinoutquart":
      return VH(t);
    case "easeinquint":
      return UH(t);
    case "easeoutquint":
      return $H(t);
    case "easeinoutquint":
      return WH(t);
    case "easeinsine":
      return ZH(t);
    case "easeoutsine":
      return XH(t);
    case "easeinoutsine":
      return qH(t);
    case "easeinexpo":
      return YH(t);
    case "easeoutexpo":
      return JH(t);
    case "easeinoutexpo":
      return KH(t);
    case "easeincirc":
      return QH(t);
    case "easeoutcirc":
      return t8(t);
    case "easeinoutcirc":
      return e8(t);
    case "easeinelastic":
      return n8(t);
    case "easeoutelastic":
      return r8(t);
    case "easeinoutelastic":
      return i8(t);
    case "easeinback":
      return s8(t);
    case "easeoutback":
      return o8(t);
    case "easeinoutback":
      return a8(t);
    case "easeinbounce":
      return l8(t);
    case "easeoutbounce":
      return h8(t);
    case "easeinoutbounce":
      return u8(t);
  }
  throw new Error("Unsupported easing function:" + i);
}
function FH(i) {
  return mP(i);
}
function mP(i) {
  return i * i;
}
function LH(i) {
  return 1 - (1 - i) * (1 - i);
}
function zH(i) {
  return i < 0.5 ? 2 * i * i : 1 - Nn(-2 * i + 2, 2) / 2;
}
function NH(i) {
  return i * i * i;
}
function HH(i) {
  return 1 - Nn(1 - i, 3);
}
function BH(i) {
  return i < 0.5 ? 4 * i * i * i : 1 - Nn(-2 * i + 2, 3) / 2;
}
function jH(i) {
  return i * i * i * i;
}
function GH(i) {
  return 1 - Nn(1 - i, 4);
}
function VH(i) {
  return i < 0.5 ? 8 * i * i * i * i : 1 - Nn(-2 * i + 2, 4) / 2;
}
function UH(i) {
  return i * i * i * i * i;
}
function $H(i) {
  return 1 - Nn(1 - i, 5);
}
function WH(i) {
  return i < 0.5 ? 16 * i * i * i * i * i : 1 - Nn(-2 * i + 2, 5) / 2;
}
function ZH(i) {
  return 1 - dP(i * ju / 2);
}
function XH(i) {
  return Su(i * ju / 2);
}
function qH(i) {
  return -(dP(ju * i) - 1) / 2;
}
function YH(i) {
  return i === 0 ? 0 : Nn(2, 10 * i - 10);
}
function JH(i) {
  return i === 1 ? 1 : 1 - Nn(2, -10 * i);
}
function KH(i) {
  return i === 0 ? 0 : i === 1 ? 1 : i < 0.5 ? Nn(2, 20 * i - 10) / 2 : (2 - Nn(2, -20 * i + 10)) / 2;
}
function QH(i) {
  return 1 - vd(1 - Nn(i, 2));
}
function t8(i) {
  return vd(1 - Nn(i - 1, 2));
}
function e8(i) {
  return i < 0.5 ? (1 - vd(1 - Nn(2 * i, 2))) / 2 : (vd(1 - Nn(-2 * i + 2, 2)) + 1) / 2;
}
function n8(i) {
  return i === 0 ? 0 : i === 1 ? 1 : -Nn(2, 10 * i - 10) * Su((i * 10 - 10.75) * gP);
}
function r8(i) {
  return i === 0 ? 0 : i === 1 ? 1 : Nn(2, -10 * i) * Su((i * 10 - 0.75) * gP) + 1;
}
function i8(i) {
  return i === 0 ? 0 : i === 1 ? 1 : i < 0.5 ? -(Nn(2, 20 * i - 10) * Su((20 * i - 11.125) * ub)) / 2 : Nn(2, -20 * i + 10) * Su((20 * i - 11.125) * ub) / 2 + 1;
}
function s8(i) {
  return pP * i * i * i - rp * i * i;
}
function o8(i) {
  return 1 + pP * Nn(i - 1, 3) + rp * Nn(i - 1, 2);
}
function a8(i) {
  return i < 0.5 ? Nn(2 * i, 2) * ((Wc + 1) * 2 * i - Wc) / 2 : (Nn(2 * i - 2, 2) * ((Wc + 1) * (i * 2 - 2) + Wc) + 2) / 2;
}
function l8(i) {
  return 1 - yd(1 - i);
}
function h8(i) {
  return yd(i);
}
function u8(i) {
  return i < 0.5 ? (1 - yd(1 - 2 * i)) / 2 : (1 + yd(2 * i - 1)) / 2;
}
function ip() {
}
const Hn = ip.prototype;
Hn.getType = function() {
  return Object.getPrototypeOf(this).constructor.type;
};
Hn.isVisible = function() {
  throw new Error("to be implemented.");
};
Hn.prepareRender = function() {
  throw new Error("to be implemented.");
};
Hn.updateCollision = function() {
  throw new Error("to be implemented.");
};
Hn.supportRenderMode = function() {
  throw new Error("to be implemented.");
};
Hn.startFrame = function() {
  throw new Error("to be implemented.");
};
Hn.endFrame = function() {
  throw new Error("to be implemented.");
};
Hn.paintTile = function() {
  throw new Error("to be implemented.");
};
Hn.getShadowMeshes = function() {
  throw new Error("to be implemented.");
};
Hn.updateSceneConfig = function() {
  throw new Error("to be implemented.");
};
Hn.updateDataConfig = function() {
  throw new Error("to be implemented.");
};
Hn.updateSymbol = function() {
  throw new Error("to be implemented.");
};
Hn.pick = function() {
  throw new Error("to be implemented.");
};
Hn.resize = function() {
  throw new Error("to be implemented.");
};
Hn.deleteTile = function() {
  throw new Error("to be implemented.");
};
Hn.remove = function() {
  throw new Error("to be implemented.");
};
Hn.needToRedraw = function() {
  throw new Error("to be implemented.");
};
Hn.needToRetireFrames = function() {
  throw new Error("to be implemented.");
};
Hn.outline = function() {
  throw new Error("to be implemented.");
};
Hn.outlineAll = function() {
  throw new Error("to be implemented.");
};
Hn.needPolygonOffset = function() {
  throw new Error("to be implemented.");
};
Hn.constructor = ip;
const c8 = Object.prototype.hasOwnProperty;
ip.extend = function(i, t) {
  const e = function() {
    this.init && this.init();
  }, r = Object.create(Hn);
  r.constructor = e, e.prototype = r, e.type = i;
  for (const n in t)
    c8.call(t, n) && (e.prototype[n] = t[n]);
  return e.registerAt = f8.bind(e), e;
};
function f8(i) {
  i.registerPlugin(this);
}
/*!
 * @maptalks/vt v0.95.0
 * LICENSE : undefined
 * (c) 2016-2024 maptalks.org
 */
const am = 'function(t){let n;const e={width:100,height:10};function r(){if(!n){const{width:t,height:r}=e;OffscreenCanvas?n=new OffscreenCanvas(t,r):(n=document.createElement("canvas"),n.width=t,n.height=r)}return n}class i{constructor(t,n={}){if(!Array.isArray(t))return void console.error("colors is not array");if(t.length<2)return void console.error("colors.length should >1");this.colors=t;let r=1/0,i=-1/0;for(let n=0,e=t.length;n<e;n++){const e=t[n][0];r=Math.min(e,r),i=Math.max(e,i)}this.min=r,this.max=i,this.valueOffset=this.max-this.min,this.options=Object.assign({},e,n),this.t()}getImageData(){return this.imgData}t(){const t=r(),{width:n,height:e}=this.options;t.width=n,t.height=e;const i=t.getContext("2d");i.clearRect(0,0,t.width,t.height);const s=i.createLinearGradient(0,0,t.width,0),{colors:o,valueOffset:a}=this;for(let t=0,n=o.length;t<n;t++){const[n,e]=o[t],r=(n-this.min)/a;s.addColorStop(r,e)}i.fillStyle=s,i.fillRect(0,0,t.width,t.height),this.imgData=i.getImageData(0,0,t.width,t.height)}getColor(t){t=Math.max(this.min,t);const n=((t=Math.min(t,this.max))-this.min)/this.valueOffset;let e=Math.round(n*this.imgData.width);e=Math.min(e,this.imgData.width-1);const r=4*e;return[this.imgData.data[r],this.imgData.data[r+1],this.imgData.data[r+2],this.imgData.data[r+3]]}}var s;function o(t,n){for(let e=0;e<t.stops.length;e++)if(n===t.stops[e][0])return t.stops[e][1];return t.default}function a(t,n){for(var e=0;e<t.stops.length&&!(n<t.stops[e][0]);e++);return t.stops[Math.max(e-1,0)][1]}function u(t,n){for(var e=void 0!==t.base?t.base:1,r=0;!(r>=t.stops.length||n<=t.stops[r][0]);)r++;return 0===r?t.stops[r][1]:r===t.stops.length?t.stops[r-1][1]:function t(n,e,r,i,s,o){return"function"==typeof s?function(){var a=s.apply(void 0,arguments),u=o.apply(void 0,arguments);return t(n,e,r,i,a,u)}:s.length?function(t,n,e,r,i,s){var o=[];for(let a=0;a<i.length;a++)o[a]=f(t,n,e,r,i[a],s[a]);return o}(n,e,r,i,s,o):f(n,e,r,i,s,o)}(n,e,t.stops[r-1][0],t.stops[r][0],t.stops[r-1][1],t.stops[r][1])}"function"==typeof Map&&(s=new Map);const l={width:100,height:1};function h(t,n){const e=t.stops;if(e&&e.length>1){let t;if(s){const n=JSON.stringify(e);if(!s.has(n)){const t=new i(e,l);s.set(n,t)}t=s.get(n)}else t=new i(e,l);const[r,o,a,u]=t.getColor(n);return[r/255,o/255,a/255,u/255]}return e&&1===e.length?e[0][1]:null}function c(t,n){return function(t,n,e){return void 0!==t?t:void 0!==n?n:void 0!==e?e:null}(n,t.default)}function f(t,n,e,r,i,s){var o,a=r-e,u=t-e;return i*(1-(o=1===n?u/a:(Math.pow(n,u)-1)/(Math.pow(n,a)-1)))+s*o}function d(t){return t&&"object"==typeof t&&(t.stops||t.property&&"identity"===t.type)}function p(t){return g(t,"exponential")}function y(t){return g(t,"interval")}function m(t,n){if(!t)return null;var e=!1;if(Array.isArray(t)){var r,i=[];for(let s=0;s<t.length;s++)(r=m(t[s],n))?(i.push(r),e=!0):i.push(t[s]);return e?i:t}var s,o={__fn_types_loaded:!0},a=[];for(s in t)t.hasOwnProperty(s)&&a.push(s);const u=function(t){Object.defineProperty(o,t,{get:function(){return this["__fn_"+t]||(this["__fn_"+t]=p(this["_"+t])),this["__fn_"+t].apply(this,n())},set:function(n){this["_"+t]=n},configurable:!0,enumerable:!0})};for(let n=0,r=a.length;n<r;n++)d(t[s=a[n]])?(e=!0,o["_"+s]=t[s],u(s)):o[s]=t[s];return e?o:t}function g(t,n){if(!d(t))return function(){return t};let e=!0,r=!0;const i=(t=JSON.parse(JSON.stringify(t))).stops;if(i)for(let t=0;t<i.length;t++)if(d(i[t][1])){const s=g(i[t][1],n);e=e&&s.isZoomConstant,r=r&&s.isFeatureConstant,i[t]=[i[t][0],s]}const s=function t(n,e){var r,i,s;if(d(n)){var l,f=n.stops&&"object"==typeof n.stops[0][0],p=f||void 0!==n.property,y=f||!p,m=n.type||e||"exponential";if("exponential"===m)l=u;else if("interval"===m)l=a;else if("categorical"===m)l=o;else if("identity"===m)l=c;else{if("color-interpolate"!==m)throw new Error(\'Unknown function type "\'+m+\'"\');l=h}if(f){var g={},v=[];for(let t=0;t<n.stops.length;t++){var b=n.stops[t];void 0===g[b[0].zoom]&&(g[b[0].zoom]={zoom:b[0].zoom,type:n.type,property:n.property,default:n.default,stops:[]}),g[b[0].zoom].stops.push([b[0].value,b[1]])}for(let n in g)v.push([g[n].zoom,t(g[n])]);r=function(t,e){const r=u({stops:v,base:n.base},t)(t,e);return"function"==typeof r?r(t,e):r},i=!1,s=!1}else y?(r=function(t){const e=l(n,t);return"function"==typeof e?e(t):e},i=!0,s=!1):(r=function(t,e){const r=l(n,e?e[n.property]:null);return"function"==typeof r?r(t,e):r},i=!1,s=!0)}else r=function(){return n},i=!0,s=!0;return r.isZoomConstant=s,r.isFeatureConstant=i,r}(t,n);return s.isZoomConstant=e&&s.isZoomConstant,s.isFeatureConstant=r&&s.isFeatureConstant,s}let v=0;const b="function"==typeof Object.assign;function w(t,...n){if(b)return Object.assign(t,...n),t;for(let e=0;e<n.length;e++){const r=n[e];for(const n in r)t[n]=r[n]}return t}function M(t){return!k(t)&&("string"==typeof t||null!==t.constructor&&t.constructor===String)}function x(t){return"number"==typeof t&&!isNaN(t)}function F(t){return!k(t)&&("function"==typeof t||null!==t.constructor&&t.constructor===Function)}function A(t){return!Array.isArray(t)&&"object"==typeof t&&!!t}function k(t){return null==t}function P(t){for(let n=1;n<arguments.length;n++){const e=arguments[n];if(e)for(let n=0,r=e.length;n<r;n++)t.push(e[n])}return t.length}function S(t){return d(t)&&t.property}const _="function"==typeof fetch&&"function"==typeof AbortController,O={jsonp:function(t,n){const e="_maptalks_jsonp_"+v++;t.match(/\\?/)?t+="&callback="+e:t+="?callback="+e;let r=document.createElement("script");return r.type="text/javascript",r.src=t,window[e]=function(t){n(null,t),document.getElementsByTagName("head")[0].removeChild(r),r=null,delete window[e]},document.getElementsByTagName("head")[0].appendChild(r),this},get:function(t,n,e){if(F(n)){const t=e;e=n,n=t}(n=n||{}).method&&(n.method=n.method.toUpperCase());const r="POST"===n.method;if(_){const r=new AbortController,i=n;i.signal=r.signal,i.referrerPolicy=i.referrerPolicy||"origin",i.method=i.method||"GET";const s=new Request(t,i);return n.returnJSON&&s.headers.set("Accept","application/json"),fetch(s).then(r=>{const i=this.s(r,n.returnJSON,n.responseType);i.message?(i.url=t,e(i)):i.then(t=>{"arraybuffer"===n.responseType?e(null,{data:t,cacheControl:r.headers.get("Cache-Control"),expires:r.headers.get("Expires"),contentType:r.headers.get("Content-Type")}):e(null,t)}).catch(n=>{n.code&&n.code===DOMException.ABORT_ERR||(console.error("Fetch error:",t,n),e(n))})}).catch(n=>{n.code&&n.code===DOMException.ABORT_ERR||(console.error("Fetch error:",t,n),e(n))}),r}{const i=O.o(e);if(i.open(n.method||"GET",t,!0),n){for(const t in n.headers)i.setRequestHeader(t,n.headers[t]);i.withCredentials="include"===n.credentials,n.responseType&&(i.responseType=n.responseType)}return i.send(r?n.body:null),i}},s:(t,n,e)=>200!==t.status?{status:t.status,statusText:t.statusText,message:`incorrect http request with status code(${t.status}): ${t.statusText}`}:"arraybuffer"===e?t.arrayBuffer():n?t.json():t.text(),u:function(t,n){return function(){if(4===t.readyState)if(200===t.status)if("arraybuffer"===t.responseType){0===t.response.byteLength?n({status:200,statusText:t.statusText,message:"http status 200 returned without content."}):n(null,{data:t.response,cacheControl:t.getResponseHeader("Cache-Control"),expires:t.getResponseHeader("Expires"),contentType:t.getResponseHeader("Content-Type")})}else n(null,t.responseText);else n({status:t.status,statusText:t.statusText,message:`incorrect http request with status code(${t.status}): ${t.statusText}`})}},o:function(t){let n;try{n=new XMLHttpRequest}catch(t){try{n=new ActiveXObject("Msxml2.XMLHTTP")}catch(t){try{n=new ActiveXObject("Microsoft.XMLHTTP")}catch(t){}}}return n.onreadystatechange=O.u(n,t),n},getArrayBuffer(t,n,e){if(F(n)){const t=e;e=n,n=t}return n||(n={}),n.responseType="arraybuffer",O.get(t,n,e)}};function E(t,n,e,r,i,s){let o=i-e,a=s-r;if(0!==o||0!==a){const u=((t-e)*o+(n-r)*a)/(o*o+a*a);u>1?(e=i,r=s):u>0&&(e+=o*u,r+=a*u)}return o=t-e,a=n-r,o*o+a*a}function I(t,n,e,r,i,s){const o={id:null==t?null:t,type:n,geometry:e,tags:r,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0};i&&(o.layer=i);return function(t,n){const e=t.geometry,r=t.type;if("Point"===r||"MultiPoint"===r||"LineString"===r)$(t,e,n);else if("Polygon"===r)$(t,e[0],n);else if("MultiLineString"===r)for(const r of e)$(t,r,n);else if("MultiPolygon"===r)for(const r of e)$(t,r[0],n)}(o,s?4:3),o}function $(t,n,e){for(let r=0;r<n.length;r+=e)t.minX=Math.min(t.minX,n[r]),t.minY=Math.min(t.minY,n[r+1]),t.maxX=Math.max(t.maxX,n[r]),t.maxY=Math.max(t.maxY,n[r+1])}function C(t,n,e,r){if(r.layer=n,"FeatureCollection"===e.type)for(let n=0;n<e.features.length;n++)T(t,e.features[n],r,n);else"Feature"===e.type?T(t,e,r):T(t,{geometry:e},r)}function T(t,n,e,r){if(!n.geometry)return;const i=n.geometry.coordinates,s=n.geometry.type,o=Math.pow(e.tolerance/((1<<e.maxZoom)*e.extent),2);let a=[],u=n.id;if(e.promoteId?u=n.properties[e.promoteId]:e.generateId&&(u=r||0),"Point"===s)z(i,a,e);else if("MultiPoint"===s)for(const t of i)z(t,a,e);else if("LineString"===s)D(i,a,o,!1,e);else if("MultiLineString"===s){if(e.lineMetrics){for(const r of i)a=[],D(r,a,o,!1,e),t.push(I(u,"LineString",a,n.properties,e.layer,e.hasAltitude));return}j(i,a,o,!1,e)}else if("Polygon"===s)j(i,a,o,!0,e);else{if("MultiPolygon"!==s){if("GeometryCollection"===s){for(const i of n.geometry.geometries)T(t,{id:u,geometry:i,properties:n.properties},e,r);return}throw new Error("Input data is not a valid GeoJSON object.")}for(const t of i){const n=[];j(t,n,o,!0,e),a.push(n)}}t.push(I(u,s,a,n.properties,e.layer,e.hasAltitude))}function z(t,n,e){n.push(U(t[0]),N(t[1],e.projection),0),e.hasAltitude&&(t.length>2?n.push(t[2]):n.push(0))}function D(t,n,e,r,i){let s,o,a=0;for(let e=0;e<t.length;e++){const u=U(t[e][0]),l=N(t[e][1],i.projection);n.push(u,l,0),i.hasAltitude&&(t[e].length>2?n.push(t[e][2]):n.push(0)),e>0&&(a+=r?(s*l-u*o)/2:Math.sqrt(Math.pow(u-s,2)+Math.pow(l-o,2))),s=u,o=l}const u=i.hasAltitude?4:3,l=n.length-u;n[2]=1,function t(n,e,r,i,s=3){let o=i;const a=r-e>>1;let u,l=r-e;const h=n[e],c=n[e+1],f=n[r],d=n[r+1];for(let t=e+s;t<r;t+=s){const e=E(n[t],n[t+1],h,c,f,d);if(e>o)u=t,o=e;else if(e===o){const n=Math.abs(t-a);n<l&&(u=t,l=n)}}o>i&&(u-e>s&&t(n,e,u,i,s),n[u+2]=o,r-u>s&&t(n,u,r,i,s))}(n,0,l,e,u),n[l+2]=1,n.size=Math.abs(a),n.start=0,n.end=n.size}function j(t,n,e,r,i){for(let s=0;s<t.length;s++){const o=[];D(t[s],o,e,r,i),n.push(o)}}function U(t){return t/360+.5}function N(t,n){switch(n){case"EPSG:4326":return(90-t)/360}const e=Math.sin(t*Math.PI/180),r=.5-.25*Math.log((1+e)/(1-e))/Math.PI;return r<0?0:r>1?1:r}function L(t,n,e,r,i,s,o,a){if(r/=n,s>=(e/=n)&&o<r)return t;if(o<e||s>=r)return null;const u=[];for(const n of t){const t=n.geometry;let s=n.type;const o=0===i?n.minX:n.minY,l=0===i?n.maxX:n.maxY;if(o>=e&&l<r){u.push(n);continue}if(l<e||o>=r)continue;let h=[];if("Point"===s||"MultiPoint"===s)V(t,h,e,r,i,a.hasAltitude);else if("LineString"===s)R(t,h,e,r,i,!1,a.lineMetrics,a.hasAltitude);else if("MultiLineString"===s)W(t,h,e,r,i,!1,a.hasAltitude);else if("Polygon"===s)W(t,h,e,r,i,!0,a.hasAltitude);else if("MultiPolygon"===s)for(const n of t){const t=[];W(n,t,e,r,i,!0,a.hasAltitude),t.length&&h.push(t)}if(h.length){if(a.lineMetrics&&"LineString"===s){for(const t of h)u.push(I(n.id,s,t,n.tags,n.layer,a.hasAltitude));continue}"LineString"!==s&&"MultiLineString"!==s||(1===h.length?(s="LineString",h=h[0]):s="MultiLineString"),"Point"!==s&&"MultiPoint"!==s||(s=3===h.length?"Point":"MultiPoint"),u.push(I(n.id,s,h,n.tags,n.layer,a.hasAltitude))}}return u.length?u:null}function V(t,n,e,r,i,s){const o=s?4:3;for(let a=0;a<t.length;a+=o){const o=t[a+i];o>=e&&o<=r&&(q(n,t[a],t[a+1],t[a+2]),s&&n.push(t[a+3]))}}function R(t,n,e,r,i,s,o,a){let u=H(t);const l=0===i?G:B;let h,c,f=t.start;const d=a?4:3,p=s?t.length:t.length-d;for(let y=0;y<p;y+=d){const m=t[y],g=t[y+1],v=t[y+2];let b,w,M,x;s&&y===p-d?(b=t[0],w=t[1]):(b=t[y+d],w=t[y+d+1]),a&&(M=t[y+3],x=s&&y===p-d?t[3]:t[y+d+3]);const F=0===i?m:g,A=0===i?b:w;let k=!1;o&&(h=Math.sqrt(Math.pow(m-b,2)+Math.pow(g-w,2))),F<e?A>e&&(c=l(u,m,g,b,w,e),a&&u.push(J(M,x,c)),o&&(u.start=f+h*c)):F>r?A<r&&(c=l(u,m,g,b,w,r),a&&u.push(J(M,x,c)),o&&(u.start=f+h*c)):(q(u,m,g,v),a&&u.push(M)),A<e&&F>=e&&(c=l(u,m,g,b,w,e),a&&u.push(J(M,x,c)),k=!0),A>r&&F<=r&&(c=l(u,m,g,b,w,r),a&&u.push(J(M,x,c)),k=!0),!s&&k&&(o&&(u.end=f+h*c),n.push(u),u=H(t)),o&&(f+=h)}let y=t.length-d;if(!s){const n=t[y],s=t[y+1],o=t[y+2],l=0===i?n:s;if(l>=e&&l<=r&&q(u,n,s,o),l>=e&&l<=r&&a){const n=t[y+3];u.push(n)}}y=u.length-d,s&&y>=d&&(u[y]!==u[0]||u[y+1]!==u[1])&&(q(u,u[0],u[1],u[2]),a&&u.push(u[3])),u.length&&n.push(u)}function H(t){const n=[];return n.size=t.size,n.start=t.start,n.end=t.end,n}function W(t,n,e,r,i,s,o){for(const a of t)R(a,n,e,r,i,s,!1,o)}function q(t,n,e,r){t.push(n,e,r)}function G(t,n,e,r,i,s){const o=(s-n)/(r-n);return q(t,s,e+(i-e)*o,1),o}function B(t,n,e,r,i,s){const o=(s-e)/(i-e);return q(t,n+(r-n)*o,s,1),o}function J(t,n,e){return t+(n-t)*e}function X(t,n,e){const r=[];for(let i=0;i<t.length;i++){const s=t[i],o=s.type;let a;if("Point"===o||"MultiPoint"===o||"LineString"===o)a=Y(s.geometry,n,e);else if("MultiLineString"===o||"Polygon"===o){a=[];for(const t of s.geometry)a.push(Y(t,n,e))}else if("MultiPolygon"===o){a=[];for(const t of s.geometry){const r=[];for(const i of t)r.push(Y(i,n,e));a.push(r)}}r.push(I(s.id,o,a,s.tags,s.layer,e))}return r}function Y(t,n,e){const r=[];r.size=t.size,void 0!==t.start&&(r.start=t.start,r.end=t.end);const i=e?4:3;for(let s=0;s<t.length;s+=i)r.push(t[s]+n,t[s+1],t[s+2]),e&&r.push(t[s+3]);return r}function Z(t,n,e){if(t.transformed)return t;const r=1<<t.z,i=t.x,s=t.y,o=e?3:2;for(const a of t.features){const t=a.geometry,u=a.type;if(a.geometry=[],1===u)for(let u=0;u<t.length;u+=o)a.geometry.push(K(t[u],t[u+1],n,r,i,s)),e&&a.geometry[a.geometry.length-1].push(t[u+2]);else for(let u=0;u<t.length;u++){const l=[];for(let a=0;a<t[u].length;a+=o)l.push(K(t[u][a],t[u][a+1],n,r,i,s)),e&&l[l.length-1].push(t[u][a+2]);a.geometry.push(l)}}return t.transformed=!0,t}function K(t,n,e,r,i,s){return[Math.round(e*(t*r-i)),Math.round(e*(n*r-s))]}function Q(t,n,e,r,i){const s=n===i.maxZoom?0:i.tolerance/((1<<n)*i.extent),o={features:[],numPoints:0,numSimplified:0,numFeatures:t.length,source:null,x:e,y:r,z:n,transformed:!1,minX:2,minY:1,maxX:-1,maxY:0};for(const n of t)tt(o,n,s,i);return o}function tt(t,n,e,r){const i=n.geometry,s=n.type,o=[],a=r.hasAltitude?4:3;if(t.minX=Math.min(t.minX,n.minX),t.minY=Math.min(t.minY,n.minY),t.maxX=Math.max(t.maxX,n.maxX),t.maxY=Math.max(t.maxY,n.maxY),"Point"===s||"MultiPoint"===s)for(let n=0;n<i.length;n+=a)o.push(i[n],i[n+1]),r.hasAltitude&&o.push(i[n+3]),t.numPoints++,t.numSimplified++;else if("LineString"===s)et(o,i,t,e,!1,!1,r);else if("MultiLineString"===s||"Polygon"===s)for(let n=0;n<i.length;n++)et(o,i[n],t,e,"Polygon"===s,0===n,r);else if("MultiPolygon"===s)for(let n=0;n<i.length;n++){const s=i[n];for(let n=0;n<s.length;n++)et(o,s[n],t,e,!0,0===n,r)}if(o.length){let e=n.tags||null;if("LineString"===s&&r.lineMetrics){e={};for(const t in n.tags)e[t]=n.tags[t];e.mapbox_clip_start=i.start/i.size,e.mapbox_clip_end=i.end/i.size}const a={geometry:o,type:"Polygon"===s||"MultiPolygon"===s?3:"LineString"===s||"MultiLineString"===s?2:1,tags:e};n.layer&&(a.layer=n.layer),null!==n.id&&(a.id=n.id),t.features.push(a)}}function nt(t,n,e){return 0===t[n+2]&&t[n+3]>0&&e}function et(t,n,e,r,i,s,o){const a=r*r,{hasAltitude:u,disableFilter:l}=o,h=u?4:3;if(!l&&r>0&&n.size<(i?a:r))return void(e.numPoints+=n.length/h);const c=[];for(let t=0;t<n.length;t+=h)(0===r||n[t+2]>a||nt(n,t,u))&&(e.numSimplified++,c.push(n[t],n[t+1]),u&&c.push(n[t+3])),e.numPoints++;i&&function(t,n,e){const r=e?3:2;let i=0;for(let n=0,e=t.length,s=e-r;n<e;s=n,n+=r)i+=(t[n]-t[s])*(t[n+1]+t[s+1]);if(i>0===n){const n=r,i=r-1,s=r-2;for(let o=0,a=t.length;o<a/2;o+=r){const r=t[o],u=t[o+1];let l;e&&(l=t[o+2]),t[o]=t[a-n-o],t[o+1]=t[a-i-o],e&&(t[o+2]=t[a-s-o]),t[a-n-o]=r,t[a-i-o]=u,e&&(t[a-s-o]=l)}}}(c,s,u),t.push(c)}O.getJSON=function(t,n,e){if(F(n)){const t=e;e=n,n=t}const r=function(t,n){const r="string"==typeof n?JSON.parse(n):n||null;e(t,r)};return n&&n.jsonp?O.jsonp(t,r):((n=n||{}).returnJSON=!0,O.get(t,n,r))};const rt={maxZoom:14,indexMaxZoom:5,indexMaxPoints:1e5,tolerance:3,extent:4096,buffer:64,lineMetrics:!1,promoteId:null,generateId:!1,hasAltitude:!1,disableFilter:!1,debug:0};class it{constructor(t,n){const e=(n=this.options=function(t,n){for(const e in n)t[e]=n[e];return t}(Object.create(rt),n)).debug;if(e&&console.time("preprocess data"),n.maxZoom<0||n.maxZoom>24)throw new Error("maxZoom should be in the 0-24 range");if(n.promoteId&&n.generateId)throw new Error("promoteId and generateId cannot be used together.");let r=function(t,n){const e=[];if(Array.isArray(t)){for(let r=0;r<t.length;r++)C(e,t[r].layer,t[r].data,n);return e}if("FeatureCollection"===t.type)for(let r=0;r<t.features.length;r++)T(e,t.features[r],n,r);else"Feature"===t.type?T(e,t,n):T(e,{geometry:t},n);return e}(t,n);this.tiles={},this.tileCoords=[],e&&(console.timeEnd("preprocess data"),console.log("index: maxZoom: %d, maxPoints: %d",n.indexMaxZoom,n.indexMaxPoints),console.time("generate tiles"),this.stats={},this.total=0),r=function(t,n){const e=n.buffer/n.extent;let r=t;const i=L(t,1,-1-e,e,0,-1,2,n),s=L(t,1,1-e,2+e,0,-1,2,n);return(i||s)&&(r=L(t,1,-e,1+e,0,-1,2,n)||[],i&&(r=X(i,1,n.hasAltitude).concat(r)),s&&(r=r.concat(X(s,-1,n.hasAltitude)))),r}(r,n),r.length&&this.splitTile(r,0,0,0),e&&(r.length&&console.log("features: %d, points: %d",this.tiles[0].numFeatures,this.tiles[0].numPoints),console.timeEnd("generate tiles"),console.log("tiles generated:",this.total,JSON.stringify(this.stats)))}splitTile(t,n,e,r,i,s,o){const a=[t,n,e,r],u=this.options,l=u.debug;for(;a.length;){r=a.pop(),e=a.pop(),n=a.pop(),t=a.pop();const h=1<<n,c=st(n,e,r);let f=this.tiles[c];if(!f&&(l>1&&console.time("creation"),f=this.tiles[c]=Q(t,n,e,r,u),this.tileCoords.push({z:n,x:e,y:r}),l)){l>1&&(console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",n,e,r,f.numFeatures,f.numPoints,f.numSimplified),console.timeEnd("creation"));const t="z"+n;this.stats[t]=(this.stats[t]||0)+1,this.total++}if(f.source=t,null==i){if(n===u.indexMaxZoom||f.numPoints<=u.indexMaxPoints)continue}else{if(n===u.maxZoom||n===i)continue;if(null!=i){const t=i-n;if(e!==s>>t||r!==o>>t)continue}}if(f.source=null,0===t.length)continue;l>1&&console.time("clipping");const d=.5*u.buffer/u.extent,p=.5-d,y=.5+d,m=1+d;let g=null,v=null,b=null,w=null,M=L(t,h,e-d,e+y,0,f.minX,f.maxX,u),x=L(t,h,e+p,e+m,0,f.minX,f.maxX,u);t=null,M&&(g=L(M,h,r-d,r+y,1,f.minY,f.maxY,u),v=L(M,h,r+p,r+m,1,f.minY,f.maxY,u),M=null),x&&(b=L(x,h,r-d,r+y,1,f.minY,f.maxY,u),w=L(x,h,r+p,r+m,1,f.minY,f.maxY,u),x=null),l>1&&console.timeEnd("clipping"),a.push(g||[],n+1,2*e,2*r),a.push(v||[],n+1,2*e,2*r+1),a.push(b||[],n+1,2*e+1,2*r),a.push(w||[],n+1,2*e+1,2*r+1)}}getTile(t,n,e){t=+t,n=+n,e=+e;const r=this.options,{extent:i,debug:s}=r,{hasAltitude:o,wrapX:a}=r;if(t<0||t>24)return null;if(a){const e=1<<t;n=n+e&e-1}const u=st(t,n,e);if(this.tiles[u])return Z(this.tiles[u],i,o);s>1&&console.log("drilling down to z%d-%d-%d",t,n,e);let l,h=t,c=n,f=e;for(;!l&&h>0;)h--,c>>=1,f>>=1,l=this.tiles[st(h,c,f)];return l&&l.source?(s>1&&(console.log("found parent tile z%d-%d-%d",h,c,f),console.time("drilling down")),this.splitTile(l.source,h,c,f,t,n,e),s>1&&console.timeEnd("drilling down"),this.tiles[u]?Z(this.tiles[u],i,o):null):null}}function st(t,n,e){return 32*((1<<t)*e+n)+t}function ot(t,n,e,r,i,s,o){const a=e&&Array.isArray(e[0]);for(let u=0,l=e.length;u<l;u++){t[n]=(a?e[u][0]:e[u].x)*r,t[n+1]=(a?e[u][1]:e[u].y)*r,o!==Float32Array&&(t[n]=Math.round(t[n]),t[n+1]=Math.round(t[n+1]));let h=i||0;Array.isArray(i)&&(h=i[u]),h=h?Math.round(r*h):0,t[n+2]=h,n+=3,s&&0!==u&&u!==l-1&&(t[n]=t[n-3],t[n+1]=t[n-2],t[n+2]=t[n-1],n+=3)}return t.trySetLength&&t.trySetLength(n),n}function at(t,n,e,r){const i=t[3*n],s=t[3*n+1],o=t[3*e],a=t[3*e+1];return i===o&&(i<0||i>r)||s===a&&(s<0||s>r)}var ut="undefined"!=typeof Float32Array?Float32Array:Array;function lt(){var t=new ut(3);return ut!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function ht(t,n,e){var r=new ut(3);return r[0]=t,r[1]=n,r[2]=e,r}function ct(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t}function ft(t,n,e,r){return t[0]=n,t[1]=e,t[2]=r,t}function dt(t,n,e){return t[0]=n[0]+e[0],t[1]=n[1]+e[1],t[2]=n[2]+e[2],t}function pt(t,n){var e=n[0],r=n[1],i=n[2],s=e*e+r*r+i*i;return s>0&&(s=1/Math.sqrt(s),t[0]=n[0]*s,t[1]=n[1]*s,t[2]=n[2]*s),t}function yt(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]}function mt(t,n,e){var r=n[0],i=n[1],s=n[2],o=e[0],a=e[1],u=e[2];return t[0]=i*u-s*a,t[1]=s*o-r*u,t[2]=r*a-i*o,t}var gt=function(t,n,e){return t[0]=n[0]-e[0],t[1]=n[1]-e[1],t[2]=n[2]-e[2],t};function vt(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t}function bt(t,n,e,r,i){return t[0]=n,t[1]=e,t[2]=r,t[3]=i,t}function wt(t,n,e){return t[0]=n[0]/e[0],t[1]=n[1]/e[1],t[2]=n[2]/e[2],t[3]=n[3]/e[3],t}function Mt(t,n,e){return t[0]=n[0]*e,t[1]=n[1]*e,t[2]=n[2]*e,t[3]=n[3]*e,t}function xt(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]}function Ft(){var t=new ut(4);return ut!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t[3]=1,t}function At(t,n){var e=n[0]+n[4]+n[8],r=void 0;if(e>0)r=Math.sqrt(e+1),t[3]=.5*r,r=.5/r,t[0]=(n[5]-n[7])*r,t[1]=(n[6]-n[2])*r,t[2]=(n[1]-n[3])*r;else{var i=0;n[4]>n[0]&&(i=1),n[8]>n[3*i+i]&&(i=2);var s=(i+1)%3,o=(i+2)%3;r=Math.sqrt(n[3*i+i]-n[3*s+s]-n[3*o+o]+1),t[i]=.5*r,r=.5/r,t[3]=(n[3*s+o]-n[3*o+s])*r,t[s]=(n[3*s+i]+n[3*i+s])*r,t[o]=(n[3*o+i]+n[3*i+o])*r}return t}!function(){var t=lt()}(),function(){var t,n=(t=new ut(4),ut!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t)}();var kt,Pt=Mt,St=function(t,n){var e=n[0],r=n[1],i=n[2],s=n[3],o=e*e+r*r+i*i+s*s;return o>0&&(o=1/Math.sqrt(o),t[0]=e*o,t[1]=r*o,t[2]=i*o,t[3]=s*o),t};function _t(t,n,e){return t[0]=n,t[1]=e,t}function Ot(t,n){var e=n[0]-t[0],r=n[1]-t[1];return Math.sqrt(e*e+r*r)}lt(),ht(1,0,0),ht(0,1,0),Ft(),Ft(),kt=new ut(9),ut!=Float32Array&&(kt[1]=0,kt[2]=0,kt[3]=0,kt[5]=0,kt[6]=0,kt[7]=0),kt[0]=1,kt[4]=1,kt[8]=1;var Et=function(t){var n=t[0],e=t[1];return Math.sqrt(n*n+e*e)};!function(){var t=function(){var t=new ut(2);return ut!=Float32Array&&(t[0]=0,t[1]=0),t}()}();const It=Math.PI/180,$t=6378137*Math.PI/180;function Ct(t,n,e){if("EPSG:3857"===e)return function(t,n){const e=85.0511287798,r=n[0],i=Math.max(Math.min(e,n[1]),-e);let s;s=0===i?0:Math.log(Math.tan((90+i)*It/2))/It;return t[0]=r*$t,t[1]=s*$t,t}(t,n);if("EPSG:4326"===e||"EPSG:4490"===e||"identity"===e)return Tt(t,n);if("baidu"===e)return Tt(t,n);throw new Error("unsupported projection:"+e)}function Tt(t,n){return t[0]=n[0],t[1]=n[1],t}function zt(t,n,e,r,i,s,o,a,u,l,h,c,f,d,p){0===t?function(t,n,e,r,i,s,o,a,u,l){const h=1/(100*s[0]),c=1/(100*s[1]),f=l&&l[0]||0,d=l&&l[1]||0,p=[0,0];for(let i=t;i<n;i+=3){const t=i/3*2,n=r[i]-f,s=r[i+1]-d;e[t]=p[0]+n/o*h/a,e[t+1]=p[1]-s/o*c/u}}(n,e,r,i,0,o,a,u,l,p):1===t&&function(t,n,e,r,i,s,o,a,u,l,h){if(!t)return;let c,f,d,p;0===t[4]?(c=t[0],f=t[1],d=t[2],p=t[3]):(c=t[1],f=t[2],d=t[3],p=t[0]);const y=Ot(c,f),m=Ot(f,d),g=[],v=[],b=[];for(let t=n;t<e;t+=3){const n=t/3*2,e=(s.x/u+i[t]/o)*a,d=s.y/u*a+(h?i[t+1]:-i[t+1])/o*a;_t(g,e,d),"EPSG:4326"!==l&&"EPSG:4490"!==l||Ct(g,g,"EPSG:3857"),Dt(v,g,c,f),Dt(b,g,p,c),r[n]=Ot(c,v)/y,r[n+1]=Ot(c,b)/m}}(h,n,e,r,i,s,a,c,f,d,!!p)}function Dt(t,n,e,r){const i=e[0]-r[0],s=e[1]-r[1];let o=(n[0]-e[0])*(e[0]-r[0])+(n[1]-e[1])*(e[1]-r[1]);return o/=i*i+s*s,t[0]=e[0]+o*i,t[1]=e[1]+o*s,t}function jt(t,n,e,r,i){const s=3*n[e-1],o=3*n[e-1]+1,a=t[s],u=t[o];return l=r,h=i,c=a,f=u,Math.sqrt((c-l)*(c-l)+(f-h)*(f-h));var l,h,c,f}"undefined"!=typeof undefinedThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof undefined?global:"undefined"!=typeof self&&self;var Ut=Nt;function Nt(t,n){this.x=t,this.y=n}function Lt(t,n,e){e=e||{},this.w=t||64,this.h=n||64,this.autoResize=!!e.autoResize,this.shelves=[],this.freebins=[],this.stats={},this.bins={},this.maxId=0}function Vt(t,n,e){this.x=0,this.y=t,this.w=this.free=n,this.h=e}function Rt(t,n,e,r,i,s,o){this.id=t,this.x=n,this.y=e,this.w=r,this.h=i,this.maxw=s||r,this.maxh=o||i,this.refcount=0}Nt.prototype={clone:function(){return new Nt(this.x,this.y)},add:function(t){return this.clone().m(t)},sub:function(t){return this.clone().M(t)},multByPoint:function(t){return this.clone().F(t)},divByPoint:function(t){return this.clone().A(t)},mult:function(t){return this.clone().k(t)},div:function(t){return this.clone().P(t)},rotate:function(t){return this.clone().S(t)},rotateAround:function(t,n){return this.clone()._(t,n)},matMult:function(t){return this.clone().O(t)},unit:function(){return this.clone().I()},perp:function(){return this.clone().C()},round:function(){return this.clone().T()},mag:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},equals:function(t){return this.x===t.x&&this.y===t.y},dist:function(t){return Math.sqrt(this.distSqr(t))},distSqr:function(t){var n=t.x-this.x,e=t.y-this.y;return n*n+e*e},angle:function(){return Math.atan2(this.y,this.x)},angleTo:function(t){return Math.atan2(this.y-t.y,this.x-t.x)},angleWith:function(t){return this.angleWithSep(t.x,t.y)},angleWithSep:function(t,n){return Math.atan2(this.x*n-this.y*t,this.x*t+this.y*n)},O:function(t){var n=t[0]*this.x+t[1]*this.y,e=t[2]*this.x+t[3]*this.y;return this.x=n,this.y=e,this},m:function(t){return this.x+=t.x,this.y+=t.y,this},M:function(t){return this.x-=t.x,this.y-=t.y,this},k:function(t){return this.x*=t,this.y*=t,this},P:function(t){return this.x/=t,this.y/=t,this},F:function(t){return this.x*=t.x,this.y*=t.y,this},A:function(t){return this.x/=t.x,this.y/=t.y,this},I:function(){return this.P(this.mag()),this},C:function(){var t=this.y;return this.y=this.x,this.x=-t,this},S:function(t){var n=Math.cos(t),e=Math.sin(t),r=n*this.x-e*this.y,i=e*this.x+n*this.y;return this.x=r,this.y=i,this},_:function(t,n){var e=Math.cos(t),r=Math.sin(t),i=n.x+e*(this.x-n.x)-r*(this.y-n.y),s=n.y+r*(this.x-n.x)+e*(this.y-n.y);return this.x=i,this.y=s,this},T:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}},Nt.convert=function(t){return t instanceof Nt?t:Array.isArray(t)?new Nt(t[0],t[1]):t},Lt.prototype.pack=function(t,n){t=[].concat(t),n=n||{};for(var e,r,i,s,o=[],a=0;a<t.length;a++)if(e=t[a].w||t[a].width,r=t[a].h||t[a].height,i=t[a].id,e&&r){if(!(s=this.packOne(e,r,i)))continue;n.inPlace&&(t[a].x=s.x,t[a].y=s.y,t[a].id=s.id),o.push(s)}return this.shrink(),o},Lt.prototype.packOne=function(t,n,e){var r,i,s,o,a,u,l,h,c={freebin:-1,shelf:-1,waste:1/0},f=0;if("string"==typeof e||"number"==typeof e){if(r=this.getBin(e))return this.ref(r),r;"number"==typeof e&&(this.maxId=Math.max(e,this.maxId))}else e=++this.maxId;for(o=0;o<this.freebins.length;o++){if(n===(r=this.freebins[o]).maxh&&t===r.maxw)return this.allocFreebin(o,t,n,e);n>r.maxh||t>r.maxw||n<=r.maxh&&t<=r.maxw&&(s=r.maxw*r.maxh-t*n)<c.waste&&(c.waste=s,c.freebin=o)}for(o=0;o<this.shelves.length;o++)if(f+=(i=this.shelves[o]).h,!(t>i.free)){if(n===i.h)return this.allocShelf(o,t,n,e);n>i.h||n<i.h&&(s=(i.h-n)*t)<c.waste&&(c.freebin=-1,c.waste=s,c.shelf=o)}return-1!==c.freebin?this.allocFreebin(c.freebin,t,n,e):-1!==c.shelf?this.allocShelf(c.shelf,t,n,e):n<=this.h-f&&t<=this.w?(i=new Vt(f,this.w,n),this.allocShelf(this.shelves.push(i)-1,t,n,e)):this.autoResize?(a=u=this.h,((l=h=this.w)<=a||t>l)&&(h=2*Math.max(t,l)),(a<l||n>a)&&(u=2*Math.max(n,a)),this.resize(h,u),this.packOne(t,n,e)):null},Lt.prototype.allocFreebin=function(t,n,e,r){var i=this.freebins.splice(t,1)[0];return i.id=r,i.w=n,i.h=e,i.refcount=0,this.bins[r]=i,this.ref(i),i},Lt.prototype.allocShelf=function(t,n,e,r){var i=this.shelves[t].alloc(n,e,r);return this.bins[r]=i,this.ref(i),i},Lt.prototype.shrink=function(){if(this.shelves.length>0){for(var t=0,n=0,e=0;e<this.shelves.length;e++){var r=this.shelves[e];n+=r.h,t=Math.max(r.w-r.free,t)}this.resize(t,n)}},Lt.prototype.getBin=function(t){return this.bins[t]},Lt.prototype.ref=function(t){if(1==++t.refcount){var n=t.h;this.stats[n]=1+(0|this.stats[n])}return t.refcount},Lt.prototype.unref=function(t){return 0===t.refcount?0:(0==--t.refcount&&(this.stats[t.h]--,delete this.bins[t.id],this.freebins.push(t)),t.refcount)},Lt.prototype.clear=function(){this.shelves=[],this.freebins=[],this.stats={},this.bins={},this.maxId=0},Lt.prototype.resize=function(t,n){this.w=t,this.h=n;for(var e=0;e<this.shelves.length;e++)this.shelves[e].resize(t);return!0},Vt.prototype.alloc=function(t,n,e){if(t>this.free||n>this.h)return null;var r=this.x;return this.x+=t,this.free-=t,new Rt(e,r,this.y,t,n,t,this.h)},Vt.prototype.resize=function(t){return this.free+=t-this.w,this.w=t,!0};var Ht={exports:{}},Wt={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},qt={exports:{}},Gt=function(t){return!(!t||"string"==typeof t)&&(t instanceof Array||Array.isArray(t)||t.length>=0&&(t.splice instanceof Function||Object.getOwnPropertyDescriptor(t,t.length-1)&&"String"!==t.constructor.name))},Bt=Array.prototype.concat,Jt=Array.prototype.slice,Xt=qt.exports=function(t){for(var n=[],e=0,r=t.length;e<r;e++){var i=t[e];Gt(i)?n=Bt.call(n,Jt.call(i)):n.push(i)}return n};Xt.wrap=function(t){return function(){return t(Xt(arguments))}};var Yt=Wt,Zt=qt.exports,Kt=Object.hasOwnProperty,Qt=Object.create(null);for(var tn in Yt)Kt.call(Yt,tn)&&(Qt[Yt[tn]]=tn);var nn=Ht.exports={to:{},get:{}};function en(t,n,e){return Math.min(Math.max(n,t),e)}function rn(t){var n=Math.round(t).toString(16).toUpperCase();return n.length<2?"0"+n:n}nn.get=function(t){var n,e;switch(t.substring(0,3).toLowerCase()){case"hsl":n=nn.get.hsl(t),e="hsl";break;case"hwb":n=nn.get.hwb(t),e="hwb";break;default:n=nn.get.rgb(t),e="rgb"}return n?{model:e,value:n}:null},nn.get.rgb=function(t){if(!t)return null;var n,e,r,i=[0,0,0,1];if(n=t.match(/^#([a-f0-9]{6})([a-f0-9]{2})?$/i)){for(r=n[2],n=n[1],e=0;e<3;e++){var s=2*e;i[e]=parseInt(n.slice(s,s+2),16)}r&&(i[3]=parseInt(r,16)/255)}else if(n=t.match(/^#([a-f0-9]{3,4})$/i)){for(r=(n=n[1])[3],e=0;e<3;e++)i[e]=parseInt(n[e]+n[e],16);r&&(i[3]=parseInt(r+r,16)/255)}else if(n=t.match(/^rgba?\\(\\s*([+-]?\\d+)(?=[\\s,])\\s*(?:,\\s*)?([+-]?\\d+)(?=[\\s,])\\s*(?:,\\s*)?([+-]?\\d+)\\s*(?:[,|\\/]\\s*([+-]?[\\d\\.]+)(%?)\\s*)?\\)$/)){for(e=0;e<3;e++)i[e]=parseInt(n[e+1],0);n[4]&&(n[5]?i[3]=.01*parseFloat(n[4]):i[3]=parseFloat(n[4]))}else{if(!(n=t.match(/^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,?\\s*([+-]?[\\d\\.]+)\\%\\s*,?\\s*([+-]?[\\d\\.]+)\\%\\s*(?:[,|\\/]\\s*([+-]?[\\d\\.]+)(%?)\\s*)?\\)$/)))return(n=t.match(/^(\\w+)$/))?"transparent"===n[1]?[0,0,0,0]:Kt.call(Yt,n[1])?((i=Yt[n[1]])[3]=1,i):null:null;for(e=0;e<3;e++)i[e]=Math.round(2.55*parseFloat(n[e+1]));n[4]&&(n[5]?i[3]=.01*parseFloat(n[4]):i[3]=parseFloat(n[4]))}for(e=0;e<3;e++)i[e]=en(i[e],0,255);return i[3]=en(i[3],0,1),i},nn.get.hsl=function(t){if(!t)return null;var n=t.match(/^hsla?\\(\\s*([+-]?(?:\\d{0,3}\\.)?\\d+)(?:deg)?\\s*,?\\s*([+-]?[\\d\\.]+)%\\s*,?\\s*([+-]?[\\d\\.]+)%\\s*(?:[,|\\/]\\s*([+-]?(?=\\.\\d|\\d)(?:0|[1-9]\\d*)?(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\s*)?\\)$/);if(n){var e=parseFloat(n[4]);return[(parseFloat(n[1])%360+360)%360,en(parseFloat(n[2]),0,100),en(parseFloat(n[3]),0,100),en(isNaN(e)?1:e,0,1)]}return null},nn.get.hwb=function(t){if(!t)return null;var n=t.match(/^hwb\\(\\s*([+-]?\\d{0,3}(?:\\.\\d+)?)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?(?=\\.\\d|\\d)(?:0|[1-9]\\d*)?(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\s*)?\\)$/);if(n){var e=parseFloat(n[4]);return[(parseFloat(n[1])%360+360)%360,en(parseFloat(n[2]),0,100),en(parseFloat(n[3]),0,100),en(isNaN(e)?1:e,0,1)]}return null},nn.to.hex=function(){var t=Zt(arguments);return"#"+rn(t[0])+rn(t[1])+rn(t[2])+(t[3]<1?rn(Math.round(255*t[3])):"")},nn.to.rgb=function(){var t=Zt(arguments);return t.length<4||1===t[3]?"rgb("+Math.round(t[0])+", "+Math.round(t[1])+", "+Math.round(t[2])+")":"rgba("+Math.round(t[0])+", "+Math.round(t[1])+", "+Math.round(t[2])+", "+t[3]+")"},nn.to.rgb.percent=function(){var t=Zt(arguments),n=Math.round(t[0]/255*100),e=Math.round(t[1]/255*100),r=Math.round(t[2]/255*100);return t.length<4||1===t[3]?"rgb("+n+"%, "+e+"%, "+r+"%)":"rgba("+n+"%, "+e+"%, "+r+"%, "+t[3]+")"},nn.to.hsl=function(){var t=Zt(arguments);return t.length<4||1===t[3]?"hsl("+t[0]+", "+t[1]+"%, "+t[2]+"%)":"hsla("+t[0]+", "+t[1]+"%, "+t[2]+"%, "+t[3]+")"},nn.to.hwb=function(){var t=Zt(arguments),n="";return t.length>=4&&1!==t[3]&&(n=", "+t[3]),"hwb("+t[0]+", "+t[1]+"%, "+t[2]+"%"+n+")"},nn.to.keyword=function(t){return Qt[t.slice(0,3)]};var sn={exports:{}},on=Wt,an={};for(var un in on)on.hasOwnProperty(un)&&(an[on[un]]=un);var ln=sn.exports={rgb:{channels:3,labels:"rgb"},hsl:{channels:3,labels:"hsl"},hsv:{channels:3,labels:"hsv"},hwb:{channels:3,labels:"hwb"},cmyk:{channels:4,labels:"cmyk"},xyz:{channels:3,labels:"xyz"},lab:{channels:3,labels:"lab"},lch:{channels:3,labels:"lch"},hex:{channels:1,labels:["hex"]},keyword:{channels:1,labels:["keyword"]},ansi16:{channels:1,labels:["ansi16"]},ansi256:{channels:1,labels:["ansi256"]},hcg:{channels:3,labels:["h","c","g"]},apple:{channels:3,labels:["r16","g16","b16"]},gray:{channels:1,labels:["gray"]}};for(var hn in ln)if(ln.hasOwnProperty(hn)){if(!("channels"in ln[hn]))throw new Error("missing channels property: "+hn);if(!("labels"in ln[hn]))throw new Error("missing channel labels property: "+hn);if(ln[hn].labels.length!==ln[hn].channels)throw new Error("channel and label counts mismatch: "+hn);var cn=ln[hn].channels,fn=ln[hn].labels;delete ln[hn].channels,delete ln[hn].labels,Object.defineProperty(ln[hn],"channels",{value:cn}),Object.defineProperty(ln[hn],"labels",{value:fn})}function dn(t,n){return Math.pow(t[0]-n[0],2)+Math.pow(t[1]-n[1],2)+Math.pow(t[2]-n[2],2)}ln.rgb.hsl=function(t){var n,e,r=t[0]/255,i=t[1]/255,s=t[2]/255,o=Math.min(r,i,s),a=Math.max(r,i,s),u=a-o;return a===o?n=0:r===a?n=(i-s)/u:i===a?n=2+(s-r)/u:s===a&&(n=4+(r-i)/u),(n=Math.min(60*n,360))<0&&(n+=360),e=(o+a)/2,[n,100*(a===o?0:e<=.5?u/(a+o):u/(2-a-o)),100*e]},ln.rgb.hsv=function(t){var n,e,r,i,s,o=t[0]/255,a=t[1]/255,u=t[2]/255,l=Math.max(o,a,u),h=l-Math.min(o,a,u),c=function(t){return(l-t)/6/h+.5};return 0===h?i=s=0:(s=h/l,n=c(o),e=c(a),r=c(u),o===l?i=r-e:a===l?i=1/3+n-r:u===l&&(i=2/3+e-n),i<0?i+=1:i>1&&(i-=1)),[360*i,100*s,100*l]},ln.rgb.hwb=function(t){var n=t[0],e=t[1],r=t[2];return[ln.rgb.hsl(t)[0],100*(1/255*Math.min(n,Math.min(e,r))),100*(r=1-1/255*Math.max(n,Math.max(e,r)))]},ln.rgb.cmyk=function(t){var n,e=t[0]/255,r=t[1]/255,i=t[2]/255;return[100*((1-e-(n=Math.min(1-e,1-r,1-i)))/(1-n)||0),100*((1-r-n)/(1-n)||0),100*((1-i-n)/(1-n)||0),100*n]},ln.rgb.keyword=function(t){var n=an[t];if(n)return n;var e,r=1/0;for(var i in on)if(on.hasOwnProperty(i)){var s=dn(t,on[i]);s<r&&(r=s,e=i)}return e},ln.keyword.rgb=function(t){return on[t]},ln.rgb.xyz=function(t){var n=t[0]/255,e=t[1]/255,r=t[2]/255;return[100*(.4124*(n=n>.04045?Math.pow((n+.055)/1.055,2.4):n/12.92)+.3576*(e=e>.04045?Math.pow((e+.055)/1.055,2.4):e/12.92)+.1805*(r=r>.04045?Math.pow((r+.055)/1.055,2.4):r/12.92)),100*(.2126*n+.7152*e+.0722*r),100*(.0193*n+.1192*e+.9505*r)]},ln.rgb.lab=function(t){var n=ln.rgb.xyz(t),e=n[0],r=n[1],i=n[2];return r/=100,i/=108.883,e=(e/=95.047)>.008856?Math.pow(e,1/3):7.787*e+16/116,[116*(r=r>.008856?Math.pow(r,1/3):7.787*r+16/116)-16,500*(e-r),200*(r-(i=i>.008856?Math.pow(i,1/3):7.787*i+16/116))]},ln.hsl.rgb=function(t){var n,e,r,i,s,o=t[0]/360,a=t[1]/100,u=t[2]/100;if(0===a)return[s=255*u,s,s];n=2*u-(e=u<.5?u*(1+a):u+a-u*a),i=[0,0,0];for(var l=0;l<3;l++)(r=o+1/3*-(l-1))<0&&r++,r>1&&r--,s=6*r<1?n+6*(e-n)*r:2*r<1?e:3*r<2?n+(e-n)*(2/3-r)*6:n,i[l]=255*s;return i},ln.hsl.hsv=function(t){var n=t[0],e=t[1]/100,r=t[2]/100,i=e,s=Math.max(r,.01);return e*=(r*=2)<=1?r:2-r,i*=s<=1?s:2-s,[n,100*(0===r?2*i/(s+i):2*e/(r+e)),100*((r+e)/2)]},ln.hsv.rgb=function(t){var n=t[0]/60,e=t[1]/100,r=t[2]/100,i=Math.floor(n)%6,s=n-Math.floor(n),o=255*r*(1-e),a=255*r*(1-e*s),u=255*r*(1-e*(1-s));switch(r*=255,i){case 0:return[r,u,o];case 1:return[a,r,o];case 2:return[o,r,u];case 3:return[o,a,r];case 4:return[u,o,r];case 5:return[r,o,a]}},ln.hsv.hsl=function(t){var n,e,r,i=t[0],s=t[1]/100,o=t[2]/100,a=Math.max(o,.01);return r=(2-s)*o,e=s*a,[i,100*(e=(e/=(n=(2-s)*a)<=1?n:2-n)||0),100*(r/=2)]},ln.hwb.rgb=function(t){var n,e,r,i,s,o,a,u=t[0]/360,l=t[1]/100,h=t[2]/100,c=l+h;switch(c>1&&(l/=c,h/=c),r=6*u-(n=Math.floor(6*u)),0!=(1&n)&&(r=1-r),i=l+r*((e=1-h)-l),n){default:case 6:case 0:s=e,o=i,a=l;break;case 1:s=i,o=e,a=l;break;case 2:s=l,o=e,a=i;break;case 3:s=l,o=i,a=e;break;case 4:s=i,o=l,a=e;break;case 5:s=e,o=l,a=i}return[255*s,255*o,255*a]},ln.cmyk.rgb=function(t){var n=t[0]/100,e=t[1]/100,r=t[2]/100,i=t[3]/100;return[255*(1-Math.min(1,n*(1-i)+i)),255*(1-Math.min(1,e*(1-i)+i)),255*(1-Math.min(1,r*(1-i)+i))]},ln.xyz.rgb=function(t){var n,e,r,i=t[0]/100,s=t[1]/100,o=t[2]/100;return e=-.9689*i+1.8758*s+.0415*o,r=.0557*i+-.204*s+1.057*o,n=(n=3.2406*i+-1.5372*s+-.4986*o)>.0031308?1.055*Math.pow(n,1/2.4)-.055:12.92*n,e=e>.0031308?1.055*Math.pow(e,1/2.4)-.055:12.92*e,r=r>.0031308?1.055*Math.pow(r,1/2.4)-.055:12.92*r,[255*(n=Math.min(Math.max(0,n),1)),255*(e=Math.min(Math.max(0,e),1)),255*(r=Math.min(Math.max(0,r),1))]},ln.xyz.lab=function(t){var n=t[0],e=t[1],r=t[2];return e/=100,r/=108.883,n=(n/=95.047)>.008856?Math.pow(n,1/3):7.787*n+16/116,[116*(e=e>.008856?Math.pow(e,1/3):7.787*e+16/116)-16,500*(n-e),200*(e-(r=r>.008856?Math.pow(r,1/3):7.787*r+16/116))]},ln.lab.xyz=function(t){var n,e,r,i=t[0];n=t[1]/500+(e=(i+16)/116),r=e-t[2]/200;var s=Math.pow(e,3),o=Math.pow(n,3),a=Math.pow(r,3);return e=s>.008856?s:(e-16/116)/7.787,n=o>.008856?o:(n-16/116)/7.787,r=a>.008856?a:(r-16/116)/7.787,[n*=95.047,e*=100,r*=108.883]},ln.lab.lch=function(t){var n,e=t[0],r=t[1],i=t[2];return(n=360*Math.atan2(i,r)/2/Math.PI)<0&&(n+=360),[e,Math.sqrt(r*r+i*i),n]},ln.lch.lab=function(t){var n,e=t[0],r=t[1];return n=t[2]/360*2*Math.PI,[e,r*Math.cos(n),r*Math.sin(n)]},ln.rgb.ansi16=function(t){var n=t[0],e=t[1],r=t[2],i=1 in arguments?arguments[1]:ln.rgb.hsv(t)[2];if(0===(i=Math.round(i/50)))return 30;var s=30+(Math.round(r/255)<<2|Math.round(e/255)<<1|Math.round(n/255));return 2===i&&(s+=60),s},ln.hsv.ansi16=function(t){return ln.rgb.ansi16(ln.hsv.rgb(t),t[2])},ln.rgb.ansi256=function(t){var n=t[0],e=t[1],r=t[2];return n===e&&e===r?n<8?16:n>248?231:Math.round((n-8)/247*24)+232:16+36*Math.round(n/255*5)+6*Math.round(e/255*5)+Math.round(r/255*5)},ln.ansi16.rgb=function(t){var n=t%10;if(0===n||7===n)return t>50&&(n+=3.5),[n=n/10.5*255,n,n];var e=.5*(1+~~(t>50));return[(1&n)*e*255,(n>>1&1)*e*255,(n>>2&1)*e*255]},ln.ansi256.rgb=function(t){if(t>=232){var n=10*(t-232)+8;return[n,n,n]}var e;return t-=16,[Math.floor(t/36)/5*255,Math.floor((e=t%36)/6)/5*255,e%6/5*255]},ln.rgb.hex=function(t){var n=(((255&Math.round(t[0]))<<16)+((255&Math.round(t[1]))<<8)+(255&Math.round(t[2]))).toString(16).toUpperCase();return"000000".substring(n.length)+n},ln.hex.rgb=function(t){var n=t.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);if(!n)return[0,0,0];var e=n[0];3===n[0].length&&(e=e.split("").map((function(t){return t+t})).join(""));var r=parseInt(e,16);return[r>>16&255,r>>8&255,255&r]},ln.rgb.hcg=function(t){var n,e=t[0]/255,r=t[1]/255,i=t[2]/255,s=Math.max(Math.max(e,r),i),o=Math.min(Math.min(e,r),i),a=s-o;return n=a<=0?0:s===e?(r-i)/a%6:s===r?2+(i-e)/a:4+(e-r)/a+4,n/=6,[360*(n%=1),100*a,100*(a<1?o/(1-a):0)]},ln.hsl.hcg=function(t){var n=t[1]/100,e=t[2]/100,r=1,i=0;return(r=e<.5?2*n*e:2*n*(1-e))<1&&(i=(e-.5*r)/(1-r)),[t[0],100*r,100*i]},ln.hsv.hcg=function(t){var n=t[1]/100,e=t[2]/100,r=n*e,i=0;return r<1&&(i=(e-r)/(1-r)),[t[0],100*r,100*i]},ln.hcg.rgb=function(t){var n=t[0]/360,e=t[1]/100,r=t[2]/100;if(0===e)return[255*r,255*r,255*r];var i,s=[0,0,0],o=n%1*6,a=o%1,u=1-a;switch(Math.floor(o)){case 0:s[0]=1,s[1]=a,s[2]=0;break;case 1:s[0]=u,s[1]=1,s[2]=0;break;case 2:s[0]=0,s[1]=1,s[2]=a;break;case 3:s[0]=0,s[1]=u,s[2]=1;break;case 4:s[0]=a,s[1]=0,s[2]=1;break;default:s[0]=1,s[1]=0,s[2]=u}return i=(1-e)*r,[255*(e*s[0]+i),255*(e*s[1]+i),255*(e*s[2]+i)]},ln.hcg.hsv=function(t){var n=t[1]/100,e=n+t[2]/100*(1-n),r=0;return e>0&&(r=n/e),[t[0],100*r,100*e]},ln.hcg.hsl=function(t){var n=t[1]/100,e=t[2]/100*(1-n)+.5*n,r=0;return e>0&&e<.5?r=n/(2*e):e>=.5&&e<1&&(r=n/(2*(1-e))),[t[0],100*r,100*e]},ln.hcg.hwb=function(t){var n=t[1]/100,e=n+t[2]/100*(1-n);return[t[0],100*(e-n),100*(1-e)]},ln.hwb.hcg=function(t){var n=t[1]/100,e=1-t[2]/100,r=e-n,i=0;return r<1&&(i=(e-r)/(1-r)),[t[0],100*r,100*i]},ln.apple.rgb=function(t){return[t[0]/65535*255,t[1]/65535*255,t[2]/65535*255]},ln.rgb.apple=function(t){return[t[0]/255*65535,t[1]/255*65535,t[2]/255*65535]},ln.gray.rgb=function(t){return[t[0]/100*255,t[0]/100*255,t[0]/100*255]},ln.gray.hsl=ln.gray.hsv=function(t){return[0,0,t[0]]},ln.gray.hwb=function(t){return[0,100,t[0]]},ln.gray.cmyk=function(t){return[0,0,0,t[0]]},ln.gray.lab=function(t){return[t[0],0,0]},ln.gray.hex=function(t){var n=255&Math.round(t[0]/100*255),e=((n<<16)+(n<<8)+n).toString(16).toUpperCase();return"000000".substring(e.length)+e},ln.rgb.gray=function(t){return[(t[0]+t[1]+t[2])/3/255*100]};var pn=sn.exports;function yn(t){var n=function(){for(var t={},n=Object.keys(pn),e=n.length,r=0;r<e;r++)t[n[r]]={distance:-1,parent:null};return t}(),e=[t];for(n[t].distance=0;e.length;)for(var r=e.pop(),i=Object.keys(pn[r]),s=i.length,o=0;o<s;o++){var a=i[o],u=n[a];-1===u.distance&&(u.distance=n[r].distance+1,u.parent=r,e.unshift(a))}return n}function mn(t,n){return function(e){return n(t(e))}}function gn(t,n){for(var e=[n[t].parent,t],r=pn[n[t].parent][t],i=n[t].parent;n[i].parent;)e.unshift(n[i].parent),r=mn(pn[n[i].parent][i],r),i=n[i].parent;return r.conversion=e,r}var vn=sn.exports,bn=function(t){for(var n=yn(t),e={},r=Object.keys(n),i=r.length,s=0;s<i;s++){var o=r[s];null!==n[o].parent&&(e[o]=gn(o,n))}return e},wn={};Object.keys(vn).forEach((function(t){wn[t]={},Object.defineProperty(wn[t],"channels",{value:vn[t].channels}),Object.defineProperty(wn[t],"labels",{value:vn[t].labels});var n=bn(t);Object.keys(n).forEach((function(e){var r=n[e];wn[t][e]=function(t){var n=function(n){if(null==n)return n;arguments.length>1&&(n=Array.prototype.slice.call(arguments));var e=t(n);if("object"==typeof e)for(var r=e.length,i=0;i<r;i++)e[i]=Math.round(e[i]);return e};return"conversion"in t&&(n.conversion=t.conversion),n}(r),wn[t][e].raw=function(t){var n=function(n){return null==n?n:(arguments.length>1&&(n=Array.prototype.slice.call(arguments)),t(n))};return"conversion"in t&&(n.conversion=t.conversion),n}(r)}))}));var Mn=wn,xn=Ht.exports,Fn=Mn,An=[].slice,kn=["keyword","gray","hex"],Pn={};Object.keys(Fn).forEach((function(t){Pn[An.call(Fn[t].labels).sort().join("")]=t}));var Sn={};function _n(t,n){if(!(this instanceof _n))return new _n(t,n);if(n&&n in kn&&(n=null),n&&!(n in Fn))throw new Error("Unknown model: "+n);var e,r;if(null==t)this.model="rgb",this.color=[0,0,0],this.valpha=1;else if(t instanceof _n)this.model=t.model,this.color=t.color.slice(),this.valpha=t.valpha;else if("string"==typeof t){var i=xn.get(t);if(null===i)throw new Error("Unable to parse color from string: "+t);this.model=i.model,r=Fn[this.model].channels,this.color=i.value.slice(0,r),this.valpha="number"==typeof i.value[r]?i.value[r]:1}else if(t.length){this.model=n||"rgb",r=Fn[this.model].channels;var s=An.call(t,0,r);this.color=$n(s,r),this.valpha="number"==typeof t[r]?t[r]:1}else if("number"==typeof t)t&=16777215,this.model="rgb",this.color=[t>>16&255,t>>8&255,255&t],this.valpha=1;else{this.valpha=1;var o=Object.keys(t);"alpha"in t&&(o.splice(o.indexOf("alpha"),1),this.valpha="number"==typeof t.alpha?t.alpha:0);var a=o.sort().join("");if(!(a in Pn))throw new Error("Unable to parse color from object: "+JSON.stringify(t));this.model=Pn[a];var u=Fn[this.model].labels,l=[];for(e=0;e<u.length;e++)l.push(t[u[e]]);this.color=$n(l)}if(Sn[this.model])for(r=Fn[this.model].channels,e=0;e<r;e++){var h=Sn[this.model][e];h&&(this.color[e]=h(this.color[e]))}this.valpha=Math.max(0,Math.min(1,this.valpha)),Object.freeze&&Object.freeze(this)}function On(t,n,e){return(t=Array.isArray(t)?t:[t]).forEach((function(t){(Sn[t]||(Sn[t]=[]))[n]=e})),t=t[0],function(r){var i;return arguments.length?(e&&(r=e(r)),(i=this[t]()).color[n]=r,i):(i=this[t]().color[n],e&&(i=e(i)),i)}}function En(t){return function(n){return Math.max(0,Math.min(t,n))}}function In(t){return Array.isArray(t)?t:[t]}function $n(t,n){for(var e=0;e<n;e++)"number"!=typeof t[e]&&(t[e]=0);return t}_n.prototype={toString:function(){return this.string()},toJSON:function(){return this[this.model]()},string:function(t){var n=this.model in xn.to?this:this.rgb(),e=1===(n=n.round("number"==typeof t?t:1)).valpha?n.color:n.color.concat(this.valpha);return xn.to[n.model](e)},percentString:function(t){var n=this.rgb().round("number"==typeof t?t:1),e=1===n.valpha?n.color:n.color.concat(this.valpha);return xn.to.rgb.percent(e)},array:function(){return 1===this.valpha?this.color.slice():this.color.concat(this.valpha)},object:function(){for(var t={},n=Fn[this.model].channels,e=Fn[this.model].labels,r=0;r<n;r++)t[e[r]]=this.color[r];return 1!==this.valpha&&(t.alpha=this.valpha),t},unitArray:function(){var t=this.rgb().color;return t[0]/=255,t[1]/=255,t[2]/=255,1!==this.valpha&&t.push(this.valpha),t},unitObject:function(){var t=this.rgb().object();return t.r/=255,t.g/=255,t.b/=255,1!==this.valpha&&(t.alpha=this.valpha),t},round:function(t){return t=Math.max(t||0,0),new _n(this.color.map(function(t){return function(n){return function(t,n){return Number(t.toFixed(n))}(n,t)}}(t)).concat(this.valpha),this.model)},alpha:function(t){return arguments.length?new _n(this.color.concat(Math.max(0,Math.min(1,t))),this.model):this.valpha},red:On("rgb",0,En(255)),green:On("rgb",1,En(255)),blue:On("rgb",2,En(255)),hue:On(["hsl","hsv","hsl","hwb","hcg"],0,(function(t){return(t%360+360)%360})),saturationl:On("hsl",1,En(100)),lightness:On("hsl",2,En(100)),saturationv:On("hsv",1,En(100)),value:On("hsv",2,En(100)),chroma:On("hcg",1,En(100)),gray:On("hcg",2,En(100)),white:On("hwb",1,En(100)),wblack:On("hwb",2,En(100)),cyan:On("cmyk",0,En(100)),magenta:On("cmyk",1,En(100)),yellow:On("cmyk",2,En(100)),black:On("cmyk",3,En(100)),x:On("xyz",0,En(100)),y:On("xyz",1,En(100)),z:On("xyz",2,En(100)),l:On("lab",0,En(100)),a:On("lab",1),b:On("lab",2),keyword:function(t){return arguments.length?new _n(t):Fn[this.model].keyword(this.color)},hex:function(t){return arguments.length?new _n(t):xn.to.hex(this.rgb().round().color)},rgbNumber:function(){var t=this.rgb().color;return(255&t[0])<<16|(255&t[1])<<8|255&t[2]},luminosity:function(){for(var t=this.rgb().color,n=[],e=0;e<t.length;e++){var r=t[e]/255;n[e]=r<=.03928?r/12.92:Math.pow((r+.055)/1.055,2.4)}return.2126*n[0]+.7152*n[1]+.0722*n[2]},contrast:function(t){var n=this.luminosity(),e=t.luminosity();return n>e?(n+.05)/(e+.05):(e+.05)/(n+.05)},level:function(t){var n=this.contrast(t);return n>=7.1?"AAA":n>=4.5?"AA":""},isDark:function(){var t=this.rgb().color;return(299*t[0]+587*t[1]+114*t[2])/1e3<128},isLight:function(){return!this.isDark()},negate:function(){for(var t=this.rgb(),n=0;n<3;n++)t.color[n]=255-t.color[n];return t},lighten:function(t){var n=this.hsl();return n.color[2]+=n.color[2]*t,n},darken:function(t){var n=this.hsl();return n.color[2]-=n.color[2]*t,n},saturate:function(t){var n=this.hsl();return n.color[1]+=n.color[1]*t,n},desaturate:function(t){var n=this.hsl();return n.color[1]-=n.color[1]*t,n},whiten:function(t){var n=this.hwb();return n.color[1]+=n.color[1]*t,n},blacken:function(t){var n=this.hwb();return n.color[2]+=n.color[2]*t,n},grayscale:function(){var t=this.rgb().color,n=.3*t[0]+.59*t[1]+.11*t[2];return _n.rgb(n,n,n)},fade:function(t){return this.alpha(this.valpha-this.valpha*t)},opaquer:function(t){return this.alpha(this.valpha+this.valpha*t)},rotate:function(t){var n=this.hsl(),e=n.color[0];return e=(e=(e+t)%360)<0?360+e:e,n.color[0]=e,n},mix:function(t,n){if(!t||!t.rgb)throw new Error(\'Argument to "mix" was not a Color instance, but rather an instance of \'+typeof t);var e=t.rgb(),r=this.rgb(),i=void 0===n?.5:n,s=2*i-1,o=e.alpha()-r.alpha(),a=((s*o==-1?s:(s+o)/(1+s*o))+1)/2,u=1-a;return _n.rgb(a*e.red()+u*r.red(),a*e.green()+u*r.green(),a*e.blue()+u*r.blue(),e.alpha()*i+r.alpha()*(1-i))}},Object.keys(Fn).forEach((function(t){if(-1===kn.indexOf(t)){var n=Fn[t].channels;_n.prototype[t]=function(){if(this.model===t)return new _n(this);if(arguments.length)return new _n(arguments,t);var e="number"==typeof arguments[n]?n:this.valpha;return new _n(In(Fn[this.model][t].raw(this.color)).concat(e),t)},_n[t]=function(e){return"number"==typeof e&&(e=$n(An.call(arguments),n)),new _n(e,t)}}}));var Cn=_n;\n/*!\n        Feature Filter by\n\n        (c) mapbox 2016 and maptalks 2018\n        www.mapbox.com | www.maptalks.org\n        License: MIT, header required.\n    */const Tn=["Unknown","Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon","GeometryCollection"];function zn(t){return new Function("f","var p = (f && f.properties || {}); return "+Dn(t))}function Dn(t){if(!t)return"true";const n=t[0];if(t.length<=1)return"any"===n?"false":"true";return`(${"=="===n?Un(t[1],t[2],"===",!1):"!="===n?Un(t[1],t[2],"!==",!1):"<"===n||">"===n||"<="===n||">="===n?Un(t[1],t[2],n,!0):"any"===n?Ln(t.slice(1),"||"):"all"===n?Ln(t.slice(1),"&&"):"none"===n?Hn(Ln(t.slice(1),"||")):"in"===n?Vn(t[1],t.slice(2)):"!in"===n?Hn(Vn(t[1],t.slice(2))):"has"===n?Rn(t[1]):"!has"===n?Hn(Rn(t[1])):"contains"===n?function(t,n,e){const r=jn(t);return void 0!==e?`(${r} + \'\').indexOf("${n}") === ${e}`:`(${r} + \'\').indexOf("${n}") >= 0`}(t[1],t[2],t[3]):"true"})`}function jn(t){return"$"===t[0]?"f."+t.substring(1):"p["+JSON.stringify(t)+"]"}function Un(t,n,e,r){if("object"==typeof(i=t)&&i&&t.op)return function(t,n,e,r){const i=t.property,s=t.op;let o=jn(i);return"length"!==s?(console.error(`not support ${s} op`),"false"):(o=`((${o}+=\'\').length)`,Nn(o,i,n,e,r))}(t,n,e,r);var i;return Nn(jn(t),t,n,e,r)}function Nn(t,n,e,r,i){const s="$type"===n?Tn.indexOf(e):JSON.stringify(e);return(i?`typeof ${t}=== typeof ${s}&&`:"")+t+r+s}function Ln(t,n){return t.map(Dn).join(n)}function Vn(t,n){"$type"===t&&(n=n.map(t=>Tn.indexOf(t)));const e=JSON.stringify(n.sort(Wn)),r=jn(t);return n.length<=200?`${e}.indexOf(${r}) !== -1`:`function(v, a, i, j) {\\n        while (i <= j) { var m = (i + j) >> 1;\\n            if (a[m] === v) return true; if (a[m] > v) j = m - 1; else i = m + 1;\\n        }\\n    return false; }(${r}, ${e},0,${n.length-1})`}function Rn(t){return"$id"===t?\'"id" in f\':JSON.stringify(t)+" in p"}function Hn(t){return`!(${t})`}function Wn(t,n){return t<n?-1:t>n?1:0}var qn={exports:{}};qn.exports=function(){function t(t,n,e){var r=t[n];t[n]=t[e],t[e]=r}function n(t,n){return t<n?-1:t>n?1:0}return function(e,r,i,s,o){!function n(e,r,i,s,o){for(;s>i;){if(s-i>600){var a=s-i+1,u=r-i+1,l=Math.log(a),h=.5*Math.exp(2*l/3),c=.5*Math.sqrt(l*h*(a-h)/a)*(u-a/2<0?-1:1),f=Math.max(i,Math.floor(r-u*h/a+c)),d=Math.min(s,Math.floor(r+(a-u)*h/a+c));n(e,r,f,d,o)}var p=e[r],y=i,m=s;for(t(e,i,r),o(e[s],p)>0&&t(e,i,s);y<m;){for(t(e,y,m),y++,m--;o(e[y],p)<0;)y++;for(;o(e[m],p)>0;)m--}0===o(e[i],p)?t(e,i,m):(m++,t(e,m,s)),m<=r&&(i=m+1),r<=m&&(s=m-1)}}(e,r,i||0,s||e.length-1,o||n)}}();var Gn=qn.exports;class Bn{constructor(t=[],n=Jn){if(this.data=t,this.length=this.data.length,this.compare=n,this.length>0)for(let t=(this.length>>1)-1;t>=0;t--)this.D(t)}push(t){this.data.push(t),this.length++,this.j(this.length-1)}pop(){if(0===this.length)return;const t=this.data[0],n=this.data.pop();return this.length--,this.length>0&&(this.data[0]=n,this.D(0)),t}peek(){return this.data[0]}j(t){const{data:n,compare:e}=this,r=n[t];for(;t>0;){const i=t-1>>1,s=n[i];if(e(r,s)>=0)break;n[t]=s,t=i}n[t]=r}D(t){const{data:n,compare:e}=this,r=this.length>>1,i=n[t];for(;t<r;){let r=1+(t<<1),s=n[r];const o=r+1;if(o<this.length&&e(n[o],s)<0&&(r=o,s=n[o]),e(s,i)>=0)break;n[t]=s,t=r}n[t]=i}}function Jn(t,n){return t<n?-1:t>n?1:0}\n/*!\n     * Contains code from google filament\n     * https://github.com/google/filament/\n     * License Apache-2.0\n     */const Xn=[],Yn=[],Zn=[],Kn=[];function Qn(t,n,e){const r=mt(Yn,n,e);t=At(t,function(t,n,e,r,i,s,o,a,u,l){return t[0]=n,t[1]=e,t[2]=r,t[3]=i,t[4]=s,t[5]=o,t[6]=a,t[7]=u,t[8]=l,t}(Xn,e[0],e[1],e[2],...r,...n));if((t=function(t){return t[3]<0?Pt(t,t,-1):t}(t=St(t,t)))[3]<1/32767){t[3]=1/32767;const n=Math.sqrt(.9999999990686206);t[0]*=n,t[1]*=n,t[2]*=n}const i=e[3]>0?mt(Zn,e,n):mt(Zn,n,e);return yt(mt(Kn,e,n),i)<0&&Pt(t,t,-1),t}const te=[];function ne(t,n,e){const r=e||[];r.setLength&&r.setLength(t.length);const i=te;i.length<t.length/3&&(i.length=t.length/3),i.fill(0,0,t.length/3);const s=void 0===n.length?n:n.length;for(let e=0;e<s/3;e++)void 0===n.length?le(t,3*e,3*e+1,3*e+2,r,i):le(t,n[3*e],n[3*e+1],n[3*e+2],r,i);for(let t=0;t<r.length;t+=3){const n=i[t/3];0!==n?(r[t]/=n,r[t+1]/=n,r[t+2]/=n):(r[t]=0,r[t+1]=0,r[t+2]=0)}return r}const ee=[],re=[],ie=[],se=[],oe=[],ae=[],ue=[];function le(t,n,e,r,i,s){ft(se,t[3*n],t[3*n+1],t[3*n+2]),ft(oe,t[3*e],t[3*e+1],t[3*e+2]),ft(ae,t[3*r],t[3*r+1],t[3*r+2]);const o=gt(ee,ae,oe),a=gt(re,se,oe),u=mt(ie,o,a);pt(ue,u),i[3*n]=i[3*n]||0,i[3*e]=i[3*e]||0,i[3*r]=i[3*r]||0,i[3*n+1]=i[3*n+1]||0,i[3*e+1]=i[3*e+1]||0,i[3*r+1]=i[3*r+1]||0,i[3*n+2]=i[3*n+2]||0,i[3*e+2]=i[3*e+2]||0,i[3*r+2]=i[3*r+2]||0,i[3*n]+=ue[0],i[3*e]+=ue[0],i[3*r]+=ue[0],i[3*n+1]+=ue[1],i[3*e+1]+=ue[1],i[3*r+1]+=ue[1],i[3*n+2]+=ue[2],i[3*e+2]+=ue[2],i[3*r+2]+=ue[2],s[n]+=1,s[e]+=1,s[r]+=1}\n/*!\n     * Contains code from THREE.JS\n     * https://github.com/mrdoob/three.js/\n     * License MIT\n     * \n     * Generate tangents per vertex.\n     */function he(t,n,e){return t[0]=n[e],t[1]=n[e+1],t[2]=n[e+2],t}function ce(t,n,e){return t[0]=n[e],t[1]=n[e+1],t}var fe={exports:{}};function de(t,n,e){e=e||2;var r,i,s,o,a,u,l,h=n&&n.length,c=h?n[0]*e:t.length,f=pe(t,0,c,e,!0),d=[];if(!f||f.next===f.prev)return d;if(h&&(f=function(t,n,e,r){var i,s,o,a,u,l=[];for(i=0,s=n.length;i<s;i++)o=n[i]*r,a=i<s-1?n[i+1]*r:t.length,(u=pe(t,o,a,r,!1))===u.next&&(u.steiner=!0),l.push(ke(u));for(l.sort(Me),i=0;i<l.length;i++)e=xe(l[i],e);return e}(t,n,f,e)),t.length>80*e){r=s=t[0],i=o=t[1];for(var p=e;p<c;p+=e)(a=t[p])<r&&(r=a),(u=t[p+1])<i&&(i=u),a>s&&(s=a),u>o&&(o=u);l=0!==(l=Math.max(s-r,o-i))?32767/l:0}return me(f,d,e,r,i,l,0),d}function pe(t,n,e,r,i){var s,o;if(i===Ue(t,n,e,r)>0)for(s=n;s<e;s+=r)o=ze(s,t[s],t[s+1],o);else for(s=e-r;s>=n;s-=r)o=ze(s,t[s],t[s+1],o);return o&&Oe(o,o.next)&&(De(o),o=o.next),o}function ye(t,n){if(!t)return t;n||(n=t);var e,r=t;do{if(e=!1,r.steiner||!Oe(r,r.next)&&0!==_e(r.prev,r,r.next))r=r.next;else{if(De(r),(r=n=r.prev)===r.next)break;e=!0}}while(e||r!==n);return n}function me(t,n,e,r,i,s,o){if(t){!o&&s&&function(t,n,e,r){var i=t;do{0===i.z&&(i.z=Ae(i.x,i.y,n,e,r)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next}while(i!==t);i.prevZ.nextZ=null,i.prevZ=null,function(t){var n,e,r,i,s,o,a,u,l=1;do{for(e=t,t=null,s=null,o=0;e;){for(o++,r=e,a=0,n=0;n<l&&(a++,r=r.nextZ);n++);for(u=l;a>0||u>0&&r;)0!==a&&(0===u||!r||e.z<=r.z)?(i=e,e=e.nextZ,a--):(i=r,r=r.nextZ,u--),s?s.nextZ=i:t=i,i.prevZ=s,s=i;e=r}s.nextZ=null,l*=2}while(o>1)}(i)}(t,r,i,s);for(var a,u,l=t;t.prev!==t.next;)if(a=t.prev,u=t.next,s?ve(t,r,i,s):ge(t))n.push(a.i/e|0),n.push(t.i/e|0),n.push(u.i/e|0),De(t),t=u.next,l=u.next;else if((t=u)===l){o?1===o?me(t=be(ye(t),n,e),n,e,r,i,s,2):2===o&&we(t,n,e,r,i,s):me(ye(t),n,e,r,i,s,1);break}}}function ge(t){var n=t.prev,e=t,r=t.next;if(_e(n,e,r)>=0)return!1;for(var i=n.x,s=e.x,o=r.x,a=n.y,u=e.y,l=r.y,h=i<s?i<o?i:o:s<o?s:o,c=a<u?a<l?a:l:u<l?u:l,f=i>s?i>o?i:o:s>o?s:o,d=a>u?a>l?a:l:u>l?u:l,p=r.next;p!==n;){if(p.x>=h&&p.x<=f&&p.y>=c&&p.y<=d&&Pe(i,a,s,u,o,l,p.x,p.y)&&_e(p.prev,p,p.next)>=0)return!1;p=p.next}return!0}function ve(t,n,e,r){var i=t.prev,s=t,o=t.next;if(_e(i,s,o)>=0)return!1;for(var a=i.x,u=s.x,l=o.x,h=i.y,c=s.y,f=o.y,d=a<u?a<l?a:l:u<l?u:l,p=h<c?h<f?h:f:c<f?c:f,y=a>u?a>l?a:l:u>l?u:l,m=h>c?h>f?h:f:c>f?c:f,g=Ae(d,p,n,e,r),v=Ae(y,m,n,e,r),b=t.prevZ,w=t.nextZ;b&&b.z>=g&&w&&w.z<=v;){if(b.x>=d&&b.x<=y&&b.y>=p&&b.y<=m&&b!==i&&b!==o&&Pe(a,h,u,c,l,f,b.x,b.y)&&_e(b.prev,b,b.next)>=0)return!1;if(b=b.prevZ,w.x>=d&&w.x<=y&&w.y>=p&&w.y<=m&&w!==i&&w!==o&&Pe(a,h,u,c,l,f,w.x,w.y)&&_e(w.prev,w,w.next)>=0)return!1;w=w.nextZ}for(;b&&b.z>=g;){if(b.x>=d&&b.x<=y&&b.y>=p&&b.y<=m&&b!==i&&b!==o&&Pe(a,h,u,c,l,f,b.x,b.y)&&_e(b.prev,b,b.next)>=0)return!1;b=b.prevZ}for(;w&&w.z<=v;){if(w.x>=d&&w.x<=y&&w.y>=p&&w.y<=m&&w!==i&&w!==o&&Pe(a,h,u,c,l,f,w.x,w.y)&&_e(w.prev,w,w.next)>=0)return!1;w=w.nextZ}return!0}function be(t,n,e){var r=t;do{var i=r.prev,s=r.next.next;!Oe(i,s)&&Ee(i,r,r.next,s)&&Ce(i,s)&&Ce(s,i)&&(n.push(i.i/e|0),n.push(r.i/e|0),n.push(s.i/e|0),De(r),De(r.next),r=t=s),r=r.next}while(r!==t);return ye(r)}function we(t,n,e,r,i,s){var o=t;do{for(var a=o.next.next;a!==o.prev;){if(o.i!==a.i&&Se(o,a)){var u=Te(o,a);return o=ye(o,o.next),u=ye(u,u.next),me(o,n,e,r,i,s,0),void me(u,n,e,r,i,s,0)}a=a.next}o=o.next}while(o!==t)}function Me(t,n){return t.x-n.x}function xe(t,n){var e=function(t,n){var e,r=n,i=t.x,s=t.y,o=-1/0;do{if(s<=r.y&&s>=r.next.y&&r.next.y!==r.y){var a=r.x+(s-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(a<=i&&a>o&&(o=a,e=r.x<r.next.x?r:r.next,a===i))return e}r=r.next}while(r!==n);if(!e)return null;var u,l=e,h=e.x,c=e.y,f=1/0;r=e;do{i>=r.x&&r.x>=h&&i!==r.x&&Pe(s<c?i:o,s,h,c,s<c?o:i,s,r.x,r.y)&&(u=Math.abs(s-r.y)/(i-r.x),Ce(r,t)&&(u<f||u===f&&(r.x>e.x||r.x===e.x&&Fe(e,r)))&&(e=r,f=u)),r=r.next}while(r!==l);return e}(t,n);if(!e)return n;var r=Te(e,t);return ye(r,r.next),ye(e,e.next)}function Fe(t,n){return _e(t.prev,t,n.prev)<0&&_e(n.next,t,t.next)<0}function Ae(t,n,e,r,i){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-e)*i|0)|t<<8))|t<<4))|t<<2))|t<<1))|(n=1431655765&((n=858993459&((n=252645135&((n=16711935&((n=(n-r)*i|0)|n<<8))|n<<4))|n<<2))|n<<1))<<1}function ke(t){var n=t,e=t;do{(n.x<e.x||n.x===e.x&&n.y<e.y)&&(e=n),n=n.next}while(n!==t);return e}function Pe(t,n,e,r,i,s,o,a){return(i-o)*(n-a)>=(t-o)*(s-a)&&(t-o)*(r-a)>=(e-o)*(n-a)&&(e-o)*(s-a)>=(i-o)*(r-a)}function Se(t,n){return t.next.i!==n.i&&t.prev.i!==n.i&&!function(t,n){var e=t;do{if(e.i!==t.i&&e.next.i!==t.i&&e.i!==n.i&&e.next.i!==n.i&&Ee(e,e.next,t,n))return!0;e=e.next}while(e!==t);return!1}(t,n)&&(Ce(t,n)&&Ce(n,t)&&function(t,n){var e=t,r=!1,i=(t.x+n.x)/2,s=(t.y+n.y)/2;do{e.y>s!=e.next.y>s&&e.next.y!==e.y&&i<(e.next.x-e.x)*(s-e.y)/(e.next.y-e.y)+e.x&&(r=!r),e=e.next}while(e!==t);return r}(t,n)&&(_e(t.prev,t,n.prev)||_e(t,n.prev,n))||Oe(t,n)&&_e(t.prev,t,t.next)>0&&_e(n.prev,n,n.next)>0)}function _e(t,n,e){return(n.y-t.y)*(e.x-n.x)-(n.x-t.x)*(e.y-n.y)}function Oe(t,n){return t.x===n.x&&t.y===n.y}function Ee(t,n,e,r){var i=$e(_e(t,n,e)),s=$e(_e(t,n,r)),o=$e(_e(e,r,t)),a=$e(_e(e,r,n));return i!==s&&o!==a||(!(0!==i||!Ie(t,e,n))||(!(0!==s||!Ie(t,r,n))||(!(0!==o||!Ie(e,t,r))||!(0!==a||!Ie(e,n,r)))))}function Ie(t,n,e){return n.x<=Math.max(t.x,e.x)&&n.x>=Math.min(t.x,e.x)&&n.y<=Math.max(t.y,e.y)&&n.y>=Math.min(t.y,e.y)}function $e(t){return t>0?1:t<0?-1:0}function Ce(t,n){return _e(t.prev,t,t.next)<0?_e(t,n,t.next)>=0&&_e(t,t.prev,n)>=0:_e(t,n,t.prev)<0||_e(t,t.next,n)<0}function Te(t,n){var e=new je(t.i,t.x,t.y),r=new je(n.i,n.x,n.y),i=t.next,s=n.prev;return t.next=n,n.prev=t,e.next=i,i.prev=e,r.next=e,e.prev=r,s.next=r,r.prev=s,r}function ze(t,n,e,r){var i=new je(t,n,e);return r?(i.next=r.next,i.prev=r,r.next.prev=i,r.next=i):(i.prev=i,i.next=i),i}function De(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function je(t,n,e){this.i=t,this.x=n,this.y=e,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function Ue(t,n,e,r){for(var i=0,s=n,o=e-r;s<e;s+=r)i+=(t[o]-t[s])*(t[s+1]+t[o+1]),o=s;return i}fe.exports=de,fe.exports.default=de,de.deviation=function(t,n,e,r){var i=n&&n.length,s=i?n[0]*e:t.length,o=Math.abs(Ue(t,0,s,e));if(i)for(var a=0,u=n.length;a<u;a++){var l=n[a]*e,h=a<u-1?n[a+1]*e:t.length;o-=Math.abs(Ue(t,l,h,e))}var c=0;for(a=0;a<r.length;a+=3){var f=r[a]*e,d=r[a+1]*e,p=r[a+2]*e;c+=Math.abs((t[f]-t[p])*(t[d+1]-t[f+1])-(t[f]-t[d])*(t[p+1]-t[f+1]))}return 0===o&&0===c?0:Math.abs((c-o)/o)},de.flatten=function(t){for(var n=t[0][0].length,e={vertices:[],holes:[],dimensions:n},r=0,i=0;i<t.length;i++){for(var s=0;s<t[i].length;s++)for(var o=0;o<n;o++)e.vertices.push(t[i][s][o]);i>0&&(r+=t[i-1].length,e.holes.push(r))}return e};var Ne=fe.exports;\n/*!\n     * @maptalks/vector-packer v0.95.0\n     * LICENSE : UNLICENSED\n     * (c) 2016-2024 maptalks.com\n     */const Le={Point:1,LineString:2,Polygon:3,MultiPoint:4,MultiLineString:5,MultiPolygon:6};function Ve(t,n={}){var e=[];if("FeatureCollection"===t.type)for(var r=0;r<t.features.length;r++)Re(e,t.features[r],n,r);else Re(e,"Feature"===t.type?t:{geometry:t},n);return e}function Re(t,n,e,r){if(n.geometry&&n.geometry.geometry){var i=n.geometry.coordinates,s=n.geometry.type,o=[],a=n.id;if(e.promoteId?a=n.properties[e.promoteId]:e.generateId&&(a=r||0),"Point"===s)He(i,o);else if("MultiPoint"===s)for(var u=0;u<i.length;u++)He(i[u],o);else if("LineString"===s)qe([i],o);else if("MultiLineString"===s){if(e.lineMetrics){for(u=0;u<i.length;u++)We(i[u],o=[]),t.push(Ge(a,"LineString",o,n.properties));return}qe(i,o)}else if("Polygon"===s)qe(i,o);else{if("MultiPolygon"!==s){if("GeometryCollection"===s){for(u=0;u<n.geometry.geometries.length;u++)Re(t,{id:a,geometry:n.geometry.geometries[u],properties:n.properties},e,r);return}return void console.warn(`Input data type(${s}) is not a valid GeoJSON geometry type.`)}for(u=0;u<i.length;u++){var l=[];qe(i[u],l),o.push(l)}}t.push(Ge(a,s,o,n.properties))}}function He(t,n){const e=new Ut(t[0],t[1]);e.z=100*(t[2]||0),n.push([e])}function We(t,n){for(let e=0;e<t.length;e++){const r=new Ut(t[e][0],t[e][1]);r.z=100*(t[e][2]||0),n.push(r)}}function qe(t,n,e,r){for(var i=0;i<t.length;i++){var s=[];We(t[i],s),n.push(s)}}function Ge(t,n,e,r){return{id:void 0===t?null:t,type:Le[n],geometry:e,properties:r}}\n/*!\n     * Codes from mapbox-gl-js\n     * github.com/mapbox/mapbox-gl-js\n     * MIT License\n     */function Be(t,{width:n,height:e},r,i){if(i){if(i.length!==n*e*r)throw new RangeError("mismatched image size")}else i=new Uint8Array(n*e*r);return t.width=n,t.height=e,t.data=i,t}function Je(t,{width:n,height:e},r){if(n===t.width&&e===t.height)return;const i=Be({},{width:n,height:e},r);Xe(t,i,{x:0,y:0},{x:0,y:0},{width:Math.min(t.width,n),height:Math.min(t.height,e)},r),t.width=n,t.height=e,t.data=i.data}function Xe(t,n,e,r,i,s){if(0===i.width||0===i.height)return n;if(i.width>t.width||i.height>t.height||e.x>t.width-i.width||e.y>t.height-i.height)throw new RangeError("out of range source coordinates for image copy");if(i.width>n.width||i.height>n.height||r.x>n.width-i.width||r.y>n.height-i.height)throw new RangeError("out of range destination coordinates for image copy");const o=t.data,a=n.data;if(o===a)return n;for(let u=0;u<i.height;u++){const l=((e.y+u)*t.width+e.x)*s,h=((r.y+u)*n.width+r.x)*s;for(let t=0;t<i.width*s;t++)a[h+t]=o[l+t]}return n}class Ye{constructor(t,n){Be(this,t,1,n)}resize(t){Je(this,t,1)}clone(){return new Ye({width:this.width,height:this.height},new Uint8Array(this.data))}static copy(t,n,e,r,i){Xe(t,n,e,r,i,1)}}class Ze{constructor(t,n){Be(this,t,4,n)}resize(t){Je(this,t,4)}clone(){return new Ze({width:this.width,height:this.height},new Uint8Array(this.data))}static copy(t,n,e,r,i){Xe(t,n,e,r,i,4)}}function Ke(t){let n=0;for(let e,r,i=0,s=t.length,o=s-1;i<s;o=i++)if(e=t[i],r=t[o],void 0!==e.x){if(e.z||r.z)return 1;n+=(r.x-e.x)*(e.y+r.y)}else{if(e[2]||r[2])return 1;n+=(r[0]-e[0])*(e[1]+r[1])}return n}function Qe(t,n,e,r,i){const s=t[n*r],o=t[n*r+1],a=t[e*r],u=t[e*r+1];return s===a&&(s<0||s>i)&&o!==u||o===u&&(o<0||o>i)&&s!==a}function tr(t,n,e){let r=e;return n&&t&&(r=+t[n]),isNaN(r)&&(r=e||0),100*r}function nr(t,n,e,r,i,s,o){n||0===n||(n=1);const a=tr(t.properties,e,r),u=a*n;let l=(s?100*s:0)||a;return i?l=tr(t.properties,i,s):o&&(l=a-tr(t.properties,o,s)),l*=n,{altitude:u,height:l}}function er(t,n){return n<1/0&&(t.x<0||t.x>n||t.y<0||t.y>n)}function rr(t){return null==t}function ir(t,n,e){if(t===e||t===n)return t;const r=e-n;return((t-n)%r+r)%r+n}function sr(t,n){if(!n)return null;const e=new Map;for(let r=0;r<n.length;r++){const i=n[r],s=t[i];let o=e.get(s);o||(o=[],e.set(s,o)),o.push(i)}return e}function or(t){return 0==(t&t-1)&&0!==t}\n/*!\n     * Codes from mapbox-gl-js\n     * github.com/mapbox/mapbox-gl-js\n     * MIT License\n     */class ar{constructor(t,n,{pixelRatio:e}){this.paddedRect=t,this.pixelRatio=e||1,this.padding=n}get tl(){return[this.paddedRect.x+this.padding,this.paddedRect.y+this.padding]}get br(){return[this.paddedRect.x+this.paddedRect.w-this.padding,this.paddedRect.y+this.paddedRect.h-this.padding]}get displaySize(){return[(this.paddedRect.w-2*this.padding)/this.pixelRatio,(this.paddedRect.h-2*this.padding)/this.pixelRatio]}}class ur{constructor(t){this.glyphMap=t,this.build()}build(){const t=this.glyphMap,n=Object.keys(t).length,e={},r=new Lt(0,0,{autoResize:!0}),i=[],s=n>1?1:0;for(const n in t){const r=t[n],o={x:0,y:0,w:r.data.width+2*s,h:r.data.height+2*s};i.push(o),e[n]=new ar(o,s,r)}if(r.pack(i,{inPlace:!0}),!or(r.w)||!or(r.h)){const t=lr(r.w),n=lr(r.h);r.resize(t,n)}const o=new Ze({width:r.w,height:r.h});for(const n in t){const r=t[n],i=e[n].paddedRect;Ze.copy(r.data,o,{x:0,y:0},{x:i.x+s,y:i.y+s},r.data)}this.image=o,this.positions=e}}function lr(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))}\n/*!\n     * Codes from mapbox-gl-js\n     * github.com/mapbox/mapbox-gl-js\n     * MIT License\n     * TODO 升级为potpack\n     */class hr{constructor(t){this.glyphMap=t,this.build()}build(){const t=this.glyphMap,n={},e=new Lt(0,0,{autoResize:!0}),r=[];for(const e in t){const i=t[e],s=n[e]={};for(const t in i){const n=i[+t];if(!n||0===n.bitmap.width||0===n.bitmap.height)continue;const e={x:0,y:0,w:n.bitmap.width+2,h:n.bitmap.height+2};r.push(e),s[t]={rect:e,metrics:n.metrics}}}e.pack(r,{inPlace:!0});const i=new Ye({width:e.w,height:e.h});for(const e in t){const r=t[e];for(const t in r){const s=r[+t];if(!s||0===s.bitmap.width||0===s.bitmap.height)continue;const o=n[e][t].rect;Ye.copy(s.bitmap,i,{x:0,y:0},{x:o.x+1,y:o.y+1},s.bitmap)}}this.image=i,this.positions=n}}function cr(t){return t<65536?Uint16Array:Uint32Array}function fr(t){return(t=Math.abs(t))<128?Int8Array:t<32768?Int16Array:Float32Array}function dr(t){return t<256?Uint8Array:t<65536?Uint16Array:Float32Array}function pr(t,n){const e=t.length;t=t.U||t;const r=new n(e);for(let n=0;n<e;n++)r[n]=t[n];return r}function yr(t){const n=t.type,e=[];if(1===n||4===n)for(let n=0;n<t.geometry.length;n++)He(t.geometry[n],e);else if(2===n)qe(t.geometry,e);else if(3===n)qe(t.geometry,e);else if(5===n)qe(t.geometry,e);else if(6===n)for(let n=0;n<t.geometry.length;n++){const r=[];qe(t.geometry[n],r),e.push(r)}return t.geometry=e,t}function mr(t){for(let n=1;n<arguments.length;n++){const e=arguments[n];for(const n in e)t[n]=e[n]}return t}function gr(t){return null==t}function vr(t){return"number"==typeof t&&!isNaN(t)}function br(t){return"object"==typeof t&&!!t}function wr(t){return!gr(t)&&("string"==typeof t||null!==t.constructor&&t.constructor===String)}function Mr(t){return!gr(t)&&("function"==typeof t||null!==t.constructor&&t.constructor===Function)}const xr=Object.prototype.hasOwnProperty;function Fr(t,n){return xr.call(t,n)}const Ar=Math.PI/180;function kr(t){return t&&d(t)&&t.property}function Pr(t){const{verticalCentimeterToPoint:n,tileRatio:e}=t;return n*e}function Sr(t){return"centimeter"===t||"cm"===t?1:"millimeter"===t||"mm"===t?.1:100}const _r={};function Or(t,n){if(!Array.isArray(n)){if(n&&void 0!==n.r&&void 0!==n.g&&void 0!==n.b)return t[0]=255*n.r,t[1]=255*n.g,t[2]=255*n.b,t[3]=void 0!==n.a?255*n.a:255,t;n=_r[n]=_r[n]||Cn(n).unitArray()}for(let e=0;e<n.length;e++)t[e]=255*n[e];return 3===n.length&&(t[3]=255),t}const Er={textFill:1,textSize:1,textOpacity:1,textDx:1,textDy:1,markerWidth:1,markerHeight:1,markerOpacity:1,markerDx:1,markerDy:1,lineWidth:1,lineColor:1,lineOpacity:1,polygonFill:1,polygonOpacity:1,polygonPatternFileWidth:1,polygonPatternFileOrigin:1},Ir={textName:1,markerTextFitPadding:1,markerTextFit:1,lineGradientProperty:1};var $r=Object.freeze({__proto__:null,now:function(){return Date.now()},extend:mr,isNil:gr,isNumber:vr,isInteger:function(t){return(0|t)===t},isObject:br,isString:wr,isFunction:Mr,hasOwn:Fr,join:function(t,n){return t.join?t.join(n||","):Array.prototype.join.call(t,n||",")},toRadian:function(t){return t*Ar},toDegree:function(t){return t/Ar},evaluate:function(t,n,e){return Mr(t)?t(void 0!==e?e:null,n):t},isFnTypeSymbol:kr,getAltitudeToLocal:Pr,getTubeSizeScale:Sr,normalizeColor:Or,checkIfIdentityZoomDependent:function(t,n,e){if(Array.isArray(e)||(e=Object.values(e)),!e||!e.length)return!1;if(!Er[t])return!1;for(let t=0;t<e.length;t++){const r=e[t]&&(e[t].feature||e[t]);if(!r)continue;const i=r.properties&&r.properties[n];if(i&&d(i)&&!p(i).isZoomConstant)return!0}return!1},checkIfZoomFnTypeSymbol:function(t){return!!Er[t]||!!Ir[t]}});class Cr{constructor(t,n,e,r){this.feature=t,this.symbol=n,this.fnTypes=e,this.options=r}getPolygonResource(){let t=this.symbol.polygonPatternFile;const{polygonPatternFileFn:n}=this.fnTypes;return this.L(t,n)}getLineResource(){let t=this.symbol.linePatternFile;const{linePatternFileFn:n}=this.fnTypes;return this.L(t,n)}L(t,n){return n&&(t=n(this.options.zoom,this.feature.properties)),t}}function Tr(t,n,e,r){const i=Math.abs(r)>>15,s=i>>1,o=i%2;let a=r%Math.pow(2,15);const u=n+(s<<14)*Math.sign(n),l=e+(o<<14)*Math.sign(e);return t[0]=u,t[1]=l,a=Math.round(a),t[2]=0===a?r<0?-1:0:a,t}const zr=Math.pow(2,14),Dr=Math.pow(2,15);\n/*!\n     * a compact version of mapbox-gl-style-spec\n     * based on mapbox-gl-style-spec@13.28.0\n     * https://github.com/mapbox/mapbox-gl-js/tree/main/src/style-spec\n     * LICENSE : ISC\n     */var jr,Ur,Nr="undefined"!=typeof undefinedThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof undefined?global:"undefined"!=typeof self?self:{},Lr={exports:{}};function Vr(t,...n){for(const e of n)for(const n in e)t[n]=e[n];return t}\n/*! https://mths.be/punycode v1.3.2 by @mathias */jr=Lr,Ur=Lr.exports,function(t){var n=Ur&&!Ur.nodeType&&Ur,e=jr&&!jr.nodeType&&jr,r="object"==typeof Nr&&Nr;r.global!==r&&r.window!==r&&r.self!==r||(t=r);var i,s,o=2147483647,a=/^xn--/,u=/[^\\x20-\\x7E]/,l=/[\\x2E\\u3002\\uFF0E\\uFF61]/g,h={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},c=Math.floor,f=String.fromCharCode;function d(t){throw RangeError(h[t])}function p(t,n){for(var e=t.length,r=[];e--;)r[e]=n(t[e]);return r}function y(t,n){var e=t.split("@"),r="";return e.length>1&&(r=e[0]+"@",t=e[1]),r+p((t=t.replace(l,".")).split("."),n).join(".")}function m(t){for(var n,e,r=[],i=0,s=t.length;i<s;)(n=t.charCodeAt(i++))>=55296&&n<=56319&&i<s?56320==(64512&(e=t.charCodeAt(i++)))?r.push(((1023&n)<<10)+(1023&e)+65536):(r.push(n),i--):r.push(n);return r}function g(t){return p(t,(function(t){var n="";return t>65535&&(n+=f((t-=65536)>>>10&1023|55296),t=56320|1023&t),n+f(t)})).join("")}function v(t,n){return t+22+75*(t<26)-((0!=n)<<5)}function b(t,n,e){var r=0;for(t=e?c(t/700):t>>1,t+=c(t/n);t>455;r+=36)t=c(t/35);return c(r+36*t/(t+38))}function w(t){var n,e,r,i,s,a,u,l,h,f,p,y=[],m=t.length,v=0,w=128,M=72;for((e=t.lastIndexOf("-"))<0&&(e=0),r=0;r<e;++r)t.charCodeAt(r)>=128&&d("not-basic"),y.push(t.charCodeAt(r));for(i=e>0?e+1:0;i<m;){for(s=v,a=1,u=36;i>=m&&d("invalid-input"),((l=(p=t.charCodeAt(i++))-48<10?p-22:p-65<26?p-65:p-97<26?p-97:36)>=36||l>c((o-v)/a))&&d("overflow"),v+=l*a,!(l<(h=u<=M?1:u>=M+26?26:u-M));u+=36)a>c(o/(f=36-h))&&d("overflow"),a*=f;M=b(v-s,n=y.length+1,0==s),c(v/n)>o-w&&d("overflow"),w+=c(v/n),v%=n,y.splice(v++,0,w)}return g(y)}function M(t){var n,e,r,i,s,a,u,l,h,p,y,g,w,M,x,F=[];for(g=(t=m(t)).length,n=128,e=0,s=72,a=0;a<g;++a)(y=t[a])<128&&F.push(f(y));for(r=i=F.length,i&&F.push("-");r<g;){for(u=o,a=0;a<g;++a)(y=t[a])>=n&&y<u&&(u=y);for(u-n>c((o-e)/(w=r+1))&&d("overflow"),e+=(u-n)*w,n=u,a=0;a<g;++a)if((y=t[a])<n&&++e>o&&d("overflow"),y==n){for(l=e,h=36;!(l<(p=h<=s?1:h>=s+26?26:h-s));h+=36)F.push(f(v(p+(x=l-p)%(M=36-p),0))),l=c(x/M);F.push(f(v(l,0))),s=b(e,w,r==i),e=0,++r}++e,++n}return F.join("")}if(i={version:"1.3.2",ucs2:{decode:m,encode:g},decode:w,encode:M,toASCII:function(t){return y(t,(function(t){return u.test(t)?"xn--"+M(t):t}))},toUnicode:function(t){return y(t,(function(t){return a.test(t)?w(t.slice(4).toLowerCase()):t}))}},n&&e)if(jr.exports==n)e.exports=i;else for(s in i)i.hasOwnProperty(s)&&(n[s]=i[s]);else t.punycode=i}(Nr);class Rr extends Error{constructor(t,n){super(n),this.message=n,this.key=t}}var Hr=Rr;class Wr{constructor(t,n=[]){this.parent=t,this.bindings={};for(const[t,e]of n)this.bindings[t]=e}concat(t){return new Wr(this,t)}get(t){if(this.bindings[t])return this.bindings[t];if(this.parent)return this.parent.get(t);throw new Error(t+" not found in scope.")}has(t){return!!this.bindings[t]||!!this.parent&&this.parent.has(t)}}var qr=Wr;const Gr={kind:"null"},Br={kind:"number"},Jr={kind:"string"},Xr={kind:"boolean"},Yr={kind:"color"},Zr={kind:"object"},Kr={kind:"value"},Qr={kind:"collator"},ti={kind:"formatted"},ni={kind:"resolvedImage"};function ei(t,n){return{kind:"array",itemType:t,N:n}}function ri(t){if("array"===t.kind){const n=ri(t.itemType);return"number"==typeof t.N?`array<${n}, ${t.N}>`:"value"===t.itemType.kind?"array":`array<${n}>`}return t.kind}const ii=[Gr,Br,Jr,Xr,Yr,ti,Zr,ei(Kr),ni];function si(t,n){if("error"===n.kind)return null;if("array"===t.kind){if("array"===n.kind&&(0===n.N&&"value"===n.itemType.kind||!si(t.itemType,n.itemType))&&("number"!=typeof t.N||t.N===n.N))return null}else{if(t.kind===n.kind)return null;if("value"===t.kind)for(const t of ii)if(!si(t,n))return null}return`Expected ${ri(t)} but found ${ri(n)} instead.`}function oi(t,n){return n.some(n=>n.kind===t.kind)}function ai(t,n){return n.some(n=>"null"===n?null===t:"array"===n?Array.isArray(t):"object"===n?t&&!Array.isArray(t)&&"object"==typeof t:n===typeof t)}var ui,li={transparent:[0,0,0,0],aliceblue:[240,248,255,1],antiquewhite:[250,235,215,1],aqua:[0,255,255,1],aquamarine:[127,255,212,1],azure:[240,255,255,1],beige:[245,245,220,1],bisque:[255,228,196,1],black:[0,0,0,1],blanchedalmond:[255,235,205,1],blue:[0,0,255,1],blueviolet:[138,43,226,1],brown:[165,42,42,1],burlywood:[222,184,135,1],cadetblue:[95,158,160,1],chartreuse:[127,255,0,1],chocolate:[210,105,30,1],coral:[255,127,80,1],cornflowerblue:[100,149,237,1],cornsilk:[255,248,220,1],crimson:[220,20,60,1],cyan:[0,255,255,1],darkblue:[0,0,139,1],darkcyan:[0,139,139,1],darkgoldenrod:[184,134,11,1],darkgray:[169,169,169,1],darkgreen:[0,100,0,1],darkgrey:[169,169,169,1],darkkhaki:[189,183,107,1],darkmagenta:[139,0,139,1],darkolivegreen:[85,107,47,1],darkorange:[255,140,0,1],darkorchid:[153,50,204,1],darkred:[139,0,0,1],darksalmon:[233,150,122,1],darkseagreen:[143,188,143,1],darkslateblue:[72,61,139,1],darkslategray:[47,79,79,1],darkslategrey:[47,79,79,1],darkturquoise:[0,206,209,1],darkviolet:[148,0,211,1],deeppink:[255,20,147,1],deepskyblue:[0,191,255,1],dimgray:[105,105,105,1],dimgrey:[105,105,105,1],dodgerblue:[30,144,255,1],firebrick:[178,34,34,1],floralwhite:[255,250,240,1],forestgreen:[34,139,34,1],fuchsia:[255,0,255,1],gainsboro:[220,220,220,1],ghostwhite:[248,248,255,1],gold:[255,215,0,1],goldenrod:[218,165,32,1],gray:[128,128,128,1],green:[0,128,0,1],greenyellow:[173,255,47,1],grey:[128,128,128,1],honeydew:[240,255,240,1],hotpink:[255,105,180,1],indianred:[205,92,92,1],indigo:[75,0,130,1],ivory:[255,255,240,1],khaki:[240,230,140,1],lavender:[230,230,250,1],lavenderblush:[255,240,245,1],lawngreen:[124,252,0,1],lemonchiffon:[255,250,205,1],lightblue:[173,216,230,1],lightcoral:[240,128,128,1],lightcyan:[224,255,255,1],lightgoldenrodyellow:[250,250,210,1],lightgray:[211,211,211,1],lightgreen:[144,238,144,1],lightgrey:[211,211,211,1],lightpink:[255,182,193,1],lightsalmon:[255,160,122,1],lightseagreen:[32,178,170,1],lightskyblue:[135,206,250,1],lightslategray:[119,136,153,1],lightslategrey:[119,136,153,1],lightsteelblue:[176,196,222,1],lightyellow:[255,255,224,1],lime:[0,255,0,1],limegreen:[50,205,50,1],linen:[250,240,230,1],magenta:[255,0,255,1],maroon:[128,0,0,1],mediumaquamarine:[102,205,170,1],mediumblue:[0,0,205,1],mediumorchid:[186,85,211,1],mediumpurple:[147,112,219,1],mediumseagreen:[60,179,113,1],mediumslateblue:[123,104,238,1],mediumspringgreen:[0,250,154,1],mediumturquoise:[72,209,204,1],mediumvioletred:[199,21,133,1],midnightblue:[25,25,112,1],mintcream:[245,255,250,1],mistyrose:[255,228,225,1],moccasin:[255,228,181,1],navajowhite:[255,222,173,1],navy:[0,0,128,1],oldlace:[253,245,230,1],olive:[128,128,0,1],olivedrab:[107,142,35,1],orange:[255,165,0,1],orangered:[255,69,0,1],orchid:[218,112,214,1],palegoldenrod:[238,232,170,1],palegreen:[152,251,152,1],paleturquoise:[175,238,238,1],palevioletred:[219,112,147,1],papayawhip:[255,239,213,1],peachpuff:[255,218,185,1],peru:[205,133,63,1],pink:[255,192,203,1],plum:[221,160,221,1],powderblue:[176,224,230,1],purple:[128,0,128,1],rebeccapurple:[102,51,153,1],red:[255,0,0,1],rosybrown:[188,143,143,1],royalblue:[65,105,225,1],saddlebrown:[139,69,19,1],salmon:[250,128,114,1],sandybrown:[244,164,96,1],seagreen:[46,139,87,1],seashell:[255,245,238,1],sienna:[160,82,45,1],silver:[192,192,192,1],skyblue:[135,206,235,1],slateblue:[106,90,205,1],slategray:[112,128,144,1],slategrey:[112,128,144,1],snow:[255,250,250,1],springgreen:[0,255,127,1],steelblue:[70,130,180,1],tan:[210,180,140,1],teal:[0,128,128,1],thistle:[216,191,216,1],tomato:[255,99,71,1],turquoise:[64,224,208,1],violet:[238,130,238,1],wheat:[245,222,179,1],white:[255,255,255,1],whitesmoke:[245,245,245,1],yellow:[255,255,0,1],yellowgreen:[154,205,50,1]};function hi(t){return(t=Math.round(t))<0?0:t>255?255:t}function ci(t){return hi("%"===t[t.length-1]?parseFloat(t)/100*255:parseInt(t))}function fi(t){return function(t){return t<0?0:t>1?1:t}("%"===t[t.length-1]?parseFloat(t)/100:parseFloat(t))}function di(t,n,e){return e<0?e+=1:e>1&&(e-=1),6*e<1?t+(n-t)*e*6:2*e<1?n:3*e<2?t+(n-t)*(2/3-e)*6:t}try{ui={}.parseCSSColor=function(t){var n,e=t.replace(/ /g,"").toLowerCase();if(e in li)return li[e].slice();if("#"===e[0])return 4===e.length?(n=parseInt(e.substr(1),16))>=0&&n<=4095?[(3840&n)>>4|(3840&n)>>8,240&n|(240&n)>>4,15&n|(15&n)<<4,1]:null:7===e.length&&(n=parseInt(e.substr(1),16))>=0&&n<=16777215?[(16711680&n)>>16,(65280&n)>>8,255&n,1]:null;var r=e.indexOf("("),i=e.indexOf(")");if(-1!==r&&i+1===e.length){var s=e.substr(0,r),o=e.substr(r+1,i-(r+1)).split(","),a=1;switch(s){case"rgba":if(4!==o.length)return null;a=fi(o.pop());case"rgb":return 3!==o.length?null:[ci(o[0]),ci(o[1]),ci(o[2]),a];case"hsla":if(4!==o.length)return null;a=fi(o.pop());case"hsl":if(3!==o.length)return null;var u=(parseFloat(o[0])%360+360)%360/360,l=fi(o[1]),h=fi(o[2]),c=h<=.5?h*(l+1):h+l-h*l,f=2*h-c;return[hi(255*di(f,c,u+1/3)),hi(255*di(f,c,u)),hi(255*di(f,c,u-1/3)),a];default:return null}}return null}}catch(t){}class pi{constructor(t,n,e,r=1){this.r=t,this.g=n,this.b=e,this.a=r}static parse(t){if(!t)return;if(t instanceof pi)return t;if("string"!=typeof t)return;const n=ui(t);return n?new pi(n[0]/255*n[3],n[1]/255*n[3],n[2]/255*n[3],n[3]):void 0}toString(){const[t,n,e,r]=this.toArray();return`rgba(${Math.round(t)},${Math.round(n)},${Math.round(e)},${r})`}toArray(){const{r:t,g:n,b:e,a:r}=this;return 0===r?[0,0,0,0]:[255*t/r,255*n/r,255*e/r,r]}toArray01(){const{r:t,g:n,b:e,a:r}=this;return 0===r?[0,0,0,0]:[t/r,n/r,e/r,r]}toArray01PremultipliedAlpha(){const{r:t,g:n,b:e,a:r}=this;return[t,n,e,r]}}pi.black=new pi(0,0,0,1),pi.white=new pi(1,1,1,1),pi.transparent=new pi(0,0,0,0),pi.red=new pi(1,0,0,1),pi.blue=new pi(0,0,1,1);var yi=pi;class mi{constructor(t,n,e){this.sensitivity=t?n?"variant":"case":n?"accent":"base",this.locale=e,this.collator=new Intl.Collator(this.locale?this.locale:[],{sensitivity:this.sensitivity,usage:"search"})}compare(t,n){return this.collator.compare(t,n)}resolvedLocale(){return new Intl.Collator(this.locale?this.locale:[]).resolvedOptions().locale}}class gi{constructor(t,n,e,r,i){this.text=t.normalize?t.normalize():t,this.image=n,this.scale=e,this.fontStack=r,this.textColor=i}}class vi{constructor(t){this.sections=t}static fromString(t){return new vi([new gi(t,null,null,null,null)])}isEmpty(){return 0===this.sections.length||!this.sections.some(t=>0!==t.text.length||t.image&&0!==t.image.name.length)}static factory(t){return t instanceof vi?t:vi.fromString(t)}toString(){return 0===this.sections.length?"":this.sections.map(t=>t.text).join("")}serialize(){const t=["format"];for(const n of this.sections){if(n.image){t.push(["image",n.image.name]);continue}t.push(n.text);const e={};n.fontStack&&(e["text-font"]=["literal",n.fontStack.split(",")]),n.scale&&(e["font-scale"]=n.scale),n.textColor&&(e["text-color"]=["rgba"].concat(n.textColor.toArray())),t.push(e)}return t}}class bi{constructor(t){this.name=t.name,this.available=t.available}toString(){return this.name}static fromString(t){return t?new bi({name:t,available:!1}):null}serialize(){return["image",this.name]}}function wi(t,n,e,r){return"number"==typeof t&&t>=0&&t<=255&&"number"==typeof n&&n>=0&&n<=255&&"number"==typeof e&&e>=0&&e<=255?void 0===r||"number"==typeof r&&r>=0&&r<=1?null:`Invalid rgba value [${[t,n,e,r].join(", ")}]: \'a\' must be between 0 and 1.`:`Invalid rgba value [${("number"==typeof r?[t,n,e,r]:[t,n,e]).join(", ")}]: \'r\', \'g\', and \'b\' must be between 0 and 255.`}function Mi(t){if(null===t)return!0;if("string"==typeof t)return!0;if("boolean"==typeof t)return!0;if("number"==typeof t)return!0;if(t instanceof yi)return!0;if(t instanceof mi)return!0;if(t instanceof vi)return!0;if(t instanceof bi)return!0;if(Array.isArray(t)){for(const n of t)if(!Mi(n))return!1;return!0}if("object"==typeof t){for(const n in t)if(!Mi(t[n]))return!1;return!0}return!1}function xi(t){if(null===t)return Gr;if("string"==typeof t)return Jr;if("boolean"==typeof t)return Xr;if("number"==typeof t)return Br;if(t instanceof yi)return Yr;if(t instanceof mi)return Qr;if(t instanceof vi)return ti;if(t instanceof bi)return ni;if(Array.isArray(t)){const n=t.length;let e;for(const n of t){const t=xi(n);if(e){if(e===t)continue;e=Kr;break}e=t}return ei(e||Kr,n)}return Zr}function Fi(t){const n=typeof t;return null===t?"":"string"===n||"number"===n||"boolean"===n?String(t):t instanceof yi||t instanceof vi||t instanceof bi?t.toString():JSON.stringify(t)}class Ai{constructor(t,n){this.type=t,this.value=n}static parse(t,n){if(2!==t.length)return n.error(`\'literal\' expression requires exactly one argument, but found ${t.length-1} instead.`);if(!Mi(t[1]))return n.error("invalid value");const e=t[1];let r=xi(e);const i=n.expectedType;return"array"!==r.kind||0!==r.N||!i||"array"!==i.kind||"number"==typeof i.N&&0!==i.N||(r=i),new Ai(r,e)}evaluate(){return this.value}eachChild(){}outputDefined(){return!0}serialize(){return"array"===this.type.kind||"object"===this.type.kind?["literal",this.value]:this.value instanceof yi?["rgba"].concat(this.value.toArray()):this.value instanceof vi?this.value.serialize():this.value}}var ki=Ai,Pi=class{constructor(t){this.name="ExpressionEvaluationError",this.message=t}toJSON(){return this.message}};const Si={string:Jr,number:Br,boolean:Xr,object:Zr};class _i{constructor(t,n){this.type=t,this.args=n}static parse(t,n){if(t.length<2)return n.error("Expected at least one argument.");let e,r=1;const i=t[0];if("array"===i){let i,s;if(t.length>2){const e=t[1];if("string"!=typeof e||!(e in Si)||"object"===e)return n.error(\'The item type argument of "array" must be one of string, number, boolean\',1);i=Si[e],r++}else i=Kr;if(t.length>3){if(null!==t[2]&&("number"!=typeof t[2]||t[2]<0||t[2]!==Math.floor(t[2])))return n.error(\'The length argument to "array" must be a positive integer literal\',2);s=t[2],r++}e=ei(i,s)}else e=Si[i];const s=[];for(;r<t.length;r++){const e=n.parse(t[r],r,Kr);if(!e)return null;s.push(e)}return new _i(e,s)}evaluate(t){for(let n=0;n<this.args.length;n++){const e=this.args[n].evaluate(t);if(!si(this.type,xi(e)))return e;if(n===this.args.length-1)throw new Pi(`Expected value to be of type ${ri(this.type)}, but found ${ri(xi(e))} instead.`)}return null}eachChild(t){this.args.forEach(t)}outputDefined(){return this.args.every(t=>t.outputDefined())}serialize(){const t=this.type,n=[t.kind];if("array"===t.kind){const e=t.itemType;if("string"===e.kind||"number"===e.kind||"boolean"===e.kind){n.push(e.kind);const r=t.N;("number"==typeof r||this.args.length>1)&&n.push(r)}}return n.concat(this.args.map(t=>t.serialize()))}}var Oi=_i;class Ei{constructor(t){this.type=ti,this.sections=t}static parse(t,n){if(t.length<2)return n.error("Expected at least one argument.");const e=t[1];if(!Array.isArray(e)&&"object"==typeof e)return n.error("First argument must be an image or text section.");const r=[];let i=!1;for(let e=1;e<=t.length-1;++e){const s=t[e];if(i&&"object"==typeof s&&!Array.isArray(s)){i=!1;let t=null;if(s["font-scale"]&&(t=n.parse(s["font-scale"],1,Br),!t))return null;let e=null;if(s["text-font"]&&(e=n.parse(s["text-font"],1,ei(Jr)),!e))return null;let o=null;if(s["text-color"]&&(o=n.parse(s["text-color"],1,Yr),!o))return null;const a=r[r.length-1];a.scale=t,a.font=e,a.textColor=o}else{const s=n.parse(t[e],1,Kr);if(!s)return null;const o=s.type.kind;if("string"!==o&&"value"!==o&&"null"!==o&&"resolvedImage"!==o)return n.error("Formatted text type must be \'string\', \'value\', \'image\' or \'null\'.");i=!0,r.push({content:s,scale:null,font:null,textColor:null})}}return new Ei(r)}evaluate(t){return new vi(this.sections.map(n=>{const e=n.content.evaluate(t);return xi(e)===ni?new gi("",e,null,null,null):new gi(Fi(e),null,n.scale?n.scale.evaluate(t):null,n.font?n.font.evaluate(t).join(","):null,n.textColor?n.textColor.evaluate(t):null)}))}eachChild(t){for(const n of this.sections)t(n.content),n.scale&&t(n.scale),n.font&&t(n.font),n.textColor&&t(n.textColor)}outputDefined(){return!1}serialize(){const t=["format"];for(const n of this.sections){t.push(n.content.serialize());const e={};n.scale&&(e["font-scale"]=n.scale.serialize()),n.font&&(e["text-font"]=n.font.serialize()),n.textColor&&(e["text-color"]=n.textColor.serialize()),t.push(e)}return t}}class Ii{constructor(t){this.type=ni,this.input=t}static parse(t,n){if(2!==t.length)return n.error("Expected two arguments.");const e=n.parse(t[1],1,Jr);return e?new Ii(e):n.error("No image name provided.")}evaluate(t){const n=this.input.evaluate(t),e=bi.fromString(n);return e&&t.availableImages&&(e.available=t.availableImages.indexOf(n)>-1),e}eachChild(t){t(this.input)}outputDefined(){return!1}serialize(){return["image",this.input.serialize()]}}const $i={"to-boolean":Xr,"to-color":Yr,"to-number":Br,"to-string":Jr};class Ci{constructor(t,n){this.type=t,this.args=n}static parse(t,n){if(t.length<2)return n.error("Expected at least one argument.");const e=t[0];if(("to-boolean"===e||"to-string"===e)&&2!==t.length)return n.error("Expected one argument.");const r=$i[e],i=[];for(let e=1;e<t.length;e++){const r=n.parse(t[e],e,Kr);if(!r)return null;i.push(r)}return new Ci(r,i)}evaluate(t){if("boolean"===this.type.kind)return Boolean(this.args[0].evaluate(t));if("color"===this.type.kind){let n,e;for(const r of this.args){if(n=r.evaluate(t),e=null,n instanceof yi)return n;if("string"==typeof n){const e=t.parseColor(n);if(e)return e}else if(Array.isArray(n)&&(e=n.length<3||n.length>4?`Invalid rbga value ${JSON.stringify(n)}: expected an array containing either three or four numeric values.`:wi(n[0],n[1],n[2],n[3]),!e))return new yi(n[0]/255,n[1]/255,n[2]/255,n[3])}throw new Pi(e||`Could not parse color from value \'${"string"==typeof n?n:String(JSON.stringify(n))}\'`)}if("number"===this.type.kind){let n=null;for(const e of this.args){if(n=e.evaluate(t),null===n)return 0;const r=Number(n);if(!isNaN(r))return r}throw new Pi(`Could not convert ${JSON.stringify(n)} to number.`)}return"formatted"===this.type.kind?vi.fromString(Fi(this.args[0].evaluate(t))):"resolvedImage"===this.type.kind?bi.fromString(Fi(this.args[0].evaluate(t))):Fi(this.args[0].evaluate(t))}eachChild(t){this.args.forEach(t)}outputDefined(){return this.args.every(t=>t.outputDefined())}serialize(){if("formatted"===this.type.kind)return new Ei([{content:this.args[0],scale:null,font:null,textColor:null}]).serialize();if("resolvedImage"===this.type.kind)return new Ii(this.args[0]).serialize();const t=["to-"+this.type.kind];return this.eachChild(n=>{t.push(n.serialize())}),t}}var Ti=Ci;const zi=["Unknown","Point","LineString","Polygon"];var Di=class{constructor(){this.globals=null,this.feature=null,this.featureState=null,this.formattedSection=null,this.V={},this.availableImages=null,this.canonical=null,this.featureTileCoord=null,this.featureDistanceData=null}id(){return this.feature&&void 0!==this.feature.id?this.feature.id:null}geometryType(){return this.feature?"number"==typeof this.feature.type?zi[this.feature.type]:this.feature.type:null}geometry(){return this.feature&&"geometry"in this.feature?this.feature.geometry:null}canonicalID(){return this.canonical}properties(){return this.feature&&this.feature.properties||{}}distanceFromCenter(){if(this.featureTileCoord&&this.featureDistanceData){const t=this.featureDistanceData.center,n=this.featureDistanceData.scale,{x:e,y:r}=this.featureTileCoord;return this.featureDistanceData.bearing[0]*(e*n-t[0])+this.featureDistanceData.bearing[1]*(r*n-t[1])}return 0}parseColor(t){let n=this.V[t];return n||(n=this.V[t]=yi.parse(t)),n}};class ji{constructor(t,n,e,r){this.name=t,this.type=n,this.R=e,this.args=r}evaluate(t){return this.R(t,this.args)}eachChild(t){this.args.forEach(t)}outputDefined(){return!1}serialize(){return[this.name].concat(this.args.map(t=>t.serialize()))}static parse(t,n){const e=t[0],r=ji.definitions[e];if(!r)return n.error(`Unknown expression "${e}". If you wanted a literal array, use ["literal", [...]].`,0);const i=Array.isArray(r)?r[0]:r.type,s=Array.isArray(r)?[[r[1],r[2]]]:r.overloads,o=s.filter(([n])=>!Array.isArray(n)||n.length===t.length-1);let a=null;for(const[r,s]of o){a=new ls(n.registry,n.path,null,n.scope);const o=[];let u=!1;for(let n=1;n<t.length;n++){const e=t[n],i=Array.isArray(r)?r[n-1]:r.type,s=a.parse(e,1+o.length,i);if(!s){u=!0;break}o.push(s)}if(!u)if(Array.isArray(r)&&r.length!==o.length)a.error(`Expected ${r.length} arguments, but found ${o.length} instead.`);else{for(let t=0;t<o.length;t++){const n=Array.isArray(r)?r[t]:r.type,e=o[t];a.concat(t+1).checkSubtype(n,e.type)}if(0===a.errors.length)return new ji(e,i,s,o)}}if(1===o.length)n.errors.push(...a.errors);else{const e=(o.length?o:s).map(([t])=>{return n=t,Array.isArray(n)?`(${n.map(ri).join(", ")})`:`(${ri(n.type)}...)`;var n}).join(" | "),r=[];for(let e=1;e<t.length;e++){const i=n.parse(t[e],1+r.length);if(!i)return null;r.push(ri(i.type))}n.error(`Expected arguments of type ${e}, but found (${r.join(", ")}) instead.`)}return null}static register(t,n){ji.definitions=n;for(const e in n)t[e]=ji}}var Ui=ji;class Ni{constructor(t,n,e){this.type=Qr,this.locale=e,this.caseSensitive=t,this.diacriticSensitive=n}static parse(t,n){if(2!==t.length)return n.error("Expected one argument.");const e=t[1];if("object"!=typeof e||Array.isArray(e))return n.error("Collator options argument must be an object.");const r=n.parse(void 0!==e["case-sensitive"]&&e["case-sensitive"],1,Xr);if(!r)return null;const i=n.parse(void 0!==e["diacritic-sensitive"]&&e["diacritic-sensitive"],1,Xr);if(!i)return null;let s=null;return e.locale&&(s=n.parse(e.locale,1,Jr),!s)?null:new Ni(r,i,s)}evaluate(t){return new mi(this.caseSensitive.evaluate(t),this.diacriticSensitive.evaluate(t),this.locale?this.locale.evaluate(t):null)}eachChild(t){t(this.caseSensitive),t(this.diacriticSensitive),this.locale&&t(this.locale)}outputDefined(){return!1}serialize(){const t={};return t["case-sensitive"]=this.caseSensitive.serialize(),t["diacritic-sensitive"]=this.diacriticSensitive.serialize(),this.locale&&(t.locale=this.locale.serialize()),["collator",t]}}function Li(t,n){t[0]=Math.min(t[0],n[0]),t[1]=Math.min(t[1],n[1]),t[2]=Math.max(t[2],n[0]),t[3]=Math.max(t[3],n[1])}function Vi(t,n){return!(t[0]<=n[0]||t[2]>=n[2]||t[1]<=n[1]||t[3]>=n[3])}function Ri(t,n){const e=(180+t[0])/360,r=(180-180/Math.PI*Math.log(Math.tan(Math.PI/4+t[1]*Math.PI/360)))/360,i=Math.pow(2,n.z);return[Math.round(e*i*8192),Math.round(r*i*8192)]}function Hi(t,n,e){const r=t[0]-n[0],i=t[1]-n[1],s=t[0]-e[0],o=t[1]-e[1];return r*o-s*i==0&&r*s<=0&&i*o<=0}function Wi(t,n){let e=!1;for(let o=0,a=n.length;o<a;o++){const a=n[o];for(let n=0,o=a.length;n<o-1;n++){if(Hi(t,a[n],a[n+1]))return!1;(i=a[n])[1]>(r=t)[1]!=(s=a[n+1])[1]>r[1]&&r[0]<(s[0]-i[0])*(r[1]-i[1])/(s[1]-i[1])+i[0]&&(e=!e)}}var r,i,s;return e}function qi(t,n){for(let e=0;e<n.length;e++)if(Wi(t,n[e]))return!0;return!1}function Gi(t,n,e,r){const i=r[0]-e[0],s=r[1]-e[1],o=(t[0]-e[0])*s-i*(t[1]-e[1]),a=(n[0]-e[0])*s-i*(n[1]-e[1]);return o>0&&a<0||o<0&&a>0}function Bi(t,n,e){for(const l of e)for(let e=0;e<l.length-1;++e)if(void 0,void 0,0!=(a=[(o=l[e+1])[0]-(s=l[e])[0],o[1]-s[1]])[0]*(u=[(i=n)[0]-(r=t)[0],i[1]-r[1]])[1]-a[1]*u[0]&&Gi(r,i,s,o)&&Gi(s,o,r,i))return!0;var r,i,s,o,a,u;return!1}function Ji(t,n){for(let e=0;e<t.length;++e)if(!Wi(t[e],n))return!1;for(let e=0;e<t.length-1;++e)if(Bi(t[e],t[e+1],n))return!1;return!0}function Xi(t,n){for(let e=0;e<n.length;e++)if(Ji(t,n[e]))return!0;return!1}function Yi(t,n,e){const r=[];for(let i=0;i<t.length;i++){const s=[];for(let r=0;r<t[i].length;r++){const o=Ri(t[i][r],e);Li(n,o),s.push(o)}r.push(s)}return r}function Zi(t,n,e){const r=[];for(let i=0;i<t.length;i++){const s=Yi(t[i],n,e);r.push(s)}return r}function Ki(t,n,e,r){if(t[0]<e[0]||t[0]>e[2]){const n=.5*r;let i=t[0]-e[0]>n?-r:e[0]-t[0]>n?r:0;0===i&&(i=t[0]-e[2]>n?-r:e[2]-t[0]>n?r:0),t[0]+=i}Li(n,t)}function Qi(t,n,e,r){const i=8192*Math.pow(2,r.z),s=[8192*r.x,8192*r.y],o=[];if(!t)return o;for(const r of t)for(const t of r){const r=[t.x+s[0],t.y+s[1]];Ki(r,n,e,i),o.push(r)}return o}function ts(t,n,e,r){const i=8192*Math.pow(2,r.z),s=[8192*r.x,8192*r.y],o=[];if(!t)return o;for(const e of t){const t=[];for(const r of e){const e=[r.x+s[0],r.y+s[1]];Li(n,e),t.push(e)}o.push(t)}if(n[2]-n[0]<=i/2){(a=n)[0]=a[1]=1/0,a[2]=a[3]=-1/0;for(const t of o)for(const r of t)Ki(r,n,e,i)}var a;return o}class ns{constructor(t,n){this.type=Xr,this.geojson=t,this.geometries=n}static parse(t,n){if(2!==t.length)return n.error(`\'within\' expression requires exactly one argument, but found ${t.length-1} instead.`);if(Mi(t[1])){const n=t[1];if("FeatureCollection"===n.type)for(let t=0;t<n.features.length;++t){const e=n.features[t].geometry.type;if("Polygon"===e||"MultiPolygon"===e)return new ns(n,n.features[t].geometry)}else if("Feature"===n.type){const t=n.geometry.type;if("Polygon"===t||"MultiPolygon"===t)return new ns(n,n.geometry)}else if("Polygon"===n.type||"MultiPolygon"===n.type)return new ns(n,n)}return n.error("\'within\' expression requires valid geojson object that contains polygon geometry type.")}evaluate(t){if(null!=t.geometry()&&null!=t.canonicalID()){if("Point"===t.geometryType())return function(t,n){const e=[1/0,1/0,-1/0,-1/0],r=[1/0,1/0,-1/0,-1/0],i=t.canonicalID();if(!i)return!1;if("Polygon"===n.type){const s=Yi(n.coordinates,r,i),o=Qi(t.geometry(),e,r,i);if(!Vi(e,r))return!1;for(const t of o)if(!Wi(t,s))return!1}if("MultiPolygon"===n.type){const s=Zi(n.coordinates,r,i),o=Qi(t.geometry(),e,r,i);if(!Vi(e,r))return!1;for(const t of o)if(!qi(t,s))return!1}return!0}(t,this.geometries);if("LineString"===t.geometryType())return function(t,n){const e=[1/0,1/0,-1/0,-1/0],r=[1/0,1/0,-1/0,-1/0],i=t.canonicalID();if(!i)return!1;if("Polygon"===n.type){const s=Yi(n.coordinates,r,i),o=ts(t.geometry(),e,r,i);if(!Vi(e,r))return!1;for(const t of o)if(!Ji(t,s))return!1}if("MultiPolygon"===n.type){const s=Zi(n.coordinates,r,i),o=ts(t.geometry(),e,r,i);if(!Vi(e,r))return!1;for(const t of o)if(!Xi(t,s))return!1}return!0}(t,this.geometries)}return!1}eachChild(){}outputDefined(){return!0}serialize(){return["within",this.geojson]}}var es=ns;function rs(t){if(t instanceof Ui){if("get"===t.name&&1===t.args.length)return!1;if("feature-state"===t.name)return!1;if("has"===t.name&&1===t.args.length)return!1;if("properties"===t.name||"geometry-type"===t.name||"id"===t.name)return!1;if(/^filter-/.test(t.name))return!1}if(t instanceof es)return!1;let n=!0;return t.eachChild(t=>{n&&!rs(t)&&(n=!1)}),n}function is(t){if(t instanceof Ui&&"feature-state"===t.name)return!1;let n=!0;return t.eachChild(t=>{n&&!is(t)&&(n=!1)}),n}function ss(t,n){if(t instanceof Ui&&n.indexOf(t.name)>=0)return!1;let e=!0;return t.eachChild(t=>{e&&!ss(t,n)&&(e=!1)}),e}class os{constructor(t,n){this.type=n.type,this.name=t,this.boundExpression=n}static parse(t,n){if(2!==t.length||"string"!=typeof t[1])return n.error("\'var\' expression requires exactly one string literal argument.");const e=t[1];return n.scope.has(e)?new os(e,n.scope.get(e)):n.error(`Unknown variable "${e}". Make sure "${e}" has been bound in an enclosing "let" expression before using it.`,1)}evaluate(t){return this.boundExpression.evaluate(t)}eachChild(){}outputDefined(){return!1}serialize(){return["var",this.name]}}var as=os;class us{constructor(t,n=[],e,r=new qr,i=[]){this.registry=t,this.path=n,this.key=n.map(t=>`[${t}]`).join(""),this.scope=r,this.errors=i,this.expectedType=e}parse(t,n,e,r,i={}){return n?this.concat(n,e,r).H(t,i):this.H(t,i)}H(t,n){function e(t,n,e){return"assert"===e?new Oi(n,[t]):"coerce"===e?new Ti(n,[t]):t}if(null!==t&&"string"!=typeof t&&"boolean"!=typeof t&&"number"!=typeof t||(t=["literal",t]),Array.isArray(t)){if(0===t.length)return this.error(\'Expected an array with at least one element. If you wanted a literal array, use ["literal", []].\');const r=t[0];if("string"!=typeof r)return this.error(`Expression name must be a string, but found ${typeof r} instead. If you wanted a literal array, use ["literal", [...]].`,0),null;const i=this.registry[r];if(i){let r=i.parse(t,this);if(!r)return null;if(this.expectedType){const t=this.expectedType,i=r.type;if("string"!==t.kind&&"number"!==t.kind&&"boolean"!==t.kind&&"object"!==t.kind&&"array"!==t.kind||"value"!==i.kind)if("color"!==t.kind&&"formatted"!==t.kind&&"resolvedImage"!==t.kind||"value"!==i.kind&&"string"!==i.kind){if(this.checkSubtype(t,i))return null}else r=e(r,t,n.typeAnnotation||"coerce");else r=e(r,t,n.typeAnnotation||"assert")}if(!(r instanceof ki)&&"resolvedImage"!==r.type.kind&&function t(n){if(n instanceof as)return t(n.boundExpression);if(n instanceof Ui&&"error"===n.name)return!1;if(n instanceof Ni)return!1;if(n instanceof es)return!1;const e=n instanceof Ti||n instanceof Oi;let r=!0;return n.eachChild(n=>{r=e?r&&t(n):r&&n instanceof ki}),!!r&&(rs(n)&&ss(n,["zoom","heatmap-density","line-progress","sky-radial-progress","accumulated","is-supported-script","pitch","distance-from-center"]))}(r)){const n=new Di;try{r=new ki(r.type,r.evaluate(n))}catch(t){return this.error(t.message),null}}return r}return this.error(`Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`,0)}return this.error(void 0===t?"\'undefined\' value invalid. Use null instead.":"object"==typeof t?\'Bare objects invalid. Use ["literal", {...}] instead.\':`Expected an array, but found ${typeof t} instead.`)}concat(t,n,e){const r="number"==typeof t?this.path.concat(t):this.path,i=e?this.scope.concat(e):this.scope;return new us(this.registry,r,n||null,i,this.errors)}error(t,...n){const e=`${this.key}${n.map(t=>`[${t}]`).join("")}`;this.errors.push(new Hr(e,t))}checkSubtype(t,n){const e=si(t,n);return e&&this.error(e),e}}var ls=us;function hs(t,n){const e=t.length-1;let r,i,s=0,o=e,a=0;for(;s<=o;)if(a=Math.floor((s+o)/2),r=t[a],i=t[a+1],r<=n){if(a===e||n<i)return a;s=a+1}else{if(!(r>n))throw new Pi("Input is not a number.");o=a-1}return 0}class cs{constructor(t,n,e){this.type=t,this.input=n,this.labels=[],this.outputs=[];for(const[t,n]of e)this.labels.push(t),this.outputs.push(n)}static parse(t,n){if(t.length-1<4)return n.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);if((t.length-1)%2!=0)return n.error("Expected an even number of arguments.");const e=n.parse(t[1],1,Br);if(!e)return null;const r=[];let i=null;n.expectedType&&"value"!==n.expectedType.kind&&(i=n.expectedType);for(let e=1;e<t.length;e+=2){const s=1===e?-1/0:t[e],o=t[e+1],a=e,u=e+1;if("number"!=typeof s)return n.error(\'Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.\',a);if(r.length&&r[r.length-1][0]>=s)return n.error(\'Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.\',a);const l=n.parse(o,u,i);if(!l)return null;i=i||l.type,r.push([s,l])}return new cs(i,e,r)}evaluate(t){const n=this.labels,e=this.outputs;if(1===n.length)return e[0].evaluate(t);const r=this.input.evaluate(t);if(r<=n[0])return e[0].evaluate(t);const i=n.length;return r>=n[i-1]?e[i-1].evaluate(t):e[hs(n,r)].evaluate(t)}eachChild(t){t(this.input);for(const n of this.outputs)t(n)}outputDefined(){return this.outputs.every(t=>t.outputDefined())}serialize(){const t=["step",this.input.serialize()];for(let n=0;n<this.labels.length;n++)n>0&&t.push(this.labels[n]),t.push(this.outputs[n].serialize());return t}}var fs=cs,ds=ps;function ps(t,n,e,r){this.cx=3*t,this.bx=3*(e-t)-this.cx,this.ax=1-this.cx-this.bx,this.cy=3*n,this.by=3*(r-n)-this.cy,this.ay=1-this.cy-this.by,this.p1x=t,this.p1y=n,this.p2x=e,this.p2y=r}function ys(t,n,e){return t*(1-e)+n*e}ps.prototype={sampleCurveX:function(t){return((this.ax*t+this.bx)*t+this.cx)*t},sampleCurveY:function(t){return((this.ay*t+this.by)*t+this.cy)*t},sampleCurveDerivativeX:function(t){return(3*this.ax*t+2*this.bx)*t+this.cx},solveCurveX:function(t,n){if(void 0===n&&(n=1e-6),t<0)return 0;if(t>1)return 1;for(var e=t,r=0;r<8;r++){var i=this.sampleCurveX(e)-t;if(Math.abs(i)<n)return e;var s=this.sampleCurveDerivativeX(e);if(Math.abs(s)<1e-6)break;e-=i/s}var o=0,a=1;for(e=t,r=0;r<20&&(i=this.sampleCurveX(e),!(Math.abs(i-t)<n));r++)t>i?o=e:a=e,e=.5*(a-o)+o;return e},solve:function(t,n){return this.sampleCurveY(this.solveCurveX(t,n))}};var ms=Object.freeze({__proto__:null,number:ys,color:function(t,n,e){return new yi(ys(t.r,n.r,e),ys(t.g,n.g,e),ys(t.b,n.b,e),ys(t.a,n.a,e))},array:function(t,n,e){return t.map((t,r)=>ys(t,n[r],e))}});const gs=6/29*3*(6/29),vs=Math.PI/180,bs=180/Math.PI;function ws(t){return t>.008856451679035631?Math.pow(t,1/3):t/gs+4/29}function Ms(t){return t>6/29?t*t*t:gs*(t-4/29)}function xs(t){return 255*(t<=.0031308?12.92*t:1.055*Math.pow(t,1/2.4)-.055)}function Fs(t){return(t/=255)<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4)}function As(t){const n=Fs(t.r),e=Fs(t.g),r=Fs(t.b),i=ws((.4124564*n+.3575761*e+.1804375*r)/.95047),s=ws((.2126729*n+.7151522*e+.072175*r)/1);return{l:116*s-16,a:500*(i-s),b:200*(s-ws((.0193339*n+.119192*e+.9503041*r)/1.08883)),alpha:t.a}}function ks(t){let n=(t.l+16)/116,e=isNaN(t.a)?n:n+t.a/500,r=isNaN(t.b)?n:n-t.b/200;return n=1*Ms(n),e=.95047*Ms(e),r=1.08883*Ms(r),new yi(xs(3.2404542*e-1.5371385*n-.4985314*r),xs(-.969266*e+1.8760108*n+.041556*r),xs(.0556434*e-.2040259*n+1.0572252*r),t.alpha)}function Ps(t,n,e){const r=n-t;return t+e*(r>180||r<-180?r-360*Math.round(r/360):r)}const Ss={forward:As,reverse:ks,interpolate:function(t,n,e){return{l:ys(t.l,n.l,e),a:ys(t.a,n.a,e),b:ys(t.b,n.b,e),alpha:ys(t.alpha,n.alpha,e)}}},_s={forward:function(t){const{l:n,a:e,b:r}=As(t),i=Math.atan2(r,e)*bs;return{h:i<0?i+360:i,c:Math.sqrt(e*e+r*r),l:n,alpha:t.a}},reverse:function(t){const n=t.h*vs,e=t.c;return ks({l:t.l,a:Math.cos(n)*e,b:Math.sin(n)*e,alpha:t.alpha})},interpolate:function(t,n,e){return{h:Ps(t.h,n.h,e),c:ys(t.c,n.c,e),l:ys(t.l,n.l,e),alpha:ys(t.alpha,n.alpha,e)}}};var Os=Object.freeze({__proto__:null,lab:Ss,hcl:_s});class Es{constructor(t,n,e,r,i){this.type=t,this.operator=n,this.interpolation=e,this.input=r,this.labels=[],this.outputs=[];for(const[t,n]of i)this.labels.push(t),this.outputs.push(n)}static interpolationFactor(t,n,e,r){let i=0;if("exponential"===t.name)i=Is(n,t.base,e,r);else if("linear"===t.name)i=Is(n,1,e,r);else if("cubic-bezier"===t.name){const s=t.controlPoints;i=new ds(s[0],s[1],s[2],s[3]).solve(Is(n,1,e,r))}return i}static parse(t,n){let[e,r,i,...s]=t;if(!Array.isArray(r)||0===r.length)return n.error("Expected an interpolation type expression.",1);if("linear"===r[0])r={name:"linear"};else if("exponential"===r[0]){const t=r[1];if("number"!=typeof t)return n.error("Exponential interpolation requires a numeric base.",1,1);r={name:"exponential",base:t}}else{if("cubic-bezier"!==r[0])return n.error("Unknown interpolation type "+String(r[0]),1,0);{const t=r.slice(1);if(4!==t.length||t.some(t=>"number"!=typeof t||t<0||t>1))return n.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.",1);r={name:"cubic-bezier",controlPoints:t}}}if(t.length-1<4)return n.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);if((t.length-1)%2!=0)return n.error("Expected an even number of arguments.");if(i=n.parse(i,2,Br),!i)return null;const o=[];let a=null;"interpolate-hcl"===e||"interpolate-lab"===e?a=Yr:n.expectedType&&"value"!==n.expectedType.kind&&(a=n.expectedType);for(let t=0;t<s.length;t+=2){const e=s[t],r=s[t+1],i=t+3,u=t+4;if("number"!=typeof e)return n.error(\'Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.\',i);if(o.length&&o[o.length-1][0]>=e)return n.error(\'Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.\',i);const l=n.parse(r,u,a);if(!l)return null;a=a||l.type,o.push([e,l])}return"number"===a.kind||"color"===a.kind||"array"===a.kind&&"number"===a.itemType.kind&&"number"==typeof a.N?new Es(a,e,r,i,o):n.error(`Type ${ri(a)} is not interpolatable.`)}evaluate(t){const n=this.labels,e=this.outputs;if(1===n.length)return e[0].evaluate(t);const r=this.input.evaluate(t);if(r<=n[0])return e[0].evaluate(t);const i=n.length;if(r>=n[i-1])return e[i-1].evaluate(t);const s=hs(n,r),o=Es.interpolationFactor(this.interpolation,r,n[s],n[s+1]),a=e[s].evaluate(t),u=e[s+1].evaluate(t);return"interpolate"===this.operator?ms[this.type.kind.toLowerCase()](a,u,o):"interpolate-hcl"===this.operator?_s.reverse(_s.interpolate(_s.forward(a),_s.forward(u),o)):Ss.reverse(Ss.interpolate(Ss.forward(a),Ss.forward(u),o))}eachChild(t){t(this.input);for(const n of this.outputs)t(n)}outputDefined(){return this.outputs.every(t=>t.outputDefined())}serialize(){let t;t="linear"===this.interpolation.name?["linear"]:"exponential"===this.interpolation.name?1===this.interpolation.base?["linear"]:["exponential",this.interpolation.base]:["cubic-bezier"].concat(this.interpolation.controlPoints);const n=[this.operator,t,this.input.serialize()];for(let t=0;t<this.labels.length;t++)n.push(this.labels[t],this.outputs[t].serialize());return n}}function Is(t,n,e,r){const i=r-e,s=t-e;return 0===i?0:1===n?s/i:(Math.pow(n,s)-1)/(Math.pow(n,i)-1)}var $s=Es;class Cs{constructor(t,n){this.type=t,this.args=n}static parse(t,n){if(t.length<2)return n.error("Expectected at least one argument.");let e=null;const r=n.expectedType;r&&"value"!==r.kind&&(e=r);const i=[];for(const r of t.slice(1)){const t=n.parse(r,1+i.length,e,void 0,{typeAnnotation:"omit"});if(!t)return null;e=e||t.type,i.push(t)}const s=r&&i.some(t=>si(r,t.type));return new Cs(s?Kr:e,i)}evaluate(t){let n,e=null,r=0;for(const i of this.args){if(r++,e=i.evaluate(t),e&&e instanceof bi&&!e.available&&(n||(n=e),e=null,r===this.args.length))return n;if(null!==e)break}return e}eachChild(t){this.args.forEach(t)}outputDefined(){return this.args.every(t=>t.outputDefined())}serialize(){const t=["coalesce"];return this.eachChild(n=>{t.push(n.serialize())}),t}}var Ts=Cs;class zs{constructor(t,n){this.type=n.type,this.bindings=[].concat(t),this.result=n}evaluate(t){return this.result.evaluate(t)}eachChild(t){for(const n of this.bindings)t(n[1]);t(this.result)}static parse(t,n){if(t.length<4)return n.error(`Expected at least 3 arguments, but found ${t.length-1} instead.`);const e=[];for(let r=1;r<t.length-1;r+=2){const i=t[r];if("string"!=typeof i)return n.error(`Expected string, but found ${typeof i} instead.`,r);if(/[^a-zA-Z0-9_]/.test(i))return n.error("Variable names must contain only alphanumeric characters or \'_\'.",r);const s=n.parse(t[r+1],r+1);if(!s)return null;e.push([i,s])}const r=n.parse(t[t.length-1],t.length-1,n.expectedType,e);return r?new zs(e,r):null}outputDefined(){return this.result.outputDefined()}serialize(){const t=["let"];for(const[n,e]of this.bindings)t.push(n,e.serialize());return t.push(this.result.serialize()),t}}var Ds=zs;class js{constructor(t,n,e){this.type=t,this.index=n,this.input=e}static parse(t,n){if(3!==t.length)return n.error(`Expected 2 arguments, but found ${t.length-1} instead.`);const e=n.parse(t[1],1,Br),r=n.parse(t[2],2,ei(n.expectedType||Kr));return e&&r?new js(r.type.itemType,e,r):null}evaluate(t){const n=this.index.evaluate(t),e=this.input.evaluate(t);if(n<0)throw new Pi(`Array index out of bounds: ${n} < 0.`);if(n>=e.length)throw new Pi(`Array index out of bounds: ${n} > ${e.length-1}.`);if(n!==Math.floor(n))throw new Pi(`Array index must be an integer, but found ${n} instead.`);return e[n]}eachChild(t){t(this.index),t(this.input)}outputDefined(){return!1}serialize(){return["at",this.index.serialize(),this.input.serialize()]}}var Us=js;class Ns{constructor(t,n){this.type=Xr,this.needle=t,this.haystack=n}static parse(t,n){if(3!==t.length)return n.error(`Expected 2 arguments, but found ${t.length-1} instead.`);const e=n.parse(t[1],1,Kr),r=n.parse(t[2],2,Kr);return e&&r?oi(e.type,[Xr,Jr,Br,Gr,Kr])?new Ns(e,r):n.error(`Expected first argument to be of type boolean, string, number or null, but found ${ri(e.type)} instead`):null}evaluate(t){const n=this.needle.evaluate(t),e=this.haystack.evaluate(t);if(null==e)return!1;if(!ai(n,["boolean","string","number","null"]))throw new Pi(`Expected first argument to be of type boolean, string, number or null, but found ${ri(xi(n))} instead.`);if(!ai(e,["string","array"]))throw new Pi(`Expected second argument to be of type array or string, but found ${ri(xi(e))} instead.`);return e.indexOf(n)>=0}eachChild(t){t(this.needle),t(this.haystack)}outputDefined(){return!0}serialize(){return["in",this.needle.serialize(),this.haystack.serialize()]}}var Ls=Ns;class Vs{constructor(t,n,e){this.type=Br,this.needle=t,this.haystack=n,this.fromIndex=e}static parse(t,n){if(t.length<=2||t.length>=5)return n.error(`Expected 3 or 4 arguments, but found ${t.length-1} instead.`);const e=n.parse(t[1],1,Kr),r=n.parse(t[2],2,Kr);if(!e||!r)return null;if(!oi(e.type,[Xr,Jr,Br,Gr,Kr]))return n.error(`Expected first argument to be of type boolean, string, number or null, but found ${ri(e.type)} instead`);if(4===t.length){const i=n.parse(t[3],3,Br);return i?new Vs(e,r,i):null}return new Vs(e,r)}evaluate(t){const n=this.needle.evaluate(t),e=this.haystack.evaluate(t);if(!ai(n,["boolean","string","number","null"]))throw new Pi(`Expected first argument to be of type boolean, string, number or null, but found ${ri(xi(n))} instead.`);if(!ai(e,["string","array"]))throw new Pi(`Expected second argument to be of type array or string, but found ${ri(xi(e))} instead.`);if(this.fromIndex){const r=this.fromIndex.evaluate(t);return e.indexOf(n,r)}return e.indexOf(n)}eachChild(t){t(this.needle),t(this.haystack),this.fromIndex&&t(this.fromIndex)}outputDefined(){return!1}serialize(){if(null!=this.fromIndex&&void 0!==this.fromIndex){const t=this.fromIndex.serialize();return["index-of",this.needle.serialize(),this.haystack.serialize(),t]}return["index-of",this.needle.serialize(),this.haystack.serialize()]}}var Rs=Vs;class Hs{constructor(t,n,e,r,i,s){this.inputType=t,this.type=n,this.input=e,this.cases=r,this.outputs=i,this.otherwise=s}static parse(t,n){if(t.length<5)return n.error(`Expected at least 4 arguments, but found only ${t.length-1}.`);if(t.length%2!=1)return n.error("Expected an even number of arguments.");let e,r;n.expectedType&&"value"!==n.expectedType.kind&&(r=n.expectedType);const i={},s=[];for(let o=2;o<t.length-1;o+=2){let a=t[o];const u=t[o+1];Array.isArray(a)||(a=[a]);const l=n.concat(o);if(0===a.length)return l.error("Expected at least one branch label.");for(const t of a){if("number"!=typeof t&&"string"!=typeof t)return l.error("Branch labels must be numbers or strings.");if("number"==typeof t&&Math.abs(t)>Number.MAX_SAFE_INTEGER)return l.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);if("number"==typeof t&&Math.floor(t)!==t)return l.error("Numeric branch labels must be integer values.");if(e){if(l.checkSubtype(e,xi(t)))return null}else e=xi(t);if(void 0!==i[String(t)])return l.error("Branch labels must be unique.");i[String(t)]=s.length}const h=n.parse(u,o,r);if(!h)return null;r=r||h.type,s.push(h)}const o=n.parse(t[1],1,Kr);if(!o)return null;const a=n.parse(t[t.length-1],t.length-1,r);return a?"value"!==o.type.kind&&n.concat(1).checkSubtype(e,o.type)?null:new Hs(e,r,o,i,s,a):null}evaluate(t){const n=this.input.evaluate(t);return(xi(n)===this.inputType&&this.outputs[this.cases[n]]||this.otherwise).evaluate(t)}eachChild(t){t(this.input),this.outputs.forEach(t),t(this.otherwise)}outputDefined(){return this.outputs.every(t=>t.outputDefined())&&this.otherwise.outputDefined()}serialize(){const t=["match",this.input.serialize()],n=Object.keys(this.cases).sort(),e=[],r={};for(const t of n){const n=r[this.cases[t]];void 0===n?(r[this.cases[t]]=e.length,e.push([this.cases[t],[t]])):e[n][1].push(t)}const i=t=>"number"===this.inputType.kind?Number(t):t;for(const[n,r]of e)t.push(1===r.length?i(r[0]):r.map(i)),t.push(this.outputs[n].serialize());return t.push(this.otherwise.serialize()),t}}var Ws=Hs;class qs{constructor(t,n,e){this.type=t,this.branches=n,this.otherwise=e}static parse(t,n){if(t.length<4)return n.error(`Expected at least 3 arguments, but found only ${t.length-1}.`);if(t.length%2!=0)return n.error("Expected an odd number of arguments.");let e;n.expectedType&&"value"!==n.expectedType.kind&&(e=n.expectedType);const r=[];for(let i=1;i<t.length-1;i+=2){const s=n.parse(t[i],i,Xr);if(!s)return null;const o=n.parse(t[i+1],i+1,e);if(!o)return null;r.push([s,o]),e=e||o.type}const i=n.parse(t[t.length-1],t.length-1,e);return i?new qs(e,r,i):null}evaluate(t){for(const[n,e]of this.branches)if(n.evaluate(t))return e.evaluate(t);return this.otherwise.evaluate(t)}eachChild(t){for(const[n,e]of this.branches)t(n),t(e);t(this.otherwise)}outputDefined(){return this.branches.every(([t,n])=>n.outputDefined())&&this.otherwise.outputDefined()}serialize(){const t=["case"];return this.eachChild(n=>{t.push(n.serialize())}),t}}var Gs=qs;class Bs{constructor(t,n,e,r){this.type=t,this.input=n,this.beginIndex=e,this.endIndex=r}static parse(t,n){if(t.length<=2||t.length>=5)return n.error(`Expected 3 or 4 arguments, but found ${t.length-1} instead.`);const e=n.parse(t[1],1,Kr),r=n.parse(t[2],2,Br);if(!e||!r)return null;if(!oi(e.type,[ei(Kr),Jr,Kr]))return n.error(`Expected first argument to be of type array or string, but found ${ri(e.type)} instead`);if(4===t.length){const i=n.parse(t[3],3,Br);return i?new Bs(e.type,e,r,i):null}return new Bs(e.type,e,r)}evaluate(t){const n=this.input.evaluate(t),e=this.beginIndex.evaluate(t);if(!ai(n,["string","array"]))throw new Pi(`Expected first argument to be of type array or string, but found ${ri(xi(n))} instead.`);if(this.endIndex){const r=this.endIndex.evaluate(t);return n.slice(e,r)}return n.slice(e)}eachChild(t){t(this.input),t(this.beginIndex),this.endIndex&&t(this.endIndex)}outputDefined(){return!1}serialize(){if(null!=this.endIndex&&void 0!==this.endIndex){const t=this.endIndex.serialize();return["slice",this.input.serialize(),this.beginIndex.serialize(),t]}return["slice",this.input.serialize(),this.beginIndex.serialize()]}}var Js=Bs;function Xs(t,n){return"=="===t||"!="===t?"boolean"===n.kind||"string"===n.kind||"number"===n.kind||"null"===n.kind||"value"===n.kind:"string"===n.kind||"number"===n.kind||"value"===n.kind}function Ys(t,n,e,r){return 0===r.compare(n,e)}function Zs(t,n,e){const r="=="!==t&&"!="!==t;return class i{constructor(t,n,e){this.type=Xr,this.lhs=t,this.rhs=n,this.collator=e,this.hasUntypedArgument="value"===t.type.kind||"value"===n.type.kind}static parse(t,n){if(3!==t.length&&4!==t.length)return n.error("Expected two or three arguments.");const e=t[0];let s=n.parse(t[1],1,Kr);if(!s)return null;if(!Xs(e,s.type))return n.concat(1).error(`"${e}" comparisons are not supported for type \'${ri(s.type)}\'.`);let o=n.parse(t[2],2,Kr);if(!o)return null;if(!Xs(e,o.type))return n.concat(2).error(`"${e}" comparisons are not supported for type \'${ri(o.type)}\'.`);if(s.type.kind!==o.type.kind&&"value"!==s.type.kind&&"value"!==o.type.kind)return n.error(`Cannot compare types \'${ri(s.type)}\' and \'${ri(o.type)}\'.`);r&&("value"===s.type.kind&&"value"!==o.type.kind?s=new Oi(o.type,[s]):"value"!==s.type.kind&&"value"===o.type.kind&&(o=new Oi(s.type,[o])));let a=null;if(4===t.length){if("string"!==s.type.kind&&"string"!==o.type.kind&&"value"!==s.type.kind&&"value"!==o.type.kind)return n.error("Cannot use collator to compare non-string types.");if(a=n.parse(t[3],3,Qr),!a)return null}return new i(s,o,a)}evaluate(i){const s=this.lhs.evaluate(i),o=this.rhs.evaluate(i);if(r&&this.hasUntypedArgument){const n=xi(s),e=xi(o);if(n.kind!==e.kind||"string"!==n.kind&&"number"!==n.kind)throw new Pi(`Expected arguments for "${t}" to be (string, string) or (number, number), but found (${n.kind}, ${e.kind}) instead.`)}if(this.collator&&!r&&this.hasUntypedArgument){const t=xi(s),e=xi(o);if("string"!==t.kind||"string"!==e.kind)return n(i,s,o)}return this.collator?e(i,s,o,this.collator.evaluate(i)):n(i,s,o)}eachChild(t){t(this.lhs),t(this.rhs),this.collator&&t(this.collator)}outputDefined(){return!0}serialize(){const n=[t];return this.eachChild(t=>{n.push(t.serialize())}),n}}}const Ks=Zs("==",(function(t,n,e){return n===e}),Ys),Qs=Zs("!=",(function(t,n,e){return n!==e}),(function(t,n,e,r){return!Ys(0,n,e,r)})),to=Zs("<",(function(t,n,e){return n<e}),(function(t,n,e,r){return r.compare(n,e)<0})),no=Zs(">",(function(t,n,e){return n>e}),(function(t,n,e,r){return r.compare(n,e)>0})),eo=Zs("<=",(function(t,n,e){return n<=e}),(function(t,n,e,r){return r.compare(n,e)<=0})),ro=Zs(">=",(function(t,n,e){return n>=e}),(function(t,n,e,r){return r.compare(n,e)>=0}));class io{constructor(t,n,e,r,i,s){this.type=Jr,this.number=t,this.locale=n,this.currency=e,this.unit=r,this.minFractionDigits=i,this.maxFractionDigits=s}static parse(t,n){if(3!==t.length)return n.error("Expected two arguments.");const e=n.parse(t[1],1,Br);if(!e)return null;const r=t[2];if("object"!=typeof r||Array.isArray(r))return n.error("NumberFormat options argument must be an object.");let i=null;if(r.locale&&(i=n.parse(r.locale,1,Jr),!i))return null;let s=null;if(r.currency&&(s=n.parse(r.currency,1,Jr),!s))return null;let o=null;if(r.unit&&(o=n.parse(r.unit,1,Jr),!o))return null;let a=null;if(r["min-fraction-digits"]&&(a=n.parse(r["min-fraction-digits"],1,Br),!a))return null;let u=null;return r["max-fraction-digits"]&&(u=n.parse(r["max-fraction-digits"],1,Br),!u)?null:new io(e,i,s,o,a,u)}evaluate(t){return new Intl.NumberFormat(this.locale?this.locale.evaluate(t):[],{style:(this.currency?"currency":this.unit&&"unit")||"decimal",currency:this.currency?this.currency.evaluate(t):void 0,unit:this.unit?this.unit.evaluate(t):void 0,minimumFractionDigits:this.minFractionDigits?this.minFractionDigits.evaluate(t):void 0,maximumFractionDigits:this.maxFractionDigits?this.maxFractionDigits.evaluate(t):void 0}).format(this.number.evaluate(t))}eachChild(t){t(this.number),this.locale&&t(this.locale),this.currency&&t(this.currency),this.unit&&t(this.unit),this.minFractionDigits&&t(this.minFractionDigits),this.maxFractionDigits&&t(this.maxFractionDigits)}outputDefined(){return!1}serialize(){const t={};return this.locale&&(t.locale=this.locale.serialize()),this.currency&&(t.currency=this.currency.serialize()),this.unit&&(t.unit=this.unit.serialize()),this.minFractionDigits&&(t["min-fraction-digits"]=this.minFractionDigits.serialize()),this.maxFractionDigits&&(t["max-fraction-digits"]=this.maxFractionDigits.serialize()),["number-format",this.number.serialize(),t]}}class so{constructor(t){this.type=Br,this.input=t}static parse(t,n){if(2!==t.length)return n.error(`Expected 1 argument, but found ${t.length-1} instead.`);const e=n.parse(t[1],1);return e?"array"!==e.type.kind&&"string"!==e.type.kind&&"value"!==e.type.kind?n.error(`Expected argument of type string or array, but found ${ri(e.type)} instead.`):new so(e):null}evaluate(t){const n=this.input.evaluate(t);if("string"==typeof n)return n.length;if(Array.isArray(n))return n.length;throw new Pi(`Expected value to be of type string or array, but found ${ri(xi(n))} instead.`)}eachChild(t){t(this.input)}outputDefined(){return!1}serialize(){const t=["length"];return this.eachChild(n=>{t.push(n.serialize())}),t}}const oo={"==":Ks,"!=":Qs,">":no,"<":to,">=":ro,"<=":eo,array:Oi,at:Us,boolean:Oi,case:Gs,coalesce:Ts,collator:Ni,format:Ei,image:Ii,in:Ls,"index-of":Rs,interpolate:$s,"interpolate-hcl":$s,"interpolate-lab":$s,length:so,let:Ds,literal:ki,match:Ws,number:Oi,"number-format":io,object:Oi,slice:Js,step:fs,string:Oi,"to-boolean":Ti,"to-color":Ti,"to-number":Ti,"to-string":Ti,var:as,within:es};function ao(t,[n,e,r,i]){n=n.evaluate(t),e=e.evaluate(t),r=r.evaluate(t);const s=i?i.evaluate(t):1,o=wi(n,e,r,s);if(o)throw new Pi(o);return new yi(n/255*s,e/255*s,r/255*s,s)}function uo(t,n){return t in n}function lo(t,n){const e=n[t];return void 0===e?null:e}function ho(t){return{type:t}}Ui.register(oo,{error:[{kind:"error"},[Jr],(t,[n])=>{throw new Pi(n.evaluate(t))}],typeof:[Jr,[Kr],(t,[n])=>ri(xi(n.evaluate(t)))],"to-rgba":[ei(Br,4),[Yr],(t,[n])=>n.evaluate(t).toArray()],rgb:[Yr,[Br,Br,Br],ao],rgba:[Yr,[Br,Br,Br,Br],ao],has:{type:Xr,overloads:[[[Jr],(t,[n])=>uo(n.evaluate(t),t.properties())],[[Jr,Zr],(t,[n,e])=>uo(n.evaluate(t),e.evaluate(t))]]},get:{type:Kr,overloads:[[[Jr],(t,[n])=>lo(n.evaluate(t),t.properties())],[[Jr,Zr],(t,[n,e])=>lo(n.evaluate(t),e.evaluate(t))]]},"feature-state":[Kr,[Jr],(t,[n])=>lo(n.evaluate(t),t.featureState||{})],properties:[Zr,[],t=>t.properties()],"geometry-type":[Jr,[],t=>t.geometryType()],id:[Kr,[],t=>t.id()],zoom:[Br,[],t=>t.globals.zoom],pitch:[Br,[],t=>t.globals.pitch||0],"distance-from-center":[Br,[],t=>t.distanceFromCenter()],"heatmap-density":[Br,[],t=>t.globals.heatmapDensity||0],"line-progress":[Br,[],t=>t.globals.lineProgress||0],"sky-radial-progress":[Br,[],t=>t.globals.skyRadialProgress||0],accumulated:[Kr,[],t=>void 0===t.globals.accumulated?null:t.globals.accumulated],"+":[Br,ho(Br),(t,n)=>{let e=0;for(const r of n)e+=r.evaluate(t);return e}],"*":[Br,ho(Br),(t,n)=>{let e=1;for(const r of n)e*=r.evaluate(t);return e}],"-":{type:Br,overloads:[[[Br,Br],(t,[n,e])=>n.evaluate(t)-e.evaluate(t)],[[Br],(t,[n])=>-n.evaluate(t)]]},"/":[Br,[Br,Br],(t,[n,e])=>n.evaluate(t)/e.evaluate(t)],"%":[Br,[Br,Br],(t,[n,e])=>n.evaluate(t)%e.evaluate(t)],ln2:[Br,[],()=>Math.LN2],pi:[Br,[],()=>Math.PI],e:[Br,[],()=>Math.E],"^":[Br,[Br,Br],(t,[n,e])=>Math.pow(n.evaluate(t),e.evaluate(t))],sqrt:[Br,[Br],(t,[n])=>Math.sqrt(n.evaluate(t))],log10:[Br,[Br],(t,[n])=>Math.log(n.evaluate(t))/Math.LN10],ln:[Br,[Br],(t,[n])=>Math.log(n.evaluate(t))],log2:[Br,[Br],(t,[n])=>Math.log(n.evaluate(t))/Math.LN2],sin:[Br,[Br],(t,[n])=>Math.sin(n.evaluate(t))],cos:[Br,[Br],(t,[n])=>Math.cos(n.evaluate(t))],tan:[Br,[Br],(t,[n])=>Math.tan(n.evaluate(t))],asin:[Br,[Br],(t,[n])=>Math.asin(n.evaluate(t))],acos:[Br,[Br],(t,[n])=>Math.acos(n.evaluate(t))],atan:[Br,[Br],(t,[n])=>Math.atan(n.evaluate(t))],min:[Br,ho(Br),(t,n)=>Math.min(...n.map(n=>n.evaluate(t)))],max:[Br,ho(Br),(t,n)=>Math.max(...n.map(n=>n.evaluate(t)))],abs:[Br,[Br],(t,[n])=>Math.abs(n.evaluate(t))],round:[Br,[Br],(t,[n])=>{const e=n.evaluate(t);return e<0?-Math.round(-e):Math.round(e)}],floor:[Br,[Br],(t,[n])=>Math.floor(n.evaluate(t))],ceil:[Br,[Br],(t,[n])=>Math.ceil(n.evaluate(t))],"filter-==":[Xr,[Jr,Kr],(t,[n,e])=>t.properties()[n.value]===e.value],"filter-id-==":[Xr,[Kr],(t,[n])=>t.id()===n.value],"filter-type-==":[Xr,[Jr],(t,[n])=>t.geometryType()===n.value],"filter-<":[Xr,[Jr,Kr],(t,[n,e])=>{const r=t.properties()[n.value],i=e.value;return typeof r==typeof i&&r<i}],"filter-id-<":[Xr,[Kr],(t,[n])=>{const e=t.id(),r=n.value;return typeof e==typeof r&&e<r}],"filter->":[Xr,[Jr,Kr],(t,[n,e])=>{const r=t.properties()[n.value],i=e.value;return typeof r==typeof i&&r>i}],"filter-id->":[Xr,[Kr],(t,[n])=>{const e=t.id(),r=n.value;return typeof e==typeof r&&e>r}],"filter-<=":[Xr,[Jr,Kr],(t,[n,e])=>{const r=t.properties()[n.value],i=e.value;return typeof r==typeof i&&r<=i}],"filter-id-<=":[Xr,[Kr],(t,[n])=>{const e=t.id(),r=n.value;return typeof e==typeof r&&e<=r}],"filter->=":[Xr,[Jr,Kr],(t,[n,e])=>{const r=t.properties()[n.value],i=e.value;return typeof r==typeof i&&r>=i}],"filter-id->=":[Xr,[Kr],(t,[n])=>{const e=t.id(),r=n.value;return typeof e==typeof r&&e>=r}],"filter-has":[Xr,[Kr],(t,[n])=>n.value in t.properties()],"filter-has-id":[Xr,[],t=>null!==t.id()&&void 0!==t.id()],"filter-type-in":[Xr,[ei(Jr)],(t,[n])=>n.value.indexOf(t.geometryType())>=0],"filter-id-in":[Xr,[ei(Kr)],(t,[n])=>n.value.indexOf(t.id())>=0],"filter-in-small":[Xr,[Jr,ei(Kr)],(t,[n,e])=>e.value.indexOf(t.properties()[n.value])>=0],"filter-in-large":[Xr,[Jr,ei(Kr)],(t,[n,e])=>function(t,n,e,r){for(;e<=r;){const i=e+r>>1;if(n[i]===t)return!0;n[i]>t?r=i-1:e=i+1}return!1}(t.properties()[n.value],e.value,0,e.value.length-1)],all:{type:Xr,overloads:[[[Xr,Xr],(t,[n,e])=>n.evaluate(t)&&e.evaluate(t)],[ho(Xr),(t,n)=>{for(const e of n)if(!e.evaluate(t))return!1;return!0}]]},any:{type:Xr,overloads:[[[Xr,Xr],(t,[n,e])=>n.evaluate(t)||e.evaluate(t)],[ho(Xr),(t,n)=>{for(const e of n)if(e.evaluate(t))return!0;return!1}]]},"!":[Xr,[Xr],(t,[n])=>!n.evaluate(t)],"is-supported-script":[Xr,[Jr],(t,[n])=>{const e=t.globals&&t.globals.isSupportedScript;return!e||e(n.evaluate(t))}],upcase:[Jr,[Jr],(t,[n])=>n.evaluate(t).toUpperCase()],downcase:[Jr,[Jr],(t,[n])=>n.evaluate(t).toLowerCase()],concat:[Jr,ho(Kr),(t,n)=>n.map(n=>Fi(n.evaluate(t))).join("")],"resolved-locale":[Jr,[Qr],(t,[n])=>n.evaluate(t).resolvedLocale()]});var co=oo;function fo(t){return{result:"success",value:t}}function po(t){return{result:"error",value:t}}function yo(t){return!!t.expression&&t.expression.interpolated}function mo(t){return t instanceof Number?"number":t instanceof String?"string":t instanceof Boolean?"boolean":Array.isArray(t)?"array":null===t?"null":typeof t}function go(t){return"object"==typeof t&&null!==t&&!Array.isArray(t)}function vo(t){return t}function bo(t,n,e){return void 0!==t?t:void 0!==n?n:void 0!==e?e:void 0}function wo(t,n,e,r,i){return bo(typeof e===i?r[e]:void 0,t.default,n.default)}function Mo(t,n,e){if("number"!==mo(e))return bo(t.default,n.default);const r=t.stops.length;if(1===r)return t.stops[0][1];if(e<=t.stops[0][0])return t.stops[0][1];if(e>=t.stops[r-1][0])return t.stops[r-1][1];const i=hs(t.stops.map(t=>t[0]),e);return t.stops[i][1]}function xo(t,n,e){const r=void 0!==t.base?t.base:1;if("number"!==mo(e))return bo(t.default,n.default);const i=t.stops.length;if(1===i)return t.stops[0][1];if(e<=t.stops[0][0])return t.stops[0][1];if(e>=t.stops[i-1][0])return t.stops[i-1][1];const s=hs(t.stops.map(t=>t[0]),e),o=function(t,n,e,r){const i=r-e,s=t-e;return 0===i?0:1===n?s/i:(Math.pow(n,s)-1)/(Math.pow(n,i)-1)}(e,r,t.stops[s][0],t.stops[s+1][0]),a=t.stops[s][1],u=t.stops[s+1][1];let l=ms[n.type]||vo;if(t.colorSpace&&"rgb"!==t.colorSpace){const n=Os[t.colorSpace];l=(t,e)=>n.reverse(n.interpolate(n.forward(t),n.forward(e),o))}return"function"==typeof a.evaluate?{evaluate(...t){const n=a.evaluate.apply(void 0,t),e=u.evaluate.apply(void 0,t);if(void 0!==n&&void 0!==e)return l(n,e,o)}}:l(a,u,o)}function Fo(t,n,e){return"color"===n.type?e=yi.parse(e):"formatted"===n.type?e=vi.fromString(e.toString()):"resolvedImage"===n.type?e=bi.fromString(e.toString()):mo(e)===n.type||"enum"===n.type&&n.values[e]||(e=void 0),bo(e,t.default,n.default)}class Ao{constructor(t,n){this.expression=t,this.W={},this.q=new Di,this.G=n?function(t){return"color"===t.type&&(go(t.default)||Array.isArray(t.default))?new yi(0,0,0,0):"color"===t.type?yi.parse(t.default)||null:void 0===t.default?null:t.default}(n):null,this.B=n&&"enum"===n.type?n.values:null}evaluateWithoutErrorHandling(t,n,e,r,i,s,o,a){return this.q.globals=t,this.q.feature=n,this.q.featureState=e,this.q.canonical=r||null,this.q.availableImages=i||null,this.q.formattedSection=s,this.q.featureTileCoord=o||null,this.q.featureDistanceData=a||null,this.expression.evaluate(this.q)}evaluate(t,n,e,r,i,s,o,a){this.q.globals=t,this.q.feature=n||null,this.q.featureState=e||null,this.q.canonical=r||null,this.q.availableImages=i||null,this.q.formattedSection=s||null,this.q.featureTileCoord=o||null,this.q.featureDistanceData=a||null;try{const t=this.expression.evaluate(this.q);if(null==t||"number"==typeof t&&t!=t)return this.G;if(this.B&&!(t in this.B))throw new Pi(`Expected value to be one of ${Object.keys(this.B).map(t=>JSON.stringify(t)).join(", ")}, but found ${JSON.stringify(t)} instead.`);return t}catch(t){return this.W[t.message]||(this.W[t.message]=!0,"undefined"!=typeof console&&console.warn(t.message)),this.G}}}function ko(t){return Array.isArray(t)&&t.length>0&&"string"==typeof t[0]&&t[0]in co}function Po(t,n){const e=new ls(co,[],n?function(t){const n={color:Yr,string:Jr,number:Br,enum:Jr,boolean:Xr,formatted:ti,resolvedImage:ni};return"array"===t.type?ei(n[t.value]||Kr,t.length):n[t.type]}(n):void 0),r=e.parse(t,void 0,void 0,void 0,n&&"string"===n.type?{typeAnnotation:"coerce"}:void 0);return r?fo(new Ao(r,n)):po(e.errors)}class So{constructor(t,n){this.kind=t,this.J=n,this.isStateDependent="constant"!==t&&!is(n.expression)}evaluateWithoutErrorHandling(t,n,e,r,i,s){return this.J.evaluateWithoutErrorHandling(t,n,e,r,i,s)}evaluate(t,n,e,r,i,s){return this.J.evaluate(t,n,e,r,i,s)}}class _o{constructor(t,n,e,r){this.kind=t,this.zoomStops=e,this.J=n,this.isStateDependent="camera"!==t&&!is(n.expression),this.interpolationType=r}evaluateWithoutErrorHandling(t,n,e,r,i,s){return this.J.evaluateWithoutErrorHandling(t,n,e,r,i,s)}evaluate(t,n,e,r,i,s){return this.J.evaluate(t,n,e,r,i,s)}interpolationFactor(t,n,e){return this.interpolationType?$s.interpolationFactor(this.interpolationType,t,n,e):0}}function Oo(t,n){if("error"===(t=Po(t,n)).result)return t;const e=t.value.expression,r=rs(e);if(!r&&!function(t){return"data-driven"===t["property-type"]}(n))return po([new Hr("","data expressions not supported")]);const i=ss(e,["zoom","pitch","distance-from-center"]);if(!i&&!function(t){return!!t.expression&&t.expression.parameters.indexOf("zoom")>-1}(n))return po([new Hr("","zoom expressions not supported")]);const s=function t(n){let e=null;if(n instanceof Ds)e=t(n.result);else if(n instanceof Ts){for(const r of n.args)if(e=t(r),e)break}else(n instanceof fs||n instanceof $s)&&n.input instanceof Ui&&"zoom"===n.input.name&&(e=n);return e instanceof Hr||n.eachChild(n=>{const r=t(n);r instanceof Hr?e=r:!e&&r?e=new Hr("",\'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.\'):e&&r&&e!==r&&(e=new Hr("",\'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.\'))}),e}(e);if(!s&&!i)return po([new Hr("",\'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.\')]);if(s instanceof Hr)return po([s]);if(s instanceof $s&&!yo(n))return po([new Hr("",\'"interpolate" expressions cannot be used with this property\')]);if(!s)return fo(new So(r?"constant":"source",t.value));const o=s instanceof $s?s.interpolation:void 0;return fo(new _o(r?"camera":"composite",t.value,s.labels,o))}class Eo{constructor(t,n){this.X=t,this.Y=n,Vr(this,function t(n,e){const r="color"===e.type,i=n.stops&&"object"==typeof n.stops[0][0],s=i||!(i||void 0!==n.property),o=n.type||(yo(e)?"exponential":"interval");if(r&&((n=Vr({},n)).stops&&(n.stops=n.stops.map(t=>[t[0],yi.parse(t[1])])),n.default=yi.parse(n.default?n.default:e.default)),n.colorSpace&&"rgb"!==n.colorSpace&&!Os[n.colorSpace])throw new Error("Unknown color space: "+n.colorSpace);let a,u,l;if("exponential"===o)a=xo;else if("interval"===o)a=Mo;else if("categorical"===o){a=wo,u=Object.create(null);for(const t of n.stops)u[t[0]]=t[1];l=typeof n.stops[0][0]}else{if("identity"!==o)throw new Error(`Unknown function type "${o}"`);a=Fo}if(i){const r={},i=[];for(let t=0;t<n.stops.length;t++){const e=n.stops[t],s=e[0].zoom;void 0===r[s]&&(r[s]={zoom:s,type:n.type,property:n.property,default:n.default,stops:[]},i.push(s)),r[s].stops.push([e[0].value,e[1]])}const s=[];for(const n of i)s.push([r[n].zoom,t(r[n],e)]);const o={name:"linear"};return{kind:"composite",interpolationType:o,interpolationFactor:$s.interpolationFactor.bind(void 0,o),zoomStops:s.map(t=>t[0]),evaluate:({zoom:t},r)=>xo({stops:s,base:n.base},e,t).evaluate(t,r)}}if(s){const t="exponential"===o?{name:"exponential",base:void 0!==n.base?n.base:1}:null;return{kind:"camera",interpolationType:t,interpolationFactor:$s.interpolationFactor.bind(void 0,t),zoomStops:n.stops.map(t=>t[0]),evaluate:({zoom:t})=>a(n,e,t,u,l)}}return{kind:"source",evaluate(t,r){const i=r&&r.properties?r.properties[n.property]:void 0;return void 0===i?bo(n.default,e.default):a(n,e,i,u,l)}}}(this.X,this.Y))}static deserialize(t){return new Eo(t.X,t.Y)}static serialize(t){return{X:t.X,Y:t.Y}}}function Io(t){if(Array.isArray(t))return t.map(Io);if(t instanceof Object&&!(t instanceof Number||t instanceof String||t instanceof Boolean)){const n={};for(const e in t)n[e]=Io(t[e]);return n}return function(t){return t instanceof Number||t instanceof String||t instanceof Boolean?t.valueOf():t}(t)}function $o(t){if(!Array.isArray(t))return!1;if(function(t){return"pitch"===t||"distance-from-center"===t}(t[0]))return!0;for(let n=1;n<t.length;n++)if($o(t[n]))return!0;return!1}const Co=new Set(["in","==","!=",">",">=","<","<=","to-boolean"]),To={StyleExpression:Ao,isExpression:ko,isExpressionFilter:function t(n){if(!0===n||!1===n)return!0;if(!Array.isArray(n)||0===n.length)return!1;switch(n[0]){case"has":return n.length>=2&&"$id"!==n[1]&&"$type"!==n[1];case"in":return n.length>=3&&("string"!=typeof n[1]||Array.isArray(n[2]));case"!in":case"!has":case"none":return!1;case"==":case"!=":case">":case">=":case"<":case"<=":return 3!==n.length||Array.isArray(n[1])||Array.isArray(n[2]);case"any":case"all":for(const e of n.slice(1))if(!t(e)&&"boolean"!=typeof e)return!1;return!0;default:return!0}},createExpression:Po,createPropertyExpression:Oo,normalizePropertyExpression:function(t,n){if(go(t))return new Eo(t,n);if(ko(t)){const e=Oo(t,n);if("error"===e.result)throw new Error(e.value.map(t=>`${t.key}: ${t.message}`).join(", "));return e.value}{let e=t;return"string"==typeof t&&"color"===n.type&&(e=yi.parse(t)),{kind:"constant",evaluate:()=>e}}},ZoomConstantExpression:So,ZoomDependentExpression:_o,StylePropertyFunction:Eo},{isExpression:zo,createExpression:Do}=To,jo={};function Uo(t){if(!0===t)return function(){return!0};if(t&&t.condition){if("any"===t.type){const n=t.condition,e=[];for(let t=0;t<n.length;t++)e.push(Uo(n[t]));return(t,n)=>{for(let r=0;r<e.length;r++)if(e[r](t,n))return!0;return!1}}const n=Uo(t.condition);if(gr(t.layer))return n;const e=n=>n.layer===t.layer;return(t,r)=>e(t)&&n(t,r)}if(function t(n){if(!0===n||!1===n)return!0;if(!Array.isArray(n)||0===n.length)return!1;switch(n[0]){case"has":case"!has":return 2===n.length&&("string"==typeof n[1]||n[1].property&&n[1].op);case"in":case"!in":return n.length>=2&&("string"==typeof n[1]||n[1].property&&n[1].op);case"==":case"!=":case">":case">=":case"<":case"<=":return 3===n.length&&("string"==typeof n[1]||n[1].property&&n[1].op);case"none":case"any":case"all":for(const e of n.slice(1))if(!t(e)&&"boolean"!=typeof e)return!1;return!0;case"contains":return!0;default:return!1}}(t))return zn(t);{let n=function(t,n="fill"){if(null==t)return{filter:()=>!0,needGeometry:!1,needFeature:!1};const e=t;let r=!0;try{r=function(t){if(!$o(t))return t;let n=Io(t);return function t(n){let e=!1;const r=[];if("case"===n[0]){for(let t=1;t<n.length-1;t+=2)e=e||$o(n[t]),r.push(n[t+1]);r.push(n[n.length-1])}else if("match"===n[0]){e=e||$o(n[1]);for(let t=2;t<n.length-1;t+=2)r.push(n[t+1]);r.push(n[n.length-1])}else if("step"===n[0]){e=e||$o(n[1]);for(let t=1;t<n.length-1;t+=2)r.push(n[t+1])}e&&(n.length=0,n.push("any",...r));for(let e=1;e<n.length;e++)t(n[e])}(n),n=function t(n){if(!Array.isArray(n))return n;const e=function(t){if(Co.has(t[0]))for(let n=1;n<t.length;n++)if($o(t[n]))return!0;return t}(n);return!0===e?e:e.map(n=>t(n))}(n),n}(e)}catch(t){console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\\nand paste the contents of this message in the report.\\nThank you!\\nFilter Expression:\\n${JSON.stringify(e,null,2)}\\n        `)}const i=Po(r,null);let s=null;if("error"===i.result)throw new Error(i.value.map(t=>`${t.key}: ${t.message}`).join(", "));s=(t,n,e)=>i.value.evaluate(t,n,{},e);let o=null,a=null;if(r!==e){const t=Po(e,null);if("error"===t.result)throw new Error(t.value.map(t=>`${t.key}: ${t.message}`).join(", "));o=(n,e,r,i,s)=>t.value.evaluate(n,e,{},r,void 0,void 0,i,s),a=!rs(t.value.expression)}return s=s,{filter:s,dynamicFilter:o||void 0,needGeometry:function t(n){if(!Array.isArray(n))return!1;if("within"===n[0])return!0;for(let e=1;e<n.length;e++)if(t(n[e]))return!0;return!1}(r),needFeature:!!a}}(t);return n=n&&n.filter,(t,e)=>(jo.zoom=e,n&&n(jo,t))}}const No={type:"number","property-type":"data-driven",expression:{parameters:["zoom","feature"]}};function Lo(t,n){No.type=n||"number";const e=Do(t,No);if("success"!==e.result)throw new Error(`Invalid maplibre spec expression: ${JSON.stringify(t)} (${e.value})`);return e.value}function Vo(t){return zo(t)}const Ro={lineWidth:1,lineStrokeWidth:1,lineDx:1,lineDy:1,lineOpacity:1,linePatternAnimSpeed:1,markerWidth:1,markerHeight:1,markerDx:1,markerDy:1,markerSpacing:1,markerOpacity:1,markerRotation:1,textWrapWidth:1,textSpacing:1,textSize:1,textHaloRadius:1,textHaloOpacity:1,textDx:1,textDy:1,textOpacity:1,textRotation:1,polygonOpacity:1};function Ho(t){return Ro[t]}const Wo={markerPlacement:1,markerFile:1,mergeOnProperty:1,markerTextFit:1,markerType:1,markerHorizontalAlignment:1,markerVerticalAlignment:1,markerRotationAlignment:1,markerPitchAlignment:1,markerFillPatternFile:1,markerLinePatternFile:1,textName:1,textPlacement:1,textFaceName:1,textStyle:1,textHorizontalAlignment:1,textVerticalAlignment:1,textRotationAlignment:1,textPitchAlignment:1,lineJoin:1,lineCap:1,linePatternFile:1,polygonPatternFile:1},qo={lineDasharray:1,markerLineDasharray:1,uvScale:1,uvOffset:1};function Go(t){return Wo[t]?"string":Ho(t)?"number":qo[t]?"array":"color"}var Bo=Object.freeze({__proto__:null,compileStyle:function(t=[]){return function t(n){if(!Array.isArray(n))return t([n]);const e=[];for(let t=0;t<n.length;t++){let r;r=!0===n[t].filter?function(){return!0}:Uo(n[t].filter),e.push(mr({},n[t],{filter:r}))}return e}(t=t.map(t=>{const n=mr({},t);return n.filter&&n.filter.value&&(n.filter=n.filter.value),n}))},compileFilter:Uo,createExpression:Lo,isExpression:Vo,isInterpolated:Ho,getExpressionType:Go});const Jo="undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope;class Xo extends Array{pushIn(...t){const n=t.length;for(let e=0;e<n;e++)this[this.Z++]=t[e]}fill(t,n,e){super.fill(t,n,e),e>this.Z&&(this.Z=e)}set(t,n){t>=this.Z&&(this.Z=t+1),this[t]=n}getLength(){return this.Z}setLength(t){this.Z=t,super.length<t&&(super.length=t)}trySetLength(t){t>this.Z&&this.setLength(t)}reset(){this.Z=0}}const Yo={get:function(t,n){return"length"===n?t.getLength():t[n]}};class Zo extends Array{setLength(t){super.length=t}trySetLength(t){super.length=t}getLength(){return super.length}}let Ko;class Qo{static createTypedArray(t,n){return pr(t,n)}static getInstance(){return Ko}static getArray(){const t=new Xo,n=new Proxy(t,Yo);return n.push=(...n)=>{t.pushIn(...n)},n.U=t,n}constructor(){this.K=[],this.Z=0}get(){if(!Jo)return new Zo;const t=this.K[this.Z]=this.K[this.Z]||Qo.getArray();return t.reset(),this.Z++,t}reset(){this.Z=0}}Ko=new Qo;const ta=[],na={},ea={},ra={},ia=[],sa=Qo.getInstance(),oa=Math.pow(2,17);class aa{static isAtlasLoaded(t,n={}){const{iconAtlas:e}=n;return!!(!t||e&&e.positions[t])}static genFnTypes(t){const n={};for(const e in t)if(Vo(t[e])){const r=(e+"_Fn_0").trim(),i=(e+"Fn").trim(),s=Go(e);n[r]=Lo(t[e],s),n[i]=(t,e)=>{let i;na.zoom=t,ea.properties=e;try{i=n[r].evaluateWithoutErrorHandling(na,ea,ra,null,ia)}catch(t){return null}return i}}else if(kr(t[e])){const r=(e+"_Fn_0").trim(),i=(e+"Fn").trim();Ho(e)?(n[r]=p(t[e]),n[i]=(t,e)=>{const i=n[r](t,e);return kr(i)?p(i)(t,e):i}):(n[r]=y(t[e]),n[i]=(t,e)=>{const i=n[r](t,e);return kr(i)?y(i)(t,e):i})}return n}constructor(t,n,e){this.options=e;const r=[];this.symbolDef=n,this.symbol=m(n,()=>(r[0]=e.zoom,r)),this.styledVectors=[],this.properties={},this.tt=e.fnTypes||aa.genFnTypes(this.symbolDef),kr(this.symbolDef.visible)&&(this.nt=p(this.symbolDef.visible)),e.atlas&&(this.iconAtlas=e.atlas.iconAtlas,this.glyphAtlas=e.atlas.glyphAtlas),this.features=this.et(t)}needAltitudeAttribute(){return this.options.forceAltitudeAttribute||this.maxPosZ>=oa||this.options.positionType===Float32Array}getPositionFormat(){return this.needAltitudeAttribute()?[{type:Int16Array,width:2,name:"aPosition"},{type:Float32Array,width:1,name:"aAltitude"}]:[{type:Int16Array,width:3,name:"aPosition"}]}fillPosition(t,n,e,r){n<this.rt&&(this.rt=n),n>this.it&&(this.it=n),e<this.st&&(this.st=e),e>this.ot&&(this.ot=e),this.needAltitudeAttribute()?(t.aPosition.push(n,e),t.aAltitude.push(r)):(Tr(ta,n,e,r),t.aPosition.push(ta[0],ta[1],ta[2]))}et(t){if(!t.length)return t;const n="__fea_idx".trim();let e,r=0,i=t[r];for(;!i.geometry;)r++,i=t[r];if(Array.isArray(i.geometry)&&i.properties){let n=i.geometry[0];for(;Array.isArray(n);)n=n[0];n instanceof Ut&&(e=t)}if(!e)if(e=[],Array.isArray(i.geometry))for(let n=0;n<t.length;n++){const r=mr({},t[n]);e.push(yr(r))}else for(let r=0;r<t.length;r++){const i=t[r],s=Ve(i);for(let t=0;t<s.length;t++){const r=s[t];r[n]=i[n],e.push(r)}}if(this.maxPosZ=0,!this.options.forceAltitudeAttribute){const t="line"===this.symbolDef.textPlacement;let n=0,r=!1;const{textPitchAlignmentFn:i}=this.tt;!i&&t&&"map"===this.symbolDef.textPitchAlignment&&(r=!0);for(let s=0;s<e.length;s++){const o=la(e[s]&&e[s].geometry);if(o>n&&(n=o),t&&!r&&i&&e[s].properties){const t=i(null,e[s].properties);"map"===t&&(r=t)}}this.hasMapPitchAlign=r,this.maxPosZ=n}const s=this.options.order;if(s){const t=[];for(let n=0;n<s.length;n++)s[n]&&t.push(Uo(s[n]));e=e.sort((n,e)=>{const r=t.length;let i=-1,s=-1;for(let o=0;o<r&&(t[o](n)&&(i=o),t[o](e)&&(s=o),!(i>=0&&i<r&&s>=0&&s<r));o++);return i-s})}return e}load(t=1){const n="__fea_idx".trim(),e="_debug_info".trim(),r=this.tt,i=this.styledVectors;this.count=0;const s=this.features;if(!s||!s.length)return Promise.resolve(null);const o={},a={},u={zoom:this.options.zoom,isVector3D:!!this.options.center},l=[],h=m(this.symbolDef,()=>(l[0]=u.zoom,l));let c=0,f=s.length;const d=this.options.debugIndex;try{for(;c<f;c++){const t=s[c];if(!t||!t.geometry)continue;if(vr(d)&&t[e].index!==d)continue;t.properties||(t.properties={}),t.properties.$layer=t.layer,t.properties.$type=t.type;const l=this.createStyledVector(t,h,r,u,o,a);l&&l.feature.geometry&&(l.featureIdx=void 0===t[n]?c:t[n],this.count++,i.push(l))}}catch(t){return Promise.reject(t)}return this.options.atlas?Promise.resolve(this.pack(t)):this.loadAtlas(o,a).then(()=>this.pack(t))}loadAtlas(t,n){return new Promise((e,r)=>{this.fetchAtlas(t,n,(t,n)=>{if(t)r(t);else{if(n){const{icons:t,glyphs:e}=n;if(t&&Object.keys(t).length){for(const n in t){const e=t[n],{width:r,height:i,data:s}=e.data;e.data=new Ze({width:r,height:i},s)}this.iconAtlas=new ur(t)}if(e&&Object.keys(e).length){for(const t in e){const n=e[t];for(const t in n){const e=n[t],{width:r,height:i,data:s}=e.bitmap;e.bitmap=new Ye({width:r,height:i},s)}}this.glyphAtlas=new hr(e)}}e({glyphAtlas:this.glyphAtlas,iconAtlas:this.iconAtlas})}})})}fetchAtlas(t,n,e){Object.keys(t).length>0||Object.keys(n).length>0?this.options.requestor(t,n,e):e()}pack(t){if(!this.count)return null;if(null==t)throw new Error("layout scale is undefined");const n=this.createDataPack(this.styledVectors,t);if(!n)return null;n.properties=this.properties,this.empty&&(n.empty=!0);const e=n.buffers;delete n.buffers;const r={data:n,buffers:e};if(this.iconAtlas){const t=r.data.iconAtlas=ua(this.iconAtlas);if(t.glyphMap)for(const n in t.glyphMap)e.push(t.glyphMap[n].data.data.buffer);e.push(r.data.iconAtlas.image.data.buffer)}return this.glyphAtlas&&(r.data.glyphAtlas=ua(this.glyphAtlas),e.push(r.data.glyphAtlas.image.data.buffer)),r}createStyledVector(t,n,e,r){return new Cr(t,n,e,r)}createDataPack(t,n){if(!t||!t.length)return null;this.maxIndex=0,this.maxPos=0,this.rt=this.st=1/0,this.it=this.ot=-1/0,this.maxAltitude=0,this.dynamicAttrs={};const e=this.data={};this.ut=sa,sa.reset();let r=this.elements=sa.get();const i=this.getFormat(Array.isArray(t[0])?t[0][0].symbol:t[0].symbol),s=this.needAltitudeAttribute()?2:3;for(let t=0;t<i.length;t++)e[i[t].name]=sa.get();let o=sa.get(),a=0;const u=sa.get();let l=0,h=!1,c=!0;const f=new Set;for(let r=0,i=t.length;r<i;r++){if(!t[r].feature.geometry)continue;const i=Array.isArray(t[r])?t[r][0].feature.id:t[r].feature.id;c&&(void 0!==ea.id?f&&(f.has(ea.id)?c=!1:f.add(ea.id)):c=!1),vr(i)&&(Math.abs(i)>l&&(l=Math.abs(i)),i<0&&(h=!0));const d=this.data.aPosition.length;if(Array.isArray(t[r]))for(let e=0;e<t[r].length;e++)this.lt(t[r][e],n);else this.lt(t[r],n);const p=(e.aPosition.length-d)/s;for(let n=0;n<p;n++)o.push(t[r].featureIdx),vr(i)&&u.push(i);a=Math.max(a,t[r].featureIdx)}if(this.countOutOfAngle>0&&console.warn("text anchor along line is ignored as anchor\'s line angle is bigger than textMaxAngle."),this.hasElements()&&!r.length)return null;const d=this.options.center?Float32Array:dr(a);o=Qo.createTypedArray(o,d),i[0].type=this.options.positionType?this.options.positionType:fr(this.maxPos);const p=this.options.center;if(p&&(p[0]||p[1])){const t=e.aPosition;for(let n=0;n<t.length;n+=s)t[n]-=p[0],t[n+1]-=p[1]}const y=function(t,n){const e={};for(let r=0;r<t.length;r++){const i=t[r],s=i.type,o=i.name;e[o]=s===Array?n[o]:pr(n[o],s)}return e}(i,e);y.aPickingId=o;const m=[];for(const t in y)m.push(y[t].buffer);const g=cr(this.maxIndex);r=Qo.createTypedArray(r,g),m.push(r.buffer);const v={data:y,isIdUnique:c,is2D:0===this.maxPosZ,indices:this.hasElements()?r:null,positionSize:s,positionBounding:[this.rt,this.st,this.it,this.ot],buffers:m,symbolIndex:this.symbolDef.index||{index:0},dynamicAttributes:this.dynamicAttrs};if(this.ht&&(v.markerPlacement=this.ht),this.ct&&(v.textPlacement=this.ct),u.length){const t=h?fr(l):dr(l);v.featureIds=Qo.createTypedArray(u,t),m.push(v.featureIds.buffer)}else v.featureIds=[];return v.pickingIdIndiceMap=sr(o,v.indices),v}lt(t,n){this.nt&&!this.nt(this.options.zoom,t.feature.properties)||this.placeVector(t,n,this.formatWidth)}addElements(...t){this.maxIndex=Math.max(this.maxIndex,...t),this.elements.push(...t)}hasElements(){return!0}getAltitude(t){const{altitudeProperty:n,defaultAltitude:e,altitudeScale:r}=this.options;let i=tr(t,n,e);return r&&(i*=r),this.maxAltitude=Math.max(this.maxAltitude,Math.abs(i)),i}getIconAtlasMaxValue(){const t=this.iconAtlas.positions;let n=0;for(const e in t)if(Fr(t,e)){const{tl:r,displaySize:i}=t[e],s=Math.max(r[0],r[1],i[0]-1,i[1]-1);s>n&&(n=s)}return n}}function ua(t){let n=t.positions,e=t.image&&t.image.format||"alpha";if(t instanceof ur){n={};for(const e in t.positions){const r=t.positions[e];n[e]={paddedRect:r.paddedRect,pixelRatio:r.pixelRatio,tl:r.tl,br:r.br,displaySize:r.displaySize}}e="rgba"}const r=t.image;return{image:{width:r.width,height:r.height,data:r.data,format:e},glyphMap:t.glyphMap,positions:n}}function la(t){if(!t)return 0;let n=0;if(Array.isArray(t))for(let e=0;e<t.length;e++)if(Array.isArray(t[e])){const r=la(t[e]);r>n&&(n=r)}else{const r=Math.abs(t[e].z||0);r>n&&(n=r)}else{const e=Math.abs(t.z||0);e>n&&(n=e)}return n}function ha(t,n,e,r){const i="__fn_textSize".trim();let s=t.textSize;if(gr(n.textSize))return[16,16];t[i]&&(s=t[i]);const o=[];if(o[0]=Mr(s)?s(r,e):s,d(o[0])){const n=o[0].ft=o[0].ft||JSON.stringify(o[0]);t.dt||(t.dt={}),t.dt[n]||(t.dt[n]=p(o[0])),o[0]=(0,t.dt[n])(r,e)}return o[1]=o[0],o}function ca(t){const n=t.stops;let e=-1/0;for(let t=0;t<n.length;t++){let r=n[t][1];br(n[t][1])&&(r=ca(n[t][1])),r>e&&(e=r)}return e}function fa(t,n,e){return[n||"normal",e||"normal","24px",t||"Open Sans Regular"].join(" ")}const da=/\\{[\\w-]+(?:\\|[\\w-]+)*\\}/g;function pa(t,n){return wr(t)?t.replace(da,(function(t){if(!n)return"";if((t=t.substring(1,t.length-1)).indexOf("|")>0){const e=t.split("|");for(let t=0;t<e.length;t++){const r=n[e[t]];if(!gr(r))return r}return""}const e=n[t];return gr(e)?"":Array.isArray(e)?e.join():e})):t}var ya=Object.freeze({__proto__:null,getSDFFont:fa,resolveText:pa,resolveVarNames:function(t){return t.match(da)},resolveExpVarNames:function t(n,e){if(2!==e.length||"get"!==e[0])for(let r=0;r<e.length;r++)2===e[r].length&&"get"===e[r][0]?n.push(e[r][1]):Array.isArray(e[r])&&t(n,e[r]);else n.push(e[1])}});const ma=t=>t>=11904&&t<=12031,ga=t=>t>=12032&&t<=12255,va=t=>t>=12272&&t<=12287,ba=t=>t>=12288&&t<=12351,wa=t=>t>=12352&&t<=12447,Ma=t=>t>=12448&&t<=12543,xa=t=>t>=12544&&t<=12591,Fa=t=>t>=12704&&t<=12735,Aa=t=>t>=12736&&t<=12783,ka=t=>t>=12784&&t<=12799,Pa=t=>t>=12800&&t<=13055,Sa=t=>t>=13056&&t<=13311,_a=t=>t>=13312&&t<=19903,Oa=t=>t>=19968&&t<=40959,Ea=t=>t>=40960&&t<=42127,Ia=t=>t>=42128&&t<=42191,$a=t=>t>=63744&&t<=64255,Ca=t=>t>=64336&&t<=65023,Ta=t=>t>=65040&&t<=65055,za=t=>t>=65072&&t<=65103,Da=t=>t>=65104&&t<=65135,ja=t=>t>=65136&&t<=65279,Ua=t=>t>=65280&&t<=65519;function Na(t){return!((t=>t>=1536&&t<=1791)(t)||(t=>t>=1872&&t<=1919)(t)||(t=>t>=2208&&t<=2303)(t)||Ca(t)||ja(t))}function La(t){return!!(746===t||747===t||!(t<4352)&&(Fa(t)||xa(t)||za(t)&&!(t>=65097&&t<=65103)||$a(t)||Sa(t)||ma(t)||Aa(t)||!(!ba(t)||t>=12296&&t<=12305||t>=12308&&t<=12319||12336===t)||_a(t)||Oa(t)||Pa(t)||(t=>t>=12592&&t<=12687)(t)||(t=>t>=43360&&t<=43391)(t)||(t=>t>=55216&&t<=55295)(t)||(t=>t>=4352&&t<=4607)(t)||(t=>t>=44032&&t<=55215)(t)||wa(t)||va(t)||(t=>t>=12688&&t<=12703)(t)||ga(t)||ka(t)||Ma(t)&&12540!==t||!(!Ua(t)||65288===t||65289===t||65293===t||t>=65306&&t<=65310||65339===t||65341===t||65343===t||t>=65371&&t<=65503||65507===t||t>=65512&&t<=65519)||!(!Da(t)||t>=65112&&t<=65118||t>=65123&&t<=65126)||(t=>t>=5120&&t<=5759)(t)||(t=>t>=6320&&t<=6399)(t)||Ta(t)||(t=>t>=19904&&t<=19967)(t)||Ea(t)||Ia(t)))}function Va(t){return!(La(t)||function(t){return!!((t=>t>=128&&t<=255)(t)&&(167===t||169===t||174===t||177===t||188===t||189===t||190===t||215===t||247===t)||(t=>t>=8192&&t<=8303)(t)&&(8214===t||8224===t||8225===t||8240===t||8241===t||8251===t||8252===t||8258===t||8263===t||8264===t||8265===t||8273===t)||(t=>t>=8448&&t<=8527)(t)||(t=>t>=8528&&t<=8591)(t)||(t=>t>=8960&&t<=9215)(t)&&(t>=8960&&t<=8967||t>=8972&&t<=8991||t>=8996&&t<=9e3||9003===t||t>=9085&&t<=9114||t>=9150&&t<=9165||9167===t||t>=9169&&t<=9179||t>=9186&&t<=9215)||(t=>t>=9216&&t<=9279)(t)&&9251!==t||(t=>t>=9280&&t<=9311)(t)||(t=>t>=9312&&t<=9471)(t)||(t=>t>=9632&&t<=9727)(t)||(t=>t>=9728&&t<=9983)(t)&&!(t>=9754&&t<=9759)||(t=>t>=11008&&t<=11263)(t)&&(t>=11026&&t<=11055||t>=11088&&t<=11097||t>=11192&&t<=11243)||ba(t)||Ma(t)||(t=>t>=57344&&t<=63743)(t)||za(t)||Da(t)||Ua(t)||8734===t||8756===t||8757===t||t>=9984&&t<=10087||t>=10102&&t<=10131||65532===t||65533===t)}(t))}function Ra(t){return t>=1424&&t<=2303||Ca(t)||ja(t)}const Ha=[[9,9],[32,32],[5760,5760],[8192,8198],[8200,8202],[8287,12288],[6158,6158],[8203,8205]];function Wa(t){for(const n of Ha)if(t>=n[0]&&t<=n[1])return!0;return!1}const qa={"!":"︕","#":"＃",$:"＄","%":"％","&":"＆","(":"︵",")":"︶","*":"＊","+":"＋",",":"︐","-":"︲",".":"・","/":"／",":":"︓",";":"︔","<":"︿","=":"＝",">":"﹀","?":"︖","@":"＠","[":"﹇","\\\\":"＼","]":"﹈","^":"＾",pt:"︳","`":"｀","{":"︷","|":"―","}":"︸","~":"～","¢":"￠","£":"￡","¥":"￥","¦":"￤","¬":"￢","¯":"￣","–":"︲","—":"︱","‘":"﹃","’":"﹄","“":"﹁","”":"﹂","…":"︙","‧":"・","₩":"￦","、":"︑","。":"︒","〈":"︿","〉":"﹀","《":"︽","》":"︾","「":"﹁","」":"﹂","『":"﹃","』":"﹄","【":"︻","】":"︼","〔":"︹","〕":"︺","〖":"︗","〗":"︘","！":"︕","（":"︵","）":"︶","，":"︐","－":"︲","．":"・","：":"︓","；":"︔","＜":"︿","＞":"﹀","？":"︖","［":"﹇","］":"﹈","＿":"︳","｛":"︷","｜":"―","｝":"︸","｟":"︵","｠":"︶","｡":"︒","｢":"﹁","｣":"﹂"};function Ga(t,n,e,r,i,s,o,a,u,l){let h=t.trim();2===l&&(h=function(t){let n="";const e=Array.from(t);for(let t=0;t<e.length;t++){const r=e[t+1].codePointAt(0)||null,i=e[t-1].codePointAt(0)||null;n+=r&&Va(r)&&!qa[e[t+1]]||i&&Va(i)&&!qa[e[t-1]]||!qa[e[t]]?e[t]:qa[e[t]]}return n}(h));const c=[],f={positionedGlyphs:c,text:h,top:a[1],bottom:a[1],left:a[0],right:a[0],writingMode:l};let d;return d=function(t,n){const e=[];let r=0;for(let i=0;i<n.length;i++){const s=n[i];e.push(t.substring(r,s)),r=s}return r<t.length&&e.push(t.substring(r,t.length)),e}(h,function(t,n,e,r){if(!e)return[];if(!t)return[];const i=[],s=function(t,n,e,r){let i=0;for(let e=0;e<t.length;e++){const s=r[t.codePointAt(e)];s&&(i+=s.metrics.advance+n)}return i/Math.max(1,Math.ceil(i/e))}(t,n,e,r);let o=0;for(let e=0;e<t.length;e++){const u=t.codePointAt(e),l=r[u];l&&(l&&!Ba[u]&&(o+=l.metrics.advance+n),e<t.length-1&&(Ja[u]||!((a=u)<11904)&&(Fa(a)||xa(a)||za(a)||$a(a)||Sa(a)||ma(a)||Aa(a)||ba(a)||_a(a)||Oa(a)||Pa(a)||Ua(a)||wa(a)||va(a)||ga(a)||ka(a)||Ma(a)||Ta(a)||Ia(a)||Ea(a)))&&i.push(Za(e+1,o,s,i,Ya(u,t.codePointAt(e+1)),!1)))}var a;return function t(n){return n?t(n.priorBreak).concat(n.index):[]}(Za(t.length,o,s,i,0,!0))}(h,o,e,n)),function(t,n,e,r,i,s,o,a,u,l){let h=0,c=0,f=0;const d=t.positionedGlyphs,p="right"===s?1:"left"===s?0:.5;for(let t=0;t<e.length;t++){let i=e[t];if(i=i.trim(),!i.length){c-=r;continue}const s=d.length;for(let t=0;t<i.length;t++){const e=i.codePointAt(t),r=n[e];r&&(La(e)&&1!==o?(32!==e&&d.push({glyph:e,x:h,y:0,vertical:!0}),h+=u+a):(32!==e&&d.push({glyph:e,x:h,y:c,vertical:!1}),h+=r.metrics.advance+a))}d.length!==s&&(f=Math.max(h-a,f),Qa(d,n,s,d.length-1,p)),h=0,c-=r}const{horizontalAlign:y,verticalAlign:m}=Ka(i,void 0);!function(t,n,e,r,i,s,o){const a=(n-e)*i,u=-(-r*o+.5)*s;if(a||u)for(let n=0;n<t.length;n++)t[n].x+=a,t[n].y+=u}(d,p,y,m,f,r,e.length);const g=e.length*r;t.top+=-m*g,t.bottom=t.top+g,t.left+=-y*f,t.right=t.left+f}(f,n,d,r,i,s,l,o,u),!!c.length&&f}const Ba={9:!0,10:!0,11:!0,12:!0,13:!0,32:!0},Ja={10:!0,32:!0,38:!0,40:!0,41:!0,43:!0,45:!0,47:!0,173:!0,183:!0,8203:!0,8208:!0,8211:!0,8231:!0};function Xa(t,n,e,r){const i=Math.pow(t-n,2);return r?t<n?i/2:2*i:i+Math.abs(e)*e}function Ya(t,n){let e=0;return 10===t&&(e-=1e4),40!==t&&65288!==t||(e+=50),41!==n&&65289!==n||(e+=50),e}function Za(t,n,e,r,i,s){let o=null,a=Xa(n,e,i,s);for(let t=0;t<r.length;t++){const u=r[t],l=Xa(n-u.x,e,i,s)+u.badness;l<=a&&(o=u,a=l)}return{index:t,x:n,priorBreak:o,badness:a}}function Ka(t,n){let e=.5,r=.5;switch(t){case"right":case"top-right":case"bottom-right":e=n?1:0;break;case"left":case"top-left":case"bottom-left":e=n?0:1}switch(t){case"bottom":case"bottom-right":case"bottom-left":r=n?1:0;break;case"top":case"top-right":case"top-left":r=n?0:1}return{horizontalAlign:e,verticalAlign:r}}function Qa(t,n,e,r,i){if(!i)return;const s=n[t[r].glyph];if(s){const n=(t[r].x+s.metrics.advance)*i;if(!n)return;for(let i=e;i<=r;i++)t[i].x-=n}}function tu(t){if(!function(t){for(const n of t)if(Ra(n.charCodeAt(0)))return!0;return!1}(t))return t;const n=[],e=[],r=[];let i=0,s=0,o=1,a=1;for(const u of t){const t=u.codePointAt(0);Wa(t)?(r.push(u),i++):(o=Ra(t)?-1:1,a!==o?(s=i,e.length&&(a>0&&e.reverse(),n.push(...e)),r.length&&(n.splice(s,0,...r),r.length=0),a=o,e.length=0):r.length&&(e.push(...r),r.length=0),e.push(u),i++)}return r.length&&e.push(...r),e.length&&(a>0&&e.reverse(),n.push(...e)),n.reverse().join("")}const nu=/\\{ *([\\w_]+) *\\}/g;class eu{constructor(t,n,e,r,i){this.feature=t,this.symbolDef=n,this.symbol=e,this.options=i,this.yt=this.gt.bind(this),this.tt=r}gt(t,n){return this.feature.properties[n]||""}getShape(t,n){if(this.vt)return this.vt;const{textHorizontalAlignmentFn:e,textVerticalAlignmentFn:r,markerHorizontalAlignmentFn:i,markerVerticalAlignmentFn:s,textWrapWidthFn:o}=this.tt;let a;const u=this.symbol,l=this.getIconAndGlyph(),h=this.feature.properties;if(l&&l.glyph){const{font:t,text:i}=l.glyph;if(""===i)return null;const s=this.size[0]/24,c=24,f=u.textKeepUpright,d="map"===u.textRotationAlignment&&"line"===u.textPlacement&&!u.isIconText,p=n.glyphMap[t],y=ru(e?e(null,h):u.textHorizontalAlignment,r?r(null,h):u.textVerticalAlignment),m=1.2*c,g=function(t){for(let n=0;n<t.length;n++)if(!Na(t.charAt(n).charCodeAt(0)))return!1;return!0}(i),v=g&&u.textLetterSpacing/s||0,b=[u.textDx/s||0,u.textDy/s||0],w=((o?o(null,h):u.textWrapWidth)||10*c)/s;a={},a.horizontal=Ga(i,p,w,m,y,"center",v,b,c,1),g&&d&&f&&(a.vertical=Ga(i,p,w,m,y,"center",v,b,c,2))}else if(l&&l.icon){if(!t.positions[l.icon.url])return null;const n=ru(i?i(null,h):u.markerHorizontalAlignment,s?s(null,h):u.markerVerticalAlignment);a=function(t,n,e){let{horizontalAlign:r,verticalAlign:i}=Ka(n,e);e?r=1-r:i=1-i;const s=-2048*r,o=-2048*i;return{image:t,top:o,bottom:o+2048,left:s,right:s+2048}}(t.positions[l.icon.url],n,this.options.isVector3D),this.size||(this.size=a.image.displaySize)}return this.vt=a,a}getIconAndGlyph(){if(this.iconGlyph)return this.iconGlyph;const{markerFileFn:t,markerTypeFn:n,markerPathFn:e,markerWidthFn:r,markerHeightFn:i,markerFillFn:s,markerFillPatternFileFn:o,markerFillOpacityFn:a,markerTextFitFn:u,markerTextFitPaddingFn:l,markerLineColorFn:h,markerLineWidthFn:c,markerLineOpacityFn:f,markerLineDasharrayFn:y,markerLinePatternFileFn:m,markerPathWidthFn:g,markerPathHeightFn:v,textNameFn:b,textFaceNameFn:w,textStyleFn:M,textWeightFn:x}=this.tt,{zoom:F}=this.options,A={},k=this.symbol,P=this.feature.properties,S=t?t(null,P):k.markerFile,_=n?n(null,P):k.markerType,O=S||_||k.markerPath,E=!gr(this.symbolDef.textName);let I;if(O){I=function(t,n,e,r,i,s){if(gr(n.markerWidth)&&gr(n.markerHeight))return null;const o="__fn_markerWidth".trim(),a="__fn_markerHeight".trim();let u=n.markerWidth||0,l=n.markerHeight||0;return br(u)&&("identity"!==u.type?u=ca(u):(u=t.markerWidth,t[o]&&(u=t[o](r,e)),br(u)&&(u="identity"===u.type?i(r,e):ca(u)))),br(l)&&("identity"!==l.type?l=ca(l):(l=t.markerHeight,t[a]&&(l=t[a](r,e)),br(l)&&(l="identity"===l.type?s(r,e):ca(l)))),[u,l]}(k,this.symbolDef,P,F,r,i)||[0,0];let t=k.markerTextFit;if(u&&(t=u(F,P)),t&&k.text&&"none"!==t){const n=k.text.textSize;let e=k.text.textName;d(e)&&(e=p(e)(F,P));const r=pa(e,P);if(r){const e="__fn_textSize".trim(),i="__fn_textSize_0".trim();d(n)&&!k.text[e]&&(k.text[i]=p(n),k.text[e]=(t,n)=>{const e=k.text[i](t,n);return d(e)?p(e)(t,n):e});const s=ha(k.text,k.text,P,F);if("width"!==t&&"both"!==t||(I[0]=s[0]*r.length),"height"!==t&&"both"!==t||(I[1]=s[1]),s[0]&&s[1]){let t=k.markerTextFitPadding||[0,0,0,0];l&&(t=l(F,P)),I[0]+=t[1]+t[3],I[1]+=t[0]+t[2]}}else I[0]=I[1]=-1}}if(E&&(I=ha(k,this.symbolDef,P,F)),!I)return A;if(I[0]=Math.ceil(I[0]),I[1]=Math.ceil(I[1]),this.size=I,O&&I[0]>=0&&I[1]>=0){let t;if(_){const n={};if(n.markerType=_,"path"===_&&(n.markerPath=e?e(null,P):k.markerPath,n.markerPathWidth=g?g(null,P):k.markerPathWidth,n.markerPathHeight=v?v(null,P):k.markerPathHeight),r){const t=r(null,P);gr(t)||(n.markerWidth=t)}else k.markerWidth>=0&&(n.markerWidth=k.markerWidth);if(i){const t=i(null,P);gr(t)||(n.markerHeight=t)}else k.markerHeight>=0&&(n.markerHeight=k.markerHeight);if(s){const t=s(null,P);gr(t)||(n.markerFill=t)}else k.markerFill&&(n.markerFill=k.markerFill);if(o){const t=o(null,P);gr(t)||(n.markerFillPatternFile=t)}else k.markerFillPatternFile&&(n.markerFillPatternFile=k.markerFillPatternFile);if(a){const t=a(null,P);gr(t)||(n.markerFillOpacity=t)}else k.markerFillOpacity>=0&&(n.markerFillOpacity=k.markerFillOpacity);if(h){const t=h(null,P);gr(t)||(n.markerLineColor=t)}else k.markerLineColor&&(n.markerLineColor=k.markerLineColor);if(c){const t=c(null,P);gr(t)||(n.markerLineWidth=t)}else k.markerLineWidth>=0&&(n.markerLineWidth=k.markerLineWidth);if(f){const t=f(null,P);gr(t)||(n.markerLineOpacity=t)}else k.markerLineOpacity>=0&&(n.markerLineOpacity=k.markerLineOpacity);if(y){const t=y(null,P);gr(t)||(n.markerLineDasharray=t)}else k.markerLineDasharray&&(n.markerLineDasharray=k.markerLineDasharray);if(m){const t=m(null,P);gr(t)||(n.markerLinePatternFile=t)}else k.markerLinePatternFile&&(n.markerLinePatternFile=k.markerLinePatternFile);t="vector://"+JSON.stringify(n)}else t=S?S.replace(nu,this.yt):k.markerPath?function(t,n,e){if(!t.markerPath)return null;let r=1;const i=function(t){const n={stroke:{stroke:t.markerLineColor,"stroke-width":t.markerLineWidth,"stroke-opacity":t.markerLineOpacity,"stroke-dasharray":null,"stroke-linecap":"butt","stroke-linejoin":"round"},fill:{fill:t.markerFill,"fill-opacity":t.markerFillOpacity}};return 0===n.stroke["stroke-width"]&&(n.stroke["stroke-opacity"]=0),n}(t);vr(t.markerOpacity)&&(r=t.markerOpacity),vr(t.opacity)&&(r*=t.opacity);const s={};if(i){for(const t in i.stroke)Fr(i.stroke,t)&&(gr(i.stroke[t])||(s[t]=i.stroke[t]));for(const t in i.fill)Fr(i.fill,t)&&(gr(i.fill[t])||(s[t]=i.fill[t]))}const o=Array.isArray(t.markerPath)?t.markerPath:[t.markerPath];let a;const u=[];for(let t=0;t<o.length;t++)a=wr(o[t])?{path:o[t]}:o[t],a=mr({},a,s),a.d=a.path,delete a.path,u.push(a);const l=[\'<svg version="1.1"\',\'xmlns="http://www.w3.org/2000/svg"\'];r<1&&l.push(\'opacity="\'+r+\'"\'),t.markerPathWidth&&t.markerPathHeight&&l.push(\'viewBox="0 0 \'+t.markerPathWidth+" "+t.markerPathHeight+\'"\'),l.push(\'preserveAspectRatio="none"\'),n&&l.push(\'width="\'+n+\'"\'),e&&l.push(\'height="\'+e+\'"\'),l.push("><defs></defs>");for(let t=0;t<u.length;t++){let n="<path ";for(const e in u[t])Fr(u[t],e)&&(n+=" "+e+\'="\'+u[t][e]+\'"\');n+="></path>",l.push(n)}return l.push("</svg>"),"data:image/svg+xml;base64,"+btoa(l.join(" "))}(k,I[0],I[1]):null;A.icon={url:t,size:I}}if(E){const t=b?b(this.options.zoom,P):k.textName;if(t||0===t){const n=fa(w?w(null,P):k.textFaceName,M?M(null,P):k.textStyle,x?x(null,P):k.textWeight);let e=pa(t,P);e&&e.length&&(e=tu(e),A.glyph={font:n,text:e})}}return this.iconGlyph=A,A}}function ru(t,n){n&&"middle"!==n||(n="center"),t&&"middle"!==t||(t="center");let e="center"!==n?n:"";return e+="center"!==t?(e.length?"-":"")+t:"",e\n/*!\n     * From mapbox-gl-js\n     * MIT License\n     * https://github.com/mapbox/mapbox-gl-js\n     */}function iu(t,n,e,r,i){const s=[];let o;for(let a=0;a<t.length;a++){const u=t[a];let l,h=!1;for(let t=0;t<u.length-1;t++){let a=u[t],c=u[t+1];a.x<n&&c.x<n||(a.x<n?(o=a,a=new Ut(n,a.y+(n-a.x)/(c.x-a.x)*(c.y-a.y)).T(),a.z=o.z+(n-o.x)/(c.x-o.x)*(c.z-o.z),h=!0):c.x<n&&(o=c,c=new Ut(n,a.y+(n-a.x)/(c.x-a.x)*(c.y-a.y)).T(),c.z=a.z+(n-a.x)/(o.x-a.x)*(o.z-a.z),h=!0),a.y<e&&c.y<e||(a.y<e?(o=a,a=new Ut(a.x+(e-a.y)/(c.y-a.y)*(c.x-a.x),e).T(),a.z=o.z+(e-o.y)/(c.y-o.y)*(c.z-o.z),h=!0):c.y<e&&(o=c,c=new Ut(a.x+(e-a.y)/(c.y-a.y)*(c.x-a.x),e).T(),c.z=a.z+(e-a.y)/(o.y-a.y)*(o.z-a.z),h=!0),a.x>=r&&c.x>=r||(a.x>=r?(o=a,a=new Ut(r,a.y+(r-a.x)/(c.x-a.x)*(c.y-a.y)).T(),a.z=o.z+(r-o.x)/(c.x-o.x)*(c.z-o.z),h=!0):c.x>=r&&(o=c,c=new Ut(r,a.y+(r-a.x)/(c.x-a.x)*(c.y-a.y)).T(),c.z=a.z+(r-a.x)/(o.x-a.x)*(o.z-a.z),h=!0),a.y>=i&&c.y>=i||(a.y>=i?(o=a,a=new Ut(a.x+(i-a.y)/(c.y-a.y)*(c.x-a.x),i).T(),a.z=o.z+(i-o.y)/(c.y-o.y)*(c.z-o.z),h=!0):c.y>=i&&(o=c,c=new Ut(a.x+(i-a.y)/(c.y-a.y)*(c.x-a.x),i).T(),c.z=a.z+(i-a.y)/(o.y-a.y)*(o.z-a.z),h=!0),l&&a.equals(l[l.length-1])||(l=[a],s.push(l)),h&&(l.clipped=!0),l.push(c)))))}}return s}class su extends Ut{constructor(t,n,e,r){super(t,n),this.angle=e,void 0!==r&&(this.segment=r)}clone(){return new su(this.x,this.y,this.angle,this.segment)}}\n/*!\n     * From mapbox-gl-js\n     * MIT License\n     * https://github.com/mapbox/mapbox-gl-js\n     */function ou(t,n,e,r,i){if(void 0===n.segment)return!0;let s=n,o=n.segment+1,a=0;for(;a>-e/2;){if(o--,o<0)return!1;a-=t[o].dist(s),s=t[o]}a+=t[o].dist(t[o+1]),o++;const u=[];let l=0;for(;a<e/2;){const n=t[o],e=t[o+1];if(!e)return!1;let s=t[o-1].angleTo(n)-n.angleTo(e);for(s=Math.abs((s+3*Math.PI)%(2*Math.PI)-Math.PI),u.push({distance:a,angleDelta:s}),l+=s;a-u[0].distance>r;)l-=u.shift().angleDelta;if(l>i)return!1;o++,a+=n.dist(e)}return!0}function au(t,n,e,r,i,s,o,a,u,l,h){const c=function(t,n,e){return t?.6*n*e:0}(r,s,o),f=function(t,n){return Math.max(t?t.right-t.left:0,n?n.right-n.left:0)}(r,i),d=0===t[0].x||t[0].x===u||0===t[0].y||t[0].y===u;return n-f*o<n/4&&(n=f*o+n/4),function t(n,e,r,i,s,o,a,u,l,h,c){let f=0;const d=o/2,p=function(t){let n=0;for(let e=0;e<t.length-1;e++)n+=t[e].dist(t[e+1]);return n}(n);let y=0,m=e-r,g=[];for(let t=0;t<n.length-1;t++){const e=n[t],a=n[t+1],u=e.dist(a),v=a.angleTo(e);for(;m+r<y+u;){m+=r;const b=(m-y)/u,w=uu(e.x,a.x,b),M=uu(e.y,a.y,b),x=uu(e.z||0,a.z||0,b);if(w>=0&&w<l&&M>=0&&M<l&&m-d>=0&&m+d<=p){const r=new su(w,M,v,t);r.z=x,h&&(r.axis=[e.y-M,w-e.x],r.angleR=x===(e.z||0)?0:Math.atan(.9*(x-(e.z||0))*c/e.dist(r))),r.line=n,r.T(),!i||ou(n,r,o,i,s)?g.push(r):i&&f++}}y+=u}return u||g.length||a||(g=t(n,y/2,r,i,s,o,a,!0,l,h,c)),g.countOutOfAngle=f,g}(t,d?n/2*a%n:(f/2+2*s)*o*a%n,n,c,e,f*o,d,!1,u,l,h)}function uu(t,n,e){return t*(1-e)+n*e}function lu(t,n){const e=t.length;if(e<=1)return[t];const r=[];let i,s;for(let n=0;n<e;n++){const e=Ke(t[n]);0!==e&&(t[n].area=Math.abs(e),void 0===s&&(s=e<0),s===e<0?(i&&r.push(i),i=[t[n]]):i.push(t[n]))}if(i&&r.push(i),n>1)for(let t=0;t<r.length;t++)r[t].length<=n||(Gn(r[t],n,1,r[t].length-1,hu),r[t]=r[t].slice(0,n));return r}function hu(t,n){return n.area-t.area}function cu(t,n,e){const r=n.distSqr(e);if(0===r)return t.distSqr(n);const i=((t.x-n.x)*(e.x-n.x)+(t.y-n.y)*(e.y-n.y))/r;return t.distSqr(i<0?n:i>1?e:e.sub(n).k(i).m(n))}function fu(t,n=1,e=!1){let r=1/0,i=1/0,s=-1/0,o=-1/0;const a=t[0];for(let t=0;t<a.length;t++){const n=a[t];(!t||n.x<r)&&(r=n.x),(!t||n.y<i)&&(i=n.y),(!t||n.x>s)&&(s=n.x),(!t||n.y>o)&&(o=n.y)}const u=Math.min(s-r,o-i);let l=u/2;const h=new Bn([],du);if(0===u)return new Ut(r,i);for(let n=r;n<s;n+=u)for(let e=i;e<o;e+=u)h.push(new pu(n+l,e+l,l,t));let c=function(t){let n=0,e=0,r=0;const i=t[0];for(let t=0,s=i.length,o=s-1;t<s;o=t++){const s=i[t],a=i[o],u=s.x*a.y-a.x*s.y;e+=(s.x+a.x)*u,r+=(s.y+a.y)*u,n+=3*u}return new pu(e/n,r/n,0,t)}(t),f=h.length;for(;h.length;){const r=h.pop();(r.d>c.d||!c.d)&&(c=r,e&&console.log("found best %d after %d probes",Math.round(1e4*r.d)/1e4,f)),r.max-c.d<=n||(l=r.h/2,h.push(new pu(r.p.x-l,r.p.y-l,l,t)),h.push(new pu(r.p.x+l,r.p.y-l,l,t)),h.push(new pu(r.p.x-l,r.p.y+l,l,t)),h.push(new pu(r.p.x+l,r.p.y+l,l,t)),f+=4)}return e&&(console.log("num probes: "+f),console.log("best distance: "+c.d)),c.p}function du(t,n){return n.max-t.max}function pu(t,n,e,r){this.p=new Ut(t,n),this.h=e,this.d=function(t,n){let e=!1,r=1/0;for(let i=0;i<n.length;i++){const s=n[i];for(let n=0,i=s.length,o=i-1;n<i;o=n++){const i=s[n],a=s[o];i.y>t.y!=a.y>t.y&&t.x<(a.x-i.x)*(t.y-i.y)/(a.y-i.y)+i.x&&(e=!e),r=Math.min(r,cu(t,i,a))}}return(e?1:-1)*Math.sqrt(r)}(this.p,r),this.max=this.d+this.h*Math.SQRT2}function yu(t,n,e,r,i,s,o,a,u,l){const{feature:h,size:c,symbol:f}=t,d=c?24:0,p=i*(c?c[0]/d:1);if("line"===o){const t=[];t.countOutOfAngle=0;let i=h.geometry;s&&(i=iu(h.geometry,0,0,s,s));for(let o=0;o<i.length;o++){const h=au(i[o],a,e,f.isIconText?null:r&&r.vertical||r&&r.horizontal||r,null,d,f.isIconText?1:p,1,s||1/0,u,l);if(f.textPlacement&&!f.isIconText)for(let t=0;t<h.length;t++)h[t].startIndex=n.length/3;if(t.push.apply(t,h),f.textPlacement&&!f.isIconText)for(let t=0;t<i[o].length;t++)n.push(i[o][t].x,i[o][t].y,i[o][t].z||0);t.countOutOfAngle+=h.countOutOfAngle||0}return t}return mu(h,o,s)}function mu(t,n,e,r,i){const s=[];if(3===t.type){const o=lu(t.geometry,0);for(let t=0;t<o.length;t++){const a=o[t];if("vertex"===n)for(let t=0;t<a.length;t++){const n=a[t];for(let o=0;o<n.length;o++)er(n[o],e)||(s.push(n[o]),r&&(0===o?gu(n[o],n[o],n[t+1],i):gu(n[o],n[o-1],n[o],i)))}else if("vertex-first"===n){const t=a[0];t&&t[0]&&!er(t[0],e)&&(s.push(t[0]),r&&gu(t[0],t[0],t[1],i))}else if("vertex-last"===n||"vertex-firstlast"===n){const t=a[0];if("vertex-firstlast"===n&&t&&t[0]&&!er(t[0],e)&&(s.push(t[0]),r&&gu(t[0],t[0],t[1],i)),t&&t[t.length-1]&&!er(t[t.length-1],e)){const n=t.length-1;s.push(t[n]),r&&gu(t[n],t[n-1],t[n],i)}}else{const t=fu(a,16);er(t,e)||s.push(t)}}}else if(2===t.type)for(let o=0;o<t.geometry.length;o++){const a=t.geometry[o];if("vertex"===n)for(let t=0;t<a.length;t++)er(a[t],e)||(s.push(a[t]),r&&(0===t?gu(a[t],a[t],a[t+1],i):gu(a[t],a[t-1],a[t],i)));else if("vertex-last"===n||"vertex-firstlast"===n){if("vertex-firstlast"!==n||er(a[0],e)||(s.push(a[0]),r&&gu(a[0],a[0],a[1],i)),a&&a[a.length-1]&&!er(a[a.length-1],e)){const t=a.length-1;s.push(a[t]),r&&gu(a[t],a[t-1],a[t],i)}}else er(a[0],e)||(s.push(a[0]),r&&gu(a[0],a[0],a[1],i))}else if(1===t.type)for(let n=0;n<t.geometry.length;n++){const i=t.geometry[n];for(let t=0;t<i.length;t++){const n=i[t];er(n,e)||(r&&(n.xRotation=0,n.yRotation=0,n.zRotation=0),s.push(n))}}return s}function gu(t,n,e,r){if(t.xRotation||t.yRotation||t.zRotation)return t;const i=e.x-n.x,s=n.y-e.y,o=(e.z-n.z)*r,a=Math.atan2(s,i);t.zRotation=a;const u=Math.atan2(o,Math.sqrt(i*i+s*s));return t.xyRotation=u,t}function vu(t,n){const e={},r={},i=[];let s=0;function o(n){i.push(t[n]),s++}function a(t,n,e){const s=r[t];return delete r[t],r[n]=s,i[s].geometry[0].pop(),i[s].geometry[0]=i[s].geometry[0].concat(e[0]),s}function u(t,n,r){const s=e[n];return delete e[n],e[t]=s,i[s].geometry[0].shift(),i[s].geometry[0]=r[0].concat(i[s].geometry[0]),s}function l(t,n,e){const r=e?n[0][n[0].length-1]:n[0][0];return`${t}:${r.x}:${r.y}`}for(let h=0;h<t.length;h++){const c=t[h],f=c.geometry;if(!f)continue;const d=c.properties[n]?c.properties[n].toString():null;if(!d){o(h);continue}const p=l(d,f),y=l(d,f,!0);if(p in r&&y in e&&r[p]!==e[y]){const t=u(p,y,f),n=a(p,y,i[t].geometry);delete e[p],delete r[y],r[l(d,i[n].geometry,!0)]=n,i[t].geometry=null}else p in r?a(p,y,f):y in e?u(p,y,f):(o(h),e[p]=s-1,r[y]=s-1)}return i.filter(t=>t.geometry)}class bu extends aa{static needMerge(t,n,e){if(!t)return!1;let r="line"===t.textPlacement||"line"===t.markerPlacement;return r||(n.textPlacementFn&&(r="line"===n.textPlacementFn(e)),n.markerPlacementFn&&(r="line"===n.markerPlacementFn(e))),t.mergeOnProperty&&r}static mergeLineFeatures(t,n,e,r){const i="__index".trim();let s=n.textPlacement,o=n.markerPlacement;e.textPlacementFn&&(s=e.textPlacementFn(r)),e.markerPlacementFn&&(o=e.markerPlacementFn(r));const a=function(t,n,e,r,i){const s="__index".trim(),o=aa.genFnTypes(n),{mergeOnPropertyFn:a}=o;if(!n.mergeOnProperty||"line"!==r&&"line"!==e)return[];if(!(rr(u=n.mergeOnProperty)||"string"!=typeof u&&(null===u.constructor||u.constructor!==String)||"line"!==r&&"line"!==e))return[{features:t,property:n.mergeOnProperty}];var u;const l=[],h={},c=[];for(let o=0;o<t.length;o++){t[o][s]=o;const u=t[o].properties=t[o].properties||{};u.$layer=t[o].layer,u.$type=t[o].type;let f=e;"line"!==f&&(f=r);const d=a?a(i,u):n.mergeOnProperty;"line"!==f||rr(d)?c.push(t[o]):(void 0===h[d]&&(h[d]=l.length,l.push({features:[],property:d})),l[h[d]].features.push(t[o]))}return c.length&&l.push({features:c}),l}(t,n,o,s,r);if(a.length){const n=[];for(let e=0;e<a.length;e++)n.push(a[e].property?vu(a[e].features,a[e].property):t);if(1===n.length)return n[0];{let t=[];for(let e=0;e<n.length;e++)t=t.concat(n[e]);return t.sort((t,n)=>t[i]-n[i]),t}}}static splitPointSymbol(t,n=0){const e=[];if(Array.isArray(t)){const n=t;for(let t=0;t<n.length;t++)n[t]&&e.push(...bu.splitPointSymbol(n[t],t));return e}let r=null,i=null;for(const n in t)0===n.indexOf("marker")?(r=r||{},r[n]=t[n]):0===n.indexOf("text")&&(i=i||{},i[n]=t[n]);return r&&(r.isIconText=!0,t.mergeOnProperty&&(r.mergeOnProperty=t.mergeOnProperty),e.push(r)),i&&(r&&(i.textPlacement=r.markerPlacement,i.textSpacing=r.markerSpacing,i.isIconText=!0),t.mergeOnProperty&&(i.mergeOnProperty=t.mergeOnProperty),e.push(i)),void 0!==t.visible&&(r&&(r.visible=t.visible),i&&(i.visible=t.visible)),r&&(r.markerTextFit&&i&&(r.text={},r.text.textName=i.textName,r.text.textSize=i.textSize),r.index={index:n,type:0}),i&&(i.index={index:n,type:1}),e}static isAtlasLoaded(t,n){const{icon:e,glyph:r}=t,{iconAtlas:i,glyphAtlas:s}=n;if(e&&(!i||!i.positions[e.url]))return!1;if(r){if(!s||!s.positions[r.font])return!1;const t=s.positions[r.font],{text:n}=r;for(const e of n)if(!t[e.codePointAt(0)])return!1}return!0}constructor(t,n,e){super(t,n,e),this.bt=n.textPlacement,this.tt.textPlacementFn&&(this.bt=this.tt.textPlacementFn(this.options.zoom))}createStyledVector(t,n,e,r,i,s){const o=new eu(t,this.symbolDef,n,e,r),a=o.getIconAndGlyph();if(a.icon&&!this.options.atlas){const{url:t,size:n}=a.icon;i[t]||(i[t]=a.icon.size),i[t][0]<n[0]&&(i[t][0]=n[0]),i[t][1]<n[1]&&(i[t][1]=n[1])}if(a.glyph&&!this.options.atlas){const{font:t,text:n}=a.glyph,e=s[t]=s[t]||{};for(const t of n)e[t.codePointAt(0)]=1;"line"===this.bt&&(s.options={isCharsCompact:!1})}return this.options.allowEmptyPack||a.icon||a.glyph?o:null}getFormat(t){const n=void 0!==t.textName,e=n?this.getPackSDFFormat(t):this.getPackMarkerFormat();n?e.push(...this.wt()):e.push(...this.Mt());const{markerOpacityFn:r,textOpacityFn:i,markerPitchAlignmentFn:s,textPitchAlignmentFn:o,markerRotationAlignmentFn:a,textRotationAlignmentFn:u,markerRotationFn:l,textRotationFn:h,markerAllowOverlapFn:c,textAllowOverlapFn:f,markerIgnorePlacementFn:d,textIgnorePlacementFn:p}=this.tt;return(r||i)&&e.push({type:Uint8Array,width:1,name:"aColorOpacity"}),(s||o)&&e.push({type:Uint8Array,width:1,name:"aPitchAlign"}),(a||u)&&e.push({type:Uint8Array,width:1,name:"aRotationAlign"}),(l||h)&&e.push({type:Uint16Array,width:1,name:"aRotation"}),(c||f||d||p)&&e.push({type:Uint8Array,width:1,name:"aOverlap"}),e}xt(){return this.hasMapPitchAlign}wt(){const{textFillFn:t,textSizeFn:n,textHaloFillFn:e,textHaloRadiusFn:r,textHaloOpacityFn:i,textDxFn:s,textDyFn:o}=this.tt,a=[];return t&&a.push({type:Uint8Array,width:4,name:"aTextFill"}),n&&a.push({type:Uint8Array,width:1,name:"aTextSize"}),e&&a.push({type:Uint8Array,width:4,name:"aTextHaloFill"}),r&&a.push({type:Uint8Array,width:1,name:"aTextHaloRadius"}),i&&a.push({type:Uint8Array,width:1,name:"aTextHaloOpacity"}),s&&a.push({type:Int8Array,width:1,name:"aTextDx"}),o&&a.push({type:Int8Array,width:1,name:"aTextDy"}),a}Mt(){const{markerWidthFn:t,markerHeightFn:n,markerDxFn:e,markerDyFn:r}=this.tt,i=[];return t&&i.push({type:this.options.markerWidthType||Uint8Array,width:1,name:"aMarkerWidth"}),n&&i.push({type:this.options.markerHeightType||Uint8Array,width:1,name:"aMarkerHeight"}),e&&i.push({type:Int8Array,width:1,name:"aMarkerDx"}),r&&i.push({type:Int8Array,width:1,name:"aMarkerDy"}),i}createDataPack(){if(!this.iconAtlas&&!this.glyphAtlas){if(!this.options.allowEmptyPack)return null;this.empty=!0}this.countOutOfAngle=0,this.lineVertex=[];const t=super.createDataPack.apply(this,arguments);return t?(t.lineVertex=new Int16Array(this.lineVertex),t.buffers.push(t.lineVertex.buffer),t):null}placeVector(t,n){const e=t.getShape(this.iconAtlas,this.glyphAtlas);if(!(this.options.allowEmptyPack||e&&e.image||e&&(e.horizontal||e.vertical)))return;const r=this.Ft(t,e,n);if(this.countOutOfAngle+=r.countOutOfAngle||0,0===r.length)return;const i=this.data,s=this.needAltitudeAttribute()?2:3;let o=this.data.aPosition.length/s;const a=t.symbol,u=t.feature.properties,l="line"===this.bt&&!a.isIconText,h=void 0!==a.textName,c=h&&l&&function(t){let n=0;for(let e=0;e<t.length;e++)if(La(t.charAt(e).charCodeAt(0)))n=0;else if(n++,n>=1)return!1;return!0}(t.getIconAndGlyph().glyph.text)?1:0,{textFillFn:f,textSizeFn:p,textHaloFillFn:y,textHaloRadiusFn:m,textHaloOpacityFn:g,textDxFn:v,textDyFn:b,textPitchAlignmentFn:w,textRotationAlignmentFn:M,textRotationFn:x,textAllowOverlapFn:F,textIgnorePlacementFn:A,textOpacityFn:k,markerWidthFn:P,markerHeightFn:S,markerDxFn:_,markerDyFn:O,markerPitchAlignmentFn:E,markerRotationAlignmentFn:I,markerRotationFn:$,markerAllowOverlapFn:C,markerIgnorePlacementFn:T,markerOpacityFn:z}=this.tt;let D,j,U,N,L,V,R,H,W,q,G,B,J,X,Y,Z,K;if(h){const n=t.getIconAndGlyph().glyph.font;D=function(t,n,e){const r=t.positionedGlyphs,i=[];for(let s=0;s<r.length;s++){const o=r[s],a=e[o.glyph];if(!a)continue;const u=a.rect;if(!u)continue;const l=4,h=a.metrics.advance/2,c=a.metrics.height/2,f=n?[o.x+h,0]:[0,0],d=n?[0,o.y-c]:[o.x+h,o.y-c],p=a.metrics.left-l-h+d[0],y=a.metrics.top-l+d[1],m=p+u.w,g=y+u.h,v=new Ut(p,y),b=new Ut(m,y),w=new Ut(p,g),M=new Ut(m,g);if(n&&o.vertical){const t=new Ut(-h,h),n=-Math.PI/2,e=new Ut(5,0);v._(n,t).m(e),b._(n,t).m(e),w._(n,t).m(e),M._(n,t).m(e)}i.push({tl:v,tr:b,bl:w,br:M,tex:u,writingMode:t.writingMode,glyphOffset:f})}return i}(e.horizontal,l,this.glyphAtlas.positions[n]),f&&(j=f(null,u),d(j)?(this.dynamicAttrs.aTextFill=1,j=[0,0,0,0]):j=Or([],j)),p&&(U=p(this.options.zoom,u),rr(U)&&(U=14)),y&&(N=y(null,u),d(N)?(this.dynamicAttrs.aTextHaloFill=1,N=[0,0,0,0]):N=Or([],N)),m&&(L=m(null,u)),g&&(V=255*g(null,u)),v&&(R=v(null,u)||0),b&&(H=b(null,u)||0),w&&(J=+("map"===w(null,u))),M&&(X=+("map"===M(null,u))),x&&(Y=ir(x(null,u),0,360)*Math.PI/180)}else D=e?function(t){const n=t.image,e=t.top-1/n.pixelRatio,r=t.left-1/n.pixelRatio,i=t.bottom+1/n.pixelRatio,s=t.right+1/n.pixelRatio;let o,a,u,l;return o=new Ut(r,e),a=new Ut(s,e),u=new Ut(s,i),l=new Ut(r,i),[{tl:o,tr:a,bl:l,br:u,tex:{x:n.tl[0],y:n.tl[1],w:n.displaySize[0],h:n.displaySize[1]},writingMode:void 0,glyphOffset:[0,0]}]}(e):function(){const t=new Ut(0,0),n=new Ut(0,0),e=new Ut(0,0);return[{tl:t,tr:n,bl:new Ut(0,0),br:e,tex:{x:0,y:0,w:0,h:0},writingMode:void 0,glyphOffset:[0,0]}]}(),P&&(W=P(null,u)),rr(W)&&(W=D[0].tex.w),S&&(q=S(null,u)),rr(q)&&(q=D[0].tex.h),_&&(G=_(null,u)),O&&(B=O(null,u)),E&&(J=+("map"===E(null,u))),I&&(X=+("map"===I(null,u))),$&&(Y=ir($(null,u),0,360)*Math.PI/180);d(U)&&(this.dynamicAttrs.aTextSize=1),d(L)&&(this.dynamicAttrs.aTextHaloRadius=1),d(V)&&(this.dynamicAttrs.aTextHaloOpacity=1),d(R)&&(this.dynamicAttrs.aTextDx=1),d(H)&&(this.dynamicAttrs.aTextDy=1),d(W)&&(this.dynamicAttrs.aMarkerWidth=1),d(q)&&(this.dynamicAttrs.aMarkerHeight=1),d(G)&&(this.dynamicAttrs.aMarkerDx=1),d(B)&&(this.dynamicAttrs.aMarkerDy=1),d(J)&&(this.dynamicAttrs.aPitchAlign=1),d(X)&&(this.dynamicAttrs.aRotationAlign=1),d(Y)&&(this.dynamicAttrs.aRotation=1);const Q=C||F;Q&&(Z=Q(null,u)||0);const tt=T||A;let nt;tt&&(K=tt(null,u)||0);const et=k||z;et&&(nt=255*et(this.options.zoom,u));const rt=this.options.EXTENT,it=D.length,{altitudeScale:st,altitudeProperty:ot,defaultAltitude:at}=this.options,{altitude:ut}=nr(t.feature,st,ot,at);for(let t=0;t<r.length;t++){const n=r[t],e=n.z||ut||0;if(rt!==1/0&&er(n,rt))continue;const s=n.x,a=n.y,u=D.length;for(let t=0;t<u;t++){const r=D[t],{tl:u,tr:f,bl:d,br:p,tex:y}=r;this.At(i,s,a,e,10*u.x,10*u.y,y.x,y.y+y.h),h&&this.kt(i,l,it,r.glyphOffset,n,c,n.axis,n.angleR),this.Pt(i,j,U,N,L,V,R,H,W,q,G,B,nt,J,X,Y,Z,K),this.At(i,s,a,e,10*f.x,10*f.y,y.x+y.w,y.y+y.h),h&&this.kt(i,l,it,r.glyphOffset,n,c,n.axis,n.angleR),this.Pt(i,j,U,N,L,V,R,H,W,q,G,B,nt,J,X,Y,Z,K),this.At(i,s,a,e,10*d.x,10*d.y,y.x,y.y),h&&this.kt(i,l,it,r.glyphOffset,n,c,n.axis,n.angleR),this.Pt(i,j,U,N,L,V,R,H,W,q,G,B,nt,J,X,Y,Z,K),this.At(i,s,a,e,10*p.x,10*p.y,y.x+y.w,y.y),h&&this.kt(i,l,it,r.glyphOffset,n,c,n.axis,n.angleR),this.Pt(i,j,U,N,L,V,R,H,W,q,G,B,nt,J,X,Y,Z,K),this.addElements(o,o+1,o+2),this.addElements(o+1,o+2,o+3),o+=4;const m=Math.max(Math.abs(s),Math.abs(a),Math.abs(e));m>this.maxPos&&(this.maxPos=m)}}}At(t,n,e,r,i,s,o,a){this.fillPosition(t,n,e,r),t.aShape.push(i,s),t.aTexCoord.push(o,a)}kt(t,n,e,r,i,s,o,a){if(t.aCount.push(e),n){t.aGlyphOffset.push(r[0],r[1]),this.xt()&&t.aPitchRotation.push(o[0],o[1],a);const n=i.startIndex;t.aSegment.push(i.segment+n,n,i.line.length),t.aVertical.push(s)}}Pt(t,n,e,r,i,s,o,a,u,l,h,c,f,d,p,y,m,g){const{textFillFn:v,textSizeFn:b,textHaloFillFn:w,textHaloRadiusFn:M,textHaloOpacityFn:x,textDxFn:F,textDyFn:A,textPitchAlignmentFn:k,textRotationAlignmentFn:P,textRotationFn:S,textAllowOverlapFn:_,textIgnorePlacementFn:O,textOpacityFn:E,markerWidthFn:I,markerHeightFn:$,markerDxFn:C,markerDyFn:T,markerPitchAlignmentFn:z,markerRotationAlignmentFn:D,markerRotationFn:j,markerAllowOverlapFn:U,markerIgnorePlacementFn:N,markerOpacityFn:L}=this.tt;v&&t.aTextFill.push(...n),b&&t.aTextSize.push(e),w&&t.aTextHaloFill.push(...r),M&&t.aTextHaloRadius.push(i),x&&t.aTextHaloOpacity.push(s),F&&t.aTextDx.push(o),A&&t.aTextDy.push(a),I&&t.aMarkerWidth.push(u),$&&t.aMarkerHeight.push(l),C&&t.aMarkerDx.push(h),T&&t.aMarkerDy.push(c),(L||E)&&t.aColorOpacity.push(f),(k||z)&&t.aPitchAlign.push(d),(D||P)&&t.aRotationAlign.push(p),(j||S)&&t.aRotation.push(9362*y);const V=U||_,R=N||O;(V||R)&&t.aOverlap.push((V?8:0)+4*m+((R?2:0)+g)),i>0&&(this.properties.hasHalo=1)}Ft(t,n,e){const{feature:r,symbol:i}=t,s=this.St(t,i),o=r.properties,{markerSpacingFn:a,textSpacingFn:u,textMaxAngleFn:l}=this.tt,h=((a?a(null,o):i.markerSpacing)||(u?u(null,o):i.textSpacing)||250)*e;let c=l?l(this.options.zoom,o):i.textMaxAngle;rr(c)&&(c=80),c*=Math.PI/180;const f=this.options.EXTENT,d=this.options.altitudeToTileScale,p=this.xt();return yu(t,this.lineVertex,c,n,e,f,s,h,p,d)}St(t,n){let e;return e=this.tt.markerPlacementFn?this.tt.markerPlacementFn(this.options.zoom,t.feature.properties):n.markerPlacement||this.bt,this.ht||!n.markerPlacement&&!n.isIconText||(this.ht=e),!this.bt||n.isIconText||this.ct||(this.ct=e),e}getPackSDFFormat(t){if("line"!==this.bt||t.isIconText)return[...this.getPositionFormat(),{type:Int16Array,width:2,name:"aShape"},{type:Uint16Array,width:2,name:"aTexCoord"},{type:Uint8Array,width:1,name:"aCount"}];{const t=[...this.getPositionFormat(),{type:Int16Array,width:2,name:"aShape"},{type:Uint16Array,width:2,name:"aTexCoord"},{type:Uint8Array,width:1,name:"aCount"},{type:Int16Array,width:2,name:"aGlyphOffset"},{type:Uint16Array,width:3,name:"aSegment"},{type:Uint8Array,width:1,name:"aVertical"}];return this.xt()&&t.push({type:Float32Array,width:3,name:"aPitchRotation"}),t}}getPackMarkerFormat(){return[...this.getPositionFormat(),{type:Int16Array,width:2,name:"aShape"},{type:Uint16Array,width:2,name:"aTexCoord"}]}}class wu{constructor(t){this.x=t.x,this.y=t.y,this.z=t.z||0}clone(){return new wu(this)}I(){return this.P(this.mag()),this}P(t){return this.x/=t,this.y/=t,this.z/=t,this}C(){var t=this.y;return this.y=this.x,this.x=-t,this}mag(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}add(t){return this.clone().m(t)}sub(t){return this.clone().M(t)}m(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}M(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}mult(t){return this.clone().k(t)}k(t){return this.x*=t,this.y*=t,this.z*=t,this}dist(t){return Math.sqrt(this.distSqr(t))}distSqr(t){var n=t.x-this.x,e=t.y-this.y,r=t.z-this.z;return n*n+e*e+r*r}T(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}angleTo(t){return Math.atan2(this.y-t.y,this.x-t.x)}}const Mu=Math.cos(Math.PI/180*37.5),xu=Math.pow(2,16)/1,Fu=new Ut,Au=new Ut,ku=new Ut;class Pu extends aa{constructor(t,n,e){super(t,n,e);let r=!1;const{lineDasharrayFn:i,lineDashColorFn:s}=this.tt;this.hasGradient=this.symbol.lineGradientProperty,i&&(r=function(t,n,e){for(let r=0;r<t.length;r++)if(e(n,t[r].properties))return!0;return!1}(t,this.options.zoom,i),r&&(this.dasharrayFn=i)),this.hasDasharray=Ou(this.symbol.lineDasharray)||r,this.hasDasharray&&s&&(this.dashColorFn=s)}createStyledVector(t,n,e,r,i){const s=new Cr(t,n,e,r),o=s.getLineResource();return!this.options.atlas&&o&&(i[o]=[0,0]),s}getFormat(){const{lineWidthFn:t,lineStrokeWidthFn:n,lineStrokeColorFn:e,lineColorFn:r,lineOpacityFn:i,lineDxFn:s,lineDyFn:o,linePatternAnimSpeedFn:a,linePatternGapFn:u}=this.tt,l=[...this.getPositionFormat()];if(l.push(this.iconAtlas||this.hasDasharray?{type:Int8Array,width:3,name:"aExtrude"}:{type:Int8Array,width:2,name:"aExtrude"}),l.push({type:this.options.positionType||Uint16Array,width:1,name:"aLinesofar"}),t&&l.push({type:Uint8Array,width:1,name:"aLineWidth"}),n&&l.push({type:Uint8Array,width:1,name:"aLineStrokeWidth"}),r&&l.push({type:Uint8Array,width:4,name:"aColor"}),e&&l.push({type:Uint8Array,width:4,name:"aStrokeColor"}),i&&l.push({type:Uint8Array,width:1,name:"aOpacity"}),this.dasharrayFn&&l.push({type:Uint8Array,width:4,name:"aDasharray"}),this.dashColorFn&&l.push({type:Uint8Array,width:4,name:"aDashColor"}),this.iconAtlas){const t=this.getIconAtlasMaxValue();l.push({type:t>255?Uint16Array:Uint8Array,width:4,name:"aTexInfo"})}return(s||o)&&l.push({type:Int8Array,width:2,name:"aLineDxDy"}),(a||u)&&l.push({type:Int8Array,width:2,name:"aLinePattern"}),l}placeVector(t){const{lineJoinFn:n,lineCapFn:e,lineWidthFn:r,lineHeightFn:i,lineStrokeWidthFn:s,lineStrokeColorFn:o,lineColorFn:a,lineOpacityFn:u,lineDxFn:l,lineDyFn:h,linePatternAnimSpeedFn:c,linePatternGapFn:f}=this.tt,p=this.symbol,y=t.feature,m=y.properties;let g=p.lineJoin||"miter",v=p.lineCap||"butt";if(n&&(g=n(this.options.zoom,m)||"miter"),e&&(v=e(this.options.zoom,m)||"butt"),r){let t=r(this.options.zoom,m);d(t)&&(this.dynamicAttrs.aLineWidth=1,t=4),gr(t)&&(t=4),this.feaLineWidth=+t}else this.feaLineWidth=+p.lineWidth;if(i){let t=i(this.options.zoom,m);d(t)&&(this.dynamicAttrs.aLineHeight=1),gr(t)&&(t=this.feaLineWidth),this.feaLineHeight=+t}else this.feaLineHeight=+p.lineHeight||this.feaLineWidth;if(s){let t=s(this.options.zoom,m);d(t)&&(this.dynamicAttrs.aLineStrokeWidth=1,t=0),gr(t)&&(t=0),this.feaLineStrokeWidth=t}else this.feaLineStrokeWidth=p.lineStrokeWidth||0;if(a&&(this.feaColor=a(this.options.zoom,m)||[255,255,255,255],d(this.feaColor)?(this.dynamicAttrs.aColor=1,this.feaColor=[0,0,0,0]):this.feaColor=Or([],this.feaColor)),o&&(this.feaStrokeColor=o(this.options.zoom,m)||[0,0,0,255],d(this.feaStrokeColor)?(this.dynamicAttrs.aStrokeColor=1,this.feaStrokeColor=[0,0,0,0]):this.feaStrokeColor=Or([],this.feaStrokeColor)),u){let t=u(this.options.zoom,m);d(t)&&(this.dynamicAttrs.aOpacity=1,t=1),gr(t)&&(t=1),this.feaOpacity=255*t}if(this.dasharrayFn){let t=this.dasharrayFn(this.options.zoom,m)||[0,0,0,0];if(d(t)&&(this.dynamicAttrs.aDasharray=1,t=[0,0,0,0]),t.length<4){const n=t;1===t.length?t=[n[0],n[0],n[0],n[0]]:2===t.length?t=[n[0],n[1],n[0],n[1]]:3===t.length&&(t=[n[0],n[1],n[2],n[2]])}this.feaDash=t}if(this.dashColorFn){let t=(this.dashColorFn?this.dashColorFn(this.options.zoom,m):this.symbol.lineDashColor)||[0,0,0,0];d(t)&&(this.dynamicAttrs.aDashColor=1,t=[0,0,0,0]),t=Or([],t),this.feaDashColor=t}if(this.iconAtlas){const n=t.getLineResource(),e=this.iconAtlas.glyphMap[n];if(this.feaTexInfo=this.feaTexInfo||[0,0,0,0],e){const{tl:t,displaySize:e}=this.iconAtlas.positions[n];this.feaTexInfo[0]=t[0]+1,this.feaTexInfo[1]=t[1]+1,this.feaTexInfo[2]=e[0]-3,this.feaTexInfo[3]=e[1]-3}else this.feaTexInfo[0]=this.feaTexInfo[1]=this.feaTexInfo[2]=this.feaTexInfo[3]=0}if(l){let t=l(this.options.zoom,m);d(t)&&(this.dynamicAttrs.aLineDxDy=1,t=0),gr(t)&&(t=0),this.feaLineDx=t}if(h){let t=h(this.options.zoom,m);d(t)&&(this.dynamicAttrs.aLineDxDy=1,t=0),gr(t)&&(t=0),this.feaLineDy=t}if(c){let t=c(this.options.zoom,m);d(t)&&(this.dynamicAttrs.aLinePatternAnimSpeed=1,t=0),gr(t)&&(t=0),0!==t&&(this.properties.hasPatternAnim=1),this.feaPatternAnimSpeed=t}if(f){let t=f(this.options.zoom,m);d(t)&&(this.dynamicAttrs.aLinePatternGap=1,t=0),gr(t)&&(t=0),this.feaLinePatternGap=t}const b=this.options.EXTENT;let w=y.geometry;if(b!==1/0){w=[];const t=[];for(let n=0;n<y.geometry.length;n++){t[0]=y.geometry[n];const e=iu(t,-1,-1,b+1,b+1);if(3===y.type&&e.length>1){const t=e[0],n=e[e.length-1];Cu(t[0],n[n.length-1])&&(e[0]=n.concat(t.slice(1)),e.length=e.length-1)}w.push(...e)}}const M=this.needAltitudeAttribute()?2:3;for(let t=0;t<w.length;t++)this.offset=this.data.aPosition.length/M,this._t(w[t],y,g,v,2,1.05)}Ot(){return this.iconAtlas&&this.feaTexInfo[2]&&this.feaTexInfo[3]}_t(t,n,e,r,i,s){const o=this.Ot()||Ou(this.feaDash)||Ou(this.symbol.lineDasharray),a=this.options.isTube;a&&(t=t.map(t=>new wu(t))),this.overscaling=1;const u=this.options.EXTENT;if(this.distance=0,this.scaledDistance=0,this.totalDistance=0,this.prevVertex=null,this.symbol.lineGradientProperty&&n.properties&&vr(n.properties.mapbox_clip_start)&&vr(n.properties.mapbox_clip_end)){this.clipStart=+n.properties.mapbox_clip_start,this.clipEnd=+n.properties.mapbox_clip_end;for(let n=0;n<t.length-1;n++)this.totalDistance+=t[n].dist(t[n+1]);this.updateScaledDistance()}const l=3===n.type&&!t.clipped;let h=t.length;for(;h>=2&&Cu(t[h-1],t[h-2]);)h--;let c=0;for(;c<h-1&&Cu(t[c],t[c+1]);)c++;if(h<(l?3:2))return;"bevel"===e&&(i=1.05);const f=this.overscaling<=16?15*u/(512*this.overscaling):0,d={vertexLength:0,primitiveLength:0,currentNormal:null};let p,y,m,g,v;this.e1=this.e2=-1,l&&(p=t[h-2],v=t[c].sub(p).I().C());for(let n=c;n<h;n++){if(m=n===h-1?l?t[c+1]:void 0:t[n+1],m&&Cu(t[n],m))continue;v&&(g=v),p&&(y=p),p=t[n],m&&p.x===m.x&&p.y===m.y&&(p.x+=1e-4),v=m?m.sub(p).I().C():g,d.dir=y?p.sub(y).I():m.sub(p).I(),g=g||v,d.currentNormal=g;let u=g.add(v);0===u.x&&0===u.y||u.I();const b=g.x*v.x+g.y*v.y,w=u.x*v.x+u.y*v.y,M=0!==w?1/w:1/0,x=2*Math.sqrt(2-2*w),F=w<Mu&&y&&m,A=g.x*v.y-g.y*v.x>0;if(!a&&F&&n>c){const t=p.dist(y);if(t>2*f){const n=p.sub(p.sub(y).k(f/t).T());n.z=p.z,this.updateDistance(y,n),this.addCurrentVertex(n,g,0,0,d),y=n}}const k=y&&m;d.middleVertex=k;let P=k?e:l?"butt":r;if(k&&"round"===P&&(M<s?P="miter":M<=2&&(P="fakeround")),"miter"===P&&M>i&&!a&&(P="bevel"),"bevel"===P&&(M>2&&(P="flipbevel"),M<i&&(P="miter")),y&&this.updateDistance(y,p),"miter"===P)a?(this.addCurrentVertex(p,g,0,0,d),d.dir=m.sub(p).I(),this.addCurrentVertex(p,v,0,0,d)):(u.k(M),this.addCurrentVertex(p,u,0,0,d),o&&(d.currentNormal=v,this.addCurrentVertex(p,u,0,0,d)));else if("flipbevel"===P){if(M>100)u=v.mult(-1);else{const t=M*g.add(v).mag()/g.sub(v).mag();u.C().k(t*(A?-1:1))}this.addCurrentVertex(p,u,0,0,d),this.addCurrentVertex(p,u.mult(-1),0,0,d)}else if("bevel"===P||"fakeround"===P){const t=-Math.sqrt(M*M-1),n=A?t:0,e=A?0:t;if(y&&this.addCurrentVertex(p,g,n,e,d),"fakeround"===P){const t=Math.round(180*x/Math.PI/20);for(let n=1;n<t;n++){let e=n/t;if(.5!==e){const t=e-.5;e+=e*t*(e-1)*((1.0904+b*(b*(3.55645-1.43519*b)-3.2452))*t*t+(.848013+b*(.215638*b-1.06021)))}const r=v.sub(g).k(e).m(g).I().k(A?-1:1);this.addHalfVertex(p,r.x,r.y,!1,A,0,d)}}m&&(d.currentNormal=v,this.addCurrentVertex(p,v,-n,-e,d))}else if("butt"===P)this.addCurrentVertex(p,u,0,0,d);else if("square"===P){const t=y?1:-1;this.addCurrentVertex(p,u,t,t,d)}else"round"===P&&(y&&(this.addCurrentVertex(p,g,0,0,d),this.addCurrentVertex(p,g,1,1,d,!0)),m&&(this.addCurrentVertex(p,v,-1,-1,d,!0),this.addCurrentVertex(p,v,0,0,d)));if(!a&&F&&n<h-1){const t=p.dist(m);if(t>2*f){const n=p.add(m.sub(p).k(f/t).T());n.z=p.z,this.updateDistance(p,n),this.addCurrentVertex(n,v,0,0,d),p=n}}}}addCurrentVertex(t,n,e,r,i,s=!1){const o=n.x+n.y*e,a=n.y-n.x*e,u=n.y*r-n.x,l=-n.y-n.x*r;let h=0,c=0;if(i.middleVertex){Fu.x=o,Fu.y=a,Au.x=u,Au.y=l;const t=i.currentNormal;if(h=$u(t,Fu),0===e&&0===r)c=-h;else{const n=ku;n.x=t.x,n.y=t.y,n.k(-1),c=$u(n,Au)}}this.addHalfVertex(t,o,a,s,!1,e,i,h),this.addHalfVertex(t,u,l,s,!0,-r,i,c),this.prevVertex&&Cu(t,this.prevVertex)||(this.prevVertex=t),this.distance>xu/2&&0===this.totalDistance&&(this.distance=0,this.updateScaledDistance(),this.addCurrentVertex(t,n,e,r,i,s))}addHalfVertex({x:t,y:n,z:e},r,i,s,o,a,u,l){this.fillData(this.data,t,n,e||0,r,i,s,o,1*this.scaledDistance,l);const h=u.vertexLength++;this.e1>=0&&this.e2>=0&&(this.addElements(this.e1,this.e2,h),u.primitiveLength++),o?this.e2=h:this.e1=h}fillData(t,n,e,r,i,s,o,a,u,l){const{lineWidthFn:h,lineStrokeWidthFn:c,lineStrokeColorFn:f,lineColorFn:d,lineOpacityFn:p,lineDxFn:y,lineDyFn:m,linePatternAnimSpeedFn:g,linePatternGapFn:v}=this.tt;this.fillPosition(t,n,e,r);let b=63*i;b=(Math.sign(b)||1)*((Math.floor(Math.abs(b))>>1<<1)+ +o);let w=63*s;w=(Math.sign(w)||1)*((Math.floor(Math.abs(w))>>1<<1)+ +a),t.aExtrude.push(b,w),(this.iconAtlas||this.hasDasharray)&&t.aExtrude.push(63*l),t.aLinesofar.push(u),h&&t.aLineWidth.push(Math.round(2*this.feaLineWidth)),c&&t.aLineStrokeWidth.push(Math.round(2*this.feaLineStrokeWidth)),d&&t.aColor.push(...this.feaColor),f&&t.aStrokeColor.push(...this.feaStrokeColor),p&&t.aOpacity.push(this.feaOpacity),this.dasharrayFn&&t.aDasharray.push(...this.feaDash),this.dashColorFn&&t.aDashColor.push(...this.feaDashColor),this.iconAtlas&&t.aTexInfo.push(...this.feaTexInfo),(y||m)&&t.aLineDxDy.push(this.feaLineDx||0,this.feaLineDy||0),(g||v)&&t.aLinePattern.push(127*(this.feaPatternAnimSpeed||0),10*(this.feaLinePatternGap||0)),this.maxPos=Math.max(this.maxPos,Math.abs(n)+1,Math.abs(e)+1)}addElements(t,n,e){super.addElements(this.offset+t,this.offset+n,this.offset+e)}Et(t){const n=this.options.EXTENT,e=this.elements;for(let r=0;r<e.length;r+=3)n!==1/0&&(_u(this.data.aPosition,e[r],e[r+1],3,n)||_u(this.data.aPosition,e[r+1],e[r+2],3,n))||t.push(e[r],e[r+1],e[r+2])}It(t){if(t.length<=1)return t;const n=[],e=this.options.EXTENT;let r,i=!0;for(r=0;r<t.length-1;r++){const s=Su(t[r],t[r+1],e);s&&i||(n.push(t[r]),i=s)}return i||n.push(t[r]),n}updateDistance(t,n){if(this.options.isTube){const e=t.dist(n),r=Pr(this.options)*(n.z-t.z);this.distance+=Math.sqrt(e*e+r*r)}else this.distance+=t.dist(n);this.updateScaledDistance()}updateScaledDistance(){this.scaledDistance=this.totalDistance>0?(this.clipStart+(this.clipEnd-this.clipStart)*this.distance/this.totalDistance)*(xu-1):this.distance}}function Su(t,n,e){return e!==1/0&&(t.x<0&&n.x<0||t.x>e&&n.x>e||t.y<0&&n.y<0||t.y>e&&n.y>e)}function _u(t,n,e,r,i){if(i===1/0)return!1;const s=Math.floor(.5*t[n*r]),o=Math.floor(.5*t[n*r+1]),a=Math.floor(.5*t[e*r]),u=Math.floor(.5*t[e*r+1]);return s===a&&(s<0||s>i)&&o!==u||o===u&&(o<0||o>i)&&s!==a}function Ou(t){if(!Array.isArray(t))return!1;for(let n=0;n<t.length;n++)if(t[n])return!0;return!1}const Eu=new Ut(0,0),Iu=new Ut(0,0);function $u(t,n){const e=t.mag(),r=n.mag();Eu.x=n.x,Eu.y=n.y;const i=t.angleTo(Iu),s=n.angleTo(Iu);return Math.sign(s-i)*Math.sqrt(r*r-e*e)}function Cu(t,n){return t.equals(n)&&t.z===n.z}class Tu extends Pu{constructor(t,n,e){super(t,n,e),this.$t=e.altitudeProperty}getFormat(){const{lineColorFn:t,lineWidthFn:n}=this.tt,e=[{type:this.maxPosZ>=Math.pow(2,15)?Float32Array:Int16Array,width:3,name:"aPosition"},{type:Uint16Array,width:1,name:"aLinesofar"},{type:Uint8Array,width:1,name:"aUp"},{type:Int16Array,width:3,name:"aExtrudedPosition"},{type:Int8Array,width:2,name:"aExtrude"}];return t&&e.push({type:Uint8Array,width:4,name:"aColor"}),n&&e.push({type:Uint8Array,width:1,name:"aLineWidth"}),this.$t&&e.push({type:Array,width:1,name:"aLineHeight"}),e}placeVector(t){const n=t.feature;if(this.$t){const{altitudeScale:t,altitudeProperty:e,defaultAltitude:r,heightProperty:i,defaultHeight:s,minHeightProperty:o}=this.options,{altitude:a,height:u}=nr(n,t,e,r,i,s,o);this.feaAltitude=a,this.feaMinHeight=(a-u)/a*32767,a>this.maxAltitude&&(this.maxAltitude=a)}return super.placeVector(t)}needAltitudeAttribute(){return!1}_t(t,n,e,r,i,s){const o=this.data.aPosition.length/3;super._t(t,n,e,r,i,s);const a=this.data.aPosition.length/3,u=this.data.aPosition.length/3-this.offset;if(3!==n.type&&u>0&&!1!==this.options.side){const t=!1!==this.options.top?1:0,n=t+4;let e=this.data.aPosition.length/3;for(const t in this.data){const n=this.data[t],r=n.length/e;for(let t=0;t<r;t++)n.push(n[o*r+3*r+t])}e=this.data.aPosition.length/3;for(const t in this.data){const r=this.data[t],i=r.length/e;for(let t=0;t<i;t++)r.push(r[o*i+i*n+t])}e=this.data.aPosition.length/3;for(const t in this.data){const r=this.data[t],i=r.length/e;for(let t=0;t<i;t++)r.push(r[o*i+i*(n+3)+t])}super.addElements(t+1,u+1,u),super.addElements(u,u+1,u+2);const r=this.data.aPosition.length/3-this.offset;e=this.data.aPosition.length/3;for(const t in this.data){const n=this.data[t],r=n.length/e;for(let t=0;t<r;t++)n.push(n[a*r-r+t])}e=this.data.aPosition.length/3;for(const t in this.data){const r=this.data[t],i=r.length/e;for(let t=0;t<i;t++)r.push(r[a*i-n*i-i+t])}e=this.data.aPosition.length/3;for(const t in this.data){const r=this.data[t],i=r.length/e;for(let t=0;t<i;t++)r.push(r[a*i-n*i-3*i+t])}super.addElements(r,u-3,r+1),super.addElements(u-3,r+2,r+1)}}fillData(t,n,e,r,i,s,o,a,u){const l=!1!==this.options.top,h=!1!==this.options.side,c=this.feaLineWidth||this.symbol.lineWidth/2*(this.options.EXTENT/this.options.tileSize),f=63*i,d=63*s,p=c*i+n,y=c*s+e;this.Ct(t,n,e,i,s,o,a,u,p,y,f,d),h&&(l&&this.Ct(t,n,e,i,s,o,a,u,p,y,f,d),this.Ct(t,n,e,i,s,o,a,u,p,y,f,d),this.Tt(t,n,e,i,s,o,a,u,p,y,f,d),this.Tt(t,n,e,i,s,o,a,u,p,y,f,d)),this.maxPos=Math.max(this.maxPos,Math.abs(n),Math.abs(e))}Ct(t,n,e,r,i,s,o,a,u,l,h,c){const{lineColorFn:f,lineWidthFn:d}=this.tt;t.aPosition.push(n,e,32767),t.aLinesofar.push(a),t.aUp.push(+o),t.aExtrudedPosition.push(u,l,1),t.aExtrude.push(h,c),f&&t.aColor.push(...this.feaColor),d&&t.aLineWidth.push(Math.round(2*this.feaLineWidth)),this.$t&&t.aLineHeight.push(this.feaAltitude)}Tt(t,n,e,r,i,s,o,a,u,l,h,c){const{lineColorFn:f,lineWidthFn:d}=this.tt;t.aPosition.push(n,e,this.feaMinHeight||0),t.aLinesofar.push(a),t.aUp.push(+o),t.aExtrudedPosition.push(u,l,1),t.aExtrude.push(h,c),f&&t.aColor.push(...this.feaColor),d&&t.aLineWidth.push(Math.round(2*this.feaLineWidth)),this.$t&&t.aLineHeight.push(this.feaAltitude)}addElements(t,n,e){const r=!1!==this.options.top,i=!1!==this.options.side,s=(r?1:0)+(i?4:0);if(t*=s,n*=s,this.data.aUp[this.offset+(e*=s)+4]){if(r&&super.addElements(n,t,e),i){const t=r?1:0;super.addElements(n+t,e+t,e+t+2),super.addElements(n+t+1,e+t+1+2,n+t+1+2)}}else if(r&&super.addElements(t,e,n),i){const n=r?1:0;super.addElements(t+n,t+n+2,e+n),super.addElements(t+n+1+2,e+n+1+2,e+n+1)}}createDataPack(t,n){this.maxAltitude=0;const e=super.createDataPack(t,n);if(!e)return e;const{data:r,indices:i}=e;this.getFormat().reduce((t,n)=>(t[n.name]={size:n.width},t),{}).aPickingId={size:1};const{aExtrudedPosition:s,aPosition:o,aLinesofar:a,aUp:u,aExtrude:l,aColor:h,aLineHeight:c,aLineWidth:f}=r,d={},p=ne(s,i);let y,m=!0;for(let t=0;t<p.length;t++)p[t]=-p[t],p[t]%1!=0&&(m=!1);if(!1!==this.options.top&&this.symbol.material&&function(t){for(const n in t)if(n.indexOf("Texture")>=0&&t[n])return!0;return!1}(this.symbol.material)&&(y=function(t,n,e){const r=[];for(let i=0;i<t.length;i+=3){const t=n[i/3];r.push(t/256,e[i/3]?1:0)}return r}(s,a,u)),d.aPosition=o,y&&(d.aTexCoord0=new Float32Array(y)),d.aNormal=m?new Int8Array(p):new Float32Array(p),d.aPickingId=r.aPickingId,d.aExtrude=l,h&&(d.aColor=h),f&&(d.aLineWidth=f),c){const t=fr(this.maxAltitude);d.aLineHeight=new t(c)}const g=[];for(const t in d)g.push(d[t].buffer);return e.data=d,e.buffers=g,e}}const zu=Math.pow(2,16)/1;class Du extends aa{getFormat(){return[...this.getPositionFormat()]}placeVector(t){const n=t.feature,e=3===n.type,r=n.geometry,i=this.elements;e&&(this.elements=[]);const s=this.needAltitudeAttribute()?2:3;for(let t=0;t<r.length;t++)this.offset=this.data.aPosition.length/s,this._t(r[t],n),e&&(this.Et(i),this.elements=[]);e&&(this.elements=i)}_t(t,n){const e=3===n.type;let r=t.length;for(;r>=2&&t[r-1].equals(t[r-2]);)r--;let i,s,o,a=0;for(;a<r-1&&t[a].equals(t[a+1]);)a++;if(!(r<(e?3:2))){this.distance=0,this.vertexLength=0,this.primitiveLength=0,this.e1=this.e2=this.e3=-1,e&&(i=t[r-2]);for(let n=a;n<r;n++)o=e&&n===r-1?t[a+1]:t[n+1],o&&t[n].equals(o)||(i&&(s=i),i=t[n],s&&(this.distance+=i.dist(s)),this.addCurrentVertex(i,this.distance))}}addCurrentVertex(t,n){const e=this.vertexLength++;this.addLineVertex(this.data,t,n),e>=1&&this.addElements(e-1,e),n>zu&&(this.distance=0,this.addCurrentVertex(t,this.distance))}addLineVertex(t,n){this.fillPosition(t,n.x,n.y,n.z||0),this.maxPos=Math.max(this.maxPos,Math.abs(n.x),Math.abs(n.y))}addElements(t,n){super.addElements(this.offset+t,this.offset+n)}Et(t){const n=this.options.EXTENT,e=this.elements;for(let r=0;r<e.length;r+=2)Qe(this.data.aPosition,e[r],e[r+1],3,n)||t.push(e[r],e[r+1])}}const ju=45*Math.PI/100;class Uu extends aa{getFormat(){const{markerFillFn:t}=this.tt;let n;return n="line"===this.symbol.markerRotationAlignment?[...this.getPositionFormat(),{type:Float32Array,width:1,name:"aXYRotation"},{type:Float32Array,width:1,name:"aZRotation"}]:[...this.getPositionFormat()],t&&n.push({type:Uint8Array,width:4,name:"aColor"}),n}placeVector(t){const n=t.feature.properties,{markerFillFn:e}=this.tt;let r;e&&(r=e(this.options.zoom,n)||[255,255,255,255],d(r)?(this.dynamicAttrs.aColor=1,r=[0,0,0,0]):r=Or([],r));const i="line"===this.symbol.markerRotationAlignment,s=this.Ft(t,this.symbol.markerSpacing||250,this.symbol.markerPlacement||"point",i);for(let t=0;t<s.length;t++){const n=s[t];this.fillPosition(this.data,n.x,n.y,n.z),i&&(this.data.aXYRotation.push(n.xyRotation||0),this.data.aZRotation.push(n.zRotation||0)),r&&this.data.aColor.push(...r);const e=Math.max(Math.abs(n.x),Math.abs(n.y));e>this.maxPos&&(this.maxPos=e)}}Ft(t,n,e,r){const i=t.feature,s=this.options.EXTENT;if("line"===e){const t=[];let e=i.geometry;s&&(e=iu(i.geometry,0,0,s,s));for(let r=0;r<e.length;r++){const i=au(e[r],n,ju,null,null,24,1,1,s||1/0);t.push.apply(t,i)}return t}return mu(i,e,s,r,this.options.altitudeToTileScale)}hasElements(){return!1}}\n/*!\n     * from @turf/bboxClip\n     * https://github.com/Turfjs/turf\n     * MIT LICENSE\n     */const Nu=[],Lu=[];function Vu(t,n){var e,r,i,s,o,a,u;for(r=1;r<=8;r*=2){for(e=[],s=!(Hu(i=t[t.length-1],n)&r),o=0;o<t.length;o++){if((u=!(Hu(a=t[o],n)&r))!==s){const t=Ru(i,a,r,n);e.push(void 0!==a.x?new Ut(t[0],t[1]):t)}u&&e.push(a),i=a,s=u}if(!(t=e).length)break}return e}function Ru(t,n,e,r){return Nu[0]=void 0===t.x?t[0]:t.x,Nu[1]=void 0===t.y?t[1]:t.y,t=Nu,Lu[0]=void 0===n.x?n[0]:n.x,Lu[1]=void 0===n.y?n[1]:n.y,n=Lu,8&e?[t[0]+(n[0]-t[0])*(r[3]-t[1])/(n[1]-t[1]),r[3]]:4&e?[t[0]+(n[0]-t[0])*(r[1]-t[1])/(n[1]-t[1]),r[1]]:2&e?[r[2],t[1]+(n[1]-t[1])*(r[2]-t[0])/(n[0]-t[0])]:1&e?[r[0],t[1]+(n[1]-t[1])*(r[0]-t[0])/(n[0]-t[0])]:null}function Hu(t,n){Nu[0]=void 0===t.x?t[0]:t.x,Nu[1]=void 0===t.y?t[1]:t.y;var e=0;return(t=Nu)[0]<n[0]?e|=1:t[0]>n[2]&&(e|=2),t[1]<n[1]?e|=4:t[1]>n[3]&&(e|=8),e}const Wu=[0,0,0,0];class qu extends aa{constructor(...t){super(...t),this.lineElements=[]}createStyledVector(t,n,e,r,i){const s=new Cr(t,n,e,r),o=s.getPolygonResource();return!this.options.atlas&&o&&(i[o]=[0,0]),s}getFormat(){const t=[...this.getPositionFormat()],{polygonFillFn:n,polygonOpacityFn:e,uvScaleFn:r,uvOffsetFn:i,polygonPatternUVFn:s}=this.tt;if(this.iconAtlas){const n=this.getIconAtlasMaxValue();t.push({type:n>255?Uint16Array:Uint8Array,width:4,name:"aTexInfo"})}return n&&t.push({type:Uint8Array,width:4,name:"aColor"}),e&&t.push({type:Uint8Array,width:1,name:"aOpacity"}),r&&t.push({type:Uint16Array,width:2,name:"aUVScale"}),i&&t.push({type:Uint8Array,width:2,name:"aUVOffset"}),s&&t.push({type:Float32Array,width:2,name:"aTexCoord"}),t}placeVector(t,n){const e=t.feature;this.zt(e.geometry,e,n)}zt(t,n){let e,r,i,s;const{polygonFillFn:o,polygonOpacityFn:a,uvScaleFn:u,uvOffsetFn:l,uvOffsetInMeterFn:h,polygonPatternUVFn:c}=this.tt,f=n.properties;o&&(e=o(this.options.zoom,f)||bt([],255,255,255,255),d(e)?(this.dynamicAttrs.aColor=1,e=Wu):e=Or([],e)),a&&(r=a(this.options.zoom,f),d(r)?(this.dynamicAttrs.aOpacity=1,r=255):(gr(r)&&(r=1),r*=255)),u&&(i=u(this.options.zoom,f),d(i)?(i=[255,255],this.dynamicAttrs.aUVScale=1):(gr(i)&&(i=[1,1]),i=[255*i[0],255*i[1]])),l&&(h&&h(null,f)?s=[0,0]:(s=l(this.options.zoom,f),d(s)?(s=[0,0],this.dynamicAttrs.aUVOffset=1):(gr(s)&&(s=[0,0]),s=[255*s[0],255*s[1]])));const p=!!this.iconAtlas,y=lu(t,500),m=[0,0],g=[0,0];if(p){const{polygonPatternFileFn:t}=this.tt,n=t?t(null,f):this.symbol.polygonPatternFile;if(this.iconAtlas.glyphMap[n]){const t=this.iconAtlas.positions[n],e=!or(t.displaySize[0])||!or(t.displaySize[1]);m[0]=t.tl[0]+(e?1:0),m[1]=t.tl[1]+(e?1:0),g[0]=t.displaySize[0]-1-(e?2:0),g[1]=t.displaySize[1]-1-(e?2:0)}}let v,b=0;c&&(v=c(this.options.zoom,f));const w=this.needAltitudeAttribute()?2:3,M=[-1,-1,n.extent+1,n.extent+1],x=this.Dt=this.Dt||this.ut.get(),F=this.jt=this.jt||this.ut.get();for(let t=0;t<y.length;t++){const n=y[t],o=this.data.aPosition.length/w;x.setLength(0),F.setLength(0);for(let t=0;t<n.length;t++){let o=n[t];if(this.options.EXTENT!==1/0&&0===this.maxPosZ&&(o=Vu(o,M)),0!==o.length){0!==t&&F.push(x.length/3);for(let t=0;t<o.length;t++){const n=o[t].x,a=o[t].y,u=o[t].z||0;if(this.fillPosition(this.data,n,a,u),p&&this.data.aTexInfo.push(m[0],m[1],g[0],g[1]),void 0!==e&&this.data.aColor.push(e[0],e[1],e[2],e[3]),void 0!==r&&this.data.aOpacity.push(r),void 0!==i&&this.data.aUVScale.push(i[0],i[1]),void 0!==s&&this.data.aUVOffset.push(s[0],s[1]),c){if(v){const t=gr(v[2*b])?v[0]:v[2*b],n=gr(v[2*b]+1)?v[1]:v[2*b+1];this.data.aTexCoord.push(t,n)}else this.data.aTexCoord.push(-9999999,-9999999);b++}const l=Math.abs(n),h=Math.abs(a);l>this.maxPos&&(this.maxPos=l),h>this.maxPos&&(this.maxPos=h),x.push(n,a,u)}}}let a=Ne(x,F,3);if(x.length&&!a.length){const t=[];for(let n=0;n<x.length;n+=3)t[n]=x[n],t[n+1]=x[n+2],t[n+2]=x[n+1];if(a=Ne(t,F,3),!a.length){for(let n=0;n<x.length;n+=3)t[n]=x[n+1],t[n+1]=x[n+2],t[n+2]=x[n];a=Ne(t,F,3)}}for(let t=0;t<a.length;t+=3)this.addElements(o+a[t],o+a[t+1],o+a[t+2])}}}const Gu=[{type:Int16Array,width:3,name:"aPosition"}];class Bu extends aa{getFormat(){return Gu}placeVector(t,n){const e=this.Ft(t,n);if(0===e.length)return;const r=this.data,i=this.getAltitude(t.feature.properties);let s=r.aPosition.length/Gu[0].width;for(let t=0;t<e.length;t++){const n=e[t];r.aPosition.push(2*n.x+0,2*n.y+0,i),r.aPosition.push(2*n.x+1,2*n.y+0,i),r.aPosition.push(2*n.x+1,2*n.y+1,i),r.aPosition.push(2*n.x+0,2*n.y+1,i),this.addElements(s,s+1,s+2),this.addElements(s,s+2,s+3),s+=4;const o=Math.max(Math.abs(2*n.x+1),Math.abs(2*n.y+1));o>this.maxPos&&(this.maxPos=o)}}Ft(t,n){const{feature:e,symbol:r}=t,i=this.St(t,r),s=e.properties,{markerSpacingFn:o}=this.tt,a=((o?o(null,s):r.markerSpacing)||250)*n;return yu(t,null,null,n,this.options.EXTENT,i,a)}St(t,n){return this.tt.markerPlacementFn?this.tt.markerPlacementFn(this.options.zoom,t.feature.properties):n.markerPlacement}}class Ju extends Pu{constructor(t,n,e){(n=mr({},n)).lineJoin="miter",n.lineCap="butt",super(t,n,e),this.options.radialSegments%2==1&&this.options.radialSegments--}getFormat(){const{lineWidthFn:t,lineColorFn:n,lineOpacityFn:e,linePatternAnimSpeedFn:r,linePatternGapFn:i}=this.tt,s=[...this.getPositionFormat(),{type:Int8Array,size:4,name:"aTubeNormal"},{type:this.options.positionType||Uint16Array,width:1,name:"aLinesofar"}];if(this.iconAtlas){s.push({type:Int8Array,width:1,name:"aNormalDistance"});const t=this.getIconAtlasMaxValue();s.push({type:t>255?Uint16Array:Uint8Array,width:4,name:"aTexInfo"})}return t&&s.push({type:Uint16Array,width:1,name:"aLineWidth"}),n&&s.push({type:Uint8Array,width:4,name:"aColor"}),e&&s.push({type:Uint8Array,width:1,name:"aOpacity"}),r&&s.push({type:Int8Array,width:1,name:"aLinePatternAnimSpeed"}),i&&s.push({type:Int8Array,width:1,name:"aLinePatternGap"}),s}addHalfVertex(t,n,e,r,i,s,o,a){const{x:u,y:l,z:h}=t,c=1*this.scaledDistance,f=this.options.radialSegments/2,{x:d,y:p,z:y}=o.dir,m=function(t,n,e,r,i,s,o,a){ft(Xu,e,r,i),ft(Yu,s,o,0),mt(Zu,Xu,Yu),pt(Yu,Yu),pt(Zu,Zu),Ku[n]||(Ku[n]=[]);const u=Ku[n];for(var l=0;l<n;l++){const t=Math.PI*l/n,e=1-Math.abs(t-0)/(Math.PI/2);u[l]=u[l]||[],Qu(Yu,Zu,u[l],1,t,e*(a?-1:1))}return u}(0,f,d,p,y,n,e,i);this.prevVertex&&this.fillTubeElements(i),this.fillData(this.data,u,l,h||0,m,i,c,a)}fillTubeElements(t){const n=this.options.radialSegments/2,e=this.needAltitudeAttribute()?2:3,r=this.data.aPosition.length/e;for(let e=0;e<n;e++){const i=e+r-2*n;let s,o;e===n-1&&t?(s=e+r-2*n+1,o=e+r-2*n-2*n+1):(s=e+r+1,o=e+r+1-2*n),super.addElements(e+r-this.offset,s-this.offset,i-this.offset),super.addElements(i-this.offset,s-this.offset,o-this.offset)}}fillData(t,n,e,r,i,s,o,a){const{lineWidthFn:u,lineColorFn:l,lineOpacityFn:h,linePatternAnimSpeedFn:c,linePatternGapFn:f}=this.tt,d=i.length;for(let s=0;s<d;s++){if(this.fillPosition(t,n,e,r),Mt(i[s],i[s],63),t.aTubeNormal.push(...i[s]),t.aLinesofar.push(o),this.iconAtlas&&(t.aNormalDistance.push(63*a),t.aTexInfo.push(...this.feaTexInfo)),u){const n=Sr(this.options.metric);let e=this.feaLineWidth*n;isNaN(e)&&(e=0),t.aLineWidth.push(Math.round(e))}l&&t.aColor.push(...this.feaColor),h&&t.aOpacity.push(this.feaOpacity),c&&t.aLinePatternAnimSpeed.push(127*(this.feaPatternAnimSpeed||0)),f&&t.aLinePatternGap.push(10*(this.feaLinePatternGap||0))}this.maxPos=Math.max(this.maxPos,Math.abs(n)+1,Math.abs(e)+1)}createDataPack(t,n){const e=super.createDataPack(t,n);return e&&(e.is2D=!1),e}}const Xu=[],Yu=[],Zu=[],Ku={};function Qu(t,n,e,r,i,s){return bt(e,r*(Math.cos(i)*t[0]+Math.sin(i)*n[0]),r*(Math.cos(i)*t[1]+Math.sin(i)*n[1]),r*(Math.cos(i)*t[2]+Math.sin(i)*n[2]),s),e}class tl extends Ju{addHalfVertex(t,n,e,r,i,s,o,a){const{x:u,y:l,z:h}=t,c=1*this.scaledDistance,{x:f,y:d,z:p}=o.dir,y=function(t,n,e,r,i,s,o,a){ft(el,e,r,i),ft(rl,s,o,0),mt(il,el,rl),pt(rl,rl),pt(il,il),_t(nl,t,n);const u=Et(nl)/t,l=Math.atan(n/t);let h=Math.PI/2+(Math.PI/2-l);return sl[0]||(sl[0]=[]),Qu(rl,il,sl[0],u,h,a?1:-1),h+=2*l,sl[1]||(sl[1]=[]),Qu(rl,il,sl[1],u,h,a?1:-1),sl}(this.feaLineWidth,this.feaLineHeight,f,d,p,n,e,i);this.prevVertex&&this.fillTubeElements(i),this.fillData(this.data,u,l,h||0,y,i,c,a)}}const nl=[],el=[],rl=[],il=[],sl=[];class ol{constructor(t){this.max=t,this.reset()}reset(){return this.data={},this.order=[],this}clear(){this.reset()}add(t,n){return this.has(t)?(this.order.splice(this.order.indexOf(t),1),this.data[t]=n,this.order.push(t)):(this.data[t]=n,this.order.push(t),this.order.length>this.max&&this.getAndRemove(this.order[0])),this}has(t){return t in this.data}keys(){return this.order}getAndRemove(t){if(!this.has(t))return null;const n=this.data[t];return delete this.data[t],this.order.splice(this.order.indexOf(t),1),n}get(t){return this.has(t)?this.data[t]:null}remove(t){return this.has(t)?(delete this.data[t],this.order.splice(this.order.indexOf(t),1),this):this}setMaxSize(t){for(this.max=t;this.order.length>this.max;)this.getAndRemove(this.order[0]);return this}}\n/*!\n     * based on @mapbox/tiny-sdf\n     * https://github.com/mapbox/tiny-sdf\n     * @License BSD 2-Clause\n     */var al=1e20;function ul(t,n,e,r,i,s,o){this.fontSize=t||24,this.buffer=void 0===n?3:n,this.cutoff=r||.25,this.fontFamily=i||"sans-serif",this.fontWeight=s||"normal",this.fontStyle=o||"normal",this.radius=e||8;var a=this.size=this.fontSize+2*this.buffer;this.canvas="undefined"==typeof document?new OffscreenCanvas(a,a):document.createElement("canvas"),this.canvas.width=this.canvas.height=a,this.ctx=this.canvas.getContext("2d",{willReadFrequently:!0}),this.ctx.font=this.fontStyle+" "+this.fontWeight+" "+this.fontSize+"px "+this.fontFamily,this.ctx.textBaseline="middle",this.ctx.fillStyle="black",this.gridOuter=new Float64Array(a*a),this.gridInner=new Float64Array(a*a),this.f=new Float64Array(a),this.z=new Float64Array(a+1),this.v=new Uint16Array(a),this.middle=Math.round(a/2*(navigator.userAgent.indexOf("Gecko/")>=0?1.2:1))}function ll(t,n,e,r,i,s){for(var o=0;o<n;o++)hl(t,o,n,e,r,i,s);for(var a=0;a<e;a++)hl(t,a*n,1,n,r,i,s)}function hl(t,n,e,r,i,s,o){var a,u,l,h;for(s[0]=0,o[0]=-al,o[1]=al,a=0;a<r;a++)i[a]=t[n+a*e];for(a=1,u=0,l=0;a<r;a++){do{l=(i[a]-i[h=s[u]]+a*a-h*h)/(a-h)/2}while(l<=o[u]&&--u>-1);s[++u]=a,o[u]=l,o[u+1]=al}for(a=0,u=0;a<r;a++){for(;o[u+1]<a;)u++;t[n+a*e]=i[h=s[u]]+(a-h)*(a-h)}}ul.prototype.draw=function(t,n,e){this.ctx.clearRect(0,0,this.size,this.size),this.ctx.textBaseline="top",this.ctx.fillText(t,this.buffer,this.buffer);for(var r=this.ctx.getImageData(0,0,n,e),i=new Uint8ClampedArray(n*e),s=0;s<n*e;s++){var o=r.data[4*s+3]/255;this.gridOuter[s]=1===o?0:0===o?al:Math.pow(Math.max(0,.5-o),2),this.gridInner[s]=1===o?al:0===o?0:Math.pow(Math.max(0,o-.5),2)}for(ll(this.gridOuter,n,e,this.f,this.v,this.z),ll(this.gridInner,n,e,this.f,this.v,this.z),s=0;s<n*e;s++){var a=Math.sqrt(this.gridOuter[s])-Math.sqrt(this.gridInner[s]);i[s]=Math.round(255-255*(a/this.radius+this.cutoff))}return i};let cl=0;class fl{constructor(t,n=15,e){this.entries={},this.Ut={},this.Nt=new ol(2048,(function(){})),this.Lt=t,this.Vt=n,this.Rt=e}getGlyphs(t,n){if(!t||!Object.keys(t).length)return void n(null,{glyphs:null});const e=this.entries,r=t.options;let i=!0;r&&(i=!1!==r.isCharsCompact),i=i||this.Rt;const s=(r,s,a)=>{let u=0,l=0;for(const n in t)if("options"!==n){e[n]=e[n]||{},s[n]=s[n]||{};for(const h in t[n]){if(l++,l<=r)continue;const t=n.split(" "),c=i&&"normal"===t[0]&&!La(+h),f=n+":"+h+":"+c;let d;if(this.Nt.has(f)?d=this.Nt.get(f):(d=this.Ht(e[n],t,h,c),this.Nt.add(f,d),u++),d=dl(d),s[n][h]=d,a.push(d.bitmap.data.buffer),this.Lt&&u>this.Vt)return void this.Lt(o(l,s,a))}}n(null,{glyphs:s,buffers:a})};function o(t,n,e){return()=>{s(t,n,e)}}s(0,{},[])}Ht(t,n,e,r){const i=n[0],s=n[1],o=n.slice(3).join(" ");let a=t.tinySDF,u="normal"!==i?5:2;const l=r?-1:2;if(!a){let n="400";/bolder/i.test(s)?n="1000":/bold/i.test(s)?n="900":/medium/i.test(s)?n="500":/light/i.test(s)&&(n="200"),a=t.tinySDF=new ul(24,u,8,.25,o,n,i)}const h=String.fromCodePoint(e),c=a.ctx.measureText(h),f=Math.round(c.width),d=a.draw(h,f+2*u,24+2*u);if(cl<4){const t="undefined"!=typeof document&&document.getElementById("sdf-debug-"+cl++);t&&(t.width=f+2*u,t.height=a.canvas.height,t.getContext("2d").drawImage(a.canvas,0,0))}return{charCode:e,bitmap:{width:f+2*u,height:24+2*u,data:d},metrics:{width:f,height:24,left:1,top:-u,advance:f+u+l}}}}function dl(t){const n={width:t.bitmap.width,height:t.bitmap.height,data:new Uint8ClampedArray(t.bitmap.data)};return{charCode:t.charCode,bitmap:n,metrics:mr({},t.metrics)}}var pl=Object.freeze({__proto__:null,clipPolygon:Vu,calculateSignedArea:Ke,getFeaAltitudeAndHeight:nr,generatePickingIndiceIndex:sr,convertRTLText:tu,packPosition:Tr,unpackPosition:function(t,n,e,r){const i=(Math.sign(n)||1)*(Math.abs(n)%zr),s=(Math.sign(e)||1)*(Math.abs(e)%zr),o=Math.floor(Math.abs(n)/zr),a=Math.floor(Math.abs(e)/zr);return t[0]=i,t[1]=s,t[2]=Math.sign(r+1e-5)*(2*o+a)*Dr+r,t},convertGeometry:yr,getPosArrayType:fr,getUnsignedArrayType:dr,getIndexArrayType:cr});const yl={},ml={},gl=[];Object.freeze({__proto__:null,loadSymbolFnTypes:function t(n,e){if(!n)return null;var r=!1;if(Array.isArray(n)){var i,s=[];for(let o=0;o<n.length;o++)(i=t(n[o],e))?(s.push(i),r=!0):s.push(n[o]);return r?s:n}var o={__fn_types_loaded:!0};const a=[];for(const t in n)Fr(n,t)&&a.push(t);const u=function(t){Object.defineProperty(o,t,{get:function(){return this["__fn_"+t]||(this["__fn_"+t]=p(this["_"+t])),this["__fn_"+t].apply(this,e())},set:function(n){this["_"+t]=n},configurable:!0,enumerable:!0})},l={},h=function(t,n){Object.defineProperty(o,t,{get:function(){this["__fn_"+t]||(this["__fn_"+t]=Lo(this["_"+t],n));const r=e()[0];l.zoom=r;try{return this["__fn_"+t].evaluateWithoutErrorHandling(l,yl,ml,null,gl)}catch(t){return null}},set:function(n){this["_"+t]=n},configurable:!0,enumerable:!0})};for(let t=0,e=a.length;t<e;t++){const e=a[t];if(d(n[e]))r=!0,o["_"+e]=n[e],u(e);else if(Vo(n[e])){r=!0;const t=Go(e);o["_"+e]=n[e],h(e,t)}else o[e]=n[e]}return r?o:n}});const vl={polygonPatternFile:1,markerFile:1,markerPlacement:1,markerSpacing:1,textName:1,textStyle:1,textFaceName:1,textWeight:1,textPlacement:1,textSpacing:1,lineJoin:1,lineCap:1,linePatternFile:1};Object.assign({visible:1,textHorizontalAlignment:1,textVerticalAlignment:1,textWrapWidth:1,markerHorizontalAlignment:1,markerVerticalAlignment:1},vl),Object.assign({lineDasharray:1,topPolygonFill:1,bottomPolygonFill:1},vl);new Float32Array([-1e12])[0];const bl="maptalks_ombb";function wl(t,n,e,r,i,s,o,a,u,l,h,c,f,d,p,y,m){const g=n.length,v=i/3;for(let e=2,r=g;e<r;e+=3)t[i+e-2]=n[e-2],t[i+e-1]=n[e-1],t[i+e-0]=n[e]-o;i+=g;for(let e=2,r=g;e<r;e+=3)t[i+e-2]=n[e-2],t[i+e-1]=n[e-1],t[i+e-0]=n[e]-a;i+=g,t.trySetLength(i+g),t.copyWithin(i,i-2*g,i-g),i+=g,t.trySetLength(i+g),t.copyWithin(i,i-2*g,i-g),i+=g,(e=e||[]).push(g/3);for(let n=0;n<e.length;n++){Ml(v+(e[n-1]||0),v+e[n],t,g/3,u,r,l,h,c,f,s,d,p,y,m)}return i}function Ml(t,n,e,r,i,s,o,a,u,l,h,c,f,d,p){const y=s.length;let m,g;for(let o=t,a=n;o<a-1;o++)m=o,g=o+1,i!==1/0&&at(e,m,g,i)||((o-t)%2==1&&(m+=2*r,g+=2*r),p?(s.push(m+r,g,m),s.push(g+r,g,m+r)):(s.push(m+r,m,g),s.push(g,g+r,m+r)));o&&function(t,n,e,r,i,s,o,a,u,l,h){let c,f=0,d=0,p=0,y=0;const m=h?[1,3,4]:[2,3,4];for(let h=s.length-1;h>=0;h--){const g=s[h],v=3*g+1,b=3*g+2,w=i[3*g],M=i[v],x=i[b];f||d||(f=Math.max(i[b],i[3*s[h-3]+2]),d=Math.min(i[b],i[3*s[h-3]+2]),c=f-d);let F=p;const A=h%6;0===t?(5===A&&(y=jt(i,s,h,w,M)),F=A===m[0]||A===m[1]||A===m[2]?p:p+y):1===t&&(A===m[0]||A===m[1]||A===m[2]?F=0:5===A?(y=jt(i,s,h,w,M),F=y):F=y);const k=F/u*(1/(100*l))/o;let P;P=1===n?x===f?1:0:"bottom"===e?x===f?c/100/a:0:x===f?0:-c/100/a,r[2*g]=k,r[2*g+1]=P,0===A&&(p+=y)}}(a,u,l,h,e,s.slice(y,s.length),c[0],c[1],f,d,p)}function xl(t){const n=[t[0]];let e=t[0];for(let r=1;r<t.length;r++)Array.isArray(t[r])?t[r][0]===e[0]&&t[r][1]===e[1]&&t[r][2]===e[2]||n.push(t[r]):t[r].x===e.x&&t[r].y===e.y&&t[r].z===e.z||n.push(t[r]),e=t[r];return n}const Fl=Qo.getInstance();function Al(t,n,e,r,i,s,o,a,u,l,h,c,f,m,g,v){void 0===n.top&&(n.top=!0),void 0===n.side&&(n.side=!0),Fl.reset();const{altitudeScale:b,altitudeProperty:w,defaultAltitude:M,heightProperty:F,minHeightProperty:A,defaultHeight:k,tangent:_,uv:O,topUVMode:E,sideUVMode:I,sideVerticalUVMode:$,top:C,side:T,textureYOrigin:z,topThickness:D}=n,j=!!v,U=function(t,n,{altitudeScale:e,altitudeProperty:r,defaultAltitude:i,heightProperty:s,minHeightProperty:o,defaultHeight:a},{center:u,side:l,top:h,topThickness:c,uvOrigin:f,uv:d,uvSize:p,topUVMode:y,sideUVMode:m,sideVerticalUVMode:g,textureYOrigin:v,tileRatio:b,centimeterToPoint:w,verticalCentimeterToPoint:M,positionType:F,res:A,glScale:k,projectionCode:S},_,O){let E=n/t[0].extent;n===1/0&&(E=1);const I=n===1/0,$=O.get(),C=O.get(),T=O.get(),z=O.get(),D=O.get(),j=O.get(),U=O.get(),N=!!d,L=!!h,V=!!l,R=N?O.get():null;function H(t,e,r,i,s,o){let a=e;if(L){const i=Ne(z,r,3);if(0===i.length)return e;if(P(D,z),e+=z.length,o)for(let n=2,e=i.length;n<e;n+=3)i[n]+=t/3,i[n-1]+=t/3,i[n-2]+=t/3;else{let n;for(let e=2,r=i.length;e<r;e+=3)n=i[e-1],i[e-1]=i[e]+t/3,i[e]=n+t/3,i[e-2]+=t/3}P(j,i),N&&zt(y||0,t,e,R,D,f,w,b,p[0],p[1],s,A,k,S,u),c>0&&!V&&(e=wl(D,z,r,j,e,R,0,c,n,N,m||0,g||0,v,p,b,M,o)),U.setLength(e/3),U.fill(1,a/3,e/3)}if(V){L&&(c=0),a=e,e=wl(D,z,r,j,e,R,c,i,n,N,m||0,g||0,v,p,b,M,o),U.setLength(e/3);const t=z.length/3;U.fill(1,a/3,a/3+t),U.fill(0,a/3+t,a/3+2*t),U.fill(1,a/3+2*t,a/3+3*t),U.fill(0,a/3+3*t,e/3)}return e}let W=0,q=0;const G=[-1,-1,n+1,n+1];let B=0,J=t.length;x(_)&&(B=_,J=_+1);let X=0,Y=!1;const Z=O.get();for(;B<J;B++){const u=t[B],l=u.id;x(l)&&(Math.abs(l)>X&&(X=Math.abs(l)),l<0&&(Y=!0));const h=u.geometry,c=u.properties[bl];let f=Array.isArray(c&&c[0]&&c[0][0])?c[0]:c;const{altitude:d,height:p}=pl.getFeaAltitudeAndHeight(u,e,r,i,s,a,o);W=Math.max(Math.abs(d),W);const y=D.length;let m=0,g=q;Z.setLength(0),z.setLength(0);const v=pl.calculateSignedArea(h[0])<0;for(let t=0,e=h.length;t<e;t++){let r=h[t];v&&(r=r.reverse()),r=xl(r);const i=pl.calculateSignedArea(r)<0;if(!i&&t>0&&(m++,f=c&&c[m],q=H(g,q,Z,p*E,f,I),z.setLength(0),Z.setLength(0),g=q),n!==1/0&&(r=pl.clipPolygon(r,G)),!r.length){t===e-1&&(q=H(g,q,Z,p*E,f,I));continue}const s=r.length;Array.isArray(r[0])?r[0][0]===r[s-1][0]&&r[0][1]===r[s-1][1]||r.push([r[0][0],r[0][1]]):r[0].x===r[s-1].x&&r[0].y===r[s-1].y||r.push(r[0]),i&&Z.push(z.length/3),ot(z,z.length,r,E,d,!1,F),t===e-1&&(q=H(g,q,Z,p*E,f,I))}const b=D.length-y,w="__fea_idx".trim();for(let t=0;t<b/3;t++)C.push(void 0===u[w]?B:u[w]),$.push(B),x(l)&&T.push(l)}const K=pl.getUnsignedArrayType(C.length?C[C.length-1]:0),Q={maxAltitude:W,vertices:D,verticeTypes:U,indices:j,pickingIds:Qo.createTypedArray(C,K),featureIndexes:$};if(T.length){const t=Y?pl.getPosArrayType(X):pl.getUnsignedArrayType(X);Q.featureIds=Qo.createTypedArray(T,t)}else Q.featureIds=[];return R&&(R.setLength(D.length/3*2),Q.uvs=R),Q}(t,e,{altitudeScale:b,altitudeProperty:w,defaultAltitude:M||0,heightProperty:F,minHeightProperty:A,defaultHeight:k||0},{center:v,top:C,side:T,topThickness:10*D||0,uv:O||_,uvSize:[i,i],uvOrigin:r,topUVMode:E,sideUVMode:I,sideVerticalUVMode:$,textureYOrigin:z,tileRatio:a,centimeterToPoint:u,verticalCentimeterToPoint:l,positionType:g,res:s,glScale:o,projectionCode:f},m,Fl),N=[],L=U.vertices.length/3,V=pl.getIndexArrayType(L),R=Qo.createTypedArray(U.indices,V);delete U.indices,N.push(R.buffer,U.pickingIds.buffer);const H=_?Fl.get():new Float32Array(3*L);H.setLength&&H.setLength(3*L);const W=ne(U.vertices,R,H);let q=!0;for(let t=0;t<W.length;t++){j||(W[t]=-W[t]);const n=W[t]%1;1-Math.abs(n)>1e-6?q=!1:0!==n&&(W[t]=Math.round(W[t]))}if(U.normals=W,_){let t=Fl.get();t.setLength(4*L),t=function(t,n,e,r,i){const s=t.length/3,o=i||new Array(4*s),a=[],u=[];for(let t=0;t<s;t++)a[t]=[0,0,0],u[t]=[0,0,0];const l=[0,0,0],h=[0,0,0],c=[0,0,0],f=[0,0],d=[0,0],p=[0,0],y=[0,0,0],m=[0,0,0];function g(n,r,i){he(l,t,3*n),he(h,t,3*r),he(c,t,3*i),ce(f,e,2*n),ce(d,e,2*r),ce(p,e,2*i);const s=h[0]-l[0],o=c[0]-l[0],g=h[1]-l[1],v=c[1]-l[1],b=h[2]-l[2],w=c[2]-l[2],M=d[0]-f[0],x=p[0]-f[0],F=d[1]-f[1],A=p[1]-f[1],k=1/(M*A-x*F);ft(y,(A*s-F*o)*k,(A*g-F*v)*k,(A*b-F*w)*k),ft(m,(M*o-x*s)*k,(M*v-x*g)*k,(M*w-x*b)*k),dt(a[n],a[n],y),dt(a[r],a[r],y),dt(a[i],a[i],y),dt(u[n],u[n],m),dt(u[r],u[r],m),dt(u[i],u[i],m)}for(let t=0,n=r.length;t<n;t+=3)g(r[t+0],r[t+1],r[t+2]);const v=[],b=[],w=[],M=[];let x,F,A;function k(t){he(w,n,3*t),ct(M,w),F=a[t],ct(v,F),gt(v,v,function(t,n,e){return t[0]=n[0]*e,t[1]=n[1]*e,t[2]=n[2]*e,t}(w,w,yt(w,F))),pt(v,v),mt(b,M,F),A=yt(b,u[t]),x=A<0?-1:1,o[4*t]=v[0],o[4*t+1]=v[1],o[4*t+2]=v[2],o[4*t+3]=x}for(let t=0,n=r.length;t<n;t+=3)k(r[t+0]),k(r[t+1]),k(r[t+2]);return o}(U.vertices,U.normals,U.uvs,R,t),t=function(t,n){const e=new Float32Array(n.length),r=[],i=[],s=[];for(let o=0;o<n.length;o+=4){const a=o/4*3;ft(i,t[a]||0,t[a+1]||0,t[a+2]||0),bt(r,n[o]||0,n[o+1]||0,n[o+2]||0,n[o+3]||0),Qn(s,i,r),vt(e.subarray(o,o+4),s)}return e}(U.normals,t),U.tangents=t,N.push(t.buffer),delete U.normals}if(U.normals&&(q&&(U.normals=Qo.createTypedArray(U.normals,Int8Array)),N.push(U.normals.buffer)),U.uvs){const t=U.uvs;U.uvs=Qo.createTypedArray(t,Float32Array),N.push(U.uvs.buffer)}if(v){const t=U.vertices;for(let n=0;n<t.length;n+=3)t[n]-=v[0],t[n+1]-=v[1]}const G=g||pl.getPosArrayType(Math.max(512,U.maxAltitude)),B=function(t,n,e,r){const i={},s={};if(S(n.polygonFill)){let o=y(n.polygonFill);const a=new Uint8Array(4*r.length);a.fill(255);for(let n=0;n<r.length;n++){const s=t[r[n]],u=s.properties||{};u.$layer=s.layer,u.$type=s.type;let l=o(e,u);d(l)&&(i.aColor=1,o=y(l),l=o(e,u)),delete u.$layer,delete u.$type,$r.normalizeColor(kl,l),a[4*n]=kl[0],a[4*n+1]=kl[1],a[4*n+2]=kl[2],a[4*n+3]=kl[3]}s.aColor=a}if(S(n.polygonOpacity)){let o=p(n.polygonOpacity);const a=new Uint8Array(r.length);a.fill(255);for(let n=0;n<r.length;n++){const s=t[r[n]],u=s.properties||{};u.$layer=s.layer,u.$type=s.type;let l=o(e,u);d(l)&&(i.aOpacity=1,o=y(l),l=o(e,u)),delete u.$layer,delete u.$type,a[n]=255*l}s.aOpacity=a}return s.dynamicAttributes=i,s}(t,h,c,U.featureIndexes),J=function(t,n,e,r,i){const s=[[],[]],o=S(r.topPolygonFill),a=S(r.bottomPolygonFill),u=[255,255,255,255];if(o||a){let l=o&&y(r.topPolygonFill),h=a&&y(r.bottomPolygonFill),c=null,f=null,p=null,m=null;for(let r=0;r<n.length;r++){if(1===t[r]&&!o||0===t[r]&&!a)continue;const g=1===t[r];if(g&&n[r]===c){t[r]=p;continue}if(!g&&n[r]===f){t[r]=m;continue}const v=e[n[r]],b=v.properties||{};b.$layer=v.layer,b.$type=v.type;let w=g?l:h,M=w(i,b);d(M)&&(w=y(M),M=w(i,b)),delete b.$layer,delete b.$type,$r.normalizeColor(kl,M),wt(kl,kl,u);let x=Pl(s,kl);x<0&&(x=s.length,s.push(vt([],kl))),t[r]=x,g?(c=n[r],p=x):(f=n[r],m=x)}}return s.slice(2)}(U.verticeTypes,U.featureIndexes,t,h,c),X={data:{data:{aVertexColorType:J.length<=252?Qo.createTypedArray(U.verticeTypes,Uint8Array):Qo.createTypedArray(U.verticeTypes,Uint16Array),aPosition:Qo.createTypedArray(U.vertices,G),aNormal:U.normals,aTexCoord0:U.uvs,aTangent:U.tangents,aPickingId:U.pickingIds},indices:R,properties:{maxAltitude:U.maxAltitude},dynamicAttributes:B.dynamicAttributes,vertexColors:J},buffers:N};return U.featureIds.length?(X.data.featureIds=U.featureIds,N.push(X.data.featureIds.buffer)):X.data.featureIds=[],B.aColor&&(X.data.data.aColor=B.aColor,X.buffers.push(B.aColor.buffer)),B.aOpacity&&(X.data.data.aOpacity=B.aOpacity,X.buffers.push(B.aOpacity.buffer)),X.buffers.push(X.data.data.aPosition.buffer),X.data.pickingIdIndiceMap=pl.generatePickingIndiceIndex(X.data.data.aPickingId,X.data.indices),X}const kl=[];function Pl(t,n){for(let e=0;e<t.length;e++)if(xt(n,t[e]))return e;return-1}function Sl(t,n,e,r,{altitudeScale:i,altitudeProperty:s,defaultAltitude:o,heightProperty:a,minHeightProperty:u,defaultHeight:l,bottom:h}){const c=h,f=n/t[0].extent,p=2*function(t,n){let e=0;for(let r=0,i=t.length;r<i;r++){const i=t[r];if(x(i.geometry[0][0])){const t=3*i.geometry.length;e+=n?2*t-6:t}else for(let t=0,r=i.geometry.length;t<r;t++){let r=3*i.geometry[t].length;3===i.type&&(r-=3),e+=n?2*r-6:r}}return e}(t)+3*t.length*2,y=[],m=new Int16Array(p),g=new Uint8Array(m.length/3*4);d(e)&&(e=Bo.compileFilter(e));const v=[];function b(t,e,r){const i=e-t,s=m.subarray(t,e),o=m.subarray(e,e+i);o.set(s);for(let t=2,n=o.length;t<n;t+=3)o[t]=s[t]-r;const a=t/3,u=i/3;let l,h;for(let t=a,e=u+a;t<e;t++)t<e-1?(l=t,h=t+1):(l=t,h=a),at(m,l,h,n)||(v.push(l,h),c&&v.push(l+u,h+u),_l(m,l,n)||v.push(l,l+u));return e+i}let w=0,M=0;const F="__fea_idx".trim(),A=[];for(let n=0,h=t.length;n<h;n++){const h=t[n],c=h.geometry;if(e){let t;t="function"==typeof e?e(h&&h.properties):e,$r.normalizeColor(A,t)}else ft(A,255,255,255);const d=w/3*4,{altitude:p,height:x}=pl.getFeaAltitudeAndHeight(h,i,s,o,a,l,u);M=Math.max(Math.abs(p),M);let k=w;for(let t=0,n=c.length;t<n;t++){let n=c[t];const e=n.length;n[0][0]===n[e-1][0]&&n[0][1]===n[e-1][1]&&(n=n.slice(0,e-1)),w=ot(m,k,n,f,p),w=b(k,w,x*f),k=w}const P=k/3*4;for(let t=d;t<P;t+=4)g[t]=A[0],g[t+1]=A[1],g[t+2]=A[2],g[t+3]=255*(r||1);const S=v.length-y.length;for(let t=0;t<S;t++)y.push(h[F])}const k=v.reduce((t,n)=>Math.max(t,n),0),P=new(pl.getIndexArrayType(k))(v),S=pl.getUnsignedArrayType(t.length);return{aPosition:new(pl.getPosArrayType(Math.max(512,M)))(m),indices:P,aPickingId:new S(y),aColor:g}}function _l(t,n,e){const r=t[3*n],i=t[3*n+1];return r<0||r>e||i<0||i>e}function Ol(t,n,e,r){const i=Sl(t,n,e.lineColor,e.lineOpacity,r),s=[i.aPosition.buffer,i.indices.buffer,i.aPickingId.buffer],o=i.indices;return delete i.indices,{data:{data:i,indices:o},buffers:s}}let El=!1;try{const t=new OffscreenCanvas(1,1);t.getContext("2d").fillText("hello",0,0),El=!0}catch(t){El=!1}var Il=El;const $l="__original_properties",Cl="__fn-type_properties";class Tl{constructor(t,n,e,r,i){this.id=t,this.options=n,this.upload=e,this.Wt(n.style),this.requests={},this.Nt=r,this.qt=0,this.loadings=i}updateStyle(t,n){this.options.style=t,this.qt=t.styleCounter,this.Wt(t),n()}updateOptions(t,n){this.options=w(this.options,t),n()}loadTile(t,n){const e=this.loadings,r=t.tileInfo.url,i=this.options.debugTile;if(i){const{x:e,y:r,z:s}=t.tileInfo;let o=!1;for(let t=0;t<i.length;t++)if(e===i[t].x&&r===i[t].y&&s===i[t].z){o=!0;break}if(!o)return void n()}if(e[r])return void e[r].push({context:t,callback:n,ref:this});e[r]=[{context:t,callback:n,ref:this}];const s=this.options.featureIdProperty;this.requests[r]=this.getTileFeatures(t,(n,i,o,a)=>{const u=e[r];if(delete e[r],this.checkIfCanceled(r))return delete this.requests[r],void this.Gt(u,null,{canceled:!0});if(delete this.requests[r],(this.options.debug||s)&&i)for(let n=0;n<i.length;n++)if(this.options.debug&&(i[n]._debug_info={index:n,id:i[n].id,tileId:t.tileInfo.id}),s){const t=A(s)?s[i[n].layer]:s,e=i[n].properties;i[n].id=e&&e[t]||null}if(n)this.Gt(u,n);else if(i&&i.length){if(u)for(let t=0;t<u.length;t++)this.Bt.call(u[t].ref,u[t].context,u[t].callback,r,o,i,a)}else this.Gt(u)})}Bt(t,n,e,r,i,s){this.Jt(r,i,t).then(e=>{e.canceled?n(null,{canceled:!0}):(e.data.style=t.styleCounter,s&&w(e.data,s),n(null,e.data,e.buffers))}).catch(t=>{n(t)})}abortTile(t,n){delete this.requests[t],this.Xt(t),n()}Xt(t){const n=this.loadings[t];if(n)for(let t=0;t<n.length;t++)n[t].callback(null,{canceled:!0});delete this.loadings[t]}Gt(t,n,e){if(t)for(let r=0;r<t.length;r++)t[r].callback(n,e)}checkIfCanceled(t){return!this.requests[t]}onRemove(){this.loadings={},delete this.Nt,this.requests={}}fetchIconGlyphs(t,n,e){if(this.options.workerGlyph&&Il){const r=[];if(t&&Object.keys(t).length){const n=new Promise(n=>{this.upload("fetchIconGlyphs",{icons:t},null,(t,e)=>{n({err:t,iconData:e})})});r.push(n)}if(n&&Object.keys(n).length){const t=new Promise(t=>{this.Yt||(this.Yt=new fl),this.Yt.getGlyphs(n,(n,e)=>{t({err:n,glyphData:e})})});r.push(t)}Promise.all(r).then(t=>{const n={icons:null,glyphs:null};for(let r=0;r<t.length;r++){if(t[r].err)return void e(t[r].err);t[r].iconData?n.icons=t[r].iconData.icons:t[r].glyphData&&(n.glyphs=t[r].glyphData.glyphs)}return n}).then(t=>{e(null,t)})}else this.upload("fetchIconGlyphs",{icons:t,glyphs:n},null,e)}Jt(t,n,e){if(!n.length)return Promise.resolve({data:null,buffers:[]});const{glScale:r,tileInfo:i}=e,s=!this.options.style.style.length&&!this.options.style.featureStyle.length;let o=this.pluginConfig.slice(0);s&&(o=this.Zt(t)),this.featurePlugins&&P(o,this.featurePlugins);const a={};for(let t=0;t<o.length;t++)Vl(n,e.tileInfo.z,o[t],a);const u=[],l=[];for(let t=0;t<n.length;t++){const e=n[t],r=a[t];if(r){l.fill(null);let t=0;for(const n in r){let i=0;const s=r[n].values();for(const t of s){let r=l[i];r||(r=ql(e),l[i]=r),r.properties[n]=t,i++}i>t&&(t=i)}for(let n=0;n<t;n++)u.push(l[n])}else u.push(e)}const h=(n=u)[0].extent,c=i.z,f={x:i.extent2d.xmin*r,y:i.extent2d.ymax*r},d=[],p=[],y=[],m=this.options,g=[],v={},b=[Promise.resolve(e.styleCounter)];let M=0,x=-1;const F=[];let A=!1;for(let t=0;t<o.length;t++){x++;const r=o[t];r.type!==M&&(x=0,M=r.type);const a=0===r.type?d:p;if(r.symbol&&!1===r.symbol.visible){a[x]=null;continue}Jl(r.symbol,F,t),A=A||F[t]&&F[t].size>0;const{tileFeatures:u,tileFeaIndexes:l}=this.Kt(c,r.type,r.filter,n,v,t);if(!u.length){a[x]=null;continue}const m=l[l.length-1],k=pl.getIndexArrayType(m);a[x]={styledFeatures:new k(l)},y.push({idx:t,typeIdx:x}),g.push(a[x].styledFeatures.buffer);const P=w({},e,{extent:h,zoom:c,tilePoint:f});if(this.options.debugTile){const t=this.options.debugTile;for(let n=0;n<t.length;n++){const{x:e,y:r,z:s}=t[n];if(i.x===e&&i.y===r&&i.z===s){P.debugIndex=t[n].index;break}}}let S=this.Qt(u,r,P);s&&(S=S.then(t=>{if(!t)return null;if(t.data)t.data.layer=u[0].layer;else if(Array.isArray(t))for(let n=0;n<t.length;n++)t[n]&&t[n].data&&(t[n].data.layer=u[0].layer);return t})),b.push(S)}return Promise.all(b).then(([e,...r])=>{function i(t,n){if(void 0===t.data.ref&&(t.data.type=o[y[n].idx].renderPlugin.dataConfig.type,t.data.filter=o[y[n].idx].filter.def,t.buffers&&t.buffers.length))for(let n=0;n<t.buffers.length;n++)g.push(t.buffers[n])}if(e!==this.qt)return{canceled:!0};for(let t=0;t<r.length;t++){if(!r[t])continue;const n=r[t],e=0===o[y[t].idx].type?d:p;if(Array.isArray(n)){const r=[];for(let e=0;e<n.length;e++)n[e]&&(i(n[e],t),(void 0===n[e].data.ref||n[n[e].data.ref])&&r.push(n[e].data));r.length&&(e[y[t].typeIdx].data=r)}else i(n,t),e[y[t].typeIdx].data=n.data}const s={},a=t;if(m.features||m.schema||A){let t,e=!1;for(let r=0,i=n.length;r<i;r++)if(t=n[r],a[t.layer].properties||(a[t.layer].properties=jl(t.properties)),t&&(m.features||A&&v[r]))if("id"===m.features)s[r]=t.id;else{m.pickingGeometry||delete t.geometry,delete t.extent,delete t.properties.$layer,delete t.properties.$type,delete t.__index;const n=t.originalFeature;if(n){const n=t.properties,e=w({},t.originalFeature);delete n[$l],e.customProps=w({},n),t=e}const i=w({},t);if(A&&v[r]&&(!m.features||"transient"===m.features)){const i=v[r];for(let r=0;r<i.length;r++){const i=F[r];i&&i.forEach(r=>{const i=n?n.properties:t.properties;i[Cl]||(i[Cl]=new Set),i[Cl].add(r),e=!0})}}s[r]=i}if(e)for(const t in s){const n=s[t],e=n.properties[Cl];if(e){delete n.properties[Cl],"transient"===m.features&&(n.fnTypeProps=w({},n.properties));for(const t in n.properties)e.has(t)||("transient"===m.features?delete n.fnTypeProps[t]:delete n.properties[t])}}}return{data:{schema:a,data:d,featureData:p,extent:h,features:s},buffers:g}}).catch(t=>{console.error(t)})}Qt(t,n,e){let r=t;const i=n.renderPlugin.dataConfig,s=n.symbol,o=this.options.tileSize,{extent:a,glScale:u,zScale:l,zoom:h,tilePoint:c,centimeterToPoint:f,verticalCentimeterToPoint:d}=e,p=a/o,y=i.type,m=e.debugIndex;let g=w({},i,{EXTENT:a,zoom:h,debugIndex:m,features:this.options.features});if("3d-extrusion"===y){const t=Ul(s);t&&(i.uv=1,2===t&&(i.tangent=1));const n=this.options.projectionCode,o=s.material&&s.material.textureWidth||23.25;return Promise.all([Promise.resolve(Al(r,i,a,c,o,e.tileInfo.res,u,a/this.options.tileSize,f,d,s,h,n,m))])}if("3d-wireframe"===y)return Promise.all([Promise.resolve(Ol(r,a,s,i))]);if("point"===y){g=w(g,{requestor:this.fetchIconGlyphs.bind(this),altitudeToTileScale:l*a/this.options.tileSize/u});const t=bu.splitPointSymbol(s),n=aa.genFnTypes(t[0]);return bu.needMerge(t[0],n,h)&&(r=bu.mergeLineFeatures(r,t[0],n,h)),Promise.all(t.map((t,e)=>(0===e?g.fnTypes=n:delete g.fnTypes,new bu(r,t,g).load(p))))}if("native-point"===y){const t=l*a/this.options.tileSize/u;return g.altitudeToTileScale=t,Nl(r,s,g,Uu,a/o)}if("line"===y)return g=w(g,{requestor:this.fetchIconGlyphs.bind(this),tileRatio:p}),Nl(r,s,g,Pu);if("native-line"===y)return Nl(r,s,g,Du);if("fill"===y)return g=w(g,{requestor:this.fetchIconGlyphs.bind(this)}),Nl(r,s,g,qu);if("line-extrusion"===y){delete s.lineGradientProperty,s.lineJoin="miter",s.lineCap="butt";const t=Ul(s);if(t&&(i.uv=1,2===t&&(i.tangent=1)),g=w(g,{tileSize:o,zScale:l,glScale:u}),t){const t=[];if(!1!==i.top){const n=w({},g);n.side=!1,t.push(new Tu(r,s,n))}return!1!==i.side&&(g.side=!0,g.top=!1,t.push(new Tu(r,s,g))),Promise.all(t.map(t=>t.load()))}return Promise.all([new Tu(r,s,g).load()])}if("circle"===y)return Nl(r,s,g,Bu);if("round-tube"===y||"square-tube"===y){const t="round-tube"===y?Ju:tl;return g=w(g,{requestor:this.fetchIconGlyphs.bind(this),radialSegments:"round-tube"===y?i.radialSegments||8:4,centimeterToPoint:f,verticalCentimeterToPoint:d,tileRatio:p,isTube:!0}),Nl(r,s,g,t)}return Promise.resolve([])}Kt(t,n,e,r,i,s){const o="__fea_idx".trim(),a=[],u=[],l=r.length;for(let h=0;h<l;h++)if((1===n||void 0===r[h].id||!this.styledFeatures[r[h].id])&&((!e.def||"default"===e.def)&&!i[h]||!0===e.def||e.def&&(void 0!==e.def.condition||Array.isArray(e.def))&&e(r[h],t))){const t=r[h];if(void 0===t[o]&&(t[o]=h),i[h]||(i[h]=[]),i[h].push(s),u.push(t),a.push(h),1===n)break}return{tileFeatures:u,tileFeaIndexes:a}}Wt(t){const{style:n,featureStyle:e}=t,r={};e.forEach(t=>{Array.isArray(t.id)?(t.id.forEach(t=>{r[t]=1}),t.filter=["in","$id",...t.id]):(r[t.id]=1,t.filter=["==","$id",t.id])});const i=Bo.compileStyle(n);for(let t=0;t<n.length;t++)i[t].filter&&(i[t].filter.def=n[t].filter?n[t].filter.value||n[t].filter:void 0),i[t].type=0;const s=[],o=Bo.compileStyle(e);for(let t=0;t<e.length;t++)o[t].type=1,o[t].filter.def=e[t].filter?e[t].filter.value||e[t].filter:void 0,o[t].renderPlugin&&s.push(o[t]);this.pluginConfig=i,this.featurePlugins=s,this.styledFeatures=r}Zt(t){let n=this.tn;this.tn||(n=this.tn={});const e=["","Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon"],r=[];for(const i in t){const s=i;if(!n[i]){const r=[];for(let n=0;n<t[i].types.length;n++){const o=t[i].types[n],a=["all",["==","$layer",s],["==","$type",e[o]]],u={filter:zn(a),renderPlugin:zl(o),symbol:Dl(o)};u.filter.def=a,u.type=0,r.push(u)}n[s]=r}r.push(...n[s])}return r}}function zl(t){switch(t){case 1:return{type:"native-point",dataConfig:{type:"native-point",only2D:!0}};case 2:return{type:"native-line",dataConfig:{type:"native-line",only2D:!0}};case 3:return{type:"fill",dataConfig:{type:"fill",only2D:!0}}}return null}function Dl(t){switch(t){case 1:return{markerFill:"#f00",markerSize:10};case 2:return{lineColor:"#fff"};case 3:return{polygonFill:"#00f",polygonOpacity:.4}}return null}function jl(t){if(Array.isArray(t)||!A(t))return{};const n={};for(const e in t){const r=t[e];M(r)?n[e]="string":x(r)?n[e]="number":!0===r||!1===r?n[e]="boolean":Array.isArray(r)?n[e]="array":n[e]="object"}return n}function Ul(t){if(!t)return 0;let n=0;for(const e in t){if(("normalTexture"===e||"bumpTexture"===e)&&t[e])return 2;if(e.indexOf("Texture")>0&&t[e])n=1;else if(A(t[e])){const r=Ul(t[e]);if(2===r)return r;1===r&&(n=1)}}return n}function Nl(t,n,e,r,i){const s={},o=Array.isArray(n)?n:[n];let a=-1;for(let t=0;t<o.length;t++)s[t]=Ll(o[t]),!s[t]&&o[t]&&-1===a&&(a=t);const u=[];for(let n=0;n<o.length;n++)o[n]&&(o[n].index={index:n},s[n]||n===a?u.push(new r(t,o[n],e).load(i)):u.push({data:{ref:a,symbolIndex:{index:n}}}));return Promise.all(u)}function Ll(t){if(!t)return 0;for(const n in t)if(S(t[n]))return 1;return 0}function Vl(t,n,e,r){const i=e.customProperties;if(!i)return t;if(i)for(let t=0;t<i.length;t++)i[t].fn=Bo.compileFilter(i[t].filter);for(let e=0;e<i.length;e++)for(let s=0,o=t.length;s<o;s++)if(i[e].fn(t[s],n))for(const t in i[e].properties){const n=i[e].properties[t];k(n)||(r[s]||(r[s]={}),r[s][t]||(r[s][t]=new Set),r[s][t].add(n))}}const Rl={get:(t,n)=>n in t?t[n]:t.originalFeature[n],has:(t,n)=>n in t||n in t.originalFeature},Hl={get:function(t,n){return n in t?t[n]:t[$l][n]},has:(t,n)=>n in t||n in t[$l]},Wl={};function ql(t){const n={};n.originalFeature=t;const e=new Proxy(n,Rl);return e.properties=new Proxy({},Hl),e.properties[$l]=t.properties||Wl,e}function Gl(t,n,e){t[n]||(t[n]=new Set),t[n].add(e)}const Bl=[];function Jl(t,n,e){if(!t)return Bl;for(const r in t){if(!t[r]||!$r.checkIfZoomFnTypeSymbol(r))continue;if(S(t[r]))Gl(n,e,t[r].property);else{if("lineGradientProperty"===r){Gl(n,e,t[r]);continue}if("textName"===r)if(M(t[r])){const i=ya.resolveVarNames(t[r]);if(i)for(let t=0;t<i.length;t++)Gl(n,e,i[t])}else if(Bo.isExpression(t[r])){const i=[];ya.resolveExpVarNames(i,t[r]);for(let t=0;t<i.length;t++)Gl(n,e,i[t])}}const i=t[r].stops;if(i&&i.length)for(let t=0;t<i.length;t++)S(i[t][1])&&Gl(n,t,i[t][1].property)}return n[e]}function Xl(t,n){Yl(t.geometry,n)}function Yl(t,n){if(t)switch(t.type){case"Point":Zl(t.coordinates,n);break;case"MultiPoint":case"LineString":Kl(t.coordinates,n);break;case"MultiLineString":!function(t,n){for(let e=0,r=t.length;e<r;e++)Kl(t[e],n)}(t.coordinates,n);break;case"Polygon":Ql(t.coordinates,n);break;case"MultiPolygon":!function(t,n){for(let e=0,r=t.length;e<r;e++)Ql(t[e],n)}(t.coordinates,n);break;case"GeometryCollection":const e=t.geometries.length;for(let r=0;r<e;r++)Yl(t.geometries[r],n)}}function Zl(t,n){n[0]=Math.min(n[0],t[0]),n[1]=Math.min(n[1],t[1]),n[2]=Math.max(n[2],t[0]),n[3]=Math.max(n[3],t[1])}function Kl(t,n){for(let e=0,r=t.length;e<r;e++)Zl(t[e],n)}function Ql(t,n){t.length&&Kl(t[0],n)}function th(t,n,e,r,i){!function t(n,e,r,i,s){for(;i>r;){if(i-r>600){var o=i-r+1,a=e-r+1,u=Math.log(o),l=.5*Math.exp(2*u/3),h=.5*Math.sqrt(u*l*(o-l)/o)*(a-o/2<0?-1:1),c=Math.max(r,Math.floor(e-a*l/o+h)),f=Math.min(i,Math.floor(e+(o-a)*l/o+h));t(n,e,c,f,s)}var d=n[e],p=r,y=i;for(nh(n,r,e),s(n[i],d)>0&&nh(n,r,i);p<y;){for(nh(n,p,y),p++,y--;s(n[p],d)<0;)p++;for(;s(n[y],d)>0;)y--}0===s(n[r],d)?nh(n,r,y):(y++,nh(n,y,i)),y<=e&&(r=y+1),e<=y&&(i=y-1)}}(t,n,e||0,r||t.length-1,i||eh)}function nh(t,n,e){var r=t[n];t[n]=t[e],t[e]=r}function eh(t,n){return t<n?-1:t>n?1:0}class rh{constructor(t=9){this.nn=Math.max(4,t),this.en=Math.max(2,Math.ceil(.4*this.nn)),this.clear()}all(){return this.rn(this.data,[])}search(t){let n=this.data;const e=[];if(!yh(t,n))return e;const r=this.toBBox,i=[];for(;n;){for(let s=0;s<n.children.length;s++){const o=n.children[s],a=n.leaf?r(o):o;yh(t,a)&&(n.leaf?e.push(o):ph(t,a)?this.rn(o,e):i.push(o))}n=i.pop()}return e}collides(t){let n=this.data;if(!yh(t,n))return!1;const e=[];for(;n;){for(let r=0;r<n.children.length;r++){const i=n.children[r],s=n.leaf?this.toBBox(i):i;if(yh(t,s)){if(n.leaf||ph(t,s))return!0;e.push(i)}}n=e.pop()}return!1}load(t){if(!t||!t.length)return this;if(t.length<this.en){for(let n=0;n<t.length;n++)this.insert(t[n]);return this}let n=this.sn(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this.an(this.data,n);else{if(this.data.height<n.height){const t=this.data;this.data=n,n=t}this.un(n,this.data.height-n.height-1,!0)}else this.data=n;return this}insert(t){return t&&this.un(t,this.data.height-1),this}clear(){return this.data=mh([]),this}remove(t,n){if(!t)return this;let e=this.data;const r=this.toBBox(t),i=[],s=[];let o,a,u;for(;e||i.length;){if(e||(e=i.pop(),a=i[i.length-1],o=s.pop(),u=!0),e.leaf){const r=ih(t,e.children,n);if(-1!==r)return e.children.splice(r,1),i.push(e),this.hn(i),this}u||e.leaf||!ph(e,r)?a?(o++,e=a.children[o],u=!1):e=null:(i.push(e),s.push(o),o=0,a=e,e=e.children[0])}return this}toBBox(t){return t}compareMinX(t,n){return t.minX-n.minX}compareMinY(t,n){return t.minY-n.minY}toJSON(){return this.data}fromJSON(t){return this.data=t,this}rn(t,n){const e=[];for(;t;)t.leaf?n.push(...t.children):e.push(...t.children),t=e.pop();return n}sn(t,n,e,r){const i=e-n+1;let s,o=this.nn;if(i<=o)return s=mh(t.slice(n,e+1)),sh(s,this.toBBox),s;r||(r=Math.ceil(Math.log(i)/Math.log(o)),o=Math.ceil(i/Math.pow(o,r-1))),s=mh([]),s.leaf=!1,s.height=r;const a=Math.ceil(i/o),u=a*Math.ceil(Math.sqrt(o));gh(t,n,e,u,this.compareMinX);for(let i=n;i<=e;i+=u){const n=Math.min(i+u-1,e);gh(t,i,n,a,this.compareMinY);for(let e=i;e<=n;e+=a){const i=Math.min(e+a-1,n);s.children.push(this.sn(t,e,i,r-1))}}return sh(s,this.toBBox),s}cn(t,n,e,r){for(;r.push(n),!n.leaf&&r.length-1!==e;){let e,r=1/0,i=1/0;for(let s=0;s<n.children.length;s++){const o=n.children[s],a=hh(o),u=fh(t,o)-a;u<i?(i=u,r=a<r?a:r,e=o):u===i&&a<r&&(r=a,e=o)}n=e||n.children[0]}return n}un(t,n,e){const r=e?t:this.toBBox(t),i=[],s=this.cn(r,this.data,n,i);for(s.children.push(t),ah(s,r);n>=0&&i[n].children.length>this.nn;)this.dn(i,n),n--;this.pn(r,i,n)}dn(t,n){const e=t[n],r=e.children.length,i=this.en;this.yn(e,i,r);const s=this.mn(e,i,r),o=mh(e.children.splice(s,e.children.length-s));o.height=e.height,o.leaf=e.leaf,sh(e,this.toBBox),sh(o,this.toBBox),n?t[n-1].children.push(o):this.an(e,o)}an(t,n){this.data=mh([t,n]),this.data.height=t.height+1,this.data.leaf=!1,sh(this.data,this.toBBox)}mn(t,n,e){let r,i=1/0,s=1/0;for(let o=n;o<=e-n;o++){const n=oh(t,0,o,this.toBBox),a=oh(t,o,e,this.toBBox),u=dh(n,a),l=hh(n)+hh(a);u<i?(i=u,r=o,s=l<s?l:s):u===i&&l<s&&(s=l,r=o)}return r||e-n}yn(t,n,e){const r=t.leaf?this.compareMinX:uh,i=t.leaf?this.compareMinY:lh;this.gn(t,n,e,r)<this.gn(t,n,e,i)&&t.children.sort(r)}gn(t,n,e,r){t.children.sort(r);const i=this.toBBox,s=oh(t,0,n,i),o=oh(t,e-n,e,i);let a=ch(s)+ch(o);for(let r=n;r<e-n;r++){const n=t.children[r];ah(s,t.leaf?i(n):n),a+=ch(s)}for(let r=e-n-1;r>=n;r--){const n=t.children[r];ah(o,t.leaf?i(n):n),a+=ch(o)}return a}pn(t,n,e){for(let r=e;r>=0;r--)ah(n[r],t)}hn(t){for(let n,e=t.length-1;e>=0;e--)0===t[e].children.length?e>0?(n=t[e-1].children,n.splice(n.indexOf(t[e]),1)):this.clear():sh(t[e],this.toBBox)}}function ih(t,n,e){if(!e)return n.indexOf(t);for(let r=0;r<n.length;r++)if(e(t,n[r]))return r;return-1}function sh(t,n){oh(t,0,t.children.length,n,t)}function oh(t,n,e,r,i){i||(i=mh(null)),i.minX=1/0,i.minY=1/0,i.maxX=-1/0,i.maxY=-1/0;for(let s=n;s<e;s++){const n=t.children[s];ah(i,t.leaf?r(n):n)}return i}function ah(t,n){return t.minX=Math.min(t.minX,n.minX),t.minY=Math.min(t.minY,n.minY),t.maxX=Math.max(t.maxX,n.maxX),t.maxY=Math.max(t.maxY,n.maxY),t}function uh(t,n){return t.minX-n.minX}function lh(t,n){return t.minY-n.minY}function hh(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function ch(t){return t.maxX-t.minX+(t.maxY-t.minY)}function fh(t,n){return(Math.max(n.maxX,t.maxX)-Math.min(n.minX,t.minX))*(Math.max(n.maxY,t.maxY)-Math.min(n.minY,t.minY))}function dh(t,n){const e=Math.max(t.minX,n.minX),r=Math.max(t.minY,n.minY),i=Math.min(t.maxX,n.maxX),s=Math.min(t.maxY,n.maxY);return Math.max(0,i-e)*Math.max(0,s-r)}function ph(t,n){return t.minX<=n.minX&&t.minY<=n.minY&&n.maxX<=t.maxX&&n.maxY<=t.maxY}function yh(t,n){return n.minX<=t.maxX&&n.minY<=t.maxY&&n.maxX>=t.minX&&n.maxY>=t.minY}function mh(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function gh(t,n,e,r,i){const s=[n,e];for(;s.length;){if((e=s.pop())-(n=s.pop())<=r)continue;const o=n+Math.ceil((e-n)/r/2)*r;th(t,o,n,e,i),s.push(n,o,o,e)}}var vh={exports:{}},bh=function(t,n,e,r){var i=t[0],s=t[1],o=!1;void 0===e&&(e=0),void 0===r&&(r=n.length);for(var a=(r-e)/2,u=0,l=a-1;u<a;l=u++){var h=n[e+2*u+0],c=n[e+2*u+1],f=n[e+2*l+0],d=n[e+2*l+1];c>s!=d>s&&i<(f-h)*(s-c)/(d-c)+h&&(o=!o)}return o},wh=function(t,n,e,r){var i=t[0],s=t[1],o=!1;void 0===e&&(e=0),void 0===r&&(r=n.length);for(var a=r-e,u=0,l=a-1;u<a;l=u++){var h=n[u+e][0],c=n[u+e][1],f=n[l+e][0],d=n[l+e][1];c>s!=d>s&&i<(f-h)*(s-c)/(d-c)+h&&(o=!o)}return o};vh.exports=function(t,n,e,r){return n.length>0&&Array.isArray(n[0])?wh(t,n,e,r):bh(t,n,e,r)};var Mh=vh.exports.nested=wh;vh.exports.flat=bh;function xh(t,n,e,r,i){let s,o,a,u,l=n[0],h=r[0],c=0,f=0;h>l==h>-l?(s=l,l=n[++c]):(s=h,h=r[++f]);let d=0;if(c<t&&f<e)for(h>l==h>-l?(o=l+s,a=s-(o-l),l=n[++c]):(o=h+s,a=s-(o-h),h=r[++f]),s=o,0!==a&&(i[d++]=a);c<t&&f<e;)h>l==h>-l?(o=s+l,u=o-s,a=s-(o-u)+(l-u),l=n[++c]):(o=s+h,u=o-s,a=s-(o-u)+(h-u),h=r[++f]),s=o,0!==a&&(i[d++]=a);for(;c<t;)o=s+l,u=o-s,a=s-(o-u)+(l-u),l=n[++c],s=o,0!==a&&(i[d++]=a);for(;f<e;)o=s+h,u=o-s,a=s-(o-u)+(h-u),h=r[++f],s=o,0!==a&&(i[d++]=a);return 0===s&&0!==d||(i[d++]=s),d}function Fh(t){return new Float64Array(t)}const Ah=Fh(4),kh=Fh(8),Ph=Fh(12),Sh=Fh(16),_h=Fh(4);function Oh(t,n,e,r,i,s){const o=(n-s)*(e-i),a=(t-i)*(r-s),u=o-a;if(0===o||0===a||o>0!=a>0)return u;const l=Math.abs(o+a);return Math.abs(u)>=33306690738754716e-32*l?u:-function(t,n,e,r,i,s,o){let a,u,l,h,c,f,d,p,y,m,g,v,b,w,M,x,F,A;const k=t-i,P=e-i,S=n-s,_=r-s;w=k*_,f=134217729*k,d=f-(f-k),p=k-d,f=134217729*_,y=f-(f-_),m=_-y,M=p*m-(w-d*y-p*y-d*m),x=S*P,f=134217729*S,d=f-(f-S),p=S-d,f=134217729*P,y=f-(f-P),m=P-y,F=p*m-(x-d*y-p*y-d*m),g=M-F,c=M-g,Ah[0]=M-(g+c)+(c-F),v=w+g,c=v-w,b=w-(v-c)+(g-c),g=b-x,c=b-g,Ah[1]=b-(g+c)+(c-x),A=v+g,c=A-v,Ah[2]=v-(A-c)+(g-c),Ah[3]=A;let O=function(t,n){let e=n[0];for(let r=1;r<t;r++)e+=n[r];return e}(4,Ah),E=22204460492503146e-32*o;if(O>=E||-O>=E)return O;if(c=t-k,a=t-(k+c)+(c-i),c=e-P,l=e-(P+c)+(c-i),c=n-S,u=n-(S+c)+(c-s),c=r-_,h=r-(_+c)+(c-s),0===a&&0===u&&0===l&&0===h)return O;if(E=11093356479670487e-47*o+33306690738754706e-32*Math.abs(O),O+=k*h+_*a-(S*l+P*u),O>=E||-O>=E)return O;w=a*_,f=134217729*a,d=f-(f-a),p=a-d,f=134217729*_,y=f-(f-_),m=_-y,M=p*m-(w-d*y-p*y-d*m),x=u*P,f=134217729*u,d=f-(f-u),p=u-d,f=134217729*P,y=f-(f-P),m=P-y,F=p*m-(x-d*y-p*y-d*m),g=M-F,c=M-g,_h[0]=M-(g+c)+(c-F),v=w+g,c=v-w,b=w-(v-c)+(g-c),g=b-x,c=b-g,_h[1]=b-(g+c)+(c-x),A=v+g,c=A-v,_h[2]=v-(A-c)+(g-c),_h[3]=A;const I=xh(4,Ah,4,_h,kh);w=k*h,f=134217729*k,d=f-(f-k),p=k-d,f=134217729*h,y=f-(f-h),m=h-y,M=p*m-(w-d*y-p*y-d*m),x=S*l,f=134217729*S,d=f-(f-S),p=S-d,f=134217729*l,y=f-(f-l),m=l-y,F=p*m-(x-d*y-p*y-d*m),g=M-F,c=M-g,_h[0]=M-(g+c)+(c-F),v=w+g,c=v-w,b=w-(v-c)+(g-c),g=b-x,c=b-g,_h[1]=b-(g+c)+(c-x),A=v+g,c=A-v,_h[2]=v-(A-c)+(g-c),_h[3]=A;const $=xh(I,kh,4,_h,Ph);w=a*h,f=134217729*a,d=f-(f-a),p=a-d,f=134217729*h,y=f-(f-h),m=h-y,M=p*m-(w-d*y-p*y-d*m),x=u*l,f=134217729*u,d=f-(f-u),p=u-d,f=134217729*l,y=f-(f-l),m=l-y,F=p*m-(x-d*y-p*y-d*m),g=M-F,c=M-g,_h[0]=M-(g+c)+(c-F),v=w+g,c=v-w,b=w-(v-c)+(g-c),g=b-x,c=b-g,_h[1]=b-(g+c)+(c-x),A=v+g,c=A-v,_h[2]=v-(A-c)+(g-c),_h[3]=A;const C=xh($,Ph,4,_h,Sh);return Sh[C-1]}(t,n,e,r,i,s,l)}function Eh(t,n,e){n=Math.max(0,void 0===n?2:n),e=e||0;var r=function(t){for(var n=t[0],e=t[0],r=t[0],i=t[0],s=0;s<t.length;s++){var o=t[s];o[0]<n[0]&&(n=o),o[0]>r[0]&&(r=o),o[1]<e[1]&&(e=o),o[1]>i[1]&&(i=o)}var a=[n,e,r,i],u=a.slice();for(s=0;s<t.length;s++)Mh(t[s],a)||u.push(t[s]);return function(t){t.sort(Rh);for(var n=[],e=0;e<t.length;e++){for(;n.length>=2&&Dh(n[n.length-2],n[n.length-1],t[e])<=0;)n.pop();n.push(t[e])}for(var r=[],i=t.length-1;i>=0;i--){for(;r.length>=2&&Dh(r[r.length-2],r[r.length-1],t[i])<=0;)r.pop();r.push(t[i])}return r.pop(),n.pop(),n.concat(r)}(u)}(t),i=new rh(16);i.toBBox=function(t){return{minX:t[0],minY:t[1],maxX:t[0],maxY:t[1]}},i.compareMinX=function(t,n){return t[0]-n[0]},i.compareMinY=function(t,n){return t[1]-n[1]},i.load(t);for(var s,o=[],a=0;a<r.length;a++){var u=r[a];i.remove(u),s=Uh(u,s),o.push(s)}var l=new rh(16);for(a=0;a<o.length;a++)l.insert(jh(o[a]));for(var h=n*n,c=e*e;o.length;){var f=o.shift(),d=f.p,p=f.next.p,y=Nh(d,p);if(!(y<c)){var m=y/h;(u=Ih(i,f.prev.p,d,p,f.next.next.p,m,l))&&Math.min(Nh(u,d),Nh(u,p))<=m&&(o.push(f),o.push(Uh(u,f)),i.remove(u),l.remove(f),l.insert(jh(f)),l.insert(jh(f.next)))}}f=s;var g=[];do{g.push(f.p),f=f.next}while(f!==s);return g.push(f.p),g}function Ih(t,n,e,r,i,s,o){for(var a=new Bn([],$h),u=t.data;u;){for(var l=0;l<u.children.length;l++){var h=u.children[l],c=u.leaf?Lh(h,e,r):Ch(e,r,h);c>s||a.push({node:h,dist:c})}for(;a.length&&!a.peek().node.children;){var f=a.pop(),d=f.node,p=Lh(d,n,e),y=Lh(d,r,i);if(f.dist<p&&f.dist<y&&zh(e,d,o)&&zh(r,d,o))return d}(u=a.pop())&&(u=u.node)}return null}function $h(t,n){return t.dist-n.dist}function Ch(t,n,e){if(Th(t,e)||Th(n,e))return 0;var r=Vh(t[0],t[1],n[0],n[1],e.minX,e.minY,e.maxX,e.minY);if(0===r)return 0;var i=Vh(t[0],t[1],n[0],n[1],e.minX,e.minY,e.minX,e.maxY);if(0===i)return 0;var s=Vh(t[0],t[1],n[0],n[1],e.maxX,e.minY,e.maxX,e.maxY);if(0===s)return 0;var o=Vh(t[0],t[1],n[0],n[1],e.minX,e.maxY,e.maxX,e.maxY);return 0===o?0:Math.min(r,i,s,o)}function Th(t,n){return t[0]>=n.minX&&t[0]<=n.maxX&&t[1]>=n.minY&&t[1]<=n.maxY}function zh(t,n,e){for(var r,i,s,o,a=Math.min(t[0],n[0]),u=Math.min(t[1],n[1]),l=Math.max(t[0],n[0]),h=Math.max(t[1],n[1]),c=e.search({minX:a,minY:u,maxX:l,maxY:h}),f=0;f<c.length;f++)if(r=c[f].p,i=c[f].next.p,s=t,r!==(o=n)&&i!==s&&Dh(r,i,s)>0!=Dh(r,i,o)>0&&Dh(s,o,r)>0!=Dh(s,o,i)>0)return!1;return!0}function Dh(t,n,e){return Oh(t[0],t[1],n[0],n[1],e[0],e[1])}function jh(t){var n=t.p,e=t.next.p;return t.minX=Math.min(n[0],e[0]),t.minY=Math.min(n[1],e[1]),t.maxX=Math.max(n[0],e[0]),t.maxY=Math.max(n[1],e[1]),t}function Uh(t,n){var e={p:t,prev:null,next:null,minX:0,minY:0,maxX:0,maxY:0};return n?(e.next=n.next,e.prev=n,n.next.prev=e,n.next=e):(e.prev=e,e.next=e),e}function Nh(t,n){var e=t[0]-n[0],r=t[1]-n[1];return e*e+r*r}function Lh(t,n,e){var r=n[0],i=n[1],s=e[0]-r,o=e[1]-i;if(0!==s||0!==o){var a=((t[0]-r)*s+(t[1]-i)*o)/(s*s+o*o);a>1?(r=e[0],i=e[1]):a>0&&(r+=s*a,i+=o*a)}return(s=t[0]-r)*s+(o=t[1]-i)*o}function Vh(t,n,e,r,i,s,o,a){var u,l,h,c,f=e-t,d=r-n,p=o-i,y=a-s,m=t-i,g=n-s,v=f*f+d*d,b=f*p+d*y,w=p*p+y*y,M=f*m+d*g,x=p*m+y*g,F=v*w-b*b,A=F,k=F;0===F?(l=0,A=1,c=x,k=w):(c=v*x-b*M,(l=b*x-w*M)<0?(l=0,c=x,k=w):l>A&&(l=A,c=x+b,k=w)),c<0?(c=0,-M<0?l=0:-M>v?l=A:(l=-M,A=v)):c>k&&(c=k,-M+b<0?l=0:-M+b>v?l=A:(l=-M+b,A=v));var P=(1-(h=0===c?0:c/k))*i+h*o-((1-(u=0===l?0:l/A))*t+u*e),S=(1-h)*s+h*a-((1-u)*n+u*r);return P*P+S*S}function Rh(t,n){return t[0]===n[0]?t[1]-n[1]:t[0]-n[0]}class Hh{constructor(t,n){this.x=t,this.y=n}clone(){return new Hh(this.x,this.y)}normalize(){const t=this.length();this.x/=t,this.y/=t}negate(){this.x=-this.x,this.y=-this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}diff(t){return new Hh(this.x-t.x,this.y-t.y)}distance(t){const n=this.x-t.x,e=this.y-t.y;return Math.sqrt(n*n+e*e)}dot(t){return this.x*t.x+this.y*t.y}equals(t){return this.x===t.x&&this.y===t.y}orthogonal(){return new Hh(this.y,-this.x)}}function Wh(t,n,e,r){const i=n.x*r.y-n.y*r.x,s=e.x-t.x,o=e.y-t.y,a=(s*r.y-o*r.x)/i;return new Hh(t.x+a*n.x,t.y+a*n.y)}const qh=[],Gh=[];function Bh(t){if(x(t[0]&&t[0].x)){const n=[];let e=0;for(let r=0;r<t.length;r++)Gh[e]?(Gh[e][0]=t[r].x,Gh[e][1]=t[r].y):Gh[e]=[t[r].x,t[r].y],n.push(Gh[e]),e++;t=n}try{const n=Eh(t,1/0);let e=[1/0,1/0],r=[-1/0,-1/0];for(let t=0;t<n.length;t++)n[t][0]<e[0]&&(e[0]=n[t][0]),n[t][0]>r[0]&&(r[0]=n[t][0]),n[t][1]<e[1]&&(e[1]=n[t][1]),n[t][1]>r[1]&&(r[1]=n[t][1]);const i=[];let s=[],o=0;for(let t=0;t<n.length;t++)t===n.length-1&&n[t][0]===n[0][0]&&n[t][1]===n[0][1]||(Ct(i,n[t],"EPSG:3857"),qh[o]?(qh[o].x=i[0],qh[o].y=i[1]):qh[o]=new Hh(i[0],i[1]),s.push(qh[o]),o++);pl.calculateSignedArea(s)<0&&(s=s.reverse());const a=function(t){let n,e=Number.MAX_VALUE;const r=function(t,r,i,s,o,a,u,l){var h=Wh(t,r,o,a),c=Wh(i,s,o,a),f=Wh(u,l,t,r),d=Wh(u,l,i,s),p=h.distance(c)*h.distance(f);0!==p&&p<e&&(n=[h,f,d,c],e=p)};var i=[];for(let n=0;n<t.length;n++)i.push(t[(n+1)%t.length].diff(t[n])),i[n].normalize();var s,o,a,u,l=new Hh(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY),h=new Hh(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY);for(let n=0;n<t.length;n++){var c=t[n];c.x<l.x&&(l.x=c.x,s=n),c.x>h.x&&(h.x=c.x,o=n),c.y<l.y&&(l.y=c.y,u=n),c.y>h.y&&(h.y=c.y,a=n)}var f=new Hh(0,-1),d=new Hh(0,1),p=new Hh(-1,0),y=new Hh(1,0);for(let n=0;n<t.length;n++){var m=[Math.acos(f.dot(i[s])),Math.acos(d.dot(i[o])),Math.acos(p.dot(i[a])),Math.acos(y.dot(i[u]))];switch(m.indexOf(Math.min.apply(Math,m))){case 0:(d=(f=i[s].clone()).clone()).negate(),(y=(p=f.orthogonal()).clone()).negate(),s=(s+1)%t.length;break;case 1:(f=(d=i[o].clone()).clone()).negate(),(y=(p=f.orthogonal()).clone()).negate(),o=(o+1)%t.length;break;case 2:(y=(p=i[a].clone()).clone()).negate(),(d=(f=y.orthogonal()).clone()).negate(),a=(a+1)%t.length;break;case 3:(p=(y=i[u].clone()).clone()).negate(),(d=(f=y.orthogonal()).clone()).negate(),u=(u+1)%t.length}r(t[s],f,t[o],d,t[a],p,t[u],y)}return n}(s);if(!a||4!==a.length)return null;const u=a[0].distance(a[1]),l=a[1].distance(a[2]),h=a.map(t=>[t.x,t.y]);return h.push(+(l>u)),h}catch(t){return null}}const Jh=[];function Xh(t,n){const e=Array.isArray(t&&t[0]&&t[0][0]);for(let r=0;r<t.length;r++)e?t[r]=Xh(t[r]):(Ct(Jh,t[r],n),t[r][0]=Jh[0],t[r][1]=Jh[1]);return t}class Yh extends Tl{constructor(t,n,e,r,i,s){super(t,n,e,r,i),(n=n||{}).extent||(n.extent=8192),this.setData(n.data,s)}setData(t,n){if(delete this.index,!t)return void n();const e={maxZoom:24,tolerance:this.options.simplifyTolerance,extent:this.options.extent,buffer:x(this.options.tileBuffer)?this.options.tileBuffer:64,hasAltitude:!!this.options.hasAltitude,debug:0,lineMetrics:!0,indexMaxZoom:5,indexMaxPoints:1e5,disableFilter:!0};if(this.options.projection&&(e.projection=this.options.projection,"EPSG:4490"===e.projection&&(e.projection="EPSG:4326")),M(t)&&"{"!=t.substring(0,1)||t.url){const r=t.url?t.url:t;O.getJSON(r,t.url?t:{},(t,i)=>{if(t&&(console.error("Failed to fetch geojson:"+r),n(t)),!i)return void n(null,{extent:null,idMap:{}});let s=i;if(this.options.convertFn){s=new Function("data",this.options.convertFn+"\\nreturn convert(data)")(s)}const o=Array.isArray(s)?s:s.features;this.vn(o);const{sample1000:a,idMap:u}=this.bn(o);this.wn(a,u,s,e,n)})}else{"string"==typeof t&&(t=JSON.parse(t));const r=Array.isArray(t)?t:t.features,i=r&&r.length;this.vn(r);let s=r;if(r&&i>1e3){s=[];for(let t=0;t<i;t++)Zh(r[t],s,t,i)}this.wn(s,null,t,e,n)}}vn(t){if(this.options.generateOMBB&&t)for(let n=0;n<t.length;n++){const e=t[n];if(e&&e.geometry&&e.geometry.coordinates)if("Polygon"===e.geometry.type){const t=e.geometry.coordinates[0];if(!t)continue;const n=Bh(t,t.length);e.properties=e.properties||{},e.properties[bl]=n}else if("MultiPolygon"===e.geometry.type){const t=e.geometry.coordinates;for(let n=0;n<t.length;n++){if(!t[n])continue;const r=t[n][0];if(!r)continue;const i=Bh(r,r.length);e.properties=e.properties||{},e.properties[bl]=e.properties[bl]||[],e.properties[bl][n]=i}}}}wn(t,n,e,r,i){try{const s=t&&t.length?function(t){let n=[Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY];switch(t.type){case"FeatureCollection":const e=t.features.length;for(let r=0;r<e;r++)Xl(t.features[r],n);break;case"Feature":Xl(t,n);break;default:Yl(t,n)}return n}({type:"FeatureCollection",features:t}):null;this.index=function(t,n){return new it(t,n)}(e,this.options.geojsonvt||r),i(null,{extent:s,idMap:n})}catch(t){console.warn(t),i({error:t.message})}}bn(t){const n=[],e={};let r=0;const i=this.options.featureIdProperty;if(t){const s=t.length;t.forEach((t,o)=>{!function(t,s,o){if(t&&("Feature"!==t.type||t.geometry)){if(x(t.id)||(t.id=r++),i){let n=i;A(i)&&(n=i[t.layer||"0"]),t.id=t.properties[n]}e[t.id]=w({},t),t.geometry?(e[t.id].geometry=w({},t.geometry),e[t.id].geometry.coordinates=null):t.coordinates&&(e[t.id].coordinates=null),Zh(t,n,s,o)}}(t,o,s)})}return{sample1000:n,idMap:e}}getTileFeatures(t,n){const e=t.tileInfo,r=[];if(!this.index)return setTimeout((function(){n({loading:!0})}),1),1;const i=this.index.getTile(e.z,e.x,e.y);if(!i||0===i.features.length)return setTimeout((function(){n(null,r,[])}),1),1;const s=[];for(let t=0,n=i.features.length;t<n;t++){const n=i.features[t];let e=n.layer;void 0===e&&(e="0"),s[e]={types:{}};s[e].types[n.type]=1,n.tags=n.tags||{},n.geometry.converted||(pl.convertGeometry(n),n.geometry.converted=1),r.push({type:n.type,layer:e,id:n.id,geometry:n.geometry,properties:n.tags,extent:this.options.extent})}for(const t in s)s[t].types=Object.keys(s[t].types).map(t=>+t);return setTimeout((function(){n(null,r,s)}),1),1}onRemove(){super.onRemove(),delete this.index}}function Zh(t,n,e,r){const i=Math.floor(r/998);(0===e||e===r-1||(0===i||e%i==0)&&n.length<999)&&n.push(t)}var Kh={\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nread:function(t,n,e,r,i){var s,o,a=8*i-r-1,u=(1<<a)-1,l=u>>1,h=-7,c=e?i-1:0,f=e?-1:1,d=t[n+c];for(c+=f,s=d&(1<<-h)-1,d>>=-h,h+=a;h>0;s=256*s+t[n+c],c+=f,h-=8);for(o=s&(1<<-h)-1,s>>=-h,h+=r;h>0;o=256*o+t[n+c],c+=f,h-=8);if(0===s)s=1-l;else{if(s===u)return o?NaN:1/0*(d?-1:1);o+=Math.pow(2,r),s-=l}return(d?-1:1)*o*Math.pow(2,s-r)},write:function(t,n,e,r,i,s){var o,a,u,l=8*s-i-1,h=(1<<l)-1,c=h>>1,f=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,d=r?0:s-1,p=r?1:-1,y=n<0||0===n&&1/n<0?1:0;for(n=Math.abs(n),isNaN(n)||n===1/0?(a=isNaN(n)?1:0,o=h):(o=Math.floor(Math.log(n)/Math.LN2),n*(u=Math.pow(2,-o))<1&&(o--,u*=2),(n+=o+c>=1?f/u:f*Math.pow(2,1-c))*u>=2&&(o++,u/=2),o+c>=h?(a=0,o=h):o+c>=1?(a=(n*u-1)*Math.pow(2,i),o+=c):(a=n*Math.pow(2,c-1)*Math.pow(2,i),o=0));i>=8;t[e+d]=255&a,d+=p,a/=256,i-=8);for(o=o<<i|a,l+=i;l>0;t[e+d]=255&o,d+=p,o/=256,l-=8);t[e+d-p]|=128*y}},Qh=nc,tc=Kh;function nc(t){this.buf=ArrayBuffer.isView&&ArrayBuffer.isView(t)?t:new Uint8Array(t||0),this.pos=0,this.type=0,this.length=this.buf.length}nc.Varint=0,nc.Fixed64=1,nc.Bytes=2,nc.Fixed32=5;var ec="undefined"==typeof TextDecoder?null:new TextDecoder("utf8");function rc(t){return t.type===nc.Bytes?t.readVarint()+t.pos:t.pos+1}function ic(t,n,e){return e?4294967296*n+(t>>>0):4294967296*(n>>>0)+(t>>>0)}function sc(t,n,e){var r=n<=16383?1:n<=2097151?2:n<=268435455?3:Math.floor(Math.log(n)/(7*Math.LN2));e.realloc(r);for(var i=e.pos-1;i>=t;i--)e.buf[i+r]=e.buf[i]}function oc(t,n){for(var e=0;e<t.length;e++)n.writeVarint(t[e])}function ac(t,n){for(var e=0;e<t.length;e++)n.writeSVarint(t[e])}function uc(t,n){for(var e=0;e<t.length;e++)n.writeFloat(t[e])}function lc(t,n){for(var e=0;e<t.length;e++)n.writeDouble(t[e])}function hc(t,n){for(var e=0;e<t.length;e++)n.writeBoolean(t[e])}function cc(t,n){for(var e=0;e<t.length;e++)n.writeFixed32(t[e])}function fc(t,n){for(var e=0;e<t.length;e++)n.writeSFixed32(t[e])}function dc(t,n){for(var e=0;e<t.length;e++)n.writeFixed64(t[e])}function pc(t,n){for(var e=0;e<t.length;e++)n.writeSFixed64(t[e])}function yc(t,n){return(t[n]|t[n+1]<<8|t[n+2]<<16)+16777216*t[n+3]}function mc(t,n,e){t[e]=n,t[e+1]=n>>>8,t[e+2]=n>>>16,t[e+3]=n>>>24}function gc(t,n){return(t[n]|t[n+1]<<8|t[n+2]<<16)+(t[n+3]<<24)}nc.prototype={destroy:function(){this.buf=null},readFields:function(t,n,e){for(e=e||this.length;this.pos<e;){var r=this.readVarint(),i=r>>3,s=this.pos;this.type=7&r,t(i,n,this),this.pos===s&&this.skip(r)}return n},readMessage:function(t,n){return this.readFields(t,n,this.readVarint()+this.pos)},readFixed32:function(){var t=yc(this.buf,this.pos);return this.pos+=4,t},readSFixed32:function(){var t=gc(this.buf,this.pos);return this.pos+=4,t},readFixed64:function(){var t=yc(this.buf,this.pos)+4294967296*yc(this.buf,this.pos+4);return this.pos+=8,t},readSFixed64:function(){var t=yc(this.buf,this.pos)+4294967296*gc(this.buf,this.pos+4);return this.pos+=8,t},readFloat:function(){var t=tc.read(this.buf,this.pos,!0,23,4);return this.pos+=4,t},readDouble:function(){var t=tc.read(this.buf,this.pos,!0,52,8);return this.pos+=8,t},readVarint:function(t){var n,e,r=this.buf;return n=127&(e=r[this.pos++]),e<128?n:(n|=(127&(e=r[this.pos++]))<<7,e<128?n:(n|=(127&(e=r[this.pos++]))<<14,e<128?n:(n|=(127&(e=r[this.pos++]))<<21,e<128?n:function(t,n,e){var r,i,s=e.buf;if(i=s[e.pos++],r=(112&i)>>4,i<128)return ic(t,r,n);if(i=s[e.pos++],r|=(127&i)<<3,i<128)return ic(t,r,n);if(i=s[e.pos++],r|=(127&i)<<10,i<128)return ic(t,r,n);if(i=s[e.pos++],r|=(127&i)<<17,i<128)return ic(t,r,n);if(i=s[e.pos++],r|=(127&i)<<24,i<128)return ic(t,r,n);if(i=s[e.pos++],r|=(1&i)<<31,i<128)return ic(t,r,n);throw new Error("Expected varint not more than 10 bytes")}(n|=(15&(e=r[this.pos]))<<28,t,this))))},readVarint64:function(){return this.readVarint(!0)},readSVarint:function(){var t=this.readVarint();return t%2==1?(t+1)/-2:t/2},readBoolean:function(){return Boolean(this.readVarint())},readString:function(){var t=this.readVarint()+this.pos,n=this.pos;return this.pos=t,t-n>=12&&ec?function(t,n,e){return ec.decode(t.subarray(n,e))}(this.buf,n,t):function(t,n,e){var r="",i=n;for(;i<e;){var s,o,a,u=t[i],l=null,h=u>239?4:u>223?3:u>191?2:1;if(i+h>e)break;1===h?u<128&&(l=u):2===h?128==(192&(s=t[i+1]))&&(l=(31&u)<<6|63&s)<=127&&(l=null):3===h?(s=t[i+1],o=t[i+2],128==(192&s)&&128==(192&o)&&((l=(15&u)<<12|(63&s)<<6|63&o)<=2047||l>=55296&&l<=57343)&&(l=null)):4===h&&(s=t[i+1],o=t[i+2],a=t[i+3],128==(192&s)&&128==(192&o)&&128==(192&a)&&((l=(15&u)<<18|(63&s)<<12|(63&o)<<6|63&a)<=65535||l>=1114112)&&(l=null)),null===l?(l=65533,h=1):l>65535&&(l-=65536,r+=String.fromCharCode(l>>>10&1023|55296),l=56320|1023&l),r+=String.fromCharCode(l),i+=h}return r}(this.buf,n,t)},readBytes:function(){var t=this.readVarint()+this.pos,n=this.buf.subarray(this.pos,t);return this.pos=t,n},readPackedVarint:function(t,n){if(this.type!==nc.Bytes)return t.push(this.readVarint(n));var e=rc(this);for(t=t||[];this.pos<e;)t.push(this.readVarint(n));return t},readPackedSVarint:function(t){if(this.type!==nc.Bytes)return t.push(this.readSVarint());var n=rc(this);for(t=t||[];this.pos<n;)t.push(this.readSVarint());return t},readPackedBoolean:function(t){if(this.type!==nc.Bytes)return t.push(this.readBoolean());var n=rc(this);for(t=t||[];this.pos<n;)t.push(this.readBoolean());return t},readPackedFloat:function(t){if(this.type!==nc.Bytes)return t.push(this.readFloat());var n=rc(this);for(t=t||[];this.pos<n;)t.push(this.readFloat());return t},readPackedDouble:function(t){if(this.type!==nc.Bytes)return t.push(this.readDouble());var n=rc(this);for(t=t||[];this.pos<n;)t.push(this.readDouble());return t},readPackedFixed32:function(t){if(this.type!==nc.Bytes)return t.push(this.readFixed32());var n=rc(this);for(t=t||[];this.pos<n;)t.push(this.readFixed32());return t},readPackedSFixed32:function(t){if(this.type!==nc.Bytes)return t.push(this.readSFixed32());var n=rc(this);for(t=t||[];this.pos<n;)t.push(this.readSFixed32());return t},readPackedFixed64:function(t){if(this.type!==nc.Bytes)return t.push(this.readFixed64());var n=rc(this);for(t=t||[];this.pos<n;)t.push(this.readFixed64());return t},readPackedSFixed64:function(t){if(this.type!==nc.Bytes)return t.push(this.readSFixed64());var n=rc(this);for(t=t||[];this.pos<n;)t.push(this.readSFixed64());return t},skip:function(t){var n=7&t;if(n===nc.Varint)for(;this.buf[this.pos++]>127;);else if(n===nc.Bytes)this.pos=this.readVarint()+this.pos;else if(n===nc.Fixed32)this.pos+=4;else{if(n!==nc.Fixed64)throw new Error("Unimplemented type: "+n);this.pos+=8}},writeTag:function(t,n){this.writeVarint(t<<3|n)},realloc:function(t){for(var n=this.length||16;n<this.pos+t;)n*=2;if(n!==this.length){var e=new Uint8Array(n);e.set(this.buf),this.buf=e,this.length=n}},finish:function(){return this.length=this.pos,this.pos=0,this.buf.subarray(0,this.length)},writeFixed32:function(t){this.realloc(4),mc(this.buf,t,this.pos),this.pos+=4},writeSFixed32:function(t){this.realloc(4),mc(this.buf,t,this.pos),this.pos+=4},writeFixed64:function(t){this.realloc(8),mc(this.buf,-1&t,this.pos),mc(this.buf,Math.floor(t*(1/4294967296)),this.pos+4),this.pos+=8},writeSFixed64:function(t){this.realloc(8),mc(this.buf,-1&t,this.pos),mc(this.buf,Math.floor(t*(1/4294967296)),this.pos+4),this.pos+=8},writeVarint:function(t){(t=+t||0)>268435455||t<0?function(t,n){var e,r;t>=0?(e=t%4294967296|0,r=t/4294967296|0):(r=~(-t/4294967296),4294967295^(e=~(-t%4294967296))?e=e+1|0:(e=0,r=r+1|0));if(t>=0x10000000000000000||t<-0x10000000000000000)throw new Error("Given varint doesn\'t fit into 10 bytes");n.realloc(10),function(t,n,e){e.buf[e.pos++]=127&t|128,t>>>=7,e.buf[e.pos++]=127&t|128,t>>>=7,e.buf[e.pos++]=127&t|128,t>>>=7,e.buf[e.pos++]=127&t|128,t>>>=7,e.buf[e.pos]=127&t}(e,0,n),function(t,n){var e=(7&t)<<4;if(n.buf[n.pos++]|=e|((t>>>=3)?128:0),!t)return;if(n.buf[n.pos++]=127&t|((t>>>=7)?128:0),!t)return;if(n.buf[n.pos++]=127&t|((t>>>=7)?128:0),!t)return;if(n.buf[n.pos++]=127&t|((t>>>=7)?128:0),!t)return;if(n.buf[n.pos++]=127&t|((t>>>=7)?128:0),!t)return;n.buf[n.pos++]=127&t}(r,n)}(t,this):(this.realloc(4),this.buf[this.pos++]=127&t|(t>127?128:0),t<=127||(this.buf[this.pos++]=127&(t>>>=7)|(t>127?128:0),t<=127||(this.buf[this.pos++]=127&(t>>>=7)|(t>127?128:0),t<=127||(this.buf[this.pos++]=t>>>7&127))))},writeSVarint:function(t){this.writeVarint(t<0?2*-t-1:2*t)},writeBoolean:function(t){this.writeVarint(Boolean(t))},writeString:function(t){t=String(t),this.realloc(4*t.length),this.pos++;var n=this.pos;this.pos=function(t,n,e){for(var r,i,s=0;s<n.length;s++){if((r=n.charCodeAt(s))>55295&&r<57344){if(!i){r>56319||s+1===n.length?(t[e++]=239,t[e++]=191,t[e++]=189):i=r;continue}if(r<56320){t[e++]=239,t[e++]=191,t[e++]=189,i=r;continue}r=i-55296<<10|r-56320|65536,i=null}else i&&(t[e++]=239,t[e++]=191,t[e++]=189,i=null);r<128?t[e++]=r:(r<2048?t[e++]=r>>6|192:(r<65536?t[e++]=r>>12|224:(t[e++]=r>>18|240,t[e++]=r>>12&63|128),t[e++]=r>>6&63|128),t[e++]=63&r|128)}return e}(this.buf,t,this.pos);var e=this.pos-n;e>=128&&sc(n,e,this),this.pos=n-1,this.writeVarint(e),this.pos+=e},writeFloat:function(t){this.realloc(4),tc.write(this.buf,t,this.pos,!0,23,4),this.pos+=4},writeDouble:function(t){this.realloc(8),tc.write(this.buf,t,this.pos,!0,52,8),this.pos+=8},writeBytes:function(t){var n=t.length;this.writeVarint(n),this.realloc(n);for(var e=0;e<n;e++)this.buf[this.pos++]=t[e]},writeRawMessage:function(t,n){this.pos++;var e=this.pos;t(n,this);var r=this.pos-e;r>=128&&sc(e,r,this),this.pos=e-1,this.writeVarint(r),this.pos+=r},writeMessage:function(t,n,e){this.writeTag(t,nc.Bytes),this.writeRawMessage(n,e)},writePackedVarint:function(t,n){n.length&&this.writeMessage(t,oc,n)},writePackedSVarint:function(t,n){n.length&&this.writeMessage(t,ac,n)},writePackedBoolean:function(t,n){n.length&&this.writeMessage(t,hc,n)},writePackedFloat:function(t,n){n.length&&this.writeMessage(t,uc,n)},writePackedDouble:function(t,n){n.length&&this.writeMessage(t,lc,n)},writePackedFixed32:function(t,n){n.length&&this.writeMessage(t,cc,n)},writePackedSFixed32:function(t,n){n.length&&this.writeMessage(t,fc,n)},writePackedFixed64:function(t,n){n.length&&this.writeMessage(t,dc,n)},writePackedSFixed64:function(t,n){n.length&&this.writeMessage(t,pc,n)},writeBytesField:function(t,n){this.writeTag(t,nc.Bytes),this.writeBytes(n)},writeFixed32Field:function(t,n){this.writeTag(t,nc.Fixed32),this.writeFixed32(n)},writeSFixed32Field:function(t,n){this.writeTag(t,nc.Fixed32),this.writeSFixed32(n)},writeFixed64Field:function(t,n){this.writeTag(t,nc.Fixed64),this.writeFixed64(n)},writeSFixed64Field:function(t,n){this.writeTag(t,nc.Fixed64),this.writeSFixed64(n)},writeVarintField:function(t,n){this.writeTag(t,nc.Varint),this.writeVarint(n)},writeSVarintField:function(t,n){this.writeTag(t,nc.Varint),this.writeSVarint(n)},writeStringField:function(t,n){this.writeTag(t,nc.Bytes),this.writeString(n)},writeFloatField:function(t,n){this.writeTag(t,nc.Fixed32),this.writeFloat(n)},writeDoubleField:function(t,n){this.writeTag(t,nc.Fixed64),this.writeDouble(n)},writeBooleanField:function(t,n){this.writeVarintField(t,Boolean(n))}};var vc=Ut,bc=wc;function wc(t,n,e,r,i){this.properties={},this.extent=e,this.type=0,this.Mn=t,this.xn=-1,this.Fn=r,this.An=i,t.readFields(Mc,this,n)}function Mc(t,n,e){1==t?n.id=e.readVarint():2==t?function(t,n){var e=t.readVarint()+t.pos;for(;t.pos<e;){var r=n.Fn[t.readVarint()],i=n.An[t.readVarint()];n.properties[r]=i}}(e,n):3==t?n.type=e.readVarint():4==t&&(n.xn=e.pos)}function xc(t){for(var n,e,r=0,i=0,s=t.length,o=s-1;i<s;o=i++)n=t[i],r+=((e=t[o]).x-n.x)*(n.y+e.y);return r}wc.types=["Unknown","Point","LineString","Polygon"],wc.prototype.loadGeometry=function(){var t=this.Mn;t.pos=this.xn;for(var n,e=t.readVarint()+t.pos,r=1,i=0,s=0,o=0,a=[];t.pos<e;){if(i<=0){var u=t.readVarint();r=7&u,i=u>>3}if(i--,1===r||2===r)s+=t.readSVarint(),o+=t.readSVarint(),1===r&&(n&&a.push(n),n=[]),n.push(new vc(s,o));else{if(7!==r)throw new Error("unknown command "+r);n&&n.push(n[0].clone())}}return n&&a.push(n),a},wc.prototype.bbox=function(){var t=this.Mn;t.pos=this.xn;for(var n=t.readVarint()+t.pos,e=1,r=0,i=0,s=0,o=1/0,a=-1/0,u=1/0,l=-1/0;t.pos<n;){if(r<=0){var h=t.readVarint();e=7&h,r=h>>3}if(r--,1===e||2===e)(i+=t.readSVarint())<o&&(o=i),i>a&&(a=i),(s+=t.readSVarint())<u&&(u=s),s>l&&(l=s);else if(7!==e)throw new Error("unknown command "+e)}return[o,u,a,l]},wc.prototype.toGeoJSON=function(t,n,e){var r,i,s=this.extent*Math.pow(2,e),o=this.extent*t,a=this.extent*n,u=this.loadGeometry(),l=wc.types[this.type];function h(t){for(var n=0;n<t.length;n++){var e=t[n],r=180-360*(e.y+a)/s;t[n]=[360*(e.x+o)/s-180,360/Math.PI*Math.atan(Math.exp(r*Math.PI/180))-90]}}switch(this.type){case 1:var c=[];for(r=0;r<u.length;r++)c[r]=u[r][0];h(u=c);break;case 2:for(r=0;r<u.length;r++)h(u[r]);break;case 3:for(u=function(t){var n=t.length;if(n<=1)return[t];for(var e,r,i=[],s=0;s<n;s++){var o=xc(t[s]);0!==o&&(void 0===r&&(r=o<0),r===o<0?(e&&i.push(e),e=[t[s]]):e.push(t[s]))}e&&i.push(e);return i}(u),r=0;r<u.length;r++)for(i=0;i<u[r].length;i++)h(u[r][i])}1===u.length?u=u[0]:l="Multi"+l;var f={type:"Feature",geometry:{type:l,coordinates:u},properties:this.properties};return"id"in this&&(f.id=this.id),f};var Fc=bc,Ac=kc;function kc(t,n){this.version=1,this.name=null,this.extent=4096,this.length=0,this.Mn=t,this.Fn=[],this.An=[],this.kn=[],t.readFields(Pc,this,n),this.length=this.kn.length}function Pc(t,n,e){15===t?n.version=e.readVarint():1===t?n.name=e.readString():5===t?n.extent=e.readVarint():2===t?n.kn.push(e.pos):3===t?n.Fn.push(e.readString()):4===t&&n.An.push(function(t){var n=null,e=t.readVarint()+t.pos;for(;t.pos<e;){var r=t.readVarint()>>3;n=1===r?t.readString():2===r?t.readFloat():3===r?t.readDouble():4===r?t.readVarint64():5===r?t.readVarint():6===r?t.readSVarint():7===r?t.readBoolean():null}return n}(e))}kc.prototype.feature=function(t){if(t<0||t>=this.kn.length)throw new Error("feature index out of bounds");this.Mn.pos=this.kn[t];var n=this.Mn.readVarint()+this.Mn.pos;return new Fc(this.Mn,n,this.extent,this.Fn,this.An)};var Sc=Ac;function _c(t,n,e){if(3===t){var r=new Sc(e,e.readVarint()+e.pos);r.length&&(n[r.name]=r)}}var Oc=function(t,n){this.layers=t.readFields(_c,{},n)};class Ec extends Tl{constructor(t,n,e,r,i,s){super(t,n,e,r,i),n=n||{},s()}getTileFeatures(t,n){const e=t.tileInfo.url,r=t.fetchOptions||{};if(this.Nt.has(e)){const{err:t,data:r}=this.Nt.get(e);return setTimeout(()=>{this.Pn(e,t,r,n)},1)}return r.referrer=t.referrer,O.getArrayBuffer(e,r,(t,r)=>{this.Nt&&(t?t.loading||this.Nt.add(e,{err:t,data:r&&r.data}):r&&r.data&&this.Nt.add(e,{err:null,data:r.data}),this.Pn(e,t,r&&r.data,n))})}Pn(t,n,e,r){if(n)return void r(n);let i;try{i=new Oc(new Qh(e))}catch(n){return void r(n.message,[],[])}const s=[];if(!i.layers)return void r(null,s,[]);const o={};let a;for(const t in i.layers)if(u=i.layers,l=t,Object.prototype.hasOwnProperty.call(u,l)){o[t]={types:{}};const e=o[t].types;for(let r=0,o=i.layers[t].length;r<o;r++)try{a=i.layers[t].feature(r),e[a.type]=1;const n={type:a.type,layer:t,geometry:a.loadGeometry(),properties:a.properties,extent:a.extent};void 0!==a.id&&(n.id=a.id);let o=n.properties[bl];o&&(M(o)&&(o=JSON.parse(o)),n.properties[bl]=Xh(o,"EPSG:3857")),s.push(n)}catch(n){console.warn("error when load vt geometry:",n)}}var u,l;for(const t in o)o[t].types=Object.keys(o[t].types).map(t=>+t);r(null,s,o,{byteLength:e.byteLength})}abortTile(t,n){const e=this.requests[t];delete this.requests[t],e&&e.abort&&e.abort(),this.Xt(t),n()}onRemove(){super.onRemove();for(const t in this.requests){const n=this.requests[t];n&&n.abort&&n.abort()}this.requests={}}}let Ic=0;const $c=new ol(128);class Cc{constructor(t){this.Sn={},this._n={},this.workerId=t}addLayer({actorId:t,mapId:n,layerId:e,params:r},i){if(this.On(n,e))return;const s=this.En(n,e),o=r.type,a=r.options,u=this.send.bind(this,t);this.Sn[s]="GeoJSONVectorTileLayer"===o?new Yh(e,a,u,$c,{},i):new Ec(e,a,u,$c,{},i)}removeLayer({mapId:t,layerId:n},e){const r=this.On(t,n),i=this.En(t,n);delete this.Sn[i],r&&r.onRemove(e)}loadTile({mapId:t,layerId:n,params:e},r){const i=this.On(t,n);i&&i.loadTile(e,r)}abortTile({mapId:t,layerId:n,params:e},r){const i=this.On(t,n);i&&i.abortTile&&i.abortTile(e.url,r)}removeTile({mapId:t,layerId:n,params:e},r){const i=this.On(t,n);i&&i.removeTile(e,r)}updateStyle({mapId:t,layerId:n,params:e},r){const i=this.On(t,n);i&&i.updateStyle(e,r)}updateOptions({mapId:t,layerId:n,params:e},r){const i=this.On(t,n);i&&i.updateOptions(e,r)}setData({mapId:t,layerId:n,params:e},r){const i=this.On(t,n);i&&i.setData(e.data,r)}receive(t){const n=t.callback,e=this._n[n];delete this._n[n],e&&t.error?e(new Error(t.error)):e&&e(null,t.data)}send(t,n,e,r,i){const s=i?`${t}-${Ic++}`:null;i&&(this._n[s]=i),postMessage({type:"<request>",workerId:this.workerId,actorId:t,command:n,params:e,callback:String(s)},r||[])}En(t,n){return`${t}-${n}`}On(t,n){const e=this.En(t,n);return this.Sn[e]}In(){$c.reset()}}t.initialize=function(){},t.onmessage=function(t,n){const e=t.data;if(this.dispatcher||(this.dispatcher=new Cc(t.workerId)),"<response>"===t.type)this.dispatcher.workerId===t.workerId&&this.dispatcher.receive(t);else{const r=e.command;this.dispatcher[r]({actorId:t.actorId,mapId:e.mapId,layerId:e.layerId,params:e.params},(t,e,i)=>{t&&404!==t.status&&204!==t.status&&console.error(r,t),n(t,e,i)})}},Object.defineProperty(t,"$n",{value:!0})}';
let d8 = 0;
function vP() {
  return d8++;
}
const p8 = typeof Object.assign == "function";
function Pe(i, ...t) {
  if (p8) return Object.assign(i, ...t), i;
  for (let e = 0; e < t.length; e++) {
    const r = t[e];
    for (const n in r) i[n] = r[n];
  }
  return i;
}
function _s(i) {
  return !Yn(i) && (typeof i == "string" || i.constructor !== null && i.constructor === String);
}
function _l(i) {
  return typeof i == "number" && !isNaN(i);
}
function lm(i) {
  return !Yn(i) && (typeof i == "function" || i.constructor !== null && i.constructor === Function);
}
function q0(i) {
  return !Array.isArray(i) && typeof i == "object" && !!i;
}
function Yn(i) {
  return i == null;
}
function ro(i) {
  for (let t = 1; t < arguments.length; t++) {
    const e = arguments[t];
    if (e) for (let r = 0, n = e.length; r < n; r++) i.push(e[r]);
  }
  return i.length;
}
function Zc(i) {
  return Ft(i) && i.property;
}
function kl(i, t) {
  return Object.prototype.hasOwnProperty.call(i, t);
}
function Rl(i, t) {
  let e;
  if (t.altitudeToPoint) {
    e = t.altitudeToPoint(100, i);
    const r = t.options.heightFactor;
    r && r !== 1 && (e /= r);
  } else e = t.distanceToPointAtRes(100, 0, i).x;
  return e / 100 / 100;
}
const g8 = ["GeoJSONVectorTileLayer"];
class m8 extends VA.Actor {
  constructor(t, e) {
    super(t);
    const r = e.getMap().id;
    this.t = e, this.i = r, this.s = "vt_" + vP();
    const n = e.getJSONType();
    this.o = g8.indexOf(n) >= 0, this.l = {}, this.h = new lP({
      iconErrorUrl: e.options.iconErrorUrl,
      maxSize: e.options.maxIconSize,
      urlModifier: (o) => {
        const a = e.getURLModifier();
        return a && a(o) || o;
      }
    });
    const s = !e.getRenderer().isEnableWorkAround("win-intel-gpu-crash");
    this.u = new aP((o) => {
      e.getMap().getRenderer().callInNextFrame(o);
    }, e.options.glyphSdfLimitPerFrame, s);
  }
  initialize(t) {
    t(null);
  }
  addLayer(t) {
    const e = this.t, r = e.getWorkerOptions() || {}, n = this.s, s = e.getJSONType(), o = {
      mapId: this.i,
      layerId: n,
      command: "addLayer",
      params: {
        type: s,
        options: r
      }
    };
    this.o ? (this.l[n] === void 0 && (this.l[n] = this.getDedicatedWorker()), this.send(o, null, t, this.l[n])) : this.broadcast(o, null, t);
  }
  abortTile(t, e) {
    const r = this.s, n = {
      mapId: this.i,
      layerId: r,
      command: "abortTile",
      params: {
        url: t
      }
    };
    this.o ? (this.l[r] === void 0 && (this.l[r] = this.getDedicatedWorker()), this.send(n, null, e, this.l[r])) : this.broadcast(n, null, e);
  }
  removeLayer(t) {
    const e = this.s, r = {
      mapId: this.i,
      layerId: e,
      command: "removeLayer"
    };
    this.o ? (this.l[e] !== void 0 && this.send(r, null, t, this.l[e]), delete this.l[e]) : this.broadcast(r, null, t);
  }
  updateStyle(t, e) {
    const r = this.s, n = {
      mapId: this.i,
      layerId: r,
      command: "updateStyle",
      params: t
    };
    this.o ? this.l[r] !== void 0 && this.send(n, null, e, this.l[r]) : this.broadcast(n, null, e);
  }
  updateOptions(t, e) {
    const r = this.s, n = {
      mapId: this.i,
      layerId: r,
      command: "updateOptions",
      params: t
    };
    this.o ? this.l[r] !== void 0 && this.send(n, null, e, this.l[r]) : this.broadcast(n, null, e);
  }
  loadTile(t, e) {
    const r = Pe({}, t);
    r.tileInfo = function(h) {
      const u = {};
      for (const c in h) h[c] !== void 0 && h[c] !== null && (h[c].toJSON ? u[c] = h[c].toJSON() : u[c] = h[c]);
      return u;
    }(t.tileInfo);
    const n = this.s, s = {
      mapId: this.i,
      layerId: n,
      command: "loadTile",
      params: r
    }, { x: o, y: a } = t.tileInfo, l = (o + a) % this.workers.length;
    this.send(s, null, e, this.l[n] === void 0 ? this.workers[l].id : this.l[n]);
  }
  remove() {
    super.remove(), this.l = {};
  }
  fetchIconGlyphs({ icons: t, glyphs: e }, r) {
    this.u.getGlyphs(e, (n, s) => {
      if (n) throw n;
      const o = s.buffers || [];
      this.h.getIcons(t, (a, l) => {
        if (a) throw a;
        l.buffers && l.buffers.length && o.push(...l.buffers), r(null, {
          icons: l.icons,
          glyphs: s.glyphs
        }, o);
      });
    });
  }
  setData(t, e) {
    const r = this.s, n = {
      mapId: this.i,
      layerId: r,
      command: "setData",
      params: {
        data: t
      }
    };
    this.send(n, null, e, this.l[r]);
  }
  m(t) {
    return t.id;
  }
}
const v8 = {}, yP = {
  collision: !0,
  fading: !1,
  fadingDuration: 224,
  fadeInDelay: 600,
  fadeOutDelay: 100,
  uniquePlacement: !1,
  depthFunc: "always"
};
class y8 {
  constructor(t, e, r) {
    this.v = t, this.A = e, this._ = r || [0, 1, 0];
  }
  draw(t, e, r, n, s) {
    if (this.S || this.M(), !this.P) {
      this.P = this.v.buffer(cb(n));
      const l = n / r;
      this.T = this.v.buffer(fb(n, l));
    }
    if (n !== this.k) {
      const l = n / r;
      this.P(cb(n)), this.T(fb(n, l));
    }
    this.k = n;
    let o = this.O;
    if (!o) {
      const l = this.A.getDevicePixelRatio() > 1 ? 2 : 1;
      o = this.O = document.createElement("canvas"), o.width = 512 * l, o.height = 64 * l;
      const h = o.getContext("2d");
      h.font = "36px monospace", h.scale(l, l), this.I = this.v.texture({
        width: o.width,
        height: o.height,
        data: o
      });
    }
    const a = o.getContext("2d");
    a.clearRect(0, 0, o.width, o.height), a.fillStyle = `rgba(${this._.map((l) => 255 * l).join()})`, a.fillText(t, 20, 36), this.I({
      width: o.width,
      height: o.height,
      data: o
    }), this.S({
      transform: e,
      data: this.P,
      texData: this.F,
      debugLine: 1,
      primitive: "lines",
      framebuffer: s || null,
      image: this.I,
      count: 8
    }), this.S({
      transform: e,
      data: this.T,
      texData: this.F,
      debugLine: 0,
      primitive: "triangle strip",
      framebuffer: s || null,
      image: this.I,
      count: 4
    });
  }
  delete() {
    this.I && (this.I.destroy(), delete this.I), this.F && (this.F.destroy(), delete this.F), this.P && (this.P.destroy(), this.T.destroy(), delete this.P, delete this.T), this.S && (this.S.destroy(), delete this.S);
  }
  M() {
    this.F = this.v.buffer(new Uint8Array([0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1])), this.S = this.v({
      vert: `
                attribute vec2 aPosition;
                attribute vec2 aTexCoord;
                uniform mat4 transform;

                varying vec2 vTexCoord;
                void main()
                {
                    gl_Position = transform * vec4(aPosition, 0.0, 1.0);
                    vTexCoord = aTexCoord;
                }
            `,
      frag: `
                precision mediump float;
                uniform sampler2D uImage;
                uniform vec3 uColor;
                uniform float uOpacity;
                uniform float uDebugLine;

                varying vec2 vTexCoord;

                void main()
                {
                    if (uDebugLine == 1.) {
                        gl_FragColor = vec4(uColor, 1.0) * uOpacity;
                    } else {
                        gl_FragColor = texture2D(uImage, vTexCoord) * uOpacity;
                    }
                    gl_FragColor *= gl_FragColor.a;
                }
            `,
      attributes: {
        aPosition: this.v.prop("data"),
        aTexCoord: this.v.prop("texData")
      },
      uniforms: {
        transform: this.v.prop("transform"),
        uColor: this._,
        uOpacity: 1,
        uDebugLine: this.v.prop("debugLine"),
        uImage: this.v.prop("image")
      },
      count: this.v.prop("count"),
      primitive: this.v.prop("primitive"),
      depth: {
        enable: !1,
        mask: !1
      },
      blend: {
        enable: !0,
        func: {
          src: "one",
          dst: "one minus src alpha"
        },
        equation: "add"
      },
      stencil: {
        enable: !1
      },
      viewport: {
        x: 0,
        y: 0,
        width: () => this.A.getRenderer().canvas.width,
        height: () => this.A.getRenderer().canvas.height
      },
      framebuffer: this.v.prop("framebuffer")
    });
  }
}
function cb(i) {
  return new Uint16Array([0, 0, 0, i, 0, i, i, i, i, i, i, 0, i, 0, 0, 0]);
}
function fb(i, t) {
  return new Uint16Array([0, i - 64 * t, 0, i, 512 * t, i - 64 * t, 512 * t, i]);
}
const db = new Uint8Array([0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1]), pb = [];
class _8 {
  constructor(t, e, r) {
    this.v = t, (this.C = new er({
      aPosition: db
    }, null, db.length / 2, {
      positionSize: 2
    })).generateBuffers(t), this.D = new ur(), this.N = [], this.L = 0, this.R = e, this.A = r, this.M(t);
  }
  start() {
    this.L = 0, this.D.clear();
  }
  add(t, e, r) {
    const n = this.H(r);
    n.setUniform("ref", t), ne(pb, e, e, 1);
    const s = n.localTransform;
    $o(s, pb), OR(s, r, s), n.setLocalTransform(s), this.D.addMesh(n);
  }
  render(t) {
    this.V.render(this.U, {
      projViewMatrix: this.A.projViewMatrix
    }, this.D, t);
  }
  H() {
    const t = this.L++;
    return this.N[t] || (this.N[t] = new tn(this.C)), this.N[t];
  }
  M(t) {
    const e = this.R, r = {
      viewport: {
        x: 0,
        y: 0,
        width: () => e.width,
        height: () => e.height
      },
      stencil: {
        enable: !0,
        mask: 255,
        func: {
          cmp: "always",
          ref: (n, s) => s.ref,
          mask: 255
        },
        op: {
          fail: "replace",
          zfail: "replace",
          zpass: "replace"
        }
      },
      depth: {
        enable: !0,
        func: "always",
        mask: !1
      },
      colorMask: [!1, !1, !1, !1]
    };
    this.U = new qe({
      vert: `
#define SHADER_NAME TILE_STENCIL_VERT
attribute vec2 aPosition;
uniform mat4 projViewModelMatrix;

void main()
{
    gl_Position = projViewModelMatrix * vec4(aPosition, 0.0, 1.0);
}
`,
      frag: `
#define SHADER_NAME TILE_STENCIL_FRAG
void main()
{
    gl_FragColor = vec4(1.0, 0.0, 0.0, 0.1);
}
`,
      uniforms: [{
        name: "projViewModelMatrix",
        type: "function",
        fn: function(n, s) {
          const o = [];
          return Jt(o, s.projViewMatrix, s.modelMatrix), o;
        }
      }],
      extraCommandProps: r
    }), this.V = new hn(t);
  }
  remove() {
    this.C.dispose();
    for (let t = 0; t < this.N.length; t++) this.N[t].dispose();
    this.N.length = 0, this.U.dispose();
  }
}
const xl = new Float32Array([-1e12])[0], x8 = "__fea_idx".trim();
function _P(i, t, e, r, n, s) {
  const o = {};
  if (function(a) {
    if (!a) return !1;
    for (const l in a) if (a[l] !== void 0 && a[l] !== null) return !0;
    return !1;
  }(i))
    for (let a = 0, l = (t || i).length; a < l; a++) {
      let h = t ? i[t[a]] : i[a];
      n.options.features === "id" && n.getFeature && (h = n.getFeature(h), h.layer = e), n instanceof Pn && (h = T8(h, s)), o[t ? t[a] : h[x8]] = {
        feature: h,
        symbol: r
      };
    }
  return o;
}
const qo = "__original_properties", ws = "__external_properties", b8 = {
  get: function(i, t) {
    return t in i ? i[t] : i[qo][t] || i[ws] && i[ws][t];
  },
  has: function(i, t) {
    return t in i || t in i[qo] || i[ws] && t in i[ws];
  }
}, w8 = {};
function T8(i, t) {
  const e = i.properties;
  if (e && e[qo]) return i;
  t && (i = Pe({}, i)), i.customProps = i.customProps || {};
  const r = i.customProps;
  return r.$layer = i.layer, r.$type = i.type, r[qo] = e || w8, i.properties = new Proxy(r, b8), i;
}
function In(i) {
  for (let t = 1; t < arguments.length; t++) {
    const e = arguments[t];
    for (const r in e) i[r] = e[r];
  }
  return i;
}
function _d(i, t, e) {
  return Math.min(e, Math.max(t, i));
}
function xP(i, t, e) {
  if (i === e || i === t) return i;
  const r = e - t;
  return ((i - t) % r + r) % r + t;
}
function gn(i) {
  return i == null;
}
function hm(i) {
  return JSON.parse(JSON.stringify(i));
}
function ue(i, t, e, r, n, s) {
  t in i || Object.defineProperty(i, t, {
    enumerable: !0,
    get: function() {
      const o = gn(e[r]) || Ft(e[r]) ? n : e[r];
      return s ? s(o) : o;
    }
  });
}
const Xc = [];
function Yo(i) {
  for (let t = 0; t < i.length; t++) Xc[t] = i[t], Xc[t] *= 255;
  return i.length === 3 && (Xc[3] = 255), Xc;
}
function fi(i, t = 4) {
  return A8.bind(this, i, t);
}
function A8(i, t, e) {
  if (Array.isArray(e)) return e.length === 3 && t === 4 && e.push(1), e;
  if (i && i[e]) return i[e];
  if (e.r !== void 0 && e.g !== void 0 && e.b !== void 0 && e.a !== void 0)
    return [e.r, e.g, e.b, e.a];
  const r = Zi(e).unitArray();
  return r.length === 3 && t === 4 && r.push(1), i && (i[e] = r), r;
}
function Nh(i, t, e, r) {
  if (i.fill) i.fill(t, e, r);
  else for (let n = e; n < r; n++) i[n] = t;
}
function zy(i) {
  return typeof i == "number" && !isNaN(i);
}
function Cu(i) {
  return i && (i.markerFile || i.markerType) && i.textName !== void 0;
}
function xd(i, t) {
  return Object.prototype.hasOwnProperty.call(i, t);
}
function Ff(i, t) {
  if (t) {
    let e = i[i.length - 1];
    const r = [e];
    for (let n = i.length - 2; n >= 0; n--) i[n] !== e && (r.push(i[n]), e = i[n]);
    return r;
  }
  {
    let e = i[i[0]];
    const r = [e];
    for (let n = 1; n < i.length; n++) i[n] !== e && (r.push(i[n]), e = i[n]);
    return r;
  }
}
const M8 = new lt(0, 0);
function ns(i, t, e, r, n) {
  const s = i.distanceToPointAtRes(t, t, r, e, M8);
  return n ? s.y : s.x;
}
const um = [], Y0 = [0, 0, 0, 0], qc = new Y(0, 0), gb = {
  color: Y0,
  depth: 1,
  stencil: 0
}, Po = (i) => i.isTerrainSkin(), cm = (i) => i.isTerrainVector();
class sp extends zs.TileLayerCanvasRenderer {
  supportRenderMode() {
    return !0;
  }
  constructor(t) {
    super(t), this.ready = !1, this.j = 0, this.B = {}, this.G = {}, this.W = {};
  }
  getTileLevelValue(t, e) {
    if (this.isBackTile(t.id)) {
      const r = t.z, n = 5;
      return r - e >= 0 ? e + n - r : n + (e - r);
    }
    return 0;
  }
  getWorkerConnection() {
    return this.X;
  }
  getStyleCounter() {
    return this.j;
  }
  setStyle(t) {
    if (this.Y && this.Y.update(), this.X) {
      this.j++, this.$();
      const e = this.layer.q();
      e.styleCounter = this.j, this.X.updateStyle(e, (r) => {
        if (r) throw new Error(r);
        t || (this.J = !0, this.Z(), this.setToRedraw()), this.layer.fire("refreshstyle");
      });
    } else this.Z();
  }
  $() {
    if (this.K) for (const e in this.K) {
      const r = this.K[e];
      r && this.deleteTile(r);
    }
    this.K = this.tilesInView;
    const t = this.tileCache;
    for (const e in this.K) {
      const r = this.K[e];
      r && r.info && t.getAndRemove(r.info.id);
    }
    t.reset(), this.tilesInView = {}, this.tilesLoading = {}, this.B = {}, this._parentTiles = [], this._childTiles = [];
  }
  updateOptions(t) {
    this.X && this.X.updateOptions(this.layer.getWorkerOptions(), (e) => {
      if (e) throw new Error(e);
      t && (t.features || t.pickingGeometry || t.altitudeProperty) && (this.clear(), this.tt(), this.Z()), this.setToRedraw();
    });
  }
  updateSceneConfig(t, e, r) {
    const n = t === 0 ? this.et() : this.nt();
    if (!n || !n[e]) return;
    this.J = !0;
    const s = this.layer.q(), o = this.layer.it(t, s);
    n[e].config = o[e].renderPlugin, n[e].updateSceneConfig({
      sceneConfig: r
    }), this.setToRedraw();
  }
  updateDataConfig(t, e, r, n) {
    const s = t === 0 ? this.et() : this.nt();
    s && s[e] && (this.J = !0, s[e].updateDataConfig(r, n) ? this.setStyle() : this.setToRedraw());
  }
  updateSymbol(t, e, r) {
    const n = t === 0 ? this.et() : this.nt();
    if (!n || !n[e]) return !1;
    const s = this.layer.q(), o = this.layer.it(t, s), a = n[e];
    a.style = o[e];
    const l = a.updateSymbol(r, o[e].symbol);
    return !l && function h(u) {
      if (Array.isArray(u)) {
        const c = u;
        for (let f = 0; f < c.length; f++) if (h(c[f])) return !0;
      }
      for (const c in u) if (Ft(u[c]) || Xh.isExpression(u[c])) return !0;
      return !1;
    }(r) && this.setStyle(!0), this.setToRedraw(), l;
  }
  needToRedraw() {
    const t = super.needToRedraw();
    if (!t) {
      const e = this.rt();
      for (let r = 0; r < e.length; r++) if (e[r] && e[r].needToRedraw()) return !0;
    }
    return t;
  }
  needRetireFrames() {
    if (this.J) return !0;
    const t = this.rt();
    for (let e = 0; e < t.length; e++) if (t[e] && t[e].needToRetireFrames()) return !0;
    return !1;
  }
  isAnimating() {
    const t = this.rt();
    for (let e = 0; e < t.length; e++) if (t[e] && t[e].isAnimating()) return !0;
    return !1;
  }
  needToRefreshTerrainTileOnZooming() {
    const t = this.rt();
    for (let e = 0; e < t.length; e++) if (t[e] && t[e].needToRefreshTerrainTileOnZooming()) return !0;
    return !1;
  }
  st() {
    return !!(this.canvas && this.canvas.gl && this.canvas.gl.wrap);
  }
  createContext() {
    const t = this.canvas.gl && this.canvas.gl.wrap;
    if (t) this.gl = this.canvas.gl.wrap(), this.regl = this.canvas.gl.regl;
    else {
      const { gl: e, regl: r, attributes: n } = this.ot(this.canvas);
      this.gl = e, this.regl = r, this.glOptions = n;
    }
    if (t && (this.canvas.pickingFBO = this.canvas.pickingFBO || this.regl.framebuffer(this.canvas.width, this.canvas.height)), this.pickingFBO = this.canvas.pickingFBO || this.regl.framebuffer(this.canvas.width, this.canvas.height), this.lt = new y8(this.regl, this.getMap()), this.ht(), this.Y = new $d(this.regl, this.layer), !this.consumeTile) {
      const e = this.getMap().VERSION;
      throw new Error(`Incompatible version of maptalks: ${e}, upgrade maptalks >= v1.0.0-rc.14`);
    }
  }
  ot(t) {
    const e = this.layer, r = e.options.glOptions || {
      alpha: !0,
      depth: !0,
      antialias: this.layer.options.antialias
    };
    r.preserveDrawingBuffer = !0, r.stencil = !0;
    const n = this.ut(t, r);
    return {
      gl: n,
      attributes: r,
      regl: zu({
        gl: n,
        attributes: r,
        extensions: ["ANGLE_instanced_arrays", "OES_element_index_uint", "OES_standard_derivatives"],
        optionalExtensions: e.options.glExtensions || ["OES_vertex_array_object", "OES_texture_half_float", "OES_texture_half_float_linear", "OES_texture_float", "OES_texture_float_linear", "WEBGL_draw_buffers", "EXT_shader_texture_lod", "EXT_frag_depth"]
      })
    };
  }
  ht() {
    this.X || (this.X = new m8("@maptalks/vt", this.layer)), this.X.addLayer((t, e) => {
      this.layer && (this.ready = !0, this.layer.onWorkerReady(t, e), this.layer.fire("workerready"), this.setToRedraw());
    });
  }
  clearCanvas() {
    super.clearCanvas(), this.regl && (this.glOptions.depth ? this.regl.clear({
      color: Y0,
      depth: 1,
      stencil: 0
    }) : this.regl.clear({
      color: Y0,
      stencil: 0
    }));
  }
  isDrawable() {
    return !0;
  }
  checkResources() {
    return um;
  }
  _drawTiles(t, e, r, n, s) {
    if (super._drawTiles(t, e, r, n, s), this.K) if (Object.keys(this.K).length) for (const o in this.K) {
      const a = this.K[o];
      this.tileCache.has(a.id) || this._drawTile(a.info, a.image, s);
    }
    else this.ct(), delete this.K;
  }
  ct() {
    const t = this.j, e = [], r = [];
    for (const n in this.G) +n !== t && (e.push(n), this.et(n).forEach((s) => {
      s.remove();
    }));
    for (const n in this.W) +n !== t && (r.push(n), this.nt(n).forEach((s) => {
      s.remove();
    }));
    for (let n = 0; n < e.length; n++) delete this.G[e[n]];
    for (let n = 0; n < r.length; n++) delete this.W[r[n]];
  }
  draw(t, e) {
    this.ft !== t && (this.J = !1, this.dt());
    const r = this.layer;
    if (this.prepareCanvas(), !this.ready || !r.ready) return void this.completeRender();
    let n = this.G[this.j];
    n || (this.Z(), this.dt(), n = this.et());
    const s = this.nt();
    r.isDefaultRender() || n.length || s.length ? (r.options.collision && r.clearCollisionIndex(), this.pt = t, this.yt = this.gt(this.getMap().getGLRes()), this.vt = e || {}, this.xt(t), super.draw(t), this.ft !== t && this.bt(t), this.At(t), this.completeRender(), this.ft = t) : this.completeRender();
  }
  dt() {
    this.rt().forEach((t, e) => {
      t && (t.renderIndex = e);
    });
  }
  bt() {
    const t = this.rt();
    this.wt = this.wt || [];
    let e = 0;
    for (let r = t.length - 1; r >= 0; r--) {
      const n = t[r];
      n.isVisible() && n.hasMesh() && (this.wt[r] = e, n.needPolygonOffset() && e++);
    }
    this.Y.isEnable() && e++, this._t = e;
  }
  getFrameTimestamp() {
    return this.pt;
  }
  drawOnInteracting(t, e, r) {
    this.draw(e, r);
  }
  drawOutline(t) {
    (this.St || this.Mt) && (this.Mt ? this.paintOutlineAll(t) : this.St.forEach((e) => {
      this[e[0]](t, ...e[1]);
    }));
  }
  getAnalysisMeshes() {
    return this.getShadowMeshes();
  }
  getShadowMeshes() {
    const t = [];
    return this.Pt().forEach((e) => {
      if (!e || !this.Tt(e)) return;
      const r = e.getShadowMeshes();
      if (Array.isArray(r)) for (let n = 0; n < r.length; n++) t.push(r[n]);
    }), t;
  }
  isForeground(t) {
    return !(!this.kt || !this.kt[t.properties.tile.id]);
  }
  Ot(t) {
    const e = this.layer;
    let r = e._getTileZoom(this.getMap().getZoom());
    const n = e.getMinZoom(), s = e.getMaxZoom();
    return r = Yr.clamp(r, n, s), r - t.properties.tile.z;
  }
  isTileNearCamera(t) {
    return this.Ot(t) <= 1;
  }
  isBackTile(t) {
    return !(!this.It || !this.It[t]);
  }
  loadTile(t) {
    const { url: e } = t, r = this.B[e];
    if (r) r.keys[t.id] || (r.tiles.push(t), r.keys[t.id] = 1);
    else {
      const n = this.getMap(), s = qc.set(t.extent2d.xmin, t.extent2d.ymax), o = n.pointAtResToCoord(new Y(s), t.res), a = [ns(n, 1, o, t.res) / 100, ns(n, 1, o, t.res, 1) / 100], l = this.getCentimeterToPoint(t.z), h = this.getTileGLScale(t.z);
      this.B[e] = {
        keys: {},
        tiles: [t]
      }, this.B[e].keys[t.id] = 1;
      const u = this.layer.options.fetchOptions, c = window && window.location.href;
      this.X.loadTile({
        tileInfo: {
          res: t.res,
          x: t.x,
          y: t.y,
          z: t.z,
          url: t.url,
          id: t.id,
          extent2d: t.extent2d
        },
        glScale: h,
        zScale: this.yt,
        centimeterToPoint: a,
        verticalCentimeterToPoint: l,
        fetchOptions: u,
        styleCounter: this.j,
        referrer: c
      }, this.Ft.bind(this, e));
    }
    return {};
  }
  getTileGLScale(t) {
    const e = this.getMap();
    return this.layer.getSpatialReference().getResolution(t) / e.getGLRes();
  }
  getCentimeterToPoint(t) {
    const e = this.getMap();
    return Rl(this.layer.getSpatialReference().getResolution(t), e);
  }
  getRenderedFeatures() {
    const t = [], e = this.tileCache.keys();
    for (let r = 0; r < e.length; r++) {
      const n = this.tileCache.get(e[r]);
      if (!n || !n.info || !n.image) continue;
      const { info: s, image: o } = n, a = E8(o);
      t.push({
        tile: {
          id: s.id,
          x: s.x,
          y: s.y,
          z: s.z,
          url: s.url
        },
        current: !!this.tilesInView[s.id],
        features: a
      });
    }
    return t;
  }
  Ft(t, e, r) {
    if (this.setToRedraw(), !this.B[t] || r && r.canceled) return;
    const n = this.layer, s = n.isDefaultRender(), { tiles: o } = this.B[t];
    if (delete this.B[t], e) {
      if (e.status && (e.status === 404 || e.status === 204)) for (let f = 0; f < o.length; f++) {
        const d = o[f];
        this.onTileError(v8, d);
      }
      return;
    }
    if (!r) {
      for (let f = 0; f < o.length; f++) {
        const d = o[f];
        this.consumeTile({
          Ct: !0
        }, d);
      }
      return;
    }
    if (r.style !== this.j) return;
    let a = !1;
    const l = r.features, h = [];
    for (let f = 0; f < r.data.length; f++) {
      const d = r.data[f];
      if (!d || !d.data || !d.styledFeatures.length) continue;
      const { isUpdated: p, layer: g } = this.Et(0, f, d, l, h);
      h.push(g), p && (a = p);
    }
    for (let f = 0; f < r.featureData.length; f++) {
      const d = r.featureData[f];
      d && d.data && d.styledFeatures.length && this.Et(1, f, d, l);
    }
    a && n.Dt();
    const u = o[0].z, c = this.layer.getDataSchema(u);
    if (this.Nt(c, r.schema), delete r.features, s && r.data.length !== h.length) {
      const f = r.data;
      r.data = [];
      for (let d = 0; d < f.length; d++) f[d] && f[d].features && r.data.push(f[d]);
    }
    r.layers = h;
    for (let f = 0; f < o.length; f++) {
      const d = o[f];
      if (f === 0 && n.options.debugTileData) {
        const { x: g, y: m, z: v } = d;
        console.log("tile", {
          layerId: n.getId(),
          x: g,
          y: m,
          z: v,
          layers: C8(Object.values(l))
        });
      }
      const p = f === 0 ? r : S8(r);
      for (let g = 0; g < p.data.length; g++) {
        if (!p.data[g]) continue;
        const m = p.data[g].features;
        for (const v in m)
          m[v].tile = d;
      }
      d.extent = p && p.extent, p.features = Object.values(l), this.onTileLoad(p, d);
    }
    this.layer.fire("datareceived", {
      url: t
    });
  }
  Et(t, e, r, n) {
    const { style: s, isUpdated: o } = this.Lt(t, e, r.data), a = this.layer, l = a.isDefaultRender(), h = s.symbol, u = _P(n, r.styledFeatures, e, h, a, !(!a.getData || !a.getData()));
    delete r.styledFeatures, r.features = u;
    let c = r.data;
    return Array.isArray(c) && (c = c[0]), {
      isUpdated: o,
      layer: l ? {
        layer: c.layer,
        type: c.type
      } : null
    };
  }
  Nt(t, e) {
    for (const r in e) {
      t[r] || (t[r] = {
        types: e[r].types,
        properties: {}
      });
      const n = e[r].properties, s = t[r].properties;
      for (const o in n) (!s[o] || s[o] && n[o] !== "object" && s[o] === "object") && (s[o] = n[o]);
    }
  }
  Lt(t, e, r) {
    Array.isArray(r) && (r = r[0]);
    const n = this.layer;
    let s, o = !1;
    if (n.isDefaultRender() && t === 0) {
      let a = this.Rt;
      a || (a = this.Rt = {});
      const l = r.layer, h = r.type;
      a[l] || (a[l] = []);
      const u = ("plugin_" + h).trim();
      a[l][u] ? s = a[l][u] : (s = this.Ht(h), s.filter = r.filter, a[l].push(s), a[l][u] = s, o = !0);
    } else {
      const a = n.q(), l = n.it(t, a), h = this.et();
      if (s = l[e], !s.renderPlugin) {
        o = !0;
        const { plugin: u, symbol: c, renderPlugin: f } = this.Ht(r.type);
        h[e] = u, s.symbol = c, s.renderPlugin = f;
      }
    }
    return {
      style: s,
      isUpdated: o
    };
  }
  rt(t) {
    const e = t && t.style;
    let r = this.et(e) || [];
    this.layer.isDefaultRender() && this.Rt && (r = [], t ? t.layers && t.layers.forEach((s) => {
      if (!s) return;
      const o = ("plugin_" + s.type).trim();
      r.push(this.Rt[s.layer][o].plugin);
    }) : Object.keys(this.Rt).forEach((s) => {
      for (let o = 0; o < this.Rt[s].length; o++) r.push(this.Rt[s][o].plugin);
    }));
    const n = this.nt(e);
    return n && n.length && (r = r.slice(), ro(r, n)), r;
  }
  Pt() {
    if (this.layer.isDefaultRender() && this.Rt) {
      const e = [];
      return Object.keys(this.Rt).forEach((r) => {
        for (let n = 0; n < this.Rt[r].length; n++) e.push(this.Rt[r][n].plugin);
      }), e;
    }
    const t = [];
    for (const e in this.G) t.push(...this.G[e]);
    for (const e in this.W) t.push(...this.W[e]);
    return t;
  }
  et(t) {
    return Yn(t) && (t = this.j), this.G[t] || um;
  }
  nt(t) {
    return Yn(t) && (t = this.j), this.W[t] || um;
  }
  xt(t, e) {
    const r = !!this.zt, n = this.layer.isDefaultRender() && this.Rt, s = this.vt;
    this.Pt().forEach((o, a) => {
      if (!o || e && !e(o) || !this.Tt(a)) return;
      const l = this.regl, h = this.gl, u = n ? o.defaultSymbol : o.style && o.style.symbol, c = {
        regl: l,
        layer: this.layer,
        symbol: u,
        gl: h,
        isRenderingTerrain: r,
        sceneConfig: o.config ? o.config.sceneConfig : null,
        dataConfig: o.config ? o.config.dataConfig : null,
        pluginIndex: a,
        timestamp: t
      };
      s && Pe(c, s), o.startFrame(c);
    });
  }
  At(t) {
    const e = this.vt, r = e.renderMode, n = e && e.renderTarget && e.renderTarget.fbo, s = this.getMap().cameraPosition, o = this.Pt(), a = !!this.zt, l = !e.timestamp || e.isFinalRender;
    this.layer.options.collision && !e.isPostProcess ? o.forEach((c) => {
      if (!this.Tt(c) || !c.hasMesh() || r && r !== "default" && !c.supportRenderMode(r) || a && !cm(c)) return;
      const f = this.Vt(c, 0, s, t);
      c.prepareRender(f), c.updateCollision(f);
    }) : o.forEach((c) => {
      if (!this.Tt(c) || !c.hasMesh() || r && r !== "default" && !c.supportRenderMode(r) || a && !cm(c)) return;
      const f = this.Vt(c, 0, s, t);
      c.prepareRender(f);
    });
    const h = this.ft !== e.timestamp;
    let u = !1;
    if (h && !a) {
      const c = this.layer.getPolygonOffset() + this.layer.getPolygonOffsetCount(), f = this.Vt(null, c, s, t);
      f.offsetFactor = c, f.offsetUnits = c, this.Y.paint(f);
    }
    o.forEach((c, f) => {
      if (!this.Ut(c) || r && r !== "default" && !c.supportRenderMode(r) || a && !cm(c)) return;
      this.regl.clear({
        stencil: 255,
        framebuffer: n
      }), this.isEnableTileStencil() && c.painter && !c.painter.needClearStencil() && this.jt(n);
      const d = this.wt[f] || 0, p = this.Vt(c, d, s, t), g = c.endFrame(p);
      g && g.redraw && this.setToRedraw(), u = !0;
    }), u && this.layer.fire("canvasisdirty"), l && this.Bt();
  }
  getPolygonOffsetCount() {
    return this._t || 0;
  }
  Bt() {
    if (this.layer.options.debug) {
      const t = this.vt, e = [], r = this.getMap().projViewMatrix;
      for (const n in this.tilesInView) {
        const s = this.tilesInView[n].info, o = s.transform, a = this.tilesInView[n].image.extent, l = t && t.renderTarget;
        if (o && a) {
          const h = this.getDebugInfo(s.id), u = Jt(e, r, o), c = this.layer.getTileSize().width;
          this.lt.draw(h, u, c, a, l && l.fbo);
        }
      }
    }
  }
  Ut(t) {
    if (!t) return !0;
    const e = this.vt, r = this.Tt(t), n = e && e.states && e.states.includesChanged, s = this.Gt(t.painter.scene.getMeshes());
    return !r || !n && !s ? 0 : s ? 2 : 1;
  }
  Vt(t, e, r, n) {
    const s = !!this.zt, o = s && t && Po(t), a = this.regl, l = this.gl, h = {
      regl: a,
      layer: this.layer,
      gl: l,
      isRenderingTerrain: s,
      isRenderingTerrainSkin: o,
      sceneConfig: t && t.config.sceneConfig,
      pluginIndex: t && t.renderIndex,
      polygonOffsetIndex: e,
      cameraPosition: r,
      timestamp: n
    }, u = this.vt;
    return u && Pe(h, u), h;
  }
  Gt(t) {
    if (!t) return !1;
    const e = this.vt && this.vt.sceneFilter;
    return e ? t.filter((r) => e(r) || r.properties.hlBloomMesh && e(r.properties.hlBloomMesh)).length > 0 : t.length > 0;
  }
  jt(t) {
    const e = this.isEnableTileStencil(), r = this.getCurrentTileZoom();
    let n = this.Wt;
    n || (n = this.Wt = new _8(this.regl, this.canvas, this.getMap())), n.start();
    const { tiles: s } = this.Xt;
    let { parentTiles: o, childTiles: a } = this.Xt, l = 1;
    a = a.sort(fm);
    for (let u = 0; u < a.length; u++) this.Yt(a[u].info, e ? l : this.getTileLevelValue(a[u].info.z, r)), l++;
    o = o.sort(fm);
    for (let u = 0; u < o.length; u++) this.Yt(o[u].info, e ? l : this.getTileLevelValue(o[u].info.z, r)), l++;
    const h = s.sort(fm);
    for (let u = h.length - 1; u >= 0; u--) this.Yt(h[u].info, e ? l : this.getTileLevelValue(h[u].info.z, r)), l++;
    n.render(t);
  }
  Yt(t, e) {
    const r = qc.set(t.extent2d.xmin, t.extent2d.ymax), n = t.transform = t.transform || this.calculateTileMatrix(r, t.z, t.extent);
    t.stencilRef = e, this.Wt.add(e, t.extent, n);
  }
  onDrawTileStart(t) {
    super.onDrawTileStart(t);
    const { tiles: e, childTiles: r, parentTiles: n } = t;
    this.kt = {}, this.It = {};
    for (let s = 0; s < e.length; s++) this.kt[e[s].info.id] = 1;
    for (let s = 0; s < r.length; s++) this.It[r[s].info.id] = 1;
    for (let s = 0; s < n.length; s++) this.It[n[s].info.id] = 1;
    this.Xt = t;
  }
  isEnableTileStencil() {
    if (this.layer.options.altitude) return !1;
    const t = this.rt();
    for (let e = 0; e < t.length; e++) if (t[e] && t[e].painter && !t[e].painter.isOnly2D()) return !1;
    return !0;
  }
  setTerrainHelper(t) {
    this.zt = t;
  }
  getTerrainHelper() {
    return this.zt;
  }
  drawTileOnTerrain(...t) {
    sp.prototype.drawTile.call(this, ...t);
  }
  createTerrainTexture(t) {
    const e = this.layer.getTileSize().width, r = 2 * e, n = 2 * e, s = t.texture({
      min: "linear",
      mag: "linear",
      type: "uint8",
      width: r,
      height: n
    });
    this.$t || (this.$t = t.renderbuffer({
      width: r,
      height: n,
      format: "depth24 stencil8"
    }));
    const o = {
      width: r,
      height: n,
      colors: [s],
      colorFormat: "rgba",
      ignoreStatusCheck: !0
    };
    o.depthStencil = this.$t;
    const a = t.framebuffer(o);
    return a.colorTex = s, a;
  }
  deleteTerrainTexture(t) {
    t.destroy(), t.colorTex && (t.colorTex.destroy(), delete t.colorTex);
  }
  renderTerrainSkin(t, e, r) {
    const n = this.ft, s = this.vt, o = this.layer.getTileSize().width;
    this.xt(n);
    for (let a = 0; a < r.length; a++) {
      const l = r[a].texture;
      this.vt = {
        renderTarget: {
          fbo: l
        }
      }, gb.framebuffer = l, t.clear(gb), this.vt.viewport = P8(o), this.qt(r[a].tile, l);
    }
    this.Jt(r), this.vt = s;
  }
  qt(t) {
    const { info: e, image: r } = t;
    this.drawTile(e, r, Po);
  }
  Jt(t) {
    const e = this.Pt(), r = this.getMap().cameraPosition, n = this.ft || 0;
    this.layer.options.collision ? e.forEach((s) => {
      if (!this.Tt(s) || !s.hasMesh() || !Po(s) || !this.layer.options.awareOfTerrain) return;
      const o = this.Vt(s, 0, r, n);
      o.isRenderingTerrainSkin = !0, s.prepareRender(o), s.updateCollision(o);
    }) : e.forEach((s) => {
      if (!this.Tt(s) || !s.hasMesh() || !Po(s) || !this.layer.options.awareOfTerrain) return;
      const o = this.Vt(s, 0, r, n);
      o.isRenderingTerrainSkin = !0, s.prepareRender(o);
    }), e.forEach((s, o) => {
      if (!this.Ut(s) || !Po(s)) return;
      for (let h = 0; h < t.length; h++) {
        const u = t[h].texture;
        this.regl.clear({
          stencil: 255,
          framebuffer: u
        });
      }
      const a = this.wt[o] || 0, l = this.Vt(s, a, [0, 0, 0], this.ft);
      l.isRenderingTerrainSkin = !0, s.endFrame(l);
    });
  }
  drawTile(t, e, r) {
    if (!e.cache) return;
    const n = !!this.zt, s = e.cache, o = qc.set(t.extent2d.xmin, t.extent2d.ymax), a = t.transform = t.transform || this.calculateTileMatrix(o, t.z, t.extent), l = t.tileTranslationMatrix = t.tileTranslationMatrix || this.calculateTileTranslationMatrix(o, t.z), h = t.terrainTransform = t.terrainTransform || this.calculateTerrainTileMatrix(o, t.z, t.extent), u = this.vt, c = [];
    ro(c, e.data), ro(c, e.featureData), this.rt(e).forEach((f, d) => {
      if (!f || r && !r(f) || !c[d] || !s[d]) return;
      const p = n && Po(f), g = this.regl, m = this.gl, v = {
        regl: g,
        layer: this.layer,
        gl: m,
        sceneConfig: f.config.sceneConfig,
        pluginIndex: d,
        tileCache: s[d],
        tileData: c[d],
        tileTransform: p ? h : a,
        tileVectorTransform: a,
        tileTranslationMatrix: l,
        tileExtent: e.extent,
        timestamp: this.pt,
        tileInfo: t,
        tileZoom: this._tileZoom,
        bloom: this.vt && this.vt.bloom,
        isRenderingTerrain: n,
        isRenderingTerrainSkin: p
      };
      p && u && u.renderTarget && (v.renderTarget = u.renderTarget);
      const _ = f.paintTile(v);
      !this.J && (_.retire || _.redraw) && f.supportRenderMode("taa") && (this.J = !0), _.redraw && this.setToRedraw();
    }), e && e.style === this.j && this.Zt(t), this.setCanvasUpdated();
  }
  Kt(t, e) {
    if (!e.loadTime || e.Ct) return;
    let r = e.cache;
    r || (r = e.cache = {});
    const n = !!this.zt, s = qc.set(t.extent2d.xmin, t.extent2d.ymax), o = t.transform = t.transform || this.calculateTileMatrix(s, t.z, e.extent), a = t.tileTranslationMatrix = t.tileTranslationMatrix || this.calculateTileTranslationMatrix(s, t.z), l = t.terrainTransform = t.terrainTransform || this.calculateTerrainTileMatrix(s, t.z, t.extent), h = [];
    ro(h, e.data), ro(h, e.featureData), this.rt(e).forEach((u, c) => {
      if (!u || !h[c]) return;
      const f = n && Po(u), d = this.regl, p = this.gl;
      r[c] || (r[c] = {});
      const g = {
        regl: d,
        layer: this.layer,
        gl: p,
        sceneConfig: u.config.sceneConfig,
        pluginIndex: c,
        tileCache: r[c],
        tileData: h[c],
        tileTransform: f ? l : o,
        tileVectorTransform: o,
        isRenderingTerrain: n,
        isRenderingTerrainSkin: f,
        tileTranslationMatrix: a,
        tileExtent: e.extent,
        timestamp: this.pt,
        tileInfo: t,
        tileZoom: this._tileZoom
      }, m = u.createTile(g);
      r[c].geometry && (e.data[c] = 1), !this.J && m.retire && u.supportRenderMode("taa") && (this.J = !0);
    });
  }
  checkTileInQueue(t) {
    return t.style === this.j;
  }
  pick(t, e, r) {
    const n = [];
    return this.layer.isVisible() && this.rt().forEach((s) => {
      if (!s || !this.Tt(s)) return;
      const o = s.pick(t, e, r.tolerance);
      o && (o.type = s.getType(), n.push(o));
    }), n;
  }
  deleteTile(t) {
    if (t) {
      if (t.image && !t.image.Ct) {
        const e = t.image && t.image.style, r = this.et(e);
        r && r.forEach((n, s) => {
          n && n.deleteTile({
            pluginIndex: s,
            regl: this.regl,
            layer: this.layer,
            gl: this.gl,
            tileCache: t.image.cache ? t.image.cache[s] : {},
            tileInfo: t.info,
            tileData: t.image
          });
        }), t.image.cache = {};
      }
      t.info && (delete t.info.completeTerrainQuery, delete t.info.terrainQueryStatus), super.deleteTile(t);
    }
  }
  abortTileLoading(t, e) {
    e && e.url && (this.X && this.X.abortTile(e.url), delete this.B[e.url]), super.abortTileLoading(t, e);
  }
  resizeCanvas(t) {
    super.resizeCanvas(t);
    const e = this.canvas;
    e && (!this.pickingFBO || this.pickingFBO.width === e.width && this.pickingFBO.height === e.height || (this.pickingFBO.resize(e.width, e.height), this.rt().forEach((r) => {
      r && r.resize(e.width, e.height);
    })));
  }
  onRemove() {
    this.Wt && this.Wt.remove(), this.X && (this.X.removeLayer((t) => {
      if (t) throw t;
    }), this.X.remove(), delete this.X), this.pickingFBO && (this.canvas.pickingFBO || this.pickingFBO.destroy(), delete this.pickingFBO), this.lt && (this.lt.delete(), delete this.lt), this.$t && (this.$t.destroy(), delete this.$t), this.Y && (this.Y.dispose(), delete this.Y), super.onRemove && super.onRemove(), this.tt();
  }
  tt() {
    this.Pt().forEach((t) => {
      t.remove();
    }), this.plugins = {};
  }
  hitDetect(t) {
    if (!this.gl || !this.layer.options.hitDetect) return !1;
    const e = this.gl, r = new Uint8Array(4), n = this.canvas.height;
    return e.readPixels(t.x, n - t.y, 1, 1, e.RGBA, e.UNSIGNED_BYTE, r), r[3] > 0;
  }
  Z() {
    const { style: t, featureStyle: e } = this.layer.q(), r = t.map((o, a) => {
      const l = o.renderPlugin;
      if (!l) return null;
      if (!l.type) throw new Error("invalid plugin type for style at " + a);
      const h = this.Qt(l);
      return h.styleCounter = this.j, h.style = o, h;
    }), n = [];
    e.forEach((o, a) => {
      const l = o.renderPlugin;
      if (!l) return null;
      if (!l.type) throw new Error("invalid plugin type for features at " + a);
      const h = this.Qt(l);
      return h.style = o, h.styleCounter = this.j, n.push(h), h;
    });
    const s = this.j;
    return this.G[s] = r, this.W[s] = n, this.layer.fire("pluginsinited"), (this.te && this.te.size || this.layer.te) && (this.layer.te && this.layer.ee(), this.getMap().getRenderer().callInNextFrame(() => {
      this.rt().forEach((o) => {
        o.highlight(this.te);
      });
    })), r;
  }
  Qt(t) {
    const e = this.layer.constructor.getPlugins()[t.type];
    if (!e) throw new Error(`Plugin for (${t.type}) is not loaded.`);
    const r = new e();
    return r.config = t, r.config.sceneConfig || (r.config.sceneConfig = {}), r;
  }
  ut(t, e) {
    const r = ["webgl", "experimental-webgl"];
    let n = null;
    for (let s = 0; s < r.length; ++s) {
      try {
        n = t.getContext(r[s], e);
      } catch {
      }
      if (n) break;
    }
    return n;
  }
  gt(t) {
    return Rl(t, this.getMap());
  }
  debugFBO(t, e) {
    const r = document.getElementById(t), n = e.width, s = e.height;
    r.width = n, r.height = s;
    const o = r.getContext("2d"), a = this.regl.read({
      framebuffer: e
    }), l = s / 2 | 0, h = 4 * n;
    for (let f = 0; f < a.length; f++) a[f] *= 255;
    const u = new Uint8Array(4 * n);
    for (let f = 0; f < l; ++f) {
      const d = f * h, p = (s - f - 1) * h;
      u.set(a.subarray(d, d + h)), a.copyWithin(d, p, p + h), a.set(u, p);
    }
    const c = new ImageData(n, s);
    c.data.set(a), o.putImageData(c, 0, 0);
  }
  Ht(t) {
    let e;
    switch (t) {
      case "native-line":
        e = {
          type: "native-line",
          dataConfig: {
            type: "native-line",
            only2D: !0
          }
        };
        break;
      case "native-point":
        e = {
          type: "native-point",
          dataConfig: {
            type: "native-point",
            only2D: !0
          }
        };
        break;
      case "fill":
        e = {
          type: "fill",
          dataConfig: {
            type: "fill",
            only2D: !0
          },
          sceneConfig: {
            antialias: !0
          }
        };
        break;
      default:
        e = null;
    }
    const r = function(s) {
      switch (s) {
        case "native-point":
          return {
            markerFill: "#f00",
            markerSize: 6,
            markerOpacity: 0.5
          };
        case "native-line":
          return {
            lineColor: "#bbb",
            lineOpacity: 0.5
          };
        case "fill":
          return {
            polygonFill: "#76a6f0",
            polygonOpacity: 0.8
          };
      }
      return null;
    }(t), n = this.Qt(e);
    return n.defaultSymbol = r, {
      plugin: n,
      symbol: r,
      renderPlugin: e
    };
  }
  Tt() {
    return !0;
  }
  isEnableWorkAround(t) {
    return t === "win-intel-gpu-crash" && this.layer.options.workarounds["win-intel-gpu-crash"] && function(e) {
      const r = e.getExtension("WEBGL_debug_renderer_info");
      if (r && typeof navigator < "u") {
        const n = e.getParameter(r.UNMASKED_RENDERER_WEBGL), s = navigator.platform === "Win32" || navigator.platform === "Win64";
        if (n && n.toLowerCase().indexOf("intel") >= 0 && s) return !0;
      }
      return !1;
    }(this.gl);
  }
  getZScale() {
    return this.yt;
  }
  outline(t, e) {
    e && (Array.isArray(e) || (e = [e]), this.St || (this.St = []), this.St.push(["paintOutline", [t, e]]), this.setToRedraw());
  }
  outlineFeatures(t) {
    t && (Array.isArray(t) || (t = [t]), this.St || (this.St = []), this.St.push(["paintOutline", [null, t]]), this.setToRedraw());
  }
  outlineBatch(t) {
    this.St || (this.St = []), this.St.push(["paintBatchOutline", [t]]), this.setToRedraw();
  }
  outlineAll() {
    this.Mt = !0, this.setToRedraw();
  }
  paintOutlineAll(t) {
    const e = this.rt();
    for (let r = 0; r < e.length; r++) e[r].outlineAll(t);
  }
  paintOutline(t, e, r) {
    if (!Yn(e)) {
      const s = e, o = this.rt();
      return !o[s] || o[s].painter && !o[s].painter.isVisible() ? void 0 : void o[s].outline(t, r);
    }
    const n = this.rt();
    for (let s = 0; s < r.length; s++) {
      const o = r[s];
      for (let a = 0; a < n.length; a++) n[a].style && n[a].style.id === o && n[a].outline(t, [o]);
    }
  }
  paintBatchOutline(t, e) {
    const r = this.rt();
    !r[e] || r[e].painter && !r[e].painter.isVisible() || r[e].outlineAll(t);
  }
  cancelOutline() {
    delete this.St, delete this.Mt, this.setToRedraw();
  }
  setZIndex() {
    return this.setToRedraw(), this.J = !0, super.setZIndex.apply(this, arguments);
  }
  consumeTile(t, e) {
    if (this.Zt(e), super.consumeTile(t, e), this.layer.options.features === "transient" && t.data) {
      for (let r = 0; r < t.data.length; r++) {
        if (!t.data[r]) continue;
        const n = t.data[r].features;
        if (n) for (const s in n) {
          const o = n[s] && n[s].feature;
          o && (o.fnTypeProps ? o.customProps[qo] = o.fnTypeProps : n[s] = null);
        }
      }
      this.layer.fire("_transientfeature", {
        tileImage: t
      });
    }
    t && t.features && (t.features = []), this.Kt(e, t);
  }
  onTileError(t, e) {
    this.Zt(e), super.onTileError(t, e);
  }
  Zt(t) {
    const { id: e } = t;
    if (this.K && this.K[e]) {
      const r = this.K[e];
      this.deleteTile(r), delete this.K[e];
    }
  }
  highlight(t) {
    if (this.te || (this.te = /* @__PURE__ */ new Map()), Array.isArray(t)) for (let e = 0; e < t.length; e++) Yn(t[e].name) && !Yn(t[e].id) && (t[e] = Pe({}, t[e]), t[e].name = t[e].id), this.te.set(t[e].name, t[e]);
    else Yn(t.name) && !Yn(t.id) && ((t = Pe({}, t)).name = t.id), this.te.set(t.name, t);
    this.rt().forEach((e) => {
      e.highlight(this.te);
    });
  }
  cancelHighlight(t) {
    if (this.te) {
      if (Array.isArray(t)) for (let e = 0; e < t.length; e++) this.te.delete(t[e]);
      else this.te.delete(t);
      this.rt().forEach((e) => {
        e.highlight(this.te);
      });
    }
  }
  cancelAllHighlight() {
    delete this.te, this.rt().forEach((t) => {
      t.cancelAllHighlight();
    });
  }
  ne() {
    const t = this.layer.options.opacity;
    return this.st() ? Yn(t) ? 1 : t : 1;
  }
}
function S8(i) {
  let t;
  Array.isArray(i.data) ? (t = [], ro(t, i.data)) : (t = {}, Pe(t, i.data));
  const e = Pe({}, i);
  return e.data = t, e;
}
function fm(i, t) {
  return t.info.z - i.info.z;
}
function C8(i) {
  const t = {};
  for (let e = 0; e < i.length; e++) {
    const r = i[e].layer || "default";
    t[r] || (t[r] = []), t[r].push(i[e]);
  }
  return t;
}
function P8(i) {
  return {
    x: 0,
    y: 0,
    width: 2 * i,
    height: 2 * i
  };
}
function E8(i) {
  if (!i.cache) return [];
  for (const t in i.cache) {
    const e = i.cache[t];
    if (e.geometry) for (let r = 0; r < e.geometry.length; r++) {
      const n = e.geometry[r] && e.geometry[r].geometry;
      if (n && n.properties && n.properties.features) {
        const s = n.properties.features.empty;
        delete n.properties.features.empty;
        const o = Object.values(n.properties.features);
        return s !== void 0 && (n.properties.features.empty = s), o;
      }
    }
  }
  return [];
}
function mb(i, t, e) {
  for (let r = 0; r < i.length; r++) {
    const n = i[r], s = Pe({}, n), { renderPlugin: o } = n, a = Pe({}, o);
    a.sceneConfig && !Object.keys(a.sceneConfig).length && delete a.sceneConfig;
    let l = -1;
    for (let h = e.length - 1; h >= 0; h--) if (fu(a, e[h])) {
      l = h;
      break;
    }
    l < 0 && (l = e.length, e.push(a)), s.renderPlugin = l, t.push(s);
  }
}
sp.include({
  calculateTileMatrix: function() {
    const i = new Array(3), t = new Array(3), e = new Array(3);
    return function(r, n, s) {
      const o = this.getTileGLScale(n), a = r, l = this.layer.getTileSize().width, h = pn([]);
      return os(h, h, ne(i, o, o, this.yt)), ss(h, h, ne(t, a.x, a.y, 0)), os(h, h, ne(e, l / s, -l / s, 1)), h;
    };
  }(),
  calculateTerrainTileMatrix: function() {
    const i = new Array(3);
    return function(t, e, r) {
      const n = pn([]), s = r / 2;
      return os(n, n, ne(i, 1 / s, -1 / s, 0)), ss(n, n, ne(i, -s, -s, 0)), n;
    };
  }(),
  calculateTileTranslationMatrix: function() {
    const i = new Array(3);
    return function(t, e) {
      const r = this.getTileGLScale(e), n = t, s = pn([]);
      return ss(s, s, ne(i, n.x * r, n.y * r, 0)), s;
    };
  }()
});
const O8 = typeof fetch == "function" && typeof AbortController == "function", io = {
  jsonp: function(i, t) {
    const e = "_maptalks_jsonp_" + vP();
    i.match(/\?/) ? i += "&callback=" + e : i += "?callback=" + e;
    let r = document.createElement("script");
    return r.type = "text/javascript", r.src = i, window[e] = function(n) {
      t(null, n), document.getElementsByTagName("head")[0].removeChild(r), r = null, delete window[e];
    }, document.getElementsByTagName("head")[0].appendChild(r), this;
  },
  get: function(i, t, e) {
    if (lm(t)) {
      const n = e;
      e = t, t = n;
    }
    (t = t || {}).method && (t.method = t.method.toUpperCase());
    const r = t.method === "POST";
    if (O8) {
      const n = new AbortController(), s = t;
      s.signal = n.signal, s.referrerPolicy = s.referrerPolicy || "origin", s.method = s.method || "GET";
      const o = new Request(i, s);
      return t.returnJSON && o.headers.set("Accept", "application/json"), fetch(o).then((a) => {
        const l = this.ie(a, t.returnJSON, t.responseType);
        l.message ? (l.url = i, e(l)) : l.then((h) => {
          t.responseType === "arraybuffer" ? e(null, {
            data: h,
            cacheControl: a.headers.get("Cache-Control"),
            expires: a.headers.get("Expires"),
            contentType: a.headers.get("Content-Type")
          }) : e(null, h);
        }).catch((h) => {
          h.code && h.code === DOMException.ABORT_ERR || (console.error("Fetch error:", i, h), e(h));
        });
      }).catch((a) => {
        a.code && a.code === DOMException.ABORT_ERR || (console.error("Fetch error:", i, a), e(a));
      }), n;
    }
    {
      const n = io.re(e);
      if (n.open(t.method || "GET", i, !0), t) {
        for (const s in t.headers) n.setRequestHeader(s, t.headers[s]);
        n.withCredentials = t.credentials === "include", t.responseType && (n.responseType = t.responseType);
      }
      return n.send(r ? t.body : null), n;
    }
  },
  ie: (i, t, e) => i.status !== 200 ? {
    status: i.status,
    statusText: i.statusText,
    message: `incorrect http request with status code(${i.status}): ${i.statusText}`
  } : e === "arraybuffer" ? i.arrayBuffer() : t ? i.json() : i.text(),
  se: function(i, t) {
    return function() {
      i.readyState === 4 && (i.status === 200 ? i.responseType === "arraybuffer" ? i.response.byteLength === 0 ? t({
        status: 200,
        statusText: i.statusText,
        message: "http status 200 returned without content."
      }) : t(null, {
        data: i.response,
        cacheControl: i.getResponseHeader("Cache-Control"),
        expires: i.getResponseHeader("Expires"),
        contentType: i.getResponseHeader("Content-Type")
      }) : t(null, i.responseText) : t({
        status: i.status,
        statusText: i.statusText,
        message: `incorrect http request with status code(${i.status}): ${i.statusText}`
      }));
    };
  },
  re: function(i) {
    let t;
    try {
      t = new XMLHttpRequest();
    } catch {
      try {
        t = new ActiveXObject("Msxml2.XMLHTTP");
      } catch {
        try {
          t = new ActiveXObject("Microsoft.XMLHTTP");
        } catch {
        }
      }
    }
    return t.onreadystatechange = io.se(t, i), t;
  },
  getArrayBuffer(i, t, e) {
    if (lm(t)) {
      const r = e;
      e = t, t = r;
    }
    return t || (t = {}), t.responseType = "arraybuffer", io.get(i, t, e);
  },
  getJSON: function(i, t, e) {
    if (lm(t)) {
      const n = e;
      e = t, t = n;
    }
    const r = function(n, s) {
      const o = typeof s == "string" ? JSON.parse(s) : s || null;
      e(n, o);
    };
    return t && t.jsonp ? io.jsonp(i, r) : ((t = t || {}).returnJSON = !0, io.get(i, t, r));
  }
}, Yc = new Y(0, 0), vb = new lt(0, 0), ka = [null, 0], k8 = [];
class on extends Pn {
  static loadFrom(t, e) {
    return fetch(t, e || {}).then((r) => r.json()).then((r) => on.fromJSON(r));
  }
  constructor(t, e) {
    super(t, e), this.VERSION = on.VERSION;
    const r = e && e.style;
    this.setStyle(r);
  }
  setURLModifier(t) {
    this.oe = t;
    const e = this.getRenderer();
    return e && e.updateOptions(), this;
  }
  getURLModifier() {
    return this.oe;
  }
  onAdd() {
    const t = this.getMap();
    this.ae();
    const e = this.getSpatialReference().toJSON().projection, r = t.getSpatialReference().toJSON().projection;
    if ((e && e.toLowerCase()) !== (r && r.toLowerCase())) throw new Error(`VectorTileLayer's projection(${e}) must be the same with map(${r}).`);
  }
  setFeatureState(t, e) {
    if (Yn(t.id)) throw new Error("missing id in first parameter of setFeatureState.");
    this.le || (this.le = {});
    const r = t.layer || "0";
    let n = this.le[r];
    return this.le[r] || (n = this.le[r] = /* @__PURE__ */ new Map()), n.set(t.id, e), this.he(), this;
  }
  removeFeatureState(t, e) {
    if (Yn(t.id)) throw new Error("missing id in first parameter of removeFeatureState.");
    if (!this.le) return this;
    const r = t.layer || "0", n = this.le[r];
    if (!n) return this;
    if (e) {
      const s = n.get(t.id);
      if (q0(e)) for (const o in e) delete s[o];
      else delete s[e];
      n.set(t.id, s);
    } else n.delete(t.id);
    return this.he(), this;
  }
  getFeatureState(t) {
    if (Yn(t.id)) throw new Error("missing id in first parameter of getFeatureState.");
    if (!this.le) return null;
    const e = t.layer || "0";
    return this.le[e].get(t.id);
  }
  he() {
    const t = this.getRenderer();
    if (!t) return;
    const e = t.getFrameTimestamp();
    this.ue = e;
  }
  ce() {
    return this.ue;
  }
  fe(t) {
    return this.ue && this.ue !== t;
  }
  ae() {
    const t = this.getMap().getProjection(), e = t.code === "EPSG:4326" || t.code === "EPSG:4490", r = t.code === "EPSG:3857";
    this.options.spatialReference || this.getTileSize().width === 512 && (r ? this.options.spatialReference = "preset-vt-3857" : e && (this.options.spatialReference = "preset-vt-4326")), this.options.tileSystem || (this.options.tms ? r ? this.options.tileSystem = [1, 1, -6378137 * Math.PI, -6378137 * Math.PI] : e && (this.options.tileSystem = [1, 1, -180, -90]) : e && (this.options.tileSystem = [1, -1, -180, 90]));
  }
  onWorkerReady() {
  }
  onConfig(t) {
    const e = this.getRenderer();
    e && e.updateOptions(t);
  }
  getWorkerOptions() {
    return {
      debug: this.options.debug,
      debugTile: this.options.debugTile,
      altitudeProperty: this.options.altitudeProperty,
      tileSize: this.getTileSize().width,
      style: this.isDefaultRender() ? {
        style: [],
        featureStyle: []
      } : this.q(),
      features: this.options.debugTileData || this.options.features,
      schema: this.options.schema,
      pickingGeometry: this.options.pickingGeometry,
      projectionCode: this.getSpatialReference().getProjection().code,
      workerGlyph: this.options.workerGlyph && !this.getURLModifier(),
      featureIdProperty: this.options.featureIdProperty
    };
  }
  setStyle(t) {
    if (t && (_s(t) || t.url)) {
      const e = t, r = e.lastIndexOf("/"), n = r < 0 ? "." : e.substring(0, r);
      return this.ready = !1, io.getJSON(t.url ? t.url : t, t.url ? t : {}, (s, o) => {
        if (s) throw this.setStyle([]), s;
        let a;
        o.style ? (a = o, a.$root || (a.$root = n)) : a = {
          $root: n,
          style: o
        }, this.options.style = e, this.de(a);
      }), this;
    }
    return this.options.style = t, this.de(t), this;
  }
  pe(t, e, r, n) {
    const s = n / this.getTileSize().width;
    return t.set(r.x + e.x / s, r.y - e.y / s);
  }
  queryTilePointTerrain(t, e, r, n, s) {
    const o = this.getRenderer(), a = o && o.getTerrainHelper();
    if (!o || !a) return ka[0] = null, ka[1] = 0, ka;
    const l = this.pe(Yc, t, r, n);
    return e && a.queryTileTerrainByPointAtRes ? a.queryTileTerrainByPointAtRes(l, s, e.id, e, k8) : (ka[0] = null, ka[1] = 0, ka);
  }
  queryTerrainTiles(t) {
    const e = this.getRenderer(), r = e && e.getTerrainHelper();
    return e && r ? r.getTerrainTiles(t) : null;
  }
  de(t) {
    if (this.me = null, t && t.$root) {
      let n = t.$root;
      n && n[n.length - 1] === "/" && (n = n.substring(0, n.length - 1)), this.me = n, this.ye = function(s) {
        return s === "{$root}" ? n : null;
      };
    }
    this.ready = !0, t = t || [], Array.isArray(t) ? t = {
      style: t
    } : t.renderPlugin && (t = {
      style: [t]
    }), t = function(n) {
      if (!n.plugins) return n;
      const { plugins: s, styles: o } = n;
      let { style: a, featureStyle: l } = o;
      a = a || [], l = l || [];
      const h = new Array(a.length);
      for (let f = 0; f < a.length; f++) h[f] = Pe({}, a[f]), h[f].renderPlugin = s[a[f].renderPlugin];
      const u = new Array(l.length);
      for (let f = 0; f < l.length; f++) u[f] = Pe({}, l[f]), u[f].renderPlugin = s[l[f].renderPlugin];
      const c = {
        style: h,
        featureStyle: u
      };
      return n.$root && (c.$root = n.$root), c;
    }(t = JSON.parse(JSON.stringify(t))), this.ge = t.featureStyle || [], this.ve = function(n) {
      if (!n || !Array.isArray(n)) return [];
      const s = [];
      for (let o = 0; o < n.length; o++) {
        const a = n[o].style;
        if (a && Array.isArray(a) && a.length) for (let l = 0; l < a.length; l++) {
          const h = Pe({}, n[o], a[l]);
          a[l].xe = s.length, delete h.style, s.push(h);
        }
        else s.push(Pe({}, n[o]));
      }
      return s;
    }(t.featureStyle), this.be = t.style || [];
    const e = t.background || {};
    this.Ae = {
      enable: e.enable || !1,
      color: R8(e.color) || [0, 0, 0, 0],
      opacity: I8(e.opacity, 1),
      patternFile: e.patternFile,
      depthRange: e.depthRange
    }, this.validateStyle(), this.ye && this.we(), this.Dt();
    const r = this.getRenderer();
    r && r.setStyle(), this.fire("setstyle", {
      style: this.getStyle(),
      computedStyle: this.getComputedStyle()
    });
  }
  getPolygonOffsetCount() {
    const t = this.getRenderer();
    return t ? t.getPolygonOffsetCount() : 0;
  }
  getPolygonOffset() {
    return this._e || 0;
  }
  setPolygonOffset(t, e) {
    return this._e = t, this.Se = e, this;
  }
  getTotalPolygonOffset() {
    return this.Se;
  }
  getRenderedFeatures() {
    const t = this.getRenderer();
    return t ? t.getRenderedFeatures() : [];
  }
  outlineAll() {
    const t = this.getRenderer();
    return t ? (t.outlineAll(), this) : this;
  }
  outline(t, e) {
    const r = this.getRenderer();
    return r ? (r.outline(t, e), this) : this;
  }
  outlineBatch(t) {
    const e = this.getRenderer();
    return e ? (e.outlineBatch(t), this) : this;
  }
  outlineFeatures(t) {
    const e = this.getRenderer();
    return e ? (e.outlineFeatures(t), this) : this;
  }
  cancelOutline() {
    const t = this.getRenderer();
    return t ? (t.cancelOutline(), this) : this;
  }
  highlight(t) {
    this.Me(t);
    const e = this.getRenderer();
    return e ? (e.highlight(t), this) : (this.te || (this.te = []), this.te.push(t), this);
  }
  Me(t) {
    if (Array.isArray(t)) for (let e = 0; e < t.length; e++) this.Me(t[e]);
    else {
      if (t.filter) {
        if (!this.options.features) throw new Error("options.features must be turned on to support filter in highlight");
        if (!t.name) throw new Error("A name is required for highlight with filter");
      }
      if (Yn(t.filter) && Yn(t.id)) throw new Error("id or filter must be provided for highlight");
    }
  }
  ee() {
    if (this.te) {
      for (let t = 0; t < this.te.length; t++) this.highlight(this.te[t]);
      delete this.te;
    }
  }
  cancelHighlight(t) {
    const e = this.getRenderer();
    return e ? (e.cancelHighlight(t), this) : this;
  }
  cancelAllHighlight() {
    const t = this.getRenderer();
    return t ? (t.cancelAllHighlight(), this) : this;
  }
  we() {
    Yr.convertStylePath(this.be, this.ye), Yr.convertStylePath(this.ve, this.ye);
  }
  updateSceneConfig(t, e) {
    return _s(t) && (t = this.Pe(t)), this.Te(0, t, e);
  }
  updateFeatureSceneConfig(t, e, r) {
    return this.Te(1, t, r, e);
  }
  Te(t, e, r, n) {
    const s = this.it(t);
    if (!s) return this;
    let o, a = e;
    if (s[e].renderPlugin.sceneConfig || (s[e].renderPlugin.sceneConfig = {}), Pe(s[e].renderPlugin.sceneConfig, r), n !== void 0) {
      Ra(this.ge, e, n), a = this.ge[e].style[n].xe;
      const h = s[a].renderPlugin;
      h.sceneConfig || (h.sceneConfig = {}), o = h.sceneConfig;
    } else ch(s, e), o = s[e].renderPlugin.sceneConfig;
    if (Pe(o, r), Array.isArray(this.options.style)) {
      const h = this.options.style[e].renderPlugin;
      h.sceneConfig || (h.sceneConfig = {}), Pe(h.sceneConfig, r);
    } else {
      const h = this.it(t, this.options.style);
      let u;
      n !== void 0 ? (Ra(h, e, n), u = h[e].style[n].renderPlugin) : (ch(h, e), u = h[e].renderPlugin), u.sceneConfig || (u.sceneConfig = {}), Pe(u.sceneConfig, r);
    }
    const l = this.getRenderer();
    return l && l.updateSceneConfig(t, a, r), t === 0 ? this.fire("updatesceneconfig", {
      index: e,
      sceneConfig: r
    }) : t === 1 && this.fire("updatefeaturesceneconfig", {
      index: e,
      styleIdx: n,
      sceneConfig: r
    }), this;
  }
  updateDataConfig(t, e) {
    return _s(t) && (t = this.Pe(t)), this.ke(0, t, e);
  }
  updateFeatureDataConfig(t, e, r) {
    return this.ke(1, t, r, e);
  }
  ke(t, e, r, n) {
    const s = this.it(t);
    if (!s) return this;
    let o, a = e;
    n !== void 0 ? (Ra(this.ge, e, n), a = this.ge[e].style[n].xe, o = s[a].renderPlugin.dataConfig) : (ch(s, e), o = s[e].renderPlugin.dataConfig);
    const l = Pe({}, o);
    if (Pe(o, r), Array.isArray(this.options.style)) Pe(this.options.style[e].renderPlugin.dataConfig, r);
    else {
      const u = this.it(t, this.options.style);
      let c;
      n !== void 0 ? (Ra(u, e, n), c = u[e].style[n].renderPlugin) : (ch(u, e), c = u[e].renderPlugin), c.dataConfig || (c.dataConfig = {}), Pe(c.dataConfig, r);
    }
    const h = this.getRenderer();
    return h && h.updateDataConfig(t, a, r, l), t === 0 ? this.fire("updatedataconfig", {
      index: e,
      dataConfig: r
    }) : t === 1 && this.fire("updatefeaturedataconfig", {
      index: e,
      styleIdx: n,
      dataConfig: r
    }), this;
  }
  updateSymbol(t, e) {
    return _s(t) && (t = this.Pe(t)), this.Oe(0, t, e);
  }
  updateFeatureSymbol(t, e, r) {
    return this.Oe(1, t, r, e);
  }
  Oe(t, e, r, n) {
    const s = this.it(t);
    if (!s) return this;
    let o = e;
    n !== void 0 && (Ra(this.ge, e, n), o = this.ge[e].style[n].xe);
    const a = s[o];
    if (!a) throw new Error("No style defined at " + e);
    const l = this, h = this.ye;
    function u(p, g, m) {
      if (!p) return !1;
      h && (p = JSON.parse(JSON.stringify(p)), Yr.parseSymbolPath(p, h));
      const v = Object.keys(p);
      let _ = !1;
      for (let w = 0; w < v.length; w++) {
        const b = v[w];
        if (yb(g[b]) || yb(p[b])) {
          _ = !0;
          break;
        }
      }
      for (const w in p) kl(p, w) && (!Yr.isObject(p[w]) || Array.isArray(p[w]) || Ft(p[w]) ? g[w] = p[w] : (g[w] || (g[w] = {}), Pe(g[w], p[w])));
      let y = l.options.style;
      if (_s(y)) return _;
      Array.isArray(y) || (y = l.it(t, l.options.style));
      const x = JSON.parse(JSON.stringify(g));
      return n !== void 0 ? (Ra(y, e, n), m === void 0 ? y[e].style[n].symbol = x : y[e].style[n].symbol[m] = x) : (ch(y, e), m === void 0 ? y[e].symbol = x : y[e].symbol[m] = x), _;
    }
    const c = this.getRenderer();
    if (!c) return u(), this.Dt(), this;
    let f = !1;
    const d = a.symbol;
    if (Array.isArray(r)) for (let p = 0; p < r.length; p++) {
      const g = u(r[p], d[p], p);
      g && (f = g);
    }
    else u(r, d);
    return this.Dt(), f ? c.setStyle() : (f = c.updateSymbol(t, o, r), f && c.setStyle()), t === 0 ? this.fire("updatesymbol", {
      index: e,
      symbol: r
    }) : t === 1 && this.fire("updatefeaturesymbol", {
      index: e,
      featureStyleIndex: n,
      symbol: r
    }), this;
  }
  it(t, e) {
    return e ? t === 0 ? e.style : e.featureStyle : t === 0 ? this.be : this.ve;
  }
  isDefaultRender() {
    return !!this.Ie && this.options.defaultRendering;
  }
  validateStyle() {
    this.Ie = !1;
    let t = this.be;
    this.options.style || (this.Ie = !0, t = this.be = []), Array.isArray(t) || (t = this.be = [t]);
    for (let e = 0; e < t.length; e++) {
      let r = t[e].filter;
      if (r && r.value && (r = r.value), r || console.warn(`render plugin at ${e} doesn't define filter, its filter will be set to 'default' by default.`), r !== void 0 && r !== "default" && r !== !0 && !Array.isArray(r) && r.condition === void 0) throw new Error(`Invalid filter at ${e} : ${JSON.stringify(r)}`);
    }
  }
  getStyle() {
    return this.options.style ? JSON.parse(JSON.stringify(this.options.style)) : null;
  }
  Pe(t) {
    const e = this.be;
    if (!e) return -1;
    for (let r = 0; r < e.length; r++) if (e[r].name === t) return r;
    throw new Error("No style defined with name: " + t);
  }
  getGroundConfig() {
    this.Fe || (this.Fe = {
      enable: !0,
      renderPlugin: {
        type: "fill",
        sceneConfig: {}
      },
      symbol: {
        polygonFill: [0, 0, 0, 0],
        polygonOpacity: 1
      }
    });
    const t = this.q().background || {};
    return this.Fe.enable = t.enable, this.Fe.symbol.polygonFill = t.color, this.Fe.symbol.polygonOpacity = t.opacity, this.Fe.symbol.polygonPatternFile = t.patternFile, this.Fe.renderPlugin.sceneConfig.depthRange = t.depthRange, this.Fe;
  }
  getComputedStyle() {
    return JSON.parse(JSON.stringify(this.q()));
  }
  q() {
    return {
      background: this.Ae,
      style: this.be || [],
      featureStyle: this.ve || []
    };
  }
  identify(t, e = {}) {
    const r = this.getMap(), n = this.getRenderer();
    if (!r || !n) return [];
    const s = r.coordToContainerPoint(new lt(t));
    return this.identifyAtPoint(s, e);
  }
  identifyAtPoint(t, e = {}) {
    const r = this.getMap(), n = this.getRenderer();
    if (!r || !n) return [];
    const s = r.getDevicePixelRatio(), o = n.pick(t.x * s, t.y * s, e);
    return this.options.features && this.options.features !== "id" ? this.Ce(o) : o;
  }
  Ce(t) {
    if (!this.getRenderer()) return t;
    const e = this._getTileConfig(), r = this.getSpatialReference();
    for (let n = 0; n < t.length; n++) {
      let s = t[n];
      if (!s || !s.data) continue;
      const { tile: o } = s.data, { x: a, y: l, z: h, extent: u } = o, c = r.getResolution(h), f = e.getTilePointNW(a, l, c), d = s.data.feature && s.data.feature.geometry;
      if (d) {
        s.data = Pe({}, s.data), s.data.feature = Pe({}, s.data.feature);
        const p = s.data.feature.type;
        s.data.feature.type = "Feature", s.data.feature.geometry = this.Ee(p, d, f, u, c);
      }
    }
    return t;
  }
  Ee(t, e, r, n, s) {
    let o, a;
    if (t === 1) e.length <= 1 ? (o = "Point", a = this.De(e, r, n, s)[0] || []) : (o = "MultiPoint", a = this.De(e, r, n, s));
    else if (t === 2) e.length <= 1 ? (o = "LineString", a = this.De(e, r, n, s)[0] || []) : (o = "MultiLineString", a = this.De(e, r, n, s));
    else if (t === 3) {
      let l;
      a = [];
      let h = 0;
      for (let u = 0; u < e.length; u++)
        Er.calculateSignedArea(e[u]) > 0 && (h++, l && l.length && a.push(l), l = []), l.push(this.De(e[u], r, n, s));
      l.length && a.push(l), h <= 1 ? (o = "Polygon", a = a[0]) : o = "MultiPolygon";
    }
    return {
      type: o,
      coordinates: a
    };
  }
  De(t, e, r, n) {
    const s = r / this.getTileSize().width, o = this.getMap(), a = [];
    for (let l = 0; l < t.length; l++) Array.isArray(t[l]) ? a.push(this.De(t[l], e, r, n)) : (Yc.x = e.x + t[l].x / s, Yc.y = e.y - t[l].y / s, o.pointAtResToCoord(Yc, n, vb), a.push(vb.toArray()));
    return a;
  }
  getDataSchema(t) {
    return this.Ne || (this.Ne = {}), Yn(t) || this.Ne[t] || (this.Ne[t] = {}), Yn(t) ? this.Ne : this.Ne[t];
  }
  onRemove() {
    super.onRemove();
  }
  static fromJSON(t) {
    return t && t.type === "VectorTileLayer" ? new on(t.id, t.options) : null;
  }
  Dt() {
  }
  static registerPlugin(t) {
    on.plugins || (on.plugins = {}), on.plugins[t.type] = t;
  }
  static getPlugins() {
    return on.plugins || {};
  }
  static compressStyleJSON(t) {
    return Array.isArray(t) && t.length ? function(e) {
      Array.isArray(e) && (e = {
        style: e,
        featureStyle: []
      });
      const r = [], n = [], s = [];
      mb(e.style, r, s), mb(e.featureStyle, n, s);
      const o = {
        plugins: s,
        styles: {
          style: r,
          featureStyle: n
        }
      };
      return e.$root && (o.$root = e.$root), o;
    }(t) : t;
  }
}
function yb(i) {
  return !(!i || !i.properties);
}
function R8(i) {
  return i ? (Array.isArray(i) || (i = Zi(i).unitArray()), i.length === 3 && i.push(1), i) : null;
}
function I8(i, t) {
  return i ?? t;
}
function Ra(i, t, e) {
  if (!i[t] || !i[t].style || !i[t].style[e]) throw new Error(`No plugin defined at feature style of ${t} - ${e}`);
}
function ch(i, t) {
  if (!i[t]) throw new Error("No plugin defined at style of " + t);
}
on.prototype._getTileZoom = function(i) {
  return i = Math.floor(i), Pn.prototype._getTileZoom.call(this, i);
}, on.registerJSONType("VectorTileLayer"), on.mergeOptions({
  renderer: "gl",
  altitudeProperty: "altitude",
  forceRenderOnZooming: !0,
  forceRenderOnMoving: !0,
  forceRenderOnRotating: !0,
  tileSize: 512,
  features: !1,
  schema: !1,
  cascadeTiles: !0,
  collision: !0,
  collisionBuffserSize: 0,
  picking: !0,
  pickingPoint: !0,
  pickingGeometry: !1,
  glyphSdfLimitPerFrame: 15,
  tileLimitPerFrame: 1,
  loadingLimitOnInteracting: 5,
  loadingLimit: 0,
  antialias: !1,
  iconErrorUrl: null,
  collisionFrameLimit: 1.5,
  defaultRendering: !0,
  textGamma: 1,
  maxIconSize: 254,
  workarounds: {
    "win-intel-gpu-crash": !1
  },
  pyramidMode: 1,
  styleScale: 1,
  enableAltitude: !0,
  fadeAnimation: !1,
  debugTileData: !1,
  fetchOptions: null,
  awareOfTerrain: !0,
  altitudeQueryTimeLimitPerFrame: 3,
  workerGlyph: !0,
  featureIdProperty: null,
  currentTilesFirst: !1
}), on.registerRenderer("gl", sp), on.registerRenderer("canvas", null);
const _b = {
  projection: "EPSG:4326",
  fullExtent: {
    top: 90,
    left: -180,
    bottom: -90,
    right: 180
  },
  resolutions: function() {
    const i = [];
    for (let t = 0; t < 22; t++) i[t] = 45 / (128 * Math.pow(2, t));
    return i;
  }()
};
Ci.registerPreset("preset-vt-4326", _b), Ci.registerPreset("preset-4326-512", _b);
class Ny extends on {
  getTileUrl(t, e, r) {
    const n = this.getMap().getResolution(r);
    return super.getTileUrl(t, e, function(s) {
      return 19 - Math.log(s / D8) / Math.LN2;
    }(n));
  }
  static fromJSON(t) {
    return t && t.type === "MapboxVectorTileLayer" ? new Ny(t.id, t.options) : null;
  }
}
Ny.registerJSONType("MapboxVectorTileLayer");
const D8 = 12756274 * Math.PI / (256 * Math.pow(2, 20));
class bd extends on {
  constructor(t, e = {}) {
    e.spatialReference = null, super(t, e), this.setData(e.data);
  }
  onAdd() {
    this.ae();
  }
  ae() {
    const t = this.getMap(), e = t.getMaxNativeZoom(), r = t.getProjection(), n = r.code === "EPSG:4326" || r.code === "EPSG:4490";
    var s;
    n && (this.options.tileSystem = [1, -1, -180, 90]), this.options.spatialReference = n ? function(o, a) {
      return {
        projection: a,
        fullExtent: {
          top: 90,
          left: -180,
          bottom: -90,
          right: 180
        },
        resolutions: function() {
          const l = [];
          for (let h = 0; h <= o + 1; h++) l[h] = 90 / (128 * Math.pow(2, h));
          return l;
        }()
      };
    }(e, r.code) : (s = e, {
      projection: "EPSG:3857",
      resolutions: function() {
        const o = [], a = 6378137 * Math.PI;
        for (let l = 0; l <= s + 1; l++) o[l] = a / (256 * Math.pow(2, l));
        return o;
      }(),
      fullExtent: {
        top: 6378137 * Math.PI,
        left: -6378137 * Math.PI,
        bottom: -6378137 * Math.PI,
        right: 6378137 * Math.PI
      }
    });
  }
  getWorkerOptions() {
    const t = super.getWorkerOptions();
    let e = this.options.data;
    return _s(e) || e && e.url ? (e.url && (e = JSON.parse(JSON.stringify(e))), e = bb(e, this.getURLModifier())) : e = this.features, t.data = e, t.tileBuffer = this.options.tileBuffer, t.extent = this.options.extent, t.hasAltitude = this.options.enableAltitude, t.simplifyTolerance = this.options.simplifyTolerance, t.projection = this.getSpatialReference().getProjection().code, t.generateOMBB = this.options.generateOMBB, t.convertFn = this.options.convertFn ? this.options.convertFn + "" : null, t;
  }
  setData(t) {
    return this.options.data = t, t && (_s(t) || t.url) ? (this.getRenderer() && this.Le(), this) : (this.Re(t), this.Le(), this);
  }
  Re(t) {
    return this.options.convertFn && (t = new Function("data", this.options.convertFn + `
return convert(data)`)(t)), this.features = t, this.He(), this;
  }
  Le() {
    const t = this.getRenderer();
    if (t) {
      const e = t.getWorkerConnection();
      if (e) {
        let r = this.options.data;
        _s(r) || r && r.url ? (r.url && (r = JSON.parse(JSON.stringify(r))), r = bb(r, this.getURLModifier())) : r = this.features, e.setData(r, (n, s) => {
          t.clear(), this.onWorkerReady(null, s), t.setToRedraw(), setTimeout(() => {
            t.setToRedraw();
          }, 500);
        });
      }
    }
  }
  getExtent() {
    return this.ze;
  }
  onWorkerReady(t, e) {
    t ? this.fire("dataerror", {
      error: t
    }) : (e && (e.extent && this.Ve(e.extent), e.idMap && (this.Ue = e.idMap)), this.fire("dataload", {
      extent: e && e.extent
    }));
  }
  Ve(t) {
    this.ze = new dn(...t);
  }
  je(t, e) {
    _s(t) ? io.getJSON(t, e) : io.getJSON(t.url, t, e);
  }
  getData() {
    return this.features || null;
  }
  getTileUrl(t, e, r) {
    return this.getId() + "," + t + "," + e + "," + r;
  }
  getFeature(t) {
    return this.Ue[t];
  }
  static fromJSON(t) {
    return t && t.type === "GeoJSONVectorTileLayer" ? new bd(t.id, t.options) : null;
  }
  He() {
    if (!this.features || (this.features = JSON.parse(JSON.stringify(this.features)), !this.features)) return;
    let t = 0;
    this.Ue = {};
    const e = this.options.featureIdProperty, r = this.features;
    Array.isArray(r) ? r.forEach((n) => {
      if (n) {
        if (_l(n.id) || (n.id = t++), e) {
          let s = e;
          q0(e) && (s = e[n.layer || "0"]), n.id = n.properties[s];
        }
        this.Ue[n.id] = n;
      }
    }) : r.features && r.features.forEach((n) => {
      if (n) {
        if (_l(n.id) || (n.id = t++), e) {
          let s = e;
          q0(e) && (s = e[n.layer || "0"]), n.id = n.properties[s];
        }
        this.Ue[n.id] = n;
      }
    });
  }
}
function xb(i) {
  let t = document.createElement("a");
  return t.href = i, i = t.href, t = null, i;
}
function bb(i, t) {
  return i.url ? i.url = t ? t(i.url) : xb(i.url) : i = t ? t(i) : xb(i), i;
}
bd.registerJSONType("GeoJSONVectorTileLayer"), bd.mergeOptions({
  features: "id",
  tileBuffer: 64,
  extent: 8192,
  pyramidMode: 1,
  simplifyTolerance: 3,
  tileStackDepth: 0,
  generateOMBB: !0
});
const F8 = new zn(1, 1);
class Rn extends Lv {
  static registerPainter(t, e) {
    Rn.painters || (Rn.painters = {}), Rn.painters[t] = e;
  }
  static get3DPainterClass(t) {
    return Rn.painters[t];
  }
  setURLModifier(t) {
    return this.oe = t, this;
  }
  getURLModifier() {
    return this.oe;
  }
  getEvents() {
    let t;
    return t = super.getEvents ? super.getEvents() : {}, t.spatialreferencechange = this.Be, t;
  }
  onConfig(t) {
    if (super.onConfig(t), t.enableBloom !== void 0) {
      const e = this.getRenderer();
      e && e.updateBloom(t.enableBloom);
    }
  }
  updateSymbol(t, e) {
    if (!this.options.style) throw new Error("can't call update symbol when style is not set");
    const r = Array.isArray(this.options.style) ? this.options.style : this.options.style.style;
    if (!r[t]) throw new Error("invalid style at " + t);
    return Pe(r[t].symbol, e), this.setStyle(this.options.style), this;
  }
  getPolygonOffsetCount() {
    return this.isEmpty() || this.options.altitude ? 0 : 1;
  }
  getPolygonOffset() {
    return this.options.altitude ? 0 : this._e || 0;
  }
  setPolygonOffset(t, e) {
    return this._e = t, this.Se = e, this;
  }
  getTotalPolygonOffset() {
    return this.Se;
  }
  identify(t, e = {}) {
    const r = this.getMap(), n = this.getRenderer();
    if (!r || !n) return [];
    const s = r.coordToContainerPoint(new lt(t));
    return this.identifyAtPoint(s, e);
  }
  identifyAtPoint(t, e = {}) {
    const r = this.getMap(), n = this.getRenderer();
    if (!r || !n) return [];
    const s = this.getMap().getDevicePixelRatio();
    return n.pick(t.x * s, t.y * s, e);
  }
  getComputedStyle() {
    return {
      style: this.getStyle() || []
    };
  }
  outlineAll() {
    const t = this.getRenderer();
    return t ? (t.outlineAll(), this) : this;
  }
  outline(t) {
    if (!Array.isArray(t) || !t.length) return this;
    const e = this.getRenderer();
    return e ? (e.outline(t), this) : this;
  }
  cancelOutline() {
    const t = this.getRenderer();
    return t ? (t.cancelOutline(), this) : this;
  }
  toJSON() {
    const t = {
      type: this.getJSONType(),
      id: this.getId(),
      options: this.config(),
      geometries: []
    }, e = this.getGeometries();
    for (let r = 0, n = e.length; r < n; r++) {
      const s = e[r].toJSON();
      t.geometries.push(s);
    }
    return t;
  }
  getTileSize() {
    return F8;
  }
  Be() {
    const t = this.getRenderer();
    t && t.Be();
  }
}
Rn.mergeOptions({
  picking: !0,
  pickingPoint: !0,
  renderer: "gl",
  collision: !1,
  collisionBufferSize: 0,
  textGamma: 1,
  geometryEvents: !0,
  styleScale: 1,
  forceRenderOnZooming: !0,
  forceRenderOnMoving: !0,
  forceRenderOnRotating: !0,
  meshRenderOrder: 0,
  enableBloom: !1,
  enableAltitude: !0,
  workarounds: {
    "win-intel-gpu-crash": !0
  }
});
const L8 = {
  markerFile: {
    type: "identity",
    default: null,
    property: "_symbol_markerFile"
  },
  markerWidth: {
    type: "identity",
    default: null,
    property: "_symbol_markerWidth"
  },
  markerHeight: {
    type: "identity",
    default: null,
    property: "_symbol_markerHeight"
  },
  markerPathWidth: {
    type: "identity",
    default: 20,
    property: "_symbol_markerPathWidth"
  },
  markerPathHeight: {
    type: "identity",
    default: 20,
    property: "_symbol_markerPathHeight"
  },
  markerDx: {
    type: "identity",
    default: null,
    property: "_symbol_markerDx"
  },
  markerDy: {
    type: "identity",
    default: null,
    property: "_symbol_markerDy"
  },
  markerType: {
    type: "identity",
    default: null,
    property: "_symbol_markerType"
  },
  markerPath: {
    type: "identity",
    default: null,
    property: "_symbol_markerPath"
  },
  markerFill: {
    type: "identity",
    default: null,
    property: "_symbol_markerFill"
  },
  markerFillPatternFile: {
    type: "identity",
    default: null,
    property: "_symbol_markerFillPatternFile"
  },
  markerFillOpacity: {
    type: "identity",
    default: null,
    property: "_symbol_markerFillOpacity"
  },
  markerLineColor: {
    type: "identity",
    default: null,
    property: "_symbol_markerLineColor"
  },
  markerLineWidth: {
    type: "identity",
    default: null,
    property: "_symbol_markerLineWidth"
  },
  markerLineOpacity: {
    type: "identity",
    default: null,
    property: "_symbol_markerLineOpacity"
  },
  markerLineDasharray: {
    type: "identity",
    default: null,
    property: "_symbol_markerLineDasharray"
  },
  markerLinePatternFile: {
    type: "identity",
    default: null,
    property: "_symbol_markerLinePatternFile"
  },
  markerVerticalAlignment: {
    type: "identity",
    default: "top",
    property: "_symbol_markerVerticalAlignment"
  },
  markerHorizontalAlignment: {
    type: "identity",
    default: "middle",
    property: "_symbol_markerHorizontalAlignment"
  },
  markerOpacity: {
    type: "identity",
    default: 1,
    property: "_symbol_markerOpacity"
  },
  markerPitchAlignment: {
    type: "identity",
    default: "viewport",
    property: "_symbol_markerPitchAlignment"
  },
  markerRotationAlignment: {
    type: "identity",
    default: "viewport",
    property: "_symbol_markerRotationAlignment"
  },
  markerRotation: {
    type: "identity",
    default: 0,
    property: "_symbol_markerRotation"
  },
  markerAllowOverlap: {
    type: "identity",
    default: 0,
    property: "_symbol_markerAllowOverlap"
  },
  markerIgnorePlacement: {
    type: "identity",
    default: 0,
    property: "_symbol_markerIgnorePlacement"
  },
  markerTextFit: {
    type: "identity",
    default: null,
    property: "_symbol_markerTextFit"
  },
  markerSpacing: {
    type: "identity",
    default: 250,
    property: "_symbol_markerSpacing"
  },
  markerTextFitPadding: {
    type: "identity",
    default: null,
    property: "_symbol_markerTextFitPadding"
  },
  markerPlacement: {
    type: "identity",
    default: "point",
    property: "_symbol_markerPlacement"
  }
}, z8 = {
  textName: {
    type: "identity",
    default: null,
    property: "_symbol_textName"
  },
  textFaceName: {
    type: "identity",
    default: null,
    property: "_symbol_textFaceName"
  },
  textWeight: {
    type: "identity",
    default: null,
    property: "_symbol_textWeight"
  },
  textStyle: {
    type: "identity",
    default: null,
    property: "_symbol_textStyle"
  },
  textWrapWidth: {
    type: "identity",
    default: null,
    property: "_symbol_textWrapWidth"
  },
  textHorizontalAlignment: {
    type: "identity",
    default: null,
    property: "_symbol_textHorizontalAlignment"
  },
  textVerticalAlignment: {
    type: "identity",
    default: null,
    property: "_symbol_textVerticalAlignment"
  },
  textFill: {
    type: "identity",
    default: null,
    property: "_symbol_textFill"
  },
  textSize: {
    type: "identity",
    default: null,
    property: "_symbol_textSize"
  },
  textHaloRadius: {
    type: "identity",
    default: null,
    property: "_symbol_textHaloRadius"
  },
  textHaloFill: {
    type: "identity",
    default: null,
    property: "_symbol_textHaloFill"
  },
  textHaloOpacity: {
    type: "identity",
    default: 1,
    property: "_symbol_textHaloOpacity"
  },
  textDx: {
    type: "identity",
    default: 0,
    property: "_symbol_textDx"
  },
  textDy: {
    type: "identity",
    default: 0,
    property: "_symbol_textDy"
  },
  textOpacity: {
    type: "identity",
    default: 1,
    property: "_symbol_textOpacity"
  },
  textPitchAlignment: {
    type: "identity",
    default: "viewport",
    property: "_symbol_textPitchAlignment"
  },
  textRotationAlignment: {
    type: "identity",
    default: "viewport",
    property: "_symbol_textRotationAlignment"
  },
  textRotation: {
    type: "identity",
    default: 0,
    property: "_symbol_textRotation"
  },
  textAllowOverlap: {
    type: "identity",
    default: 0,
    property: "_symbol_textAllowOverlap"
  },
  textIgnorePlacement: {
    type: "identity",
    default: 0,
    property: "_symbol_textIgnorePlacement"
  },
  textSpacing: {
    type: "identity",
    default: 250,
    property: "_symbol_textSpacing"
  },
  textPlacement: {
    type: "identity",
    default: "point",
    property: "_symbol_textPlacement"
  }
}, Lf = {
  lineWidth: {
    type: "identity",
    default: 2,
    property: "_symbol_lineWidth"
  },
  lineStrokeWidth: {
    type: "identity",
    default: 0,
    property: "_symbol_lineStrokeWidth"
  },
  lineColor: {
    type: "identity",
    default: [1, 1, 1, 1],
    property: "_symbol_lineColor"
  },
  lineStrokeColor: {
    type: "identity",
    default: [0, 0, 0, 0],
    property: "_symbol_lineStrokeColor"
  },
  lineDx: {
    type: "identity",
    default: 0,
    property: "_symbol_lineDx"
  },
  lineDy: {
    type: "identity",
    default: 0,
    property: "_symbol_lineDy"
  },
  linePatternFile: {
    type: "identity",
    default: null,
    property: "_symbol_linePatternFile"
  },
  linePatternAnimSpeed: {
    type: "identity",
    default: 0,
    property: "_symbol_linePatternAnimSpeed"
  },
  linePatternGap: {
    type: "identity",
    default: 0,
    property: "_symbol_linePatternGap"
  },
  lineOpacity: {
    type: "identity",
    default: 1,
    property: "_symbol_lineOpacity"
  },
  lineJoin: {
    type: "identity",
    default: null,
    property: "_symbol_lineJoin"
  },
  lineCap: {
    type: "identity",
    default: null,
    property: "_symbol_lineCap"
  },
  lineDasharray: {
    type: "identity",
    default: null,
    property: "_symbol_lineDasharray"
  },
  lineDashColor: {
    type: "identity",
    default: null,
    property: "_symbol_lineDashColor"
  }
}, xi = new Y(0, 0), Gn = "_vector3dlayer_id", N8 = "_line_gradient_property".trim();
function wb(i, t, e) {
  const r = "__fea_idx".trim(), n = i.getMap(), s = n.getGLRes();
  let o = i.getCoordinates();
  const a = [], l = [];
  let h = 1;
  if (i instanceof xn || i instanceof jo) {
    i instanceof xn && (o = [o]);
    for (let g = 0; g < o.length; g++) n.coordToPointAtRes(o[g], s, xi), a.push([xi.x, xi.y, o[g].z || 0]), l.push([o[g].x, o[g].y]);
  } else if (i instanceof Tn || i instanceof Go) {
    h = 2, i instanceof Tn && (o = [o]);
    for (let g = 0; g < o.length; g++) {
      a[g] = [], l[g] = [];
      for (let m = 0; m < o[g].length; m++) n.coordToPointAtRes(o[g][m], s, xi), a[g].push([xi.x, xi.y, o[g][m].z || 0]), l[g].push([o[g][m].x, o[g][m].y]);
    }
  } else if (i instanceof vn || i instanceof Vo) {
    h = 3, i instanceof Pi || i instanceof Fo || i instanceof as || i instanceof Ko ? o = [[i.getShell()]] : i instanceof vn && (o = [o]);
    let g = 0;
    for (let m = 0; m < o.length; m++) {
      let v = !1;
      for (let _ = 0; _ < o[m].length; _++) {
        if (a[g] = [], l[g] = [], v) for (let y = o[m][_].length - 1; y >= 0; y--) n.coordToPointAtRes(o[m][_][y], s, xi), a[g].push([xi.x, xi.y, o[m][_][y].z || 0]), l[g].push([o[m][_][y].x, o[m][_][y].y]);
        else for (let y = 0; y < o[m][_].length; y++) n.coordToPointAtRes(o[m][_][y], s, xi), a[g].push([xi.x, xi.y, o[m][_][y].z || 0]), l[g].push([o[m][_][y].x, o[m][_][y].y]);
        _ === 0 && (v = Er.calculateSignedArea(a[g]) < 0, v && (a[g] = a[g].reverse(), l[g] = l[g].reverse())), g++;
      }
    }
  }
  const u = i.getProperties() ? Object.assign({}, i.getProperties()) : {}, c = i._getInternalSymbol() || function(g) {
    if (g instanceof xn || g instanceof jo) return {
      markerType: "ellipse",
      markerWidth: 8,
      markerHeight: 0,
      markerFill: "#000"
    };
    if (g instanceof Tn || g instanceof Go) return {
      lineColor: "#000",
      lineWidth: 1
    };
    if (g instanceof vn || g instanceof Vo) return {
      polygonFill: "#fff",
      lineColor: "#000",
      lineWidth: 1
    };
  }(i), f = e ? Array.isArray(e) ? e[0].id : e.id : t.id++;
  if (Array.isArray(c) && c.length) {
    const g = [], m = c.length;
    for (let v = 0; v < m; v++) {
      const _ = v === m - 1 ? u : Pe({}, u), y = Tb(c[v], _);
      for (const b in c[v]) kl(c[v], b) && (_[("_symbol_" + b).trim()] = c[v][b]);
      y && (c[v].lineGradientProperty = y);
      const x = e && e[v] ? e[v][r] : t.pickingId++, w = {
        type: h,
        id: f,
        properties: _,
        visible: i.isVisible(),
        geometry: a,
        coordinates: l,
        extent: 1 / 0
      };
      w[r] = x, g.push(w);
    }
    return g;
  }
  if (c) {
    const g = Tb(c, u);
    for (const m in c) kl(c, m) && (u[("_symbol_" + m).trim()] = c[m]);
    g && (c.lineGradientProperty = g);
  }
  const d = e ? e.id : t.pickingId++, p = {
    type: h,
    id: f,
    properties: u,
    visible: i.isVisible(),
    geometry: a,
    coordinates: l,
    extent: 1 / 0
  };
  return p[r] = d, p;
}
function Tb(i, t) {
  const e = i.lineGradientProperty;
  return e && (t[N8] = t[e], t.mapbox_clip_start = 0, t.mapbox_clip_end = 1, delete t[e]), e;
}
let H8 = 1;
const Ss = "_symbol_".trim(), Ki = "__fea_idx".trim();
let Jc = new Float32Array(1);
const B8 = [];
class Hy extends zs.CanvasRenderer {
  constructor(...t) {
    super(...t), this.features = {}, this.Ge = {}, this.L = 0, this.We = {}, this.Xe = {}, this.Ye = {}, this.$e = {}, this.qe = {}, this.Je = !0, this.Ze = {
      id: 0,
      pickingId: 0
    }, this.Ke = {};
  }
  setURLModifier(t) {
    this.oe = t;
  }
  getURLModifier() {
    return this.oe;
  }
  hasNoAARendering() {
    return !0;
  }
  needToRedraw() {
    return super.needToRedraw() || this.painter && this.painter.needToRedraw() || this.Qe && this.Qe.needToRedraw() || this.tn && this.tn.needToRedraw();
  }
  getAnalysisMeshes() {
    return this.painter && this.painter.getAnalysisMeshes() || B8;
  }
  getRayCastData() {
    return null;
  }
  draw(t, e) {
    this.pt = t;
    const r = this.layer;
    this.prepareCanvas(), this.yt = this.gt(this.getMap().getGLRes()), this.vt = e || {};
    const n = this.vt.renderMode, s = this.en();
    if (this.xt(s, n), this.Je) this.buildMesh(), this.nn(), this.in(), this.Ke = {}, this.rn = !1, this.Je = !1, this.sn = !1;
    else if (this.rn) {
      const h = this.atlas, u = this.an, c = this.ln;
      delete this.atlas, delete this.an, delete this.ln, this.buildMesh(h), this.nn(u), this.in(c), this.rn = !1, this.sn = !1;
    } else if (this.sn) {
      const h = this.ln;
      delete this.ln, this.in(h), this.sn = !1;
    }
    if (!this.meshes && !this.hn && !this.un) return void this.completeRender();
    this.cn && (this.dn(), this.cn = !1), this.pn();
    const o = !n || n === "default";
    let a = 0;
    this.layer.options.meshRenderOrder === 0 && this.mn(s, a, n);
    let l = 0;
    if (this.un && (o || this.tn.supportRenderMode(n))) {
      this.tn.startFrame(s), this.tn.addMesh(this.un, null, {
        bloom: this.vt.bloom
      }), this.tn.prepareRender(s);
      const h = s.polygonOffsetIndex || 0;
      a = this.meshes && this.meshes.length ? a - 1 : a, s.polygonOffsetIndex = (s.polygonOffsetIndex || 0) + a, l = this.tn.render(s).drawCount, s.polygonOffsetIndex = h;
    }
    if (this.layer.options.meshRenderOrder === 1 && this.mn(s, l ? a - 1 : a, n), this.hn && (o || this.Qe.supportRenderMode(n))) {
      const h = !this.vt.timestamp || this.vt.isFinalRender, u = !this.yn || this.yn !== t;
      r.options.collision && u && r.clearCollisionIndex();
      const c = this.layer.options.sceneConfig;
      this.Qe.sceneConfig.collision = !c || !!Yn(c.collision) || c.collision, this.Qe.startFrame(s), this.Qe.addMesh(this.hn, null, {
        bloom: this.vt.bloom
      }), this.Qe.prepareRender(s), r.options.collision && u && (this.Qe.updateCollision(s), h && (this.yn = t)), this.Qe.render(s);
    }
    (o || e && e.isFinalRender) && (this.completeRender(), this.layer.fire("canvasisdirty"));
  }
  xt(t, e) {
    const r = !e || e === "default";
    this.painter && (r || this.painter.supportRenderMode(e)) && this.painter.startFrame(t);
  }
  mn(t, e, r) {
    const n = !r || r === "default";
    return this.painter && this.meshes && (n || this.painter.supportRenderMode(r)) ? (this.painter.addMesh(this.meshes, null, {
      bloom: t && t.bloom
    }), this.painter.prepareRender(t), t.polygonOffsetIndex = (t.polygonOffsetIndex || 0) + e, this.painter.render(t)) : {
      redraw: !1,
      drawCount: 0
    };
  }
  supportRenderMode() {
    return !0;
  }
  isForeground() {
    return !0;
  }
  en() {
    const t = {
      regl: this.regl,
      layer: this.layer,
      symbol: this.gn,
      gl: this.gl,
      sceneConfig: this.layer.options.sceneConfig,
      pluginIndex: 0,
      cameraPosition: this.getMap().cameraPosition,
      timestamp: this.getFrameTimestamp()
    };
    return this.vt && Pe(t, this.vt), t;
  }
  drawOnInteracting(t, e, r) {
    this.draw(e, r);
  }
  getFrameTimestamp() {
    return this.pt;
  }
  vn(t, e) {
    (t = t || e) === e && (e = null);
    const r = [], n = [0, 0, 0, 0];
    this.layer._sortGeometries();
    const s = this.layer.getGeometries();
    for (let o = 0; o < s.length; o++) {
      const a = s[o][Gn];
      if (!this.features[a]) continue;
      const l = this.features[a];
      if (Array.isArray(l)) for (let h = 0; h < l.length; h++) {
        const u = l[h], c = u[Ki];
        (!t || t[c] || e && (!e || e[c])) && (u.visible || (this.cn = !0), this.xn(u.geometry, n, u.coordinates), r.push(u));
      }
      else {
        l.visible || (this.cn = !0);
        const h = l[Ki];
        if (t && !t[h] && (!e || e && !e[h])) continue;
        this.xn(l.geometry, n, l.coordinates), r.push(l);
      }
    }
    if (r.length || (this.meshes && this.painter && (this.painter.deleteMesh(this.meshes), delete this.meshes), this.hn && (this.Qe.deleteMesh(this.hn), delete this.hn), this.un && (this.tn.deleteMesh(this.un), delete this.un)), n[3] && (n[0] /= n[3], n[1] /= n[3]), isNaN(n[0]) || isNaN(n[1])) throw new Error("invalid geometry coordinates for " + this.layer.getJSONType());
    return {
      features: r,
      center: n
    };
  }
  buildMesh() {
  }
  createVectorPacks(t, e, r, n, s, o) {
    return !t || !n || !n.length ? Promise.resolve(null) : new e(n, r, {
      zoom: this.getMap().getZoom(),
      EXTENT: 1 / 0,
      requestor: this.requestor,
      atlas: s,
      center: o,
      positionType: Float32Array
    }).load();
  }
  createMesh(t, e, r, n, s, o) {
    return this.createVectorPacks(t, e, r, n, s, o).then((a) => this.bn(a, t, e, r, n, s, o));
  }
  bn(t, e, r, n, s, o, a) {
    if (!t) return null;
    const l = e.createGeometries([t.data], _P(s, null, 0, n, this.layer));
    for (let c = 0; c < l.length; c++) l[c] && this.An(l[c].geometry);
    const h = pn([]);
    ss(h, h, ne([], a[0], a[1], 0)), os(h, h, ne([], 1, 1, this.yt));
    const u = e.createMeshes(l, h, {
      tilePoint: [a[0], a[1]]
    });
    for (let c = 0; c < u.length; c++) {
      const f = u[c];
      f.properties.level = 0, f.properties.tileTransform = h;
      const d = f.defines;
      d.ENABLE_TILE_STENCIL = 1, f.setDefines(d), f.properties.meshKey = this.layer.getId();
    }
    return {
      meshes: u,
      atlas: {
        iconAtlas: t.data.iconAtlas
      }
    };
  }
  xn(t, e, r) {
    for (let n = 0; n < t.length; n++) if (Array.isArray(t[n][0])) for (let s = 0; s < t[n].length; s++) if (Array.isArray(t[n][s][0])) for (let o = 0; o < t[n][s].length; o++) isNaN(+t[n][s][o][0]) || isNaN(+t[n][s][o][1]) || this.wn(e, t[n][s][o][0], t[n][s][o][1], t[n][s][o][2], 1, r[n][s][o]);
    else isNaN(+t[n][s][0]) || isNaN(+t[n][s][1]) || this.wn(e, t[n][s][0], t[n][s][1], t[n][s][2], 1, r[n][s]);
    else isNaN(+t[n][0]) || isNaN(+t[n][1]) || this.wn(e, t[n][0], t[n][1], t[n][2], 1, r[n]);
  }
  wn(t, e, r, n, s, o) {
    let a = !1;
    (o[0] > 180 || o[0] < -180) && (a = !0, console.warn(`Layer(${this.layer.getId()}) has invalid longitude value: ${o[0]}`)), (o[1] > 90 || o[1] < -90) && (a = !0, console.warn(`Layer(${this.layer.getId()}) has invalid latitude value: ${o[1]}`)), a || (t[0] += e, t[1] += r, t[2] += n || 0, t[3] += s);
  }
  An(t) {
    const e = this.getMap(), r = t.properties;
    Object.defineProperty(r, "tileResolution", {
      enumerable: !0,
      get: function() {
        return e.getGLRes();
      }
    }), r.tileRatio = 1, r.z = 1, r.tileExtent = 1, r.elements = t.elements, r.aPickingId = t.data.aPickingId;
  }
  _n(t) {
    return t === "win-intel-gpu-crash" && this.layer.options.workarounds["win-intel-gpu-crash"] && Ab(this.gl);
  }
  prepareRequestors() {
    if (this.h) return;
    const t = this.layer;
    this.h = new lP({
      iconErrorUrl: t.options.iconErrorUrl,
      urlModifier: (r) => {
        const n = t.getURLModifier();
        return n && n(r) || r;
      }
    });
    const e = !this._n("win-intel-gpu-crash");
    this.u = new aP((r) => {
      t.getMap().getRenderer().callInNextFrame(r);
    }, t.options.glyphSdfLimitPerFrame, e), this.requestor = this.Sn.bind(this), this.Mn = this.Pn.bind(this);
  }
  Sn(t, e, r) {
    const n = [];
    this.h.getIcons(t, (s, o) => {
      if (s) throw s;
      o.buffers && n.push(...o.buffers), r(null, {
        icons: o.icons
      }, n);
    });
  }
  Pn(t, e, r) {
    this.u.getGlyphs(e, (n, s) => {
      if (n) throw n;
      const o = s.buffers || [];
      this.h.getIcons(t, (a, l) => {
        if (a) throw a;
        l.buffers && l.buffers.length && o.push(...l.buffers), r(null, {
          icons: l.icons,
          glyphs: s.glyphs
        }, o);
      });
    });
  }
  nn(t) {
    const e = Object.keys(this.Ye), r = Object.keys(this.$e);
    if (!e.length && !r.length) return void (this.hn && (this.Qe.deleteMesh(this.hn), delete this.hn));
    const { features: n, center: s } = this.vn(this.Ye, this.$e), o = [], a = [];
    for (let f = 0; f < n.length; f++) {
      const d = n[f][Ki];
      this.Ye[d] && o.push(n[f]), this.$e[d] && a.push(n[f]);
    }
    if (!o.length && !a.length) return void (this.hn && (this.Qe.deleteMesh(this.hn), delete this.hn));
    const l = this.cn;
    this.Tn = s;
    const h = this.kn(o, a, t, s);
    this.an = {};
    const u = [], c = [];
    this.On = !0, Promise.all(h).then((f) => {
      if (this.hn && (this.Qe.deleteMesh(this.hn), delete this.hn), !f || !f.length) return void this.setToRedraw();
      const d = this.Qe.createGeometries(f.map((_) => (_ && _.data && (_.data.isIdUnique = !0), _ && _.data)), this.We);
      for (let _ = 0; _ < d.length; _++) this.An(d[_].geometry, f[_] && f[_].data);
      const p = f[0] && f[0].data.iconAtlas, g = f[0] && f[0].data.glyphAtlas || f[1] && f[1].data.glyphAtlas;
      p && (this.an.iconAtlas = p), g && (this.an.glyphAtlas = g);
      const m = pn([]);
      ss(m, m, ne(c, s[0], s[1], 0)), os(m, m, ne(u, 1, 1, this.yt));
      const v = this.Qe.createMeshes(d, m);
      for (let _ = 0; _ < v.length; _++) v[_].geometry.properties.originElements = v[_].geometry.properties.elements.slice(), v[_].properties.level = 0, v[_].material.set("flipY", 1), v[_].properties.meshKey = H8++;
      this.hn = v, l && (this.cn = !0), this.On = !1, this.setToRedraw(), this.layer.fire("buildmarkermesh");
    });
  }
  dn() {
    if (this.hn && (this.In(this.hn[0], this.Ye), this.In(this.hn[1], this.$e), this.hn[0] && this.Qe.prepareCollideIndex(this.hn[0].geometry), this.hn[1] && this.Qe.prepareCollideIndex(this.hn[1].geometry)), this.un) for (let t = 0; t < this.un.length; t++) this.In(this.un[t], this.qe);
    if (this.meshes) for (let t = 0; t < this.meshes.length; t++) this.In(this.meshes[t], this.We);
  }
  In(t, e) {
    if (!t) return;
    const { aPickingId: r, originElements: n } = t.geometry.properties, s = [];
    for (let a = 0; a < n.length; a++) {
      const l = r[n[a]];
      e[l] && e[l].feature.visible && s.push(n[a]);
    }
    const o = t.geometry.properties.elements = new n.constructor(s);
    t.geometry.setElements(o);
  }
  kn(t, e, r, n) {
    const s = {
      zoom: this.getMap().getZoom(),
      EXTENT: 1 / 0,
      requestor: this.Mn,
      atlas: r,
      center: n,
      positionType: Float32Array,
      defaultAltitude: 0,
      forceAltitudeAttribute: !0,
      markerWidthType: Uint16Array,
      markerHeightType: Uint16Array
    }, o = Pe({}, s);
    return s.allowEmptyPack = 1, tm.splitPointSymbol(this.Fn).map((a, l) => new tm(l === 0 ? t : e, a, l === 0 ? s : o).load());
  }
  updateMesh() {
  }
  Cn(t) {
    const e = t._getInternalSymbol(), r = {
      zoom: this.getMap().getZoom(),
      isVector3D: !0
    }, n = this.En(t);
    if (!this.hn) return !1;
    let s = this.features[n];
    Array.isArray(s) || (s = [s]);
    const o = [], a = [], l = [], h = this.getMap().getZoom();
    let u, c;
    u = Array.isArray(e) ? e.map((g) => g && vu(g, () => (o[0] = h, o))) : vu(e, () => (o[0] = h, o)), c = Array.isArray(e) ? e.map((g) => g && ao.genFnTypes(g)) : ao.genFnTypes(e);
    for (let g = 0; g < s.length; g++) {
      if (!s[g]) continue;
      const m = Array.isArray(e) ? e[g] : e, v = Array.isArray(u) ? u[g] : u, _ = Array.isArray(c) ? c[g] : c, y = new KC(s, m, v, _, r).getIconAndGlyph();
      if (!this.an || !tm.isAtlasLoaded(y, this.an)) return this.Dn(), this.setToRedraw(), !1;
    }
    for (let g = 0; g < s.length; g++) {
      const m = s[g][Ki];
      this.Ye[m] && a.push(s[g]), this.$e[m] && l.push(s[g]);
    }
    const f = s[0].id, d = this.kn(a, l, this.an, this.Tn), p = this.hn;
    return Promise.all(d).then((g) => {
      for (let m = 0; m < g.length; m++) {
        if (!g[m]) continue;
        g[m].data && (g[m].data.isIdUnique = !0);
        const v = p[m], _ = v.geometry.properties.aFeaIds.indexOf(f);
        if (_ < 0) continue;
        const y = g[m].data.featureIds.length, x = g[m].data.dynamicAttributes;
        for (const w in g[m].data.data) {
          if (w === "aPickingId" || x[w]) continue;
          const b = g[m].data.data[w];
          b && v.geometry.updateSubData(w, b, _ * b.length / y);
        }
      }
      this.setToRedraw();
    }), !0;
  }
  Nn(t) {
    return this.Ln(t, this.un, this.ln, this.Rn, this.tn, Df, Lf, this.Hn);
  }
  Ln(t, e, r, n, s, o, a, l) {
    if (!e) return !1;
    if (!r) return this.Dn(), this.setToRedraw(), !1;
    const h = t._getInternalSymbol(), u = {
      zoom: this.getMap().getZoom()
    }, c = t[Gn];
    let f = this.features[c];
    Array.isArray(f) || (f = [f]);
    const d = [];
    for (let _ = 0; _ < f.length; _++) {
      const y = f[_];
      if (!y) continue;
      const x = Array.isArray(h) ? h[_] : h, w = ao.genFnTypes(x), b = new Yd(f, x, w, u), T = o === Df ? b.getLineResource() : b.getPolygonResource();
      if (!ao.isAtlasLoaded(T, r[_])) return this.Dn(), this.setToRedraw(), !1;
      d.push(y);
    }
    const p = f[0].id, g = l.call(this, d);
    for (let _ = 0; _ < g.length; _++) if (g[_].length) {
      const y = e.filter((x) => x.feaGroupIndex === _);
      if (!y.length) return this.Dn(), this.setToRedraw(), !1;
      if (y[0].geometry.properties.aFeaIds.indexOf(p) < 0) return this.Dn(), this.setToRedraw(), !1;
    }
    const m = Pe({}, a), v = g.map((_) => this.createVectorPacks(s, o, m, _, r[0], n));
    return Promise.all(v).then((_) => {
      for (let y = 0; y < _.length; y++) {
        let x;
        if (Array.isArray(e)) {
          for (let w = 0; w < e.length; w++) if (e[w].feaGroupIndex === y) {
            x = e[w];
            break;
          }
        } else x = e;
        x && this.zn(x, p, _[y]);
      }
    }), !0;
  }
  zn(t, e, r) {
    const n = t.geometry.properties.aFeaIds, s = n.indexOf(e);
    if (!(s < 0)) {
      if (r) {
        const o = r.data.dynamicAttributes, a = r.data.featureIds.length, l = r.data.data;
        for (const h in l) if (!o[h] && kl(l, h) && l[h]) {
          const u = l[h];
          t.geometry.updateSubData(h, u, s * u.length / a);
        }
      } else {
        let o = s + 1;
        for (; n[o] === e; ) o++;
        const a = o - s, l = t.geometry.desc.positionSize;
        Jc.length !== 3 * a && (Jc = new Float32Array(a * l), Jc.fill(-1 / 0, 0)), t.geometry.updateSubData(t.geometry.desc.positionAttribute, Jc, s * l);
      }
      this.layer.fire("updatemesh"), this.setToRedraw();
    }
  }
  in(t) {
    if (!Object.keys(this.qe).length) return void (this.un && (this.tn.deleteMesh(this.un), delete this.un));
    const { features: e, center: r } = this.vn(this.qe);
    if (!e.length) return;
    const n = this.cn;
    this.Rn = r;
    const s = this.Hn(e), o = Pe({}, Lf), a = s.map((l, h) => this.createMesh(this.tn, Df, o, l, t && t[h], r));
    this.Vn = !0, Promise.all(a).then((l) => {
      this.un && this.tn.deleteMesh(this.un);
      const h = [], u = [];
      for (let c = 0; c < l.length; c++) {
        const f = l[c] && l[c].meshes;
        if (f) {
          for (let d = 0; d < f.length; d++) {
            const p = f[d];
            p.feaGroupIndex = c, h.push(p), p.geometry.properties.originElements = p.geometry.properties.elements.slice();
          }
          u[c] = l[c].atlas;
        }
      }
      this.un = h, this.ln = u, n && (this.cn = n), this.Vn = !1, this.setToRedraw(), this.layer.fire("buildlinemesh");
    });
  }
  Hn(t) {
    const e = (Ss + "lineDasharray").trim(), r = (Ss + "linePatternFile").trim(), n = [], s = [], o = [];
    for (let a = 0; a < t.length; a++) {
      const l = t[a], h = l.properties && l.properties[e];
      h && V8(h) ? o.push(l) : l.properties && l.properties[r] ? s.push(l) : n.push(l);
    }
    return [n, s, o];
  }
  Un() {
    this.rn = !0, this.setToRedraw();
  }
  Dn() {
    this.Je = !0, this.setToRedraw();
  }
  jn(t) {
    const e = this.layer.getId();
    for (let r = 0; r < t.length; r++) {
      const n = t[r];
      let s = !1;
      for (let o = 0; o < this.GeometryTypes.length; o++) if (n instanceof this.GeometryTypes[o]) {
        s = !0;
        break;
      }
      if (!s) throw new Error(`${n.getJSONType()} can't be added to ${this.layer.getJSONType()}(id:${e}).`);
      this.En(n);
    }
  }
  En(t) {
    t[Gn] === void 0 && (t[Gn] = this.L++);
    const e = t[Gn];
    this.features[e] && this.Bn(e), this.features[e] = wb(t, this.Ze, this.features[e]);
    const r = this.features[e];
    return this.Gn(r, e), this.Ge[e] = t, e;
  }
  Gn(t, e) {
    if (!t) return;
    const r = Array.isArray(t) ? t[0].id : t.id;
    if (this.Xe[r] = t, Array.isArray(t)) for (let n = 0; n < t.length; n++) {
      const s = t[n][Ki];
      if (t[n][Gn] = e, this.We[s] = {
        feature: t[n]
      }, this.We[s][Gn] = e, !this.needCheckPointLineSymbols()) continue;
      const o = {
        feature: t[n]
      };
      (Mb(t[n]) || Kc(t[n])) && (this.Ye[s] = o), Kc(t[n]) && (this.$e[s] = o), Sb(t[n]) && (this.qe[s] = o);
    }
    else {
      t[Gn] = e;
      const n = {
        feature: t
      }, s = t[Ki];
      if (this.We[s] = n, !this.needCheckPointLineSymbols()) return;
      (Mb(t) || Kc(t)) && (this.Ye[s] = n), Kc(t) && (this.$e[s] = n), Sb(t) && (this.qe[s] = n);
    }
  }
  needCheckPointLineSymbols() {
    return !0;
  }
  Bn(t) {
    const e = this.features[t];
    if (e) if (Array.isArray(e)) for (let r = 0; r < e.length; r++) {
      const n = e[r][Ki], s = e[r].id;
      delete this.Xe[s], delete this.We[n], delete this.Ye[n], delete this.$e[n], delete this.qe[n];
    }
    else {
      const r = e[Ki], n = e.id;
      delete this.Xe[n], delete this.We[r], delete this.Ye[r], delete this.$e[r], delete this.qe[r];
    }
  }
  pick(t, e, r) {
    const n = [];
    return this.layer.isVisible() && [this.painter, this.Qe, this.tn].forEach((s) => {
      if (!s) return;
      const o = s.pick(t, e, r.tolerance);
      if (o && o.data && o.data.feature) {
        const a = o.data.feature, l = this.Ge[a[Gn]];
        r && r.includeInternals ? n.push(l) : (o.geometry = l, delete o.plugin, delete o.data, delete o.point, n.push(o));
      }
    }), n;
  }
  Wn(t) {
    const e = t[Gn], r = this.features[e];
    return Array.isArray(r) ? r[0][Ki] : r[Ki];
  }
  pn() {
    let t = !1;
    for (const e in this.Ke) {
      const r = this.Ke[e], n = this.Wn(r);
      if (!this.On && (this.Ye[n] || this.$e[n])) {
        const s = this.Cn(r);
        t = t || s;
      }
      if (!this.Vn && this.qe[n]) {
        const s = this.Nn(r);
        t = t || s;
      }
      if (!this.Xn) {
        const s = this.updateMesh(r);
        t = t || s;
      }
    }
    this.Ke = {}, t && (Ws(this), this.layer.fire("partialupdate"));
  }
  Yn(t) {
    this.En(t), this.Dn(), Ws(this);
  }
  onGeometryAdd(t) {
    this.setToRedraw(), this.canvas && t && t.length && (this.jn(t), this.Dn(), Ws(this));
  }
  onGeometryRemove(t) {
    if (t && t.length) {
      for (let e = 0; e < t.length; e++) {
        const r = t[e][Gn];
        r !== void 0 && (delete this.Ge[r], this.Bn(r), delete this.features[r]);
      }
      this.Dn(), Ws(this);
    }
  }
  onGeometrySymbolChange(t) {
    const e = t.target._getParent() || t.target, r = e[Gn];
    if (r === void 0) return;
    let n = t.properties;
    if (Array.isArray(n)) {
      const a = {};
      for (let l = 0; l < n.length; l++) n[l] && Pe(a, n[l]);
      n = a;
    } else if (n && n[0] !== void 0) {
      const a = {};
      for (const l in n) n[l] && Pe(a, n[l]);
      n = a;
    }
    for (const a in n) if (kl(n, a) && cP[a]) return void this.Yn(e);
    const s = e._getInternalSymbol(), o = this.features[r];
    if (this.En(e), o) if (function(a, l) {
      return Array.isArray(a) ? !!Array.isArray(l) && a.length === l.length : !Array.isArray(l);
    }(s, o)) {
      if (Array.isArray(s)) {
        for (let a = 0; a < s.length; a++)
          if (!Cb(s[a], o[a])) return void this.Yn(e);
      } else if (!Cb(s, o)) return void this.Yn(e);
      this.onGeometryPositionChange(t);
    } else this.Yn(e);
    else this.Yn(e);
  }
  onGeometryShapeChange(t) {
    const e = t.target._getParent() || t.target;
    e[Gn] !== void 0 && (this.jn([e]), this.Un(), Ws(this));
  }
  onGeometryPositionChange(t) {
    const e = t.target._getParent() || t.target, r = e[Gn];
    r !== void 0 && (this.jn([e]), this.Ke[r] = e, Ws(this));
  }
  onGeometryZIndexChange(t) {
    (t.target._getParent() || t.target)[Gn] !== void 0 && this.Dn();
  }
  onGeometryShow(t) {
    (t.target._getParent() || t.target)[Gn] !== void 0 && this.$n(t);
  }
  onGeometryHide(t) {
    (t.target._getParent() || t.target)[Gn] !== void 0 && this.$n(t);
  }
  $n(t) {
    const e = t.target, r = e[Gn], n = this.features[r];
    if (n) {
      const s = e.isVisible();
      if (Array.isArray(n)) {
        if (s === n[0].visible) return;
        for (let o = 0; o < n.length; o++) n[o].visible = s;
      } else {
        if (s === n.visible) return;
        n.visible = s;
      }
      this.qn(), Ws(this);
    }
  }
  qn() {
    this.cn = !0;
  }
  onGeometryPropertiesChange(t) {
    const e = t.target._getParent() || t.target, r = e[Gn];
    r !== void 0 && (this.features[r] = wb(e, this.Ze), this.Gn(this.features[r], r), this.Dn(), Ws(this));
  }
  createContext() {
    const t = this.canvas.gl && this.canvas.gl.wrap;
    t ? (this.gl = this.canvas.gl.wrap(), this.regl = this.canvas.gl.regl) : this.ot(), t && (this.canvas.pickingFBO = this.canvas.pickingFBO || this.regl.framebuffer(this.canvas.width, this.canvas.height)), this.prepareRequestors(), this.pickingFBO = this.canvas.pickingFBO || this.regl.framebuffer(this.canvas.width, this.canvas.height), this.painter = this.createPainter();
    const e = Rn.get3DPainterClass("icon");
    let r = e.getBloomSymbol();
    const n = Pe({}, L8, z8);
    n.markerPerspectiveRatio = this.layer.options.markerPerspectiveRatio || 0, this.Jn(n, r), this.Fn = n;
    const s = Pe({}, yP, this.layer.options.sceneConfig || {});
    this.Qe = new e(this.regl, this.layer, n, s, 0), this.Qe.setTextShaderDefines({
      REVERSE_MAP_ROTATION_ON_PITCH: 1
    });
    const o = Rn.get3DPainterClass("line"), a = Pe({}, Lf);
    r = o.getBloomSymbol(), this.Jn(a, r), this.Zn = a;
    const l = Pe({}, this.layer.options.sceneConfig || {});
    l.depthMask === void 0 && (l.depthMask = !0), this.tn = new o(this.regl, this.layer, a, l, 0), this.layer.getGeometries() && this.onGeometryAdd(this.layer.getGeometries());
  }
  st() {
    return !!(this.canvas && this.canvas.gl && this.canvas.gl.wrap);
  }
  Jn(t, e) {
    for (let r = 0; r < e.length; r++) t[e[r]] = this.layer.options.enableBloom;
  }
  updateBloom(t) {
    this.Qe && this.Kn(this.Qe, this.Fn, t), this.tn && this.Kn(this.tn, this.Zn, t), this.painter && this.Kn(this.painter, this.painterSymbol, t);
  }
  Kn(t, e, r) {
    const n = t.constructor.getBloomSymbol().reduce((s, o) => (s[o] = r, e[o] = r, s), {});
    t.updateSymbol(n, e);
  }
  createPainter() {
  }
  ot() {
    const t = this.layer.options.glOptions || {
      alpha: !0,
      depth: !0,
      stencil: !0,
      antialias: !1
    };
    t.preserveDrawingBuffer = !0, t.stencil = !0, this.glOptions = t, this.gl = this.gl || this.ut(this.canvas, t), this.regl = zu({
      gl: this.gl,
      attributes: t,
      extensions: W_.WEBGL_EXTENSIONS,
      optionalExtensions: W_.WEBGL_OPTIONAL_EXTENSIONS
    });
  }
  ut(t, e) {
    const r = ["webgl", "experimental-webgl"];
    let n = null;
    for (let s = 0; s < r.length; ++s) {
      try {
        n = t.getContext(r[s], e);
      } catch {
      }
      if (n) break;
    }
    return n;
  }
  clearCanvas() {
    super.clearCanvas(), this.regl && this.regl.clear({
      color: [0, 0, 0, 0],
      depth: 1,
      stencil: 255
    });
  }
  resizeCanvas(t) {
    super.resizeCanvas(t);
    const e = this.canvas;
    e && (!this.pickingFBO || this.pickingFBO.width === e.width && this.pickingFBO.height === e.height || this.pickingFBO.resize(e.width, e.height), this.painter && this.painter.resize(e.width, e.height));
  }
  onRemove() {
    super.onRemove(), this.painter && (this.painter.delete(), delete this.painter), this.Qe && (this.Qe.delete(), delete this.Qe), this.tn && (this.tn.delete(), delete this.tn);
  }
  drawOutline(t) {
    if (this.Mt && (this.painter && this.painter.outlineAll(t), this.Qe.outlineAll(t), this.tn.outlineAll(t)), this.Qn) for (let e = 0; e < this.Qn.length; e++) this.painter && this.painter.outline(t, this.Qn[e]), this.Qe.outline(t, this.Qn[e]), this.tn.outline(t, this.Qn[e]);
  }
  outlineAll() {
    this.Mt = !0, this.setToRedraw();
  }
  outline(t) {
    this.Qn || (this.Qn = []);
    const e = [];
    for (let r = 0; r < t.length; r++) {
      const n = this.layer.getGeometryById(t[r]);
      if (n) {
        const s = this.features[n[Gn]];
        if (Array.isArray(s)) for (let o = 0; o < s.length; o++) e.push(s[o].id);
        else e.push(s.id);
      }
    }
    this.Qn.push(e), this.setToRedraw();
  }
  cancelOutline() {
    delete this.Mt, delete this.Qn, this.setToRedraw();
  }
  isEnableWorkAround(t) {
    return t === "win-intel-gpu-crash" && this.layer.options.workarounds["win-intel-gpu-crash"] && Ab(this.gl);
  }
  gt(t) {
    return Rl(t, this.getMap());
  }
  Be() {
    const t = this.layer.getGeometries();
    t && this.jn(t), this.Dn();
  }
  ne() {
    const t = this.layer.options.opacity;
    return this.st() ? Yn(t) ? 1 : t : 1;
  }
}
function Ws(i) {
  i.setToRedraw();
}
function Ab(i) {
  const t = i.getExtension("WEBGL_debug_renderer_info");
  if (t && typeof navigator < "u") {
    const e = i.getParameter(t.UNMASKED_RENDERER_WEBGL), r = navigator.platform === "Win32" || navigator.platform === "Win64";
    if (e && e.toLowerCase().indexOf("intel") >= 0 && r) return !0;
  }
  return !1;
}
function Mb({ properties: i }) {
  const t = (Ss + "markerFile").trim(), e = (Ss + "markerType").trim();
  return i[t] || i[e];
}
function Kc({ properties: i }) {
  return i[(Ss + "textName").trim()];
}
const j8 = (Ss + "lineWidth").trim(), G8 = "_line_gradient_property".trim();
function Sb(i) {
  return i.type === 2 && !i.properties[G8] || i.type === 3 && i.properties[j8] !== void 0;
}
function V8(i) {
  if (!Array.isArray(i)) return 0;
  let t = 0;
  for (let e = 0; e < i.length; e++) t += i[e];
  return t;
}
function Cb(i, t) {
  if (Object.keys(i).sort().join() !== Object.keys(t.properties || {}).filter((e) => e.indexOf(Ss) === 0).map((e) => e.substring(Ss.length)).sort().join()) return !1;
  for (const e in i) if (kl(i, e)) {
    const r = (Ss + e).trim();
    if (Ft(i[e]) !== Ft(t.properties[r])) return !1;
  }
  return !0;
}
function op(i, t, e) {
  if (!i || i.type !== t) return null;
  const r = new e(i.id, i.options), n = i.geometries, s = [];
  for (let o = 0; o < n.length; o++) {
    const a = nn.fromJSON(n[o]);
    a && s.push(a);
  }
  return r.addGeometry(s), r;
}
class bl extends Rn {
  static fromJSON(t) {
    return op(t, "PointLayer", bl);
  }
  constructor(...t) {
    super(...t), this.options.sceneConfig || (this.options.sceneConfig = Pe({}, yP));
  }
  getPolygonOffsetCount() {
    return 0;
  }
  getPolygonOffset() {
    return 0;
  }
}
bl.mergeOptions({
  glyphSdfLimitPerFrame: 15,
  iconErrorUrl: null,
  workarounds: {
    "win-intel-gpu-crash": !0
  },
  collision: !1,
  collisionFrameLimit: 1
}), bl.registerJSONType("PointLayer"), bl.registerRenderer("canvas", null);
bl.registerRenderer("gl", class extends Hy {
  constructor(...i) {
    super(...i), this.GeometryTypes = [xn, jo];
  }
  onGeometryAdd(i) {
    i && (Array.isArray(i) ? i.forEach((t) => {
      t.options.maxMarkerWidth = t.options.maxMarkerHeight = 255;
    }) : i.options.maxMarkerWidth = i.options.maxMarkerHeight = 255, super.onGeometryAdd(i));
  }
});
class Il extends Rn {
  static fromJSON(t) {
    return op(t, "LineStringLayer", Il);
  }
}
Il.mergeOptions({
  meshRenderOrder: 1
}), Il.registerJSONType("LineStringLayer");
const Pb = "_line_gradient_property".trim();
Il.registerRenderer("gl", class extends Hy {
  constructor(...i) {
    super(...i), this.GeometryTypes = [Tn, Go];
  }
  createPainter() {
    const i = Rn.get3DPainterClass("line-gradient");
    this.painterSymbol = Pe({}, {
      lineGradientProperty: Pb
    }, Lf), this.Jn(this.painterSymbol, i.getBloomSymbol());
    const t = Pe({}, this.layer.options.sceneConfig || {});
    return t.depthMask === void 0 && (t.depthMask = !0), new i(this.regl, this.layer, this.painterSymbol, t, 0);
  }
  buildMesh() {
    let { features: i, center: t } = this.vn();
    if (i = i.filter((s) => !!s.properties[Pb]), !i.length) return;
    const e = this.cn;
    this.ti = t;
    const r = Pe({}, this.painterSymbol), n = this.createMesh(this.painter, Df, r, i, null, t);
    this.Xn = !0, n.then((s) => {
      this.meshes && this.painter.deleteMesh(this.meshes);
      const o = [], a = s && s.meshes;
      if (a) {
        o.push(...a);
        for (let l = 0; l < a.length; l++) a[l].feaGroupIndex = 0, a[l].geometry.properties.originElements = a[l].geometry.properties.elements.slice();
      }
      this.meshes = o, e && (this.cn = e), this.Xn = !1, this.setToRedraw();
    });
  }
}), Il.registerRenderer("canvas", null);
class Pu extends Rn {
  static fromJSON(t) {
    return op(t, "PolygonLayer", Pu);
  }
}
Pu.registerJSONType("PolygonLayer");
const dm = {
  polygonFill: {
    type: "identity",
    default: [1, 1, 1, 1],
    property: "_symbol_polygonFill"
  },
  polygonPatternFile: {
    type: "identity",
    default: void 0,
    property: "_symbol_polygonPatternFile"
  },
  polygonOpacity: {
    type: "identity",
    default: 1,
    property: "_symbol_polygonOpacity"
  },
  uvScale: {
    type: "identity",
    default: [1, 1],
    property: "_symbol_uvScale"
  },
  uvOffset: {
    type: "identity",
    default: [0, 0],
    property: "_symbol_uvOffset"
  },
  uvOffsetInMeter: {
    type: "identity",
    default: !1,
    property: "_symbol_uvOffsetInMeter"
  },
  polygonPatternFileWidth: {
    type: "identity",
    default: void 0,
    property: "_symbol_polygonPatternFileWidth"
  },
  polygonPatternFileHeight: {
    type: "identity",
    default: void 0,
    property: "_symbol_polygonPatternFileHeight"
  },
  polygonPatternFileOrigin: {
    type: "identity",
    default: void 0,
    property: "_symbol_polygonPatternFileOrigin"
  },
  polygonPatternUV: {
    type: "identity",
    default: void 0,
    property: "_symbol_polygonPatternUV"
  }
};
class bP extends Hy {
  constructor(...t) {
    super(...t), this.GeometryTypes = [vn, Vo];
  }
  getPolygonOffsetCount() {
    return this.options.altitude > 0 ? 0 : 2;
  }
  buildMesh(t) {
    const { features: e, center: r } = this.vn();
    if (!e.length) return;
    const n = this.cn;
    this.ti = r;
    const s = this.ei(e), o = Pe({}, dm), a = s.map((l, h) => this.createMesh(this.painter, eb, o, l, t && t[h], r));
    this.Xn = !0, Promise.all(a).then((l) => {
      this.meshes && this.painter.deleteMesh(this.meshes), l = function(c) {
        const f = [];
        for (let d = 0; d < c.length; d++) Array.isArray(c[d]) ? f.push(...c[d]) : f.push(c[d]);
        return f;
      }(l);
      const h = [], u = [];
      for (let c = 0; c < l.length; c++) {
        const f = l[c] && l[c].meshes;
        if (f) {
          h.push(...f);
          for (let d = 0; d < f.length; d++) f[d].feaGroupIndex = c, f[d].geometry.properties.originElements = f[d].geometry.properties.elements.slice(), c === 1 && (f[d].transparent = !0);
          u[c] = l[c].atlas;
        }
      }
      this.meshes = h, this.atlas = u, n && (this.cn = n), this.Xn = !1, this.setToRedraw(), this.layer.fire("buildmesh");
    });
  }
  getRayCastData(t, e) {
    const r = this.painter.getRayCastData(t, e);
    if (!r || !r.feature) return null;
    const n = r.feature[Gn];
    return this.Ge[n];
  }
  ei(t) {
    const e = [], r = [];
    for (let n = 0; n < t.length; n++) {
      const s = t[n];
      s.properties && s.properties._symbol_polygonOpacity < 1 ? r.push(s) : e.push(s);
    }
    return [e, r];
  }
  createPainter() {
    const t = Rn.get3DPainterClass("fill"), e = this.painterSymbol = Pe({}, dm);
    return this.Jn(e, t.getBloomSymbol()), new t(this.regl, this.layer, e, this.layer.options.sceneConfig, 0);
  }
  updateMesh(t) {
    return this.Ln(t, this.meshes, this.atlas, this.ti, this.painter, eb, dm, this.ei);
  }
}
function U8(i, t, e, r, n, s, o) {
  const a = e && Array.isArray(e[0]);
  for (let l = 0, h = e.length; l < h; l++) {
    i[t] = (a ? e[l][0] : e[l].x) * r, i[t + 1] = (a ? e[l][1] : e[l].y) * r, o !== Float32Array && (i[t] = Math.round(i[t]), i[t + 1] = Math.round(i[t + 1]));
    let u = n || 0;
    Array.isArray(n) && (u = n[l]), u = u ? Math.round(r * u) : 0, i[t + 2] = u, t += 3;
  }
  return i.trySetLength && i.trySetLength(t), t;
}
Pu.registerRenderer("gl", bP), Pu.registerRenderer("canvas", null);
const Eb = Math.PI / 180, Ob = 6378137 * Math.PI / 180;
function wP(i, t, e) {
  return function(r, n) {
    const s = 85.0511287798, o = n[0], a = Math.max(Math.min(s, n[1]), -s);
    let l;
    return l = a === 0 ? 0 : Math.log(Math.tan((90 + a) * Eb / 2)) / Eb, r[0] = o * Ob, r[1] = l * Ob, r;
  }(i, t);
}
function $8(i, t, e, r, n, s, o, a, l, h, u, c, f, d, p) {
  i === 0 ? function(g, m, v, _, y, x, w, b, T, A) {
    const M = 1 / (100 * x[0]), S = 1 / (100 * x[1]), P = A && A[0] || 0, C = A && A[1] || 0, k = [0, 0];
    for (let O = g; O < m; O += 3) {
      const R = O / 3 * 2, I = _[O] - P, D = _[O + 1] - C;
      v[R] = k[0] + I / w * M / b, v[R + 1] = k[1] - D / w * S / T;
    }
  }(t, e, r, n, 0, o, a, l, h, p) : i === 1 && function(g, m, v, _, y, x, w, b, T, A, M) {
    if (!g) return;
    let S, P, C, k;
    g[4] === 0 ? (S = g[0], P = g[1], C = g[2], k = g[3]) : (S = g[1], P = g[2], C = g[3], k = g[0]);
    const O = fc(S, P), R = fc(P, C), I = [], D = [], z = [];
    for (let H = m; H < v; H += 3) {
      const G = H / 3 * 2, $ = (x.x / T + y[H] / w) * b, K = x.y / T * b + (M ? y[H + 1] : -y[H + 1]) / w * b;
      we(I, $, K), A !== "EPSG:4326" && A !== "EPSG:4490" || wP(I, I), kb(D, I, S, P), kb(z, I, k, S), _[G] = fc(S, D) / O, _[G + 1] = fc(S, z) / R;
    }
  }(u, t, e, r, n, s, a, c, f, d, !!p);
}
function kb(i, t, e, r) {
  const n = e[0] - r[0], s = e[1] - r[1];
  let o = (t[0] - e[0]) * (e[0] - r[0]) + (t[1] - e[1]) * (e[1] - r[1]);
  return o /= n * n + s * s, i[0] = e[0] + o * n, i[1] = e[1] + o * s, i;
}
function Rb(i, t, e, r, n) {
  const s = 3 * t[e - 1], o = 3 * t[e - 1] + 1, a = i[s], l = i[o];
  return h = r, u = n, c = a, f = l, Math.sqrt((c - h) * (c - h) + (f - u) * (f - u));
  var h, u, c, f;
}
function Ib(i, t, e, r, n, s, o, a, l, h, u, c, f, d, p, g, m) {
  const v = t.length, _ = n / 3;
  for (let y = 2, x = v; y < x; y += 3) i[n + y - 2] = t[y - 2], i[n + y - 1] = t[y - 1], i[n + y - 0] = t[y] - o;
  n += v;
  for (let y = 2, x = v; y < x; y += 3) i[n + y - 2] = t[y - 2], i[n + y - 1] = t[y - 1], i[n + y - 0] = t[y] - a;
  n += v, i.trySetLength(n + v), i.copyWithin(n, n - 2 * v, n - v), n += v, i.trySetLength(n + v), i.copyWithin(n, n - 2 * v, n - v), n += v, (e = e || []).push(v / 3);
  for (let y = 0; y < e.length; y++)
    W8(_ + (e[y - 1] || 0), _ + e[y], i, v / 3, l, r, h, u, c, f, s, d, p, g);
  return n;
}
function W8(i, t, e, r, n, s, o, a, l, h, u, c, f, d, p) {
  const g = s.length;
  let m, v;
  for (let _ = i, y = t; _ < y - 1; _++) m = _, v = _ + 1, (_ - i) % 2 == 1 && (m += 2 * r, v += 2 * r), s.push(m + r, v, m), s.push(v + r, v, m + r);
  o && function(_, y, x, w, b, T, A, M, S, P, C) {
    let k, O = 0, R = 0, I = 0, D = 0;
    const z = [1, 3, 4];
    for (let H = T.length - 1; H >= 0; H--) {
      const G = T[H], $ = 3 * G + 1, K = 3 * G + 2, dt = b[3 * G], it = b[$], st = b[K];
      O || R || (O = Math.max(b[K], b[3 * T[H - 3] + 2]), R = Math.min(b[K], b[3 * T[H - 3] + 2]), k = O - R);
      let pt = I;
      const Ht = H % 6;
      _ === 0 ? (Ht === 5 && (D = Rb(b, T, H, dt, it)), pt = Ht === z[0] || Ht === z[1] || Ht === z[2] ? I : I + D) : _ === 1 && (Ht === z[0] || Ht === z[1] || Ht === z[2] ? pt = 0 : (Ht === 5 && (D = Rb(b, T, H, dt, it)), pt = D));
      const Rt = pt / S * (1 / (100 * P)) / A;
      let Tt;
      Tt = y === 1 ? st === O ? 1 : 0 : x === "bottom" ? st === O ? k / 100 / M : 0 : st === O ? 0 : -k / 100 / M, w[2 * G] = Rt, w[2 * G + 1] = Tt, Ht === 0 && (I += D);
    }
  }(a, l, h, u, e, s.slice(g, s.length), c[0], c[1], f, d);
}
function Z8(i) {
  const t = [i[0]];
  let e = i[0];
  for (let r = 1; r < i.length; r++) Array.isArray(i[r]) ? i[r][0] === e[0] && i[r][1] === e[1] && i[r][2] === e[2] || t.push(i[r]) : i[r].x === e.x && i[r].y === e.y && i[r].z === e.z || t.push(i[r]), e = i[r];
  return t;
}
const Qc = Xr.getInstance();
function X8(i, t, e, r, n, s, o, a, l, h, u, c, f, d, p, g) {
  t.top === void 0 && (t.top = !0), t.side === void 0 && (t.side = !0), Qc.reset();
  const { altitudeScale: m, altitudeProperty: v, defaultAltitude: _, heightProperty: y, minHeightProperty: x, defaultHeight: w, tangent: b, uv: T, topUVMode: A, sideUVMode: M, sideVerticalUVMode: S, top: P, side: C, textureYOrigin: k, topThickness: O } = t, R = !!g, I = function(Rt, Tt, { altitudeScale: $t, altitudeProperty: Wt, defaultAltitude: re, heightProperty: ie, minHeightProperty: Kt, defaultHeight: fe }, { center: Xt, side: Re, top: Oe, topThickness: oe, uvOrigin: nr, uv: Ke, uvSize: Ye, topUVMode: We, sideUVMode: bn, sideVerticalUVMode: wn, textureYOrigin: On, tileRatio: $e, centimeterToPoint: be, verticalCentimeterToPoint: Ee, positionType: Ze, res: yn, glScale: Cr, projectionCode: vr }, an, Ve) {
    let Qn = Tt / Rt[0].extent;
    Qn = 1;
    const Kr = Tt === 1 / 0, Br = Ve.get(), An = Ve.get(), Ri = Ve.get(), yr = Ve.get(), jr = Ve.get(), Rr = Ve.get(), un = Ve.get(), Wn = !!Ke, yo = !!Oe, hs = !!Re, Gr = Wn ? Ve.get() : null;
    function Qr(q, ut, ht, gt, kt, Pt) {
      let zt = ut;
      if (yo) {
        const St = Pf(yr, ht, 3);
        if (St.length === 0) return ut;
        if (ro(jr, yr), ut += yr.length, Pt) for (let Vt = 2, tt = St.length; Vt < tt; Vt += 3) St[Vt] += q / 3, St[Vt - 1] += q / 3, St[Vt - 2] += q / 3;
        ro(Rr, St), Wn && $8(We || 0, q, ut, Gr, jr, nr, be, $e, Ye[0], Ye[1], kt, yn, Cr, vr, Xt), oe > 0 && !hs && (ut = Ib(jr, yr, ht, Rr, ut, Gr, 0, oe, Tt, Wn, bn || 0, wn || 0, On, Ye, $e, Ee)), un.setLength(ut / 3), un.fill(1, zt / 3, ut / 3);
      }
      if (hs) {
        yo && (oe = 0), zt = ut, ut = Ib(jr, yr, ht, Rr, ut, Gr, oe, gt, Tt, Wn, bn || 0, wn || 0, On, Ye, $e, Ee), un.setLength(ut / 3);
        const St = yr.length / 3;
        un.fill(1, zt / 3, zt / 3 + St), un.fill(0, zt / 3 + St, zt / 3 + 2 * St), un.fill(1, zt / 3 + 2 * St, zt / 3 + 3 * St), un.fill(0, zt / 3 + 3 * St, ut / 3);
      }
      return ut;
    }
    let qi = 0, rr = 0, Ir = 0, _o = Rt.length;
    _l(an) && (Ir = an, _o = an + 1);
    let xo = 0, jl = !1;
    const Hs = Ve.get();
    for (; Ir < _o; Ir++) {
      const q = Rt[Ir], ut = q.id;
      _l(ut) && (Math.abs(ut) > xo && (xo = Math.abs(ut)), ut < 0 && (jl = !0));
      const ht = q.geometry, gt = q.properties.maptalks_ombb;
      let kt = Array.isArray(gt && gt[0] && gt[0][0]) ? gt[0] : gt;
      const { altitude: Pt, height: zt } = Er.getFeaAltitudeAndHeight(q, $t, Wt, re, ie, fe, Kt);
      qi = Math.max(Math.abs(Pt), qi);
      const St = jr.length;
      let Vt = 0, tt = rr;
      Hs.setLength(0), yr.setLength(0);
      const ct = Er.calculateSignedArea(ht[0]) < 0;
      for (let at = 0, vt = ht.length; at < vt; at++) {
        let Z = ht[at];
        ct && (Z = Z.reverse()), Z = Z8(Z);
        const Mt = Er.calculateSignedArea(Z) < 0;
        if (!Mt && at > 0 && (Vt++, kt = gt && gt[Vt], rr = Qr(tt, rr, Hs, zt * Qn, kt, Kr), yr.setLength(0), Hs.setLength(0), tt = rr), !Z.length) {
          at === vt - 1 && (rr = Qr(tt, rr, Hs, zt * Qn, kt, Kr));
          continue;
        }
        const mt = Z.length;
        Array.isArray(Z[0]) ? Z[0][0] === Z[mt - 1][0] && Z[0][1] === Z[mt - 1][1] || Z.push([Z[0][0], Z[0][1]]) : Z[0].x === Z[mt - 1].x && Z[0].y === Z[mt - 1].y || Z.push(Z[0]), Mt && Hs.push(yr.length / 3), U8(yr, yr.length, Z, Qn, Pt, !1, Ze), at === vt - 1 && (rr = Qr(tt, rr, Hs, zt * Qn, kt, Kr));
      }
      const _t = jr.length - St, bt = "__fea_idx".trim();
      for (let at = 0; at < _t / 3; at++) An.push(q[bt] === void 0 ? Ir : q[bt]), Br.push(Ir), _l(ut) && Ri.push(ut);
    }
    const E = Er.getUnsignedArrayType(An.length ? An[An.length - 1] : 0), V = {
      maxAltitude: qi,
      vertices: jr,
      verticeTypes: un,
      indices: Rr,
      pickingIds: Xr.createTypedArray(An, E),
      featureIndexes: Br
    };
    if (Ri.length) {
      const q = jl ? Er.getPosArrayType(xo) : Er.getUnsignedArrayType(xo);
      V.featureIds = Xr.createTypedArray(Ri, q);
    } else V.featureIds = [];
    return Gr && (Gr.setLength(jr.length / 3 * 2), V.uvs = Gr), V;
  }(i, e, {
    altitudeScale: m,
    altitudeProperty: v,
    defaultAltitude: _ || 0,
    heightProperty: y,
    minHeightProperty: x,
    defaultHeight: w || 0
  }, {
    center: g,
    top: P,
    side: C,
    topThickness: 10 * O || 0,
    uv: T || b,
    uvSize: [n, n],
    uvOrigin: r,
    topUVMode: A,
    sideUVMode: M,
    sideVerticalUVMode: S,
    textureYOrigin: k,
    tileRatio: a,
    centimeterToPoint: l,
    verticalCentimeterToPoint: h,
    positionType: p,
    res: s,
    glScale: o,
    projectionCode: f
  }, d, Qc), D = [], z = I.vertices.length / 3, H = Er.getIndexArrayType(z), G = Xr.createTypedArray(I.indices, H);
  delete I.indices, D.push(G.buffer, I.pickingIds.buffer);
  const $ = b ? Qc.get() : new Float32Array(3 * z);
  $.setLength && $.setLength(3 * z);
  const K = aM(I.vertices, G, $);
  let dt = !0;
  for (let Rt = 0; Rt < K.length; Rt++) {
    R || (K[Rt] = -K[Rt]);
    const Tt = K[Rt] % 1;
    1 - Math.abs(Tt) > 1e-6 ? dt = !1 : Tt !== 0 && (K[Rt] = Math.round(K[Rt]));
  }
  if (I.normals = K, b) {
    let Rt = Qc.get();
    Rt.setLength(4 * z), Rt = lM(I.vertices, I.normals, I.uvs, G, Rt), Rt = function(Tt, $t) {
      const Wt = new Float32Array($t.length), re = [], ie = [], Kt = [];
      for (let fe = 0; fe < $t.length; fe += 4) {
        const Xt = fe / 4 * 3;
        ne(ie, Tt[Xt] || 0, Tt[Xt + 1] || 0, Tt[Xt + 2] || 0), Sr(re, $t[fe] || 0, $t[fe + 1] || 0, $t[fe + 2] || 0, $t[fe + 3] || 0), oM(Kt, ie, re), nd(Wt.subarray(fe, fe + 4), Kt);
      }
      return Wt;
    }(I.normals, Rt), I.tangents = Rt, D.push(Rt.buffer), delete I.normals;
  }
  if (I.normals && (dt && (I.normals = Xr.createTypedArray(I.normals, Int8Array)), D.push(I.normals.buffer)), I.uvs) {
    const Rt = I.uvs;
    I.uvs = Xr.createTypedArray(Rt, Float32Array), D.push(I.uvs.buffer);
  }
  if (g) {
    const Rt = I.vertices;
    for (let Tt = 0; Tt < Rt.length; Tt += 3) Rt[Tt] -= g[0], Rt[Tt + 1] -= g[1];
  }
  const it = p || Er.getPosArrayType(Math.max(512, I.maxAltitude)), st = function(Rt, Tt, $t, Wt) {
    const re = {}, ie = {};
    if (Zc(Tt.polygonFill)) {
      let Kt = ln(Tt.polygonFill);
      const fe = new Uint8Array(4 * Wt.length);
      fe.fill(255);
      for (let Xt = 0; Xt < Wt.length; Xt++) {
        const Re = Rt[Wt[Xt]], Oe = Re.properties || {};
        Oe.$layer = Re.layer, Oe.$type = Re.type;
        let oe = Kt($t, Oe);
        Ft(oe) && (re.aColor = 1, Kt = ln(oe), oe = Kt($t, Oe)), delete Oe.$layer, delete Oe.$type, Ol.normalizeColor(Qi, oe), fe[4 * Xt] = Qi[0], fe[4 * Xt + 1] = Qi[1], fe[4 * Xt + 2] = Qi[2], fe[4 * Xt + 3] = Qi[3];
      }
      ie.aColor = fe;
    }
    if (Zc(Tt.polygonOpacity)) {
      let Kt = he(Tt.polygonOpacity);
      const fe = new Uint8Array(Wt.length);
      fe.fill(255);
      for (let Xt = 0; Xt < Wt.length; Xt++) {
        const Re = Rt[Wt[Xt]], Oe = Re.properties || {};
        Oe.$layer = Re.layer, Oe.$type = Re.type;
        let oe = Kt($t, Oe);
        Ft(oe) && (re.aOpacity = 1, Kt = ln(oe), oe = Kt($t, Oe)), delete Oe.$layer, delete Oe.$type, fe[Xt] = 255 * oe;
      }
      ie.aOpacity = fe;
    }
    return ie.dynamicAttributes = re, ie;
  }(i, u, c, I.featureIndexes), pt = function(Rt, Tt, $t, Wt, re) {
    const ie = [[], []], Kt = Zc(Wt.topPolygonFill), fe = Zc(Wt.bottomPolygonFill), Xt = [255, 255, 255, 255];
    if (Kt || fe) {
      let Re = Kt && ln(Wt.topPolygonFill), Oe = fe && ln(Wt.bottomPolygonFill), oe = null, nr = null, Ke = null, Ye = null;
      for (let We = 0; We < Tt.length; We++) {
        if (Rt[We] === 1 && !Kt || Rt[We] === 0 && !fe) continue;
        const bn = Rt[We] === 1;
        if (bn && Tt[We] === oe) {
          Rt[We] = Ke;
          continue;
        }
        if (!bn && Tt[We] === nr) {
          Rt[We] = Ye;
          continue;
        }
        const wn = $t[Tt[We]], On = wn.properties || {};
        On.$layer = wn.layer, On.$type = wn.type;
        let $e = bn ? Re : Oe, be = $e(re, On);
        Ft(be) && ($e = ln(be), be = $e(re, On)), delete On.$layer, delete On.$type, Ol.normalizeColor(Qi, be), FR(Qi, Qi, Xt);
        let Ee = q8(ie, Qi);
        Ee < 0 && (Ee = ie.length, ie.push(nd([], Qi))), Rt[We] = Ee, bn ? (oe = Tt[We], Ke = Ee) : (nr = Tt[We], Ye = Ee);
      }
    }
    return ie.slice(2);
  }(I.verticeTypes, I.featureIndexes, i, u, c), Ht = {
    data: {
      data: {
        aVertexColorType: pt.length <= 252 ? Xr.createTypedArray(I.verticeTypes, Uint8Array) : Xr.createTypedArray(I.verticeTypes, Uint16Array),
        aPosition: Xr.createTypedArray(I.vertices, it),
        aNormal: I.normals,
        aTexCoord0: I.uvs,
        aTangent: I.tangents,
        aPickingId: I.pickingIds
      },
      indices: G,
      properties: {
        maxAltitude: I.maxAltitude
      },
      dynamicAttributes: st.dynamicAttributes,
      vertexColors: pt
    },
    buffers: D
  };
  return I.featureIds.length ? (Ht.data.featureIds = I.featureIds, D.push(Ht.data.featureIds.buffer)) : Ht.data.featureIds = [], st.aColor && (Ht.data.data.aColor = st.aColor, Ht.buffers.push(st.aColor.buffer)), st.aOpacity && (Ht.data.data.aOpacity = st.aOpacity, Ht.buffers.push(st.aOpacity.buffer)), Ht.buffers.push(Ht.data.data.aPosition.buffer), Ht.data.pickingIdIndiceMap = Er.generatePickingIndiceIndex(Ht.data.data.aPickingId, Ht.data.indices), Ht;
}
const Qi = [];
function q8(i, t) {
  for (let e = 0; e < i.length; e++) if (zR(t, i[e])) return e;
  return -1;
}
class Y8 {
  constructor(t = [], e = J8) {
    if (this.data = t, this.length = this.data.length, this.compare = e, this.length > 0) for (let r = (this.length >> 1) - 1; r >= 0; r--) this.ni(r);
  }
  push(t) {
    this.data.push(t), this.length++, this.ii(this.length - 1);
  }
  pop() {
    if (this.length === 0) return;
    const t = this.data[0], e = this.data.pop();
    return this.length--, this.length > 0 && (this.data[0] = e, this.ni(0)), t;
  }
  peek() {
    return this.data[0];
  }
  ii(t) {
    const { data: e, compare: r } = this, n = e[t];
    for (; t > 0; ) {
      const s = t - 1 >> 1, o = e[s];
      if (r(n, o) >= 0) break;
      e[t] = o, t = s;
    }
    e[t] = n;
  }
  ni(t) {
    const { data: e, compare: r } = this, n = this.length >> 1, s = e[t];
    for (; t < n; ) {
      let o = 1 + (t << 1), a = e[o];
      const l = o + 1;
      if (l < this.length && r(e[l], a) < 0 && (o = l, a = e[l]), r(a, s) >= 0) break;
      e[t] = a, t = o;
    }
    e[t] = s;
  }
}
function J8(i, t) {
  return i < t ? -1 : i > t ? 1 : 0;
}
var By = {
  exports: {}
}, TP = function(i, t, e, r) {
  var n = i[0], s = i[1], o = !1;
  e === void 0 && (e = 0), r === void 0 && (r = t.length);
  for (var a = (r - e) / 2, l = 0, h = a - 1; l < a; h = l++) {
    var u = t[e + 2 * l + 0], c = t[e + 2 * l + 1], f = t[e + 2 * h + 0], d = t[e + 2 * h + 1];
    c > s != d > s && n < (f - u) * (s - c) / (d - c) + u && (o = !o);
  }
  return o;
}, AP = function(i, t, e, r) {
  var n = i[0], s = i[1], o = !1;
  e === void 0 && (e = 0), r === void 0 && (r = t.length);
  for (var a = r - e, l = 0, h = a - 1; l < a; h = l++) {
    var u = t[l + e][0], c = t[l + e][1], f = t[h + e][0], d = t[h + e][1];
    c > s != d > s && n < (f - u) * (s - c) / (d - c) + u && (o = !o);
  }
  return o;
};
By.exports = function(i, t, e, r) {
  return t.length > 0 && Array.isArray(t[0]) ? AP(i, t, e, r) : TP(i, t, e, r);
};
var K8 = By.exports.nested = AP;
By.exports.flat = TP;
function pm(i, t, e, r, n) {
  let s, o, a, l, h = t[0], u = r[0], c = 0, f = 0;
  u > h == u > -h ? (s = h, h = t[++c]) : (s = u, u = r[++f]);
  let d = 0;
  if (c < i && f < e) for (u > h == u > -h ? (o = h + s, a = s - (o - h), h = t[++c]) : (o = u + s, a = s - (o - u), u = r[++f]), s = o, a !== 0 && (n[d++] = a); c < i && f < e; ) u > h == u > -h ? (o = s + h, l = o - s, a = s - (o - l) + (h - l), h = t[++c]) : (o = s + u, l = o - s, a = s - (o - l) + (u - l), u = r[++f]), s = o, a !== 0 && (n[d++] = a);
  for (; c < i; ) o = s + h, l = o - s, a = s - (o - l) + (h - l), h = t[++c], s = o, a !== 0 && (n[d++] = a);
  for (; f < e; ) o = s + u, l = o - s, a = s - (o - l) + (u - l), u = r[++f], s = o, a !== 0 && (n[d++] = a);
  return s === 0 && d !== 0 || (n[d++] = s), d;
}
function Gu(i) {
  return new Float64Array(i);
}
const Ia = Gu(4), Db = Gu(8), Fb = Gu(12), Lb = Gu(16), Fr = Gu(4);
function Q8(i, t, e, r, n, s) {
  const o = (t - s) * (e - n), a = (i - n) * (r - s), l = o - a;
  if (o === 0 || a === 0 || o > 0 != a > 0) return l;
  const h = Math.abs(o + a);
  return Math.abs(l) >= 33306690738754716e-32 * h ? l : -function(u, c, f, d, p, g, m) {
    let v, _, y, x, w, b, T, A, M, S, P, C, k, O, R, I, D, z;
    const H = u - p, G = f - p, $ = c - g, K = d - g;
    O = H * K, b = 134217729 * H, T = b - (b - H), A = H - T, b = 134217729 * K, M = b - (b - K), S = K - M, R = A * S - (O - T * M - A * M - T * S), I = $ * G, b = 134217729 * $, T = b - (b - $), A = $ - T, b = 134217729 * G, M = b - (b - G), S = G - M, D = A * S - (I - T * M - A * M - T * S), P = R - D, w = R - P, Ia[0] = R - (P + w) + (w - D), C = O + P, w = C - O, k = O - (C - w) + (P - w), P = k - I, w = k - P, Ia[1] = k - (P + w) + (w - I), z = C + P, w = z - C, Ia[2] = C - (z - w) + (P - w), Ia[3] = z;
    let dt = function(Rt, Tt) {
      let $t = Tt[0];
      for (let Wt = 1; Wt < Rt; Wt++) $t += Tt[Wt];
      return $t;
    }(4, Ia), it = 22204460492503146e-32 * m;
    if (dt >= it || -dt >= it || (w = u - H, v = u - (H + w) + (w - p), w = f - G, y = f - (G + w) + (w - p), w = c - $, _ = c - ($ + w) + (w - g), w = d - K, x = d - (K + w) + (w - g), v === 0 && _ === 0 && y === 0 && x === 0) || (it = 11093356479670487e-47 * m + 33306690738754706e-32 * Math.abs(dt), dt += H * x + K * v - ($ * y + G * _), dt >= it || -dt >= it)) return dt;
    O = v * K, b = 134217729 * v, T = b - (b - v), A = v - T, b = 134217729 * K, M = b - (b - K), S = K - M, R = A * S - (O - T * M - A * M - T * S), I = _ * G, b = 134217729 * _, T = b - (b - _), A = _ - T, b = 134217729 * G, M = b - (b - G), S = G - M, D = A * S - (I - T * M - A * M - T * S), P = R - D, w = R - P, Fr[0] = R - (P + w) + (w - D), C = O + P, w = C - O, k = O - (C - w) + (P - w), P = k - I, w = k - P, Fr[1] = k - (P + w) + (w - I), z = C + P, w = z - C, Fr[2] = C - (z - w) + (P - w), Fr[3] = z;
    const st = pm(4, Ia, 4, Fr, Db);
    O = H * x, b = 134217729 * H, T = b - (b - H), A = H - T, b = 134217729 * x, M = b - (b - x), S = x - M, R = A * S - (O - T * M - A * M - T * S), I = $ * y, b = 134217729 * $, T = b - (b - $), A = $ - T, b = 134217729 * y, M = b - (b - y), S = y - M, D = A * S - (I - T * M - A * M - T * S), P = R - D, w = R - P, Fr[0] = R - (P + w) + (w - D), C = O + P, w = C - O, k = O - (C - w) + (P - w), P = k - I, w = k - P, Fr[1] = k - (P + w) + (w - I), z = C + P, w = z - C, Fr[2] = C - (z - w) + (P - w), Fr[3] = z;
    const pt = pm(st, Db, 4, Fr, Fb);
    O = v * x, b = 134217729 * v, T = b - (b - v), A = v - T, b = 134217729 * x, M = b - (b - x), S = x - M, R = A * S - (O - T * M - A * M - T * S), I = _ * y, b = 134217729 * _, T = b - (b - _), A = _ - T, b = 134217729 * y, M = b - (b - y), S = y - M, D = A * S - (I - T * M - A * M - T * S), P = R - D, w = R - P, Fr[0] = R - (P + w) + (w - D), C = O + P, w = C - O, k = O - (C - w) + (P - w), P = k - I, w = k - P, Fr[1] = k - (P + w) + (w - I), z = C + P, w = z - C, Fr[2] = C - (z - w) + (P - w), Fr[3] = z;
    const Ht = pm(pt, Fb, 4, Fr, Lb);
    return Lb[Ht - 1];
  }(i, t, e, r, n, s, h);
}
function tB(i, t, e) {
  t = Math.max(0, t === void 0 ? 2 : t), e = e || 0;
  var r = function(_) {
    for (var y = _[0], x = _[0], w = _[0], b = _[0], T = 0; T < _.length; T++) {
      var A = _[T];
      A[0] < y[0] && (y = A), A[0] > w[0] && (w = A), A[1] < x[1] && (x = A), A[1] > b[1] && (b = A);
    }
    var M = [y, x, w, b], S = M.slice();
    for (T = 0; T < _.length; T++) K8(_[T], M) || S.push(_[T]);
    return function(P) {
      P.sort(iB);
      for (var C = [], k = 0; k < P.length; k++) {
        for (; C.length >= 2 && nl(C[C.length - 2], C[C.length - 1], P[k]) <= 0; ) C.pop();
        C.push(P[k]);
      }
      for (var O = [], R = P.length - 1; R >= 0; R--) {
        for (; O.length >= 2 && nl(O[O.length - 2], O[O.length - 1], P[R]) <= 0; ) O.pop();
        O.push(P[R]);
      }
      return O.pop(), C.pop(), C.concat(O);
    }(S);
  }(i), n = new lb(16);
  n.toBBox = function(_) {
    return {
      minX: _[0],
      minY: _[1],
      maxX: _[0],
      maxY: _[1]
    };
  }, n.compareMinX = function(_, y) {
    return _[0] - y[0];
  }, n.compareMinY = function(_, y) {
    return _[1] - y[1];
  }, n.load(i);
  for (var s, o = [], a = 0; a < r.length; a++) {
    var l = r[a];
    n.remove(l), s = Hb(l, s), o.push(s);
  }
  var h = new lb(16);
  for (a = 0; a < o.length; a++) h.insert(gm(o[a]));
  for (var u = t * t, c = e * e; o.length; ) {
    var f = o.shift(), d = f.p, p = f.next.p, g = mm(d, p);
    if (!(g < c)) {
      var m = g / u;
      (l = eB(n, f.prev.p, d, p, f.next.next.p, m, h)) && Math.min(mm(l, d), mm(l, p)) <= m && (o.push(f), o.push(Hb(l, f)), n.remove(l), h.remove(f), h.insert(gm(f)), h.insert(gm(f.next)));
    }
  }
  f = s;
  var v = [];
  do
    v.push(f.p), f = f.next;
  while (f !== s);
  return v.push(f.p), v;
}
function eB(i, t, e, r, n, s, o) {
  for (var a = new Y8([], nB), l = i.data; l; ) {
    for (var h = 0; h < l.children.length; h++) {
      var u = l.children[h], c = l.leaf ? vm(u, e, r) : rB(e, r, u);
      c > s || a.push({
        node: u,
        dist: c
      });
    }
    for (; a.length && !a.peek().node.children; ) {
      var f = a.pop(), d = f.node, p = vm(d, t, e), g = vm(d, r, n);
      if (f.dist < p && f.dist < g && Nb(e, d, o) && Nb(r, d, o)) return d;
    }
    (l = a.pop()) && (l = l.node);
  }
  return null;
}
function nB(i, t) {
  return i.dist - t.dist;
}
function rB(i, t, e) {
  if (zb(i, e) || zb(t, e)) return 0;
  var r = tf(i[0], i[1], t[0], t[1], e.minX, e.minY, e.maxX, e.minY);
  if (r === 0) return 0;
  var n = tf(i[0], i[1], t[0], t[1], e.minX, e.minY, e.minX, e.maxY);
  if (n === 0) return 0;
  var s = tf(i[0], i[1], t[0], t[1], e.maxX, e.minY, e.maxX, e.maxY);
  if (s === 0) return 0;
  var o = tf(i[0], i[1], t[0], t[1], e.minX, e.maxY, e.maxX, e.maxY);
  return o === 0 ? 0 : Math.min(r, n, s, o);
}
function zb(i, t) {
  return i[0] >= t.minX && i[0] <= t.maxX && i[1] >= t.minY && i[1] <= t.maxY;
}
function Nb(i, t, e) {
  for (var r, n, s, o, a = Math.min(i[0], t[0]), l = Math.min(i[1], t[1]), h = Math.max(i[0], t[0]), u = Math.max(i[1], t[1]), c = e.search({
    minX: a,
    minY: l,
    maxX: h,
    maxY: u
  }), f = 0; f < c.length; f++) if (r = c[f].p, n = c[f].next.p, s = i, r !== (o = t) && n !== s && nl(r, n, s) > 0 != nl(r, n, o) > 0 && nl(s, o, r) > 0 != nl(s, o, n) > 0) return !1;
  return !0;
}
function nl(i, t, e) {
  return Q8(i[0], i[1], t[0], t[1], e[0], e[1]);
}
function gm(i) {
  var t = i.p, e = i.next.p;
  return i.minX = Math.min(t[0], e[0]), i.minY = Math.min(t[1], e[1]), i.maxX = Math.max(t[0], e[0]), i.maxY = Math.max(t[1], e[1]), i;
}
function Hb(i, t) {
  var e = {
    p: i,
    prev: null,
    next: null,
    minX: 0,
    minY: 0,
    maxX: 0,
    maxY: 0
  };
  return t ? (e.next = t.next, e.prev = t, t.next.prev = e, t.next = e) : (e.prev = e, e.next = e), e;
}
function mm(i, t) {
  var e = i[0] - t[0], r = i[1] - t[1];
  return e * e + r * r;
}
function vm(i, t, e) {
  var r = t[0], n = t[1], s = e[0] - r, o = e[1] - n;
  if (s !== 0 || o !== 0) {
    var a = ((i[0] - r) * s + (i[1] - n) * o) / (s * s + o * o);
    a > 1 ? (r = e[0], n = e[1]) : a > 0 && (r += s * a, n += o * a);
  }
  return (s = i[0] - r) * s + (o = i[1] - n) * o;
}
function tf(i, t, e, r, n, s, o, a) {
  var l, h, u, c, f = e - i, d = r - t, p = o - n, g = a - s, m = i - n, v = t - s, _ = f * f + d * d, y = f * p + d * g, x = p * p + g * g, w = f * m + d * v, b = p * m + g * v, T = _ * x - y * y, A = T, M = T;
  T === 0 ? (h = 0, A = 1, c = b, M = x) : (c = _ * b - y * w, (h = y * b - x * w) < 0 ? (h = 0, c = b, M = x) : h > A && (h = A, c = b + y, M = x)), c < 0 ? (c = 0, -w < 0 ? h = 0 : -w > _ ? h = A : (h = -w, A = _)) : c > M && (c = M, -w + y < 0 ? h = 0 : -w + y > _ ? h = A : (h = -w + y, A = _));
  var S = (1 - (u = c === 0 ? 0 : c / M)) * n + u * o - ((1 - (l = h === 0 ? 0 : h / A)) * i + l * e), P = (1 - u) * s + u * a - ((1 - l) * t + l * r);
  return S * S + P * P;
}
function iB(i, t) {
  return i[0] === t[0] ? i[1] - t[1] : i[0] - t[0];
}
class Ai {
  constructor(t, e) {
    this.x = t, this.y = e;
  }
  clone() {
    return new Ai(this.x, this.y);
  }
  normalize() {
    const t = this.length();
    this.x /= t, this.y /= t;
  }
  negate() {
    this.x = -this.x, this.y = -this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  diff(t) {
    return new Ai(this.x - t.x, this.y - t.y);
  }
  distance(t) {
    const e = this.x - t.x, r = this.y - t.y;
    return Math.sqrt(e * e + r * r);
  }
  dot(t) {
    return this.x * t.x + this.y * t.y;
  }
  equals(t) {
    return this.x === t.x && this.y === t.y;
  }
  orthogonal() {
    return new Ai(this.y, -this.x);
  }
}
function ef(i, t, e, r) {
  const n = t.x * r.y - t.y * r.x, s = e.x - i.x, o = e.y - i.y, a = (s * r.y - o * r.x) / n;
  return new Ai(i.x + a * t.x, i.y + a * t.y);
}
const fh = [], dh = [];
function Bb(i) {
  if (_l(i[0] && i[0].x)) {
    const t = [];
    let e = 0;
    for (let r = 0; r < i.length; r++) dh[e] ? (dh[e][0] = i[r].x, dh[e][1] = i[r].y) : dh[e] = [i[r].x, i[r].y], t.push(dh[e]), e++;
    i = t;
  }
  try {
    const t = tB(i, 1 / 0);
    let e = [1 / 0, 1 / 0], r = [-1 / 0, -1 / 0];
    for (let c = 0; c < t.length; c++) t[c][0] < e[0] && (e[0] = t[c][0]), t[c][0] > r[0] && (r[0] = t[c][0]), t[c][1] < e[1] && (e[1] = t[c][1]), t[c][1] > r[1] && (r[1] = t[c][1]);
    const n = [];
    let s = [], o = 0;
    for (let c = 0; c < t.length; c++) c === t.length - 1 && t[c][0] === t[0][0] && t[c][1] === t[0][1] || (wP(n, t[c], "EPSG:3857"), fh[o] ? (fh[o].x = n[0], fh[o].y = n[1]) : fh[o] = new Ai(n[0], n[1]), s.push(fh[o]), o++);
    Er.calculateSignedArea(s) < 0 && (s = s.reverse());
    const a = function(c) {
      let f, d = Number.MAX_VALUE;
      const p = function(C, k, O, R, I, D, z, H) {
        var G = ef(C, k, I, D), $ = ef(O, R, I, D), K = ef(z, H, C, k), dt = ef(z, H, O, R), it = G.distance($) * G.distance(K);
        it !== 0 && it < d && (f = [G, K, dt, $], d = it);
      };
      var g = [];
      for (let C = 0; C < c.length; C++) g.push(c[(C + 1) % c.length].diff(c[C])), g[C].normalize();
      var m, v, _, y, x = new Ai(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), w = new Ai(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
      for (let C = 0; C < c.length; C++) {
        var b = c[C];
        b.x < x.x && (x.x = b.x, m = C), b.x > w.x && (w.x = b.x, v = C), b.y < x.y && (x.y = b.y, y = C), b.y > w.y && (w.y = b.y, _ = C);
      }
      var T = new Ai(0, -1), A = new Ai(0, 1), M = new Ai(-1, 0), S = new Ai(1, 0);
      for (let C = 0; C < c.length; C++) {
        var P = [Math.acos(T.dot(g[m])), Math.acos(A.dot(g[v])), Math.acos(M.dot(g[_])), Math.acos(S.dot(g[y]))];
        switch (P.indexOf(Math.min.apply(Math, P))) {
          case 0:
            (A = (T = g[m].clone()).clone()).negate(), (S = (M = T.orthogonal()).clone()).negate(), m = (m + 1) % c.length;
            break;
          case 1:
            (T = (A = g[v].clone()).clone()).negate(), (S = (M = T.orthogonal()).clone()).negate(), v = (v + 1) % c.length;
            break;
          case 2:
            (S = (M = g[_].clone()).clone()).negate(), (A = (T = S.orthogonal()).clone()).negate(), _ = (_ + 1) % c.length;
            break;
          case 3:
            (M = (S = g[y].clone()).clone()).negate(), (A = (T = S.orthogonal()).clone()).negate(), y = (y + 1) % c.length;
        }
        p(c[m], T, c[v], A, c[_], M, c[y], S);
      }
      return f;
    }(s);
    if (!a || a.length !== 4) return null;
    const l = a[0].distance(a[1]), h = a[1].distance(a[2]), u = a.map((c) => [c.x, c.y]);
    return u.push(+(h > l)), u;
  } catch {
    return null;
  }
}
class Dl extends Rn {
  static fromJSON(t) {
    return op(t, "ExtrudePolygonLayer", Dl);
  }
  getPolygonOffsetCount() {
    return 0;
  }
  getPolygonOffset() {
    return 0;
  }
  onConfig(t) {
    const e = this.getRenderer();
    return e && e.onConfig(t), super.onConfig(t);
  }
  updateMaterial(t) {
    this.options.material || (this.options.material = {}), t ? Pe(this.options.material, t) : this.options.material = null;
    const e = this.getRenderer();
    return e && e.updateMaterial(t), this;
  }
  updateSideMaterial(t) {
    let e = !1;
    this.options.sideMaterial || (this.options.sideMaterial = {}, e = !0), t ? Pe(this.options.sideMaterial, t) : this.options.sideMaterial = null;
    const r = this.getRenderer();
    return r && (e && r.ri(), r.updateSideMaterial(t)), this;
  }
  updateDataConfig(t) {
    if (!t) return this;
    this.options.dataConfig || (this.options.dataConfig = {});
    const e = JSON.parse(JSON.stringify(this.options.dataConfig));
    Pe(this.options.dataConfig, t);
    const r = this.getRenderer();
    return r && r.updateDataConfig(t, e), this;
  }
}
Dl.registerJSONType("ExtrudePolygonLayer"), Dl.mergeOptions({
  cullFace: !1,
  castShadow: !0
});
const ym = {
  polygonFill: {
    type: "identity",
    default: [1, 1, 1, 1],
    property: "_symbol_polygonFill"
  },
  polygonOpacity: {
    type: "identity",
    default: 1,
    property: "_symbol_polygonOpacity"
  },
  topPolygonFill: {
    type: "identity",
    default: [1, 1, 1, 1],
    property: "_symbol_topPolygonFill"
  },
  bottomPolygonFill: {
    type: "identity",
    default: [1, 1, 1, 1],
    property: "_symbol_bottomPolygonFill"
  }
}, jb = {
  defaultAltitude: 20
}, Gb = (i) => i.properties.top === 1;
Dl.registerRenderer("gl", class extends bP {
  constructor(...i) {
    super(...i), this.GeometryTypes = [vn, Vo];
  }
  ei(i) {
    return [i];
  }
  onConfig(i) {
    this.painter && (Yn(i.cullFace) || this.painter.updateSceneConfig({
      cullFace: i.cullFace
    }));
  }
  updateMaterial(i) {
    this.painter && (this.painter.si(i), this.layer.options.sideMaterial || this.sidePainter.si(i), this.setToRedraw());
  }
  ri() {
    this.sidePainter && this.sidePainter.deleteMaterial();
  }
  updateSideMaterial(i) {
    this.sidePainter && (i ? this.sidePainter.si(i) : (this.sidePainter.deleteMaterial(), this.sidePainter.si(this.layer.options.material)), this.setToRedraw());
  }
  updateDataConfig(i, t) {
    this.painter && (this.painter.updateDataConfig(i, t), this.Dn());
  }
  updateBloom(i) {
    super.updateBloom(i), this.sidePainter && this.Kn(this.sidePainter, this.sidePainterSymbol, i);
  }
  needCheckPointLineSymbols() {
    return !1;
  }
  draw(i, t) {
    return super.draw(i, t);
  }
  createPainter() {
    const i = Rn.get3DPainterClass("lit");
    this.painterSymbol = Pe({}, ym), this.sidePainterSymbol = Pe({}, ym), this.Jn(this.painterSymbol, i.getBloomSymbol());
    const t = Pe({}, jb, this.layer.options.dataConfig || {});
    this.layer.options.material && (this.painterSymbol.material = this.layer.options.material), this.layer.options.sideMaterial ? this.sidePainterSymbol.material = this.layer.options.sideMaterial : this.sidePainterSymbol.material = this.layer.options.material;
    const e = {
      cullFace: this.layer.options.cullFace
    };
    Object.defineProperty(e, "castShadow", {
      enumerable: !0,
      get: () => this.layer.options.castShadow
    });
    const r = Pe({}, t);
    r.upsideUpTexture = !0;
    const n = new i(this.regl, this.layer, this.painterSymbol, e, 0, r);
    return this.sidePainter = new i(this.regl, this.layer, this.sidePainterSymbol, e, 0, t), n;
  }
  xt(...i) {
    super.xt(...i);
    const t = this.painter;
    this.painter = this.sidePainter, super.xt(...i), this.painter = t;
  }
  mn(...i) {
    const t = i[0], e = t.sceneFilter;
    t.sceneFilter = (o) => (!e || e(o)) && Gb(o);
    const r = super.mn(...i);
    t.sceneFilter = (o) => (!e || e(o)) && Gb(o);
    const n = this.painter;
    this.painter = this.sidePainter;
    const s = t.sceneFilter = (o) => (!e || e(o)) && ((a) => a.properties.side === 1)(o);
    return super.mn(...i), this.painter = n, t.sceneFilter = e, {
      redraw: r.redraw || s.redraw,
      drawCount: (r.drawCount || 0) + (s.drawCount || 0)
    };
  }
  createMesh(i, t, e, r, n, s) {
    const o = [];
    this.oi = s;
    const a = this.ai(r, e, !0, !1), l = this.ai(r, e, !1, !0);
    if (a) {
      const h = this.bn(a, i, t, e, r, null, s);
      h.meshes[0].properties.top = 1, o.push(h);
    }
    if (l) {
      const h = this.bn(l, i, t, e, r, null, s);
      h.meshes[0].properties.side = 1, o.push(h);
    }
    return o;
  }
  ai(i, t, e, r) {
    const n = this.getMap();
    t = ym;
    const s = this.oi, o = n.getZoom(), a = new Y(0, 0), l = new lt(0, 0), h = Pe({}, jb, this.layer.options.dataConfig);
    if (h.tangent = 1, h.top && (h.top = e), h.side && (h.side = r), h.top === !1 && h.side === !1 || !i.length) return null;
    const u = n.getGLRes(), c = n.getProjection().code, f = e ? this.painterSymbol && this.painterSymbol.material : this.sidePainterSymbol && this.sidePainterSymbol.material, d = f && f.textureWidth || hP, p = [ns(n, 1, l, u) / 100, ns(n, 1, l, u, 1) / 100];
    return X8(i, h, 1 / 0, a, d, n.getGLRes(), 1, 1, p, this.yt, t, o, c, void 0, Float32Array, s);
  }
  updateMesh(i) {
    const t = i[Gn];
    let e = this.features[t];
    if (!e) return;
    const r = this.ai([e], this.painterSymbol, !0, !1);
    let n = 0;
    r && r.data && this.zn(this.meshes[n++], e.id, r);
    const s = this.ai([e], this.painterSymbol, !1, !0);
    s && s.data && this.zn(this.meshes[n++], e.id, s);
  }
  En(i) {
    if (i.getProperties() || i.setProperties({}), !i.getProperties().maptalks_ombb) {
      const t = i.getCoordinates();
      if (i instanceof Vo) {
        const e = [];
        for (let r = 0; r < t.length; r++) {
          const n = t[r] && t[r][0];
          e[r] = Bb(n);
        }
        i.getProperties().maptalks_ombb = e;
      } else {
        const e = Bb(t[0]);
        i.getProperties().maptalks_ombb = e;
      }
    }
    return super.En(i);
  }
  resizeCanvas(i) {
    super.resizeCanvas(i), this.sidePainter && this.sidePainter.resize(this.canvas.width, this.canvas.height);
  }
  onRemove() {
    super.onRemove(), this.sidePainter && (this.sidePainter.delete(), delete this.sidePainter);
  }
  drawOutline(i) {
    if (super.drawOutline(i), this.Mt && this.sidePainter && this.sidePainter.outlineAll(i), this.Qn) for (let t = 0; t < this.Qn.length; t++) this.sidePainter && this.sidePainter.outline(i, this.Qn[t]);
  }
  getShadowMeshes() {
    return this.painter ? this.painter.getShadowMeshes() : [];
  }
}), Dl.registerRenderer("canvas", null);
const _m = {
  redraw: !1,
  retire: !1
}, sB = [];
let Vb = 1;
function Hr(i, t) {
  return ip.extend(i, {
    init: function() {
      this.li = {};
    },
    isVisible() {
      return this.painter && this.painter.isVisible();
    },
    supportRenderMode: function(e) {
      return this.painter.supportRenderMode(e);
    },
    hasMesh() {
      return this.painter && this.painter.hasMesh();
    },
    startFrame: function(e) {
      const r = e.layer, n = e.regl, s = e.sceneConfig, o = e.dataConfig, a = e.symbol;
      let l = this.painter;
      if (!l) {
        const u = e.pluginIndex;
        l = this.painter = new t(n, r, a, s, u, o);
      }
      this.li || (this.li = {});
      const h = s.excludes;
      this.hi ? h !== this.hi && (this.ui = h ? cS(h) : null, this.hi = h) : h && (this.hi = h), l.startFrame(e), this.ci = {};
    },
    updateCollision: function(e) {
      const r = this.painter;
      return r && r.isVisible() ? r.updateCollision(e) : null;
    },
    prepareRender: function(e) {
      const r = this.painter;
      return r && r.isVisible() ? r.prepareRender(e) : null;
    },
    endFrame: function(e) {
      const r = this.painter;
      return r && r.isVisible() ? r.render(e) : null;
    },
    getShadowMeshes() {
      const e = this.painter;
      return e && e.getShadowMeshes && e.getShadowMeshes() || sB;
    },
    createTile: function(e) {
      const { tileCache: r, tileData: n } = e;
      let s = !1;
      const o = this.painter;
      if (!o) return {
        retire: s
      };
      const a = this.fi(e);
      let l = r.geometry;
      if (!l) {
        const u = n.features, c = n.data;
        if (!c || !c.length) return {
          retire: s
        };
        const f = c;
        if (this.painter.colorSymbol && !function(d) {
          if (!d) return !0;
          for (const p in d) return !1;
          return !0;
        }(u)) for (let d = 0; d < c.length; d++) {
          const p = this.di(u, c[d].data.aPickingId, c[d].indices, c[d].data.aPosition, c[d].positionSize);
          c[d].data.aColor = p;
        }
        l = r.geometry = o.createGeometries(f, u);
        for (let d = 0; d < l.length; d++) l[d] && l[d].geometry && (s = !0, l[d].geometry.properties.features = u, this.An(l[d].geometry, e));
      }
      let h = this.H(a);
      if (!h) {
        const { meshes: u, retire: c } = this.pi(l, e);
        s || (s = c), h = u;
      }
      return {
        retire: s
      };
    },
    pi(e, r) {
      const { layer: n, tileInfo: s, tileExtent: o, tileTransform: a, tileTranslationMatrix: l, tileVectorTransform: h, tileZoom: u, sceneConfig: c } = r;
      let f = !1;
      const d = this.painter, p = [s.extent2d.xmin, s.extent2d.ymax], g = d.createMeshes(e, a, {
        tileExtent: o,
        tilePoint: p,
        tileZoom: u,
        tileTranslationMatrix: l,
        tileVectorTransform: h
      }, r);
      if (g.length) {
        const m = n.getRenderer().isEnableTileStencil();
        for (let _ = 0; _ < g.length; _++) g[_] && (f = !0, this.mi(g[_], a, r.timestamp, Vb++, m));
        c.animation && (g.yi = r.timestamp);
        const v = this.fi(r);
        this.li[v] = g;
      }
      return {
        meshes: g,
        retire: f
      };
    },
    paintTile: function(e) {
      const { tileCache: r, tileInfo: n, tileZoom: s, sceneConfig: o } = e, a = this.painter;
      if (!a) return _m;
      let l = r.geometry;
      if (!l) return _m;
      let h = !1;
      const u = this.fi(e);
      let c = this.H(u);
      if (!c) {
        const { meshes: p, retire: g } = this.pi(l, e);
        h || (h = g), c = p;
      }
      if (!c.length) return _m;
      const f = a.getTileLevelValue(n, s);
      c.forEach((p) => {
        p.properties.tile = n, p.properties.level = f;
      });
      let d = !1;
      if (!this.ci[u]) {
        let p = null, g = o.animation;
        if (g) {
          const m = e.sceneConfig.animationDuration || 800, v = (e.timestamp - c.yi) / m, _ = c[0].properties.createTime;
          c.yi - _ < m && v < 1 && (g !== !0 && g !== 1 || (g = "linear"), p = g === "linear" ? v : DH(g, v), d = !0);
        }
        a.addMesh(c, p, e), this.ci[u] = 1;
      }
      return {
        redraw: d,
        retire: h
      };
    },
    mi: function(e, r, n, s, o) {
      if (e.properties.tileTransform = r, e.properties.createTime = n, e.properties.meshKey = s, e.needUpdateShadow = !0, o) {
        const a = e.defines || {};
        a.ENABLE_TILE_STENCIL = 1, e.setDefines(a), "stencilRef" in e.uniforms || Object.defineProperty(e.uniforms, "stencilRef", {
          enumerable: !0,
          get: function() {
            return e.properties.tile && e.properties.tile.stencilRef !== void 0 ? e.properties.tile.stencilRef : e.properties.level;
          }
        });
      }
    },
    An: function(e, r) {
      const { layer: n, tileInfo: s } = r, o = n.getMap(), a = (n.getSpatialReference ? n.getSpatialReference() : o.getSpatialReference()).getResolution(s.z), l = r.tileExtent / n.getTileSize().width;
      e.properties.tileResolution = a, e.properties.tileRatio = l, e.properties.z = s.z, e.properties.tileExtent = r.tileExtent;
    },
    updateSceneConfig: function(e) {
      const r = this.painter;
      r && r.updateSceneConfig(e.sceneConfig);
    },
    updateDataConfig: function(e, r) {
      const n = this.painter;
      return !n || n.updateDataConfig(e, r);
    },
    updateSymbol: function(e, r) {
      const n = this.painter;
      if (!n) return !1;
      if (n.shouldDeleteMeshOnUpdateSymbol(e)) {
        if (this.li) for (const s in this.li) n.deleteMesh(this.li[s], !0);
        delete this.li, delete this.ci;
      }
      return n.updateSymbol(e, r);
    },
    pick: function(e, r, n) {
      return this.painter && this.painter.pick ? this.painter.pick(e, r, n) : null;
    },
    deleteTile: function(e) {
      if (!this.li) return;
      const r = this.fi(e), n = this.li[r];
      n && this.painter && this.painter.deleteMesh(n), delete this.li[r], this.ci && delete this.ci[r];
    },
    remove: function() {
      const e = this.painter;
      if (e && this.li) {
        for (const r in this.li) e.deleteMesh(this.li[r]);
        e.delete(), delete this.painter;
      }
      delete this.li, delete this.ci;
    },
    resize: function(e, r) {
      const n = this.painter;
      n && n.resize(e, r);
    },
    needToRedraw: function() {
      return !!this.painter && this.painter.needToRedraw();
    },
    needToRetireFrames: function() {
      return !!this.painter && this.painter.needToRetireFrames();
    },
    isAnimating() {
      return !!this.painter && this.painter.isAnimating();
    },
    needToRefreshTerrainTileOnZooming: function() {
      return !!this.painter && this.painter.needToRefreshTerrainTileOnZooming();
    },
    isTerrainSkin: function() {
      return !!this.painter && this.painter.isTerrainSkin();
    },
    isTerrainVector: function() {
      return !!this.painter && this.painter.isTerrainVector();
    },
    di: function(e, r, n, s, o = 3) {
      if (!s || !e || !r.length) return null;
      const a = new Uint8Array(s.length / o * 4);
      let l, h;
      const u = this.painter.colorSymbol, c = {};
      let f;
      for (let d = 0, p = r.length; d < p; d++) {
        const g = r[d];
        if (l = e[g].symbol, h = c[g], !h) if (u) {
          let m;
          m = typeof u == "function" ? u(e[g].feature && e[g].feature.properties) : u, m = Zi(m), h = c[g] = m.array();
        } else h = c[g] = [255, 255, 255];
        f = 4 * d, a[f] = h[0], a[f + 1] = h[1], a[f + 2] = h[2], a[f + 3] = 255 * (l[this.painter.opacitySymbol] || 1);
      }
      return a;
    },
    fi: function(e) {
      const r = e.tileInfo;
      return r.meshKey || (r.meshKey = Vb++), r.meshKey;
    },
    H: function(e) {
      return this.li[e];
    },
    gi(e, r) {
      if (Array.isArray(e)) e.forEach((n, s) => {
        const { features: o } = n.properties;
        this.vi(n, r[s], o);
      });
      else {
        const { features: n } = e.properties;
        this.vi(e, Array.isArray(r) ? r[0] : r, n);
      }
    },
    vi(e, r, n) {
      const s = r.featureIndexes || r.data.featureIndexes;
      if (s) if (this.ui) {
        const o = r.indices;
        let a = null, l = !1;
        const h = [];
        for (let u = 0; u < o.length; u++) {
          const c = n[s[o[u]]];
          a !== null && a === o[u] || (l = this.ui(c.feature), a = o[u]), l || h.push(o[u]);
        }
        e.setElements(new r.indices.constructor(h));
      } else e.setElements(r.indices);
    },
    outline(e, r) {
      const n = this.painter;
      n && n.outline(e, r);
    },
    outlineAll(e) {
      const r = this.painter;
      r && r.outlineAll(e);
    },
    needPolygonOffset() {
      const e = this.painter;
      return e && e.needPolygonOffset();
    },
    highlight(e) {
      const r = this.painter, n = this.style.name, s = this.renderIndex;
      if (e) {
        const o = [];
        if (e.forEach((a, l) => {
          a.plugin !== void 0 && a.plugin !== null && (Array.isArray(a.plugin) ? a.plugin.length && a.plugin.indexOf(n) < 0 && a.plugin.indexOf(s) < 0 && o.push(l) : a.plugin !== n && a.plugin !== s && o.push(l));
        }), o.length) {
          const a = new Map(e);
          for (let l = 0; l < o.length; l++) a.delete(o[l]);
          e = a;
        }
      }
      return r && r.highlight(e);
    },
    cancelAllHighlight() {
      const e = this.painter;
      return e && e.cancelAllHighlight();
    }
  });
}
class oB {
  constructor() {
    this.xi = 1;
  }
  write(t, e) {
    const r = t.gl, n = this.xi++;
    return t.stencilFunc(r.ALWAYS, n, 255), t.draw(e), n;
  }
  start(t) {
    const e = t.gl;
    e.clearStencil(255), e.clear(e.STENCIL_BUFFER_BIT), this.xi = 1, t.start();
  }
  end(t) {
    t.end();
  }
}
function wl(i) {
  return !i || (i.empty !== void 0 || (i.empty = function(t) {
    for (const e in t) return !1;
    return !0;
  }(i)), i.empty);
}
const mn = "_fn_type_";
function Ns(i, t, e) {
  if (!wl(i.properties.features)) for (let r = 0; r < e.length; r++) {
    const { symbolName: n } = e[r];
    (i.bi = i.bi || {})[n] = t[n], MP(i, t, e[r]);
  }
}
function MP(i, t, e) {
  const r = function(l) {
    const h = l.properties;
    let u = h.aPickingId;
    return u || (u = h.aPickingId = new l.data.aPickingId.constructor(l.data.aPickingId)), u;
  }(i), { attrName: n, symbolName: s, related: o } = e;
  let a = i.data[n];
  return a ? rs(t[s]) || function(l, h) {
    if (!Array.isArray(l)) return !1;
    for (let u = 0; u < l.length; u++) if (rs(h[l[u]])) return !0;
    return !1;
  }(o, t) ? (rs(t[s]) && Ub(i, t, e), a) : (i.deleteData(n), J0(i, n), null) : rs(t[s]) ? (a = i.data[n] = new e.type(e.width * r.length), function(l, h, u, c) {
    const { attrName: f } = c, d = (mn + f + "Index").trim();
    Ub(h, u, c);
    const p = h.properties[d];
    K0(h, p, c);
  }(a, i, t, e), a) : null;
}
function Ub(i, t, e) {
  const { attrName: r, symbolName: n } = e, s = i.properties, o = (mn + r + "Index").trim(), a = (mn + r).trim();
  if (s[o] && s[a]) return;
  const l = function(p) {
    if (!p) return hB;
    const g = [];
    for (let m = 0; m < p.length; m++) Ft(p[m][1]) && !he(p[m][1]).isZoomConstant && g.push(p[m][0]);
    return g;
  }(t[n].stops), h = t[n].type === "identity" && Ol.checkIfIdentityZoomDependent(n, t[n].property, s.features);
  if (!h && !l.length) return void J0(i, r);
  const { features: u, aPickingId: c } = s, f = function(p, g, m, v, _) {
    const y = [];
    let x = 0, w = g[0];
    for (let b = 1, T = g.length; b < T; b++) g[b] === w && b !== T - 1 || ((_ || lB(p[w].feature, m, v)) && y.push(x, b === T - 1 ? T : b), w = g[b], x = b);
    return y;
  }(u, c, t[n].property, l, h);
  if (!f.length) return void J0(i, r);
  const d = i.data[r];
  s[o] = f, s[a] = d.BYTES_PER_ELEMENT ? new d.constructor(d) : new e.type(d.length);
}
function J0(i, t) {
  const e = i.properties, r = (mn + t + "Index").trim(), n = (mn + t).trim();
  delete e[r], delete e[n];
}
function SP(i, t, e, r, n) {
  if (!r) return;
  const s = r.geometry;
  if (!s || wl(s.properties.features)) return;
  const o = r.geometry.properties.layer;
  for (let a = 0; a < e.length; a++) {
    const l = e[a], h = l.attrName;
    if (!(aB(s, t, l) || o.fe && o.fe(r.geometry.Ai))) {
      const { aPickingId: f } = s.properties;
      if (!f || s.wi === n) continue;
      const d = (mn + h + "Index").trim(), p = s.properties[d];
      if (!p) continue;
      K0(s, p, l);
      continue;
    }
    const u = MP(s, t, l), c = l.define;
    if (u) {
      const f = (mn + h + "Index").trim();
      if (K0(s, s.properties[f], l), o.ce && (s.Ai = o.ce()), c) {
        const d = r.defines;
        d[c] = 1, r.setDefines(d);
      }
      s.generateBuffers(i);
    } else if (c) {
      const f = r.defines;
      f[c] && (delete f[c], r.setDefines(f));
    }
  }
  s.wi = n;
}
function aB(i, t, e) {
  const r = t[e.symbolName], n = i.bi;
  return !fu(r, n[e.symbolName]) && (n[e.symbolName] = r, !0);
}
function lB(i, t, e) {
  for (let r = 0; r < e.length; r++) if (t[0] === "$" && i[t.substring(1)] === e[r] || i.properties[t] === e[r]) return !0;
  return !1;
}
const hB = [];
function K0(i, t, e) {
  const { attrName: r, evaluate: n } = e, { aPickingId: s, features: o } = i.properties;
  let a;
  if (t) {
    const l = (mn + r).trim();
    a = i.properties[l];
    const h = a.length / s.length, u = t.length;
    for (let c = 0; c < u; c += 2) {
      const f = t[c], d = t[c + 1];
      let p = o[s[f]];
      p && p.feature && $b(a, p, n, f, d, h, i);
    }
  } else {
    if (a = i.data[r], function(c) {
      return Array.isArray(c) || c.constructor === Float32Array || c.constructor === Float64Array || c.constructor === Uint8Array || c.constructor === Int8Array || c.constructor === Uint16Array || c.constructor === Int16Array || c.constructor === Uint32Array || c.constructor === Int32Array || c.constructor === Uint8ClampedArray;
    }(a)) a.dirty = !0;
    else {
      const c = (mn + r).trim();
      a = i.properties[c], a || (a = i.properties[c] = new e.type(e.width * s.length), a.dirty = !0);
    }
    const l = a.length / s.length, h = s.length;
    let u = 0;
    for (let c = 0; c < h; c++) {
      if (s[c] === s[u] && c < h - 1) continue;
      let f = o[s[u]];
      f && f.feature && ($b(a, f, n, u, c === h - 1 ? h : c, l, i), u = c);
    }
  }
  a.dirty && (i.updateData(r, a), a.dirty = !1);
}
const xm = {};
function $b(i, t, e, r, n, s, o) {
  const a = (t = t.feature).properties || {};
  a.$layer === void 0 && (t.properties || (t.properties = a), a.$layer = t.layer, a.$type = t.type);
  const l = o.properties.layer;
  if (l.getFeatureState && (xm.layer = t.layer, xm.id = t.id, t[ws] && (t[ws] = null), !gn(t.id))) {
    const u = l.getFeatureState(xm);
    t.properties[ws] = u;
  }
  const h = e(a, o, i, r * s);
  if (Array.isArray(h)) {
    let u = !1;
    for (let c = 0; c < s; c++) if (i[r * s + c] !== h[c]) {
      u = !0;
      break;
    }
    if (u) {
      for (let c = r * s; c < n * s; c += s) i.set(h, c);
      i.dirty = !0;
    }
  } else i[r] !== h && (Nh(i, h, r, n), i.dirty = !0);
}
function rs(i) {
  return Ol.isFnTypeSymbol(i);
}
var nf = Za;
function Za(i, t) {
  this.x = i, this.y = t;
}
Za.prototype = {
  clone: function() {
    return new Za(this.x, this.y);
  },
  add: function(i) {
    return this.clone()._i(i);
  },
  sub: function(i) {
    return this.clone().Si(i);
  },
  multByPoint: function(i) {
    return this.clone().Mi(i);
  },
  divByPoint: function(i) {
    return this.clone().Pi(i);
  },
  mult: function(i) {
    return this.clone().Ti(i);
  },
  div: function(i) {
    return this.clone().ki(i);
  },
  rotate: function(i) {
    return this.clone().Oi(i);
  },
  rotateAround: function(i, t) {
    return this.clone().Ii(i, t);
  },
  matMult: function(i) {
    return this.clone().Fi(i);
  },
  unit: function() {
    return this.clone().Ci();
  },
  perp: function() {
    return this.clone().Ei();
  },
  round: function() {
    return this.clone().Di();
  },
  mag: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  equals: function(i) {
    return this.x === i.x && this.y === i.y;
  },
  dist: function(i) {
    return Math.sqrt(this.distSqr(i));
  },
  distSqr: function(i) {
    var t = i.x - this.x, e = i.y - this.y;
    return t * t + e * e;
  },
  angle: function() {
    return Math.atan2(this.y, this.x);
  },
  angleTo: function(i) {
    return Math.atan2(this.y - i.y, this.x - i.x);
  },
  angleWith: function(i) {
    return this.angleWithSep(i.x, i.y);
  },
  angleWithSep: function(i, t) {
    return Math.atan2(this.x * t - this.y * i, this.x * i + this.y * t);
  },
  Fi: function(i) {
    var t = i[0] * this.x + i[1] * this.y, e = i[2] * this.x + i[3] * this.y;
    return this.x = t, this.y = e, this;
  },
  _i: function(i) {
    return this.x += i.x, this.y += i.y, this;
  },
  Si: function(i) {
    return this.x -= i.x, this.y -= i.y, this;
  },
  Ti: function(i) {
    return this.x *= i, this.y *= i, this;
  },
  ki: function(i) {
    return this.x /= i, this.y /= i, this;
  },
  Mi: function(i) {
    return this.x *= i.x, this.y *= i.y, this;
  },
  Pi: function(i) {
    return this.x /= i.x, this.y /= i.y, this;
  },
  Ci: function() {
    return this.ki(this.mag()), this;
  },
  Ei: function() {
    var i = this.y;
    return this.y = this.x, this.x = -i, this;
  },
  Oi: function(i) {
    var t = Math.cos(i), e = Math.sin(i), r = t * this.x - e * this.y, n = e * this.x + t * this.y;
    return this.x = r, this.y = n, this;
  },
  Ii: function(i, t) {
    var e = Math.cos(i), r = Math.sin(i), n = t.x + e * (this.x - t.x) - r * (this.y - t.y), s = t.y + r * (this.x - t.x) + e * (this.y - t.y);
    return this.x = n, this.y = s, this;
  },
  Di: function() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
}, Za.convert = function(i) {
  return i instanceof Za ? i : Array.isArray(i) ? new Za(i[0], i[1]) : i;
};
const Zr = [];
function is(i, t, e, r, n) {
  return Sr(Zr, t[0], t[1], t[2], 1), ho(Zr, Zr, e), i[2] = Zr[3], Sl(Zr, Zr, 1 / Zr[3]), i[0] = (Zr[0] + 1) * r / 2, i[1] = (1 - Zr[1]) * n / 2, i;
}
const uB = [], cB = [], fB = [], dB = [-99999, -99999], CP = new Y(0, 0), pB = [];
function bm(i, t, e, r, n, s, o, a) {
  const { res: l, extent: h, extent2d: u } = e.properties.tile, { xmin: c, ymax: f } = u, d = c + r.x * n, p = f - r.y * n;
  let g = null;
  if (a) {
    for (let y = 0; y < a.length; y++) if (PP(a[y], d, p, l)) {
      g = a[y];
      break;
    }
  }
  if (!g) return dB;
  const m = CP.set(c, f), v = s.queryTilePointTerrain(r, g, m, h, l), _ = v[0] === null ? xl : v[0];
  if (_) {
    let y = ne(pB, r.x, r.y, 0);
    return y[2] += 100 * _, y = is(i, y, o, t.width, t.height), y;
  }
  return i[0] = r.x, i[1] = r.y, i;
}
function PP(i, t, e, r) {
  const n = CP.set(t, e)._multi(r / i.res);
  return i.extent2d.contains(n);
}
const { loginIBLResOnCanvas: gB, logoutIBLResOnCanvas: mB, getIBLResOnCanvas: vB } = Kn.PBRUtils, Wb = [], Zb = [], yB = new Y(0, 0), Xb = new Y(0, 0), qb = new Float32Array(1), Yb = [], _B = (i) => i.properties.level === 0, xB = (i) => i.properties.level > 0;
class jy {
  static getBloomSymbol() {
    return ["bloom"];
  }
  constructor(t, e, r, n, s, o) {
    this.Ni = !0, this.regl = t, this.layer = e, this.canvas = t._gl.canvas, this.sceneConfig = n || {}, this.dataConfig = o || {}, this.pluginIndex = s, this.scene = new ur(), this.pickingFBO = e.getRenderer().pickingFBO, this.Li = new oB(), this.level0Filter = _B, this.levelNFilter = xB, this.loginTextureCache(), this.symbolDef = Array.isArray(r) ? r.map((a) => hm(a)) : [hm(r)], this.Ri(), this.pickingViewport = {
      x: 0,
      y: 0,
      width: () => this.canvas ? this.canvas.width : 1,
      height: () => this.canvas ? this.canvas.height : 1
    }, this.sortByCommandKey = bB.bind(this), this.colorCache = {}, this.Hi = this.symbolDef.map((a) => !(!a || a.visible !== !1));
  }
  hasMesh() {
    const t = this.scene && this.scene.getMeshes();
    return this.isVisible() && t && !!t.length;
  }
  getMap() {
    return this.layer ? this.layer.getMap() : null;
  }
  getTileLevelValue(t, e) {
    const r = this.layer.getRenderer();
    return r.getTileLevelValue && r.getTileLevelValue(t, e) || 0;
  }
  getAnalysisMeshes() {
    return this.getShadowMeshes ? this.getShadowMeshes() : Yb;
  }
  isVisible() {
    const { minZoom: t, maxZoom: e } = this.sceneConfig, r = this.getMap().getZoom();
    if (!gn(t) && r < t || !gn(e) && r > e) return !1;
    const n = this.zi;
    if (n.length) {
      for (let o = 0; o < n.length; o++) if (n[o] && !n[o].isFeatureConstant) return !0;
    }
    const s = this.getSymbols();
    for (let o = 0; o < s.length; o++) {
      const a = s[o].visible;
      if (a !== !1 && a !== 0) return !0;
    }
    return !1;
  }
  isMeshVisible(t) {
    const e = t && t.properties && t.properties.symbolIndex;
    if (!e) return !1;
    const r = this.zi, n = e.index;
    let s;
    if (r[n]) {
      if (!r[n].isFeatureConstant) return !0;
      s = r[n](this.getMap().getZoom());
    } else s = this.getSymbol(e).visible;
    return s !== !1 && s !== 0;
  }
  isAnimating() {
    return !1;
  }
  needToRedraw() {
    return this.isAnimating() || this.Vi;
  }
  needToRetireFrames() {
    return this.J;
  }
  needToRefreshTerrainTileOnZooming() {
    return !0;
  }
  isTerrainSkin() {
    return this.layer.options.awareOfTerrain;
  }
  isTerrainVector() {
    return !1;
  }
  isShadowIncludeChanged(t) {
    const e = t && t.isRenderingTerrain && this.isTerrainSkin();
    return t && t.states && t.states.includesChanged.shadow || e && this.Ui;
  }
  fillIncludes(t, e, r) {
    if (delete this.Ui, r && r.isRenderingTerrain && this.isTerrainSkin()) return;
    const n = r && r.includes;
    if (n) {
      let s = "";
      for (const o in n) n[o] && (s += o, r[o].uniformDeclares && e.push(...r[o].uniformDeclares), r[o].defines && In(t, r[o].defines));
      this.Ui = s;
    }
  }
  setIncludeUniformValues(t, e) {
    if (e && e.isRenderingTerrain && this.isTerrainSkin()) return;
    const r = e && e.includes;
    if (r) for (const n in r) r[n] && e[n].renderUniforms && In(t, e[n].renderUniforms);
  }
  createGeometries(t, e) {
    if (!t.length) return Yb;
    const r = [];
    for (let n = 0; n < t.length; n++) if (t[n]) if (t[n].ref !== void 0) r[t[n].ref] ? r.push({
      geometry: r[t[n].ref].geometry,
      symbolIndex: t[n].symbolIndex,
      ref: t[n].ref
    }) : r.push(null);
    else {
      t[n] && !t[n].is2D && (this.Ni = !1);
      const s = this.createGeometry(t[n], e, n);
      if (s && s.geometry) {
        const o = s.geometry.properties, { pickingIdMap: a, idPickingMap: l, hasFeaIds: h } = this.ji(t[n]);
        h && (o.feaIdPickingMap = a, o.feaPickingIdMap = l), o.symbolIndex = s.symbolIndex, o.features = e, o.is2D = t[n].is2D, o.layer = this.layer, o.positionBounding = t[n].positionBounding, this.postCreateGeometry(s, r);
      }
      r.push(s);
    }
    return r;
  }
  isOnly2D() {
    return this.Ni;
  }
  postCreateGeometry() {
  }
  ji(t) {
    if (!t) return {};
    if (Array.isArray(t) && !(t = t[0])) return {};
    const e = t.featureIds, r = {}, n = {}, s = e && e.length;
    if (s) for (let o = 0; o < e.length; o++) {
      const a = t.data.aPickingId[o];
      r[a] === void 0 && (r[a] = e[o], n[e[o]] || (n[e[o]] = []), n[e[o]].push(t.data.aPickingId[o]));
    }
    return {
      hasFeaIds: s,
      idPickingMap: r,
      pickingIdMap: n
    };
  }
  createGeometry() {
    throw new Error("not implemented");
  }
  createMeshes(t, e, r, n) {
    const s = this.layer.options.awareOfTerrain, o = [];
    for (let a = 0; a < t.length; a++) {
      if (!t[a]) continue;
      if (s && n && n.isRenderingTerrain && this.isTerrainVector()) {
        const h = t[a], u = h && h.geometry;
        this.Bi(u, u.data, u.properties, u.positionSize || u.desc.positionSize, n);
      }
      let l = this.createMesh(t[a], e, r, n || {});
      Array.isArray(l) ? (l = l.filter((h) => !!h), o.push(...l)) : l && o.push(l);
    }
    return o;
  }
  createMesh() {
    throw new Error("not implemented");
  }
  getAltitudeOffsetMatrix() {
    const t = 100 * (this.dataConfig.altitudeOffset || 0), e = pn([]);
    return ne(Zb, 0, 0, t), ss(e, e, Zb), e;
  }
  isBloom(t) {
    return !!this.getSymbol(t.properties.symbolIndex).bloom;
  }
  forbiddenTerrainUpscale() {
    return !0;
  }
  addMesh(t, e, r) {
    if (r.isRenderingTerrain && this.isTerrainSkin() && this.forbiddenTerrainUpscale()) {
      const l = this.getMap().getResolution();
      if (r.tileInfo.res / l > 3) return;
    }
    const n = r.isRenderingTerrain && this.isTerrainVector(), s = this.getRenderFBO(r);
    t = t.filter((l) => this.isMeshVisible(l)), n && (t = t.filter((l) => l.geometry && l.geometry.data.aTerrainAltitude));
    const o = this.sceneConfig.castShadow === void 0 || !!this.sceneConfig.castShadow, a = !(!r || !r.bloom);
    t.forEach((l) => {
      const h = this.isBloom(l) && a;
      l.bloom = h, l.castShadow = o;
      let u = !1;
      const c = l.defines || {};
      if (!!c.HAS_BLOOM !== h && (u = !0, h ? c.HAS_BLOOM = 1 : delete c.HAS_BLOOM), n) {
        if (l.geometry.data.aTerrainAltitude) {
          const f = l.geometry;
          this.Bi(f, f.data, f.properties, f.desc.positionSize, r);
        }
        l.geometry.data.aTerrainAltitude && !c.HAS_TERRAIN_ALTITUDE && (c.HAS_TERRAIN_ALTITUDE = 1, u = !0);
      } else c.HAS_TERRAIN_ALTITUDE && (delete c.HAS_TERRAIN_ALTITUDE, u = !0);
      u && l.setDefines(c), s ? l.setUniform("targetFramebuffer", s) : l.uniforms.targetFramebuffer && (l.uniforms.targetFramebuffer = null), this.Gi(l);
    }), this.scene.addMesh(t);
  }
  updateCollision() {
  }
  render(t) {
    return this.pluginIndex = t.pluginIndex, this.polygonOffsetIndex = t.polygonOffsetIndex, this.paint(t), {
      redraw: this.Vi,
      drawCount: this.Wi
    };
  }
  prepareRender(t) {
    if (this.ft === t.timestamp || !this.createFnTypeConfig) return;
    const e = this.scene.getMeshes();
    if (!e || !e.length) return;
    const r = t && t.sceneFilter, n = this.getMap().getZoom();
    for (let s = 0; s < e.length; s++) {
      if (!e[s] || !e[s].geometry || r && !r(e[s])) continue;
      const { symbolIndex: o } = e[s].properties, a = this.getSymbolDef(o);
      if (!a) continue;
      this.ft = t.timestamp;
      const l = this.getFnTypeConfig(o);
      SP(this.regl, a, l, e[s], n);
    }
  }
  paint(t) {
    const e = this.layer.getMap();
    if (!e) return {
      redraw: !1
    };
    this.Xi = t;
    const r = this.getUniformValues(e, t);
    return this.callShader(r, t), {
      redraw: this.Vi
    };
  }
  setToRedraw(t) {
    t && (this.J = t), this.Vi = !0;
  }
  callShader(t, e) {
    this.callCurrentTileShader(t, e), this.callBackgroundTileShader(t, e);
  }
  callCurrentTileShader(t, e) {
    this.shader && (this.shader.filter = e && e.sceneFilter ? [this.level0Filter, e.sceneFilter] : this.level0Filter), this.callRenderer(this.shader, t, e);
  }
  callBackgroundTileShader(t, e) {
    this.shader && (this.shader.filter = e && e.sceneFilter ? [this.levelNFilter, e.sceneFilter] : this.levelNFilter), this.scene.getMeshes().sort(wB), this.callRenderer(this.shader, t, e);
  }
  callRenderer(t, e, r) {
    const n = this.scene.getMeshes(), s = [];
    n.forEach((o) => {
      o.properties.hlBloomMesh && r && r.bloom && s.push(o.properties.hlBloomMesh), s.push(o);
    }), this.Yi(e), this.scene.setMeshes(s), this.Wi += this.renderer.render(t, e, this.scene, this.getRenderFBO(r)), this.scene.setMeshes(n);
  }
  Yi(t) {
    const e = this.layer.options.altitude || 0, r = this.layer.getRenderer();
    t.layerOpacity = r.ne(), t.minAltitude = e;
  }
  getRenderFBO(t) {
    return t && t.renderTarget && t.renderTarget.fbo;
  }
  needPolygonOffset() {
    return !1;
  }
  getPolygonOffset() {
    const t = this.layer;
    return {
      factor: () => t.getPolygonOffset() + (this.polygonOffsetIndex || 0),
      units: () => t.getPolygonOffset() + (this.polygonOffsetIndex || 0)
    };
  }
  getBlendFunc() {
    return {
      src: () => this.sceneConfig.blendSrc || "one",
      dst: () => this.sceneConfig.blendDst || "one minus src alpha"
    };
  }
  pick(t, e, r = 3) {
    if (!this.layer.options.picking || this.sceneConfig.picking === !1 || !this.pickingFBO || !this.picking) return null;
    const n = this.getMap(), s = this.getUniformValues(n);
    this.Yi(s);
    for (let o = 0; o < this.picking.length; o++) {
      const a = this.picking[o];
      a.render(this.scene.getMeshes(), s, !0);
      let l = {};
      a.getRenderedMeshes().length && (l = a.pick(t, e, r, s, {
        viewMatrix: n.viewMatrix,
        projMatrix: n.projMatrix,
        returnPoint: this.layer.options.pickingPoint && this.sceneConfig.pickingPoint !== !1,
        logDepthBufFC: 2 / (Math.log(n.cameraFar + 1) / Math.LN2)
      }));
      const { meshId: h, pickingId: u, point: c } = l, f = (h === 0 || h) && a.getMeshAt(h);
      if (!f || !f.geometry) continue;
      let d = f.geometry.properties;
      return d.features || (d = f.properties), c && c.length && (c[0] = Math.round(1e5 * c[0]) / 1e5, c[1] = Math.round(1e5 * c[1]) / 1e5, c[2] = Math.round(1e5 * c[2]) / 1e5), {
        data: this.$i(d && d.features && d.features[u]),
        point: c,
        coordinate: l.coordinate,
        plugin: this.pluginIndex
      };
    }
    return null;
  }
  $i(t) {
    const e = t && t.feature;
    if (!e || !e.customProps) return t;
    const r = In({}, t);
    return r.feature = In({}, t.feature), delete r.feature.customProps, r.feature.properties = In({}, e.properties, e.properties[qo], e.properties[ws]), delete r.feature.properties[ws], delete r.feature.properties[qo], delete r.feature.properties.$layer, delete r.feature.properties.$type, r;
  }
  updateSceneConfig() {
  }
  updateDataConfig(t) {
    return In(this.dataConfig, t), !0;
  }
  deleteMesh(t, e) {
    if (t) if (this.scene.removeMesh(t), Array.isArray(t)) for (let r = 0; r < t.length; r++) {
      if (!t[r].isValid()) continue;
      const n = t[r].geometry;
      !e && n && n.dispose(), t[r].material && t[r].material.dispose(), t[r].dispose(), zg.deleteHighlightBloomMesh(t[r]);
    }
    else {
      if (!t.isValid()) return;
      !e && t.geometry && t.geometry.dispose(), t.material && t.material.dispose(), t.dispose(), zg.deleteHighlightBloomMesh(t);
    }
  }
  startFrame(t) {
    this.qi || (this.init(t), this.qi = !0), this.ft !== t.timestamp && (this.Vi = !1, this.J = !1, this.Wi = 0), this.scene.clear();
  }
  resize() {
  }
  delete() {
    if (this.scene.clear(), this.shader && this.shader.dispose(), this.picking) {
      for (let t = 0; t < this.picking.length; t++) this.picking[t].dispose();
      delete this.picking;
    }
    if (this.Ji) {
      for (let t = 0; t < this.Ji.length; t++) this.Ji[t].dispose();
      delete this.Ji;
    }
    delete this.Zi, this.logoutTextureCache();
  }
  updateSymbol(t, e) {
    Array.isArray(t) || (t = [t], e = [e]);
    let r = !1;
    for (let n = 0; n < t.length; n++) if (t[n]) {
      const s = this.Ki(n, t[n], e[n]);
      s && (r = s);
    }
    return delete this.Qi, this.setToRedraw(!1), r;
  }
  tr(t, e) {
    for (const r in e) if (xd(e, r) && (Ol.isFnTypeSymbol(e[r]) && !this.layer.options.features && (!t[r] || t[r].property !== e[r].property) || uP[r] && !fu(e[r], t[r])))
      return !0;
    return !1;
  }
  Ki(t, e, r) {
    if (!this.er) return !1;
    const n = this.tr(this.symbolDef[t] || {}, r);
    if (this.Hi[t] && r.visible !== !1) return this.Hi[t] = !1, !0;
    this.symbolDef[t] = hm(r);
    const s = this.er[t];
    for (const h in s) delete s[h];
    const o = this.getMap(), a = [], l = ob.loadSymbolFnTypes(this.symbolDef[t], () => (a[0] = o.getZoom(), a));
    for (const h in l) {
      const u = Object.getOwnPropertyDescriptor(l, h);
      u.get ? Object.defineProperty(s, h, {
        get: u.get,
        set: u.set,
        configurable: !0,
        enumerable: !0
      }) : s[h] = l[h];
    }
    return Ft(r.visible) && (this.zi[t] = he(r.visible)), n;
  }
  getSymbolDef(t) {
    return this.symbolDef[t.index];
  }
  getSymbols() {
    return this.er;
  }
  getSymbol(t) {
    const e = t.index;
    return this.er[e];
  }
  Ri() {
    const t = this.getMap(), e = [], r = () => (e[0] = t.getZoom(), e);
    this.er = [], this.zi = [];
    for (let n = 0; n < this.symbolDef.length; n++) this.er[n] = ob.loadSymbolFnTypes(In({}, this.symbolDef[n]), r), this.symbolDef[n] && Ft(this.symbolDef[n].visible) && (this.zi[n] = he(this.symbolDef[n].visible));
  }
  getFnTypeConfig(t) {
    this.Qi || (this.Qi = []);
    const e = t.index;
    if (!this.Qi[e]) {
      const r = this.getSymbolDef(t), n = this.getMap();
      this.Qi[e] = this.createFnTypeConfig(n, r);
    }
    return this.Qi[e];
  }
  nr() {
    delete this.Qi;
  }
  loginTextureCache() {
    const t = "__gl_textures".trim(), e = this.getMap();
    e[t] || (e[t] = {
      count: 0
    }), e[t].count++;
  }
  logoutTextureCache() {
    const t = "__gl_textures".trim(), e = this.getMap(), r = this.ir;
    if (r) for (const n in r) xd(r, n) && e[t][n] && (e[t][n].count--, e[t][n].count <= 0 && delete e[t][n]);
    e[t].count--, e[t].count <= 0 && (e[t] = {});
  }
  getCachedTexture(t) {
    const e = "__gl_textures".trim(), r = this.getMap()[e][t];
    return r ? r.data : null;
  }
  addCachedTexture(t, e) {
    const r = "__gl_textures".trim(), n = this.getMap();
    let s = n[r][t];
    s ? s.data = e : s = n[r][t] = {
      data: e,
      count: 0
    }, this.ir || (this.ir = {}), s.data.then || this.ir[t] || (s.count++, this.ir[t] = 1);
  }
  disposeCachedTexture(t) {
    let e;
    if (e = typeof t == "string" ? t : t.url, !this.ir || !this.ir[e]) return;
    const r = "__gl_textures".trim();
    delete this.ir[e];
    const n = this.getMap();
    n[r][e] && (n[r][e].count--, n[r][e].count <= 0 && delete n[r][e]);
  }
  shouldDeleteMeshOnUpdateSymbol() {
    return !1;
  }
  needClearStencil() {
    return !1;
  }
  supportRenderMode(t) {
    return t === "taa" || t === "fxaa";
  }
  rr(t) {
    const e = this.scene.getMeshes();
    if (!e.length) return;
    const r = e.map((o) => ({
      transform: o.localTransform,
      level: o.properties.level,
      mesh: o
    })).sort(this.sr), n = this.getMap().projViewMatrix;
    this.Li.start(t);
    const s = {};
    for (let o = 0; o < r.length; o++) {
      const a = r[o].mesh;
      let l = s[a.properties.tile.id];
      l === void 0 && (Jt(Wb, n, r[o].transform), l = this.Li.write(t, Wb), s[a.properties.tile.id] = l), a.setUniform("ref", l);
    }
    this.Li.end(t), this.regl.or();
  }
  sr(t, e) {
    return e.level - t.level;
  }
  outline(t, e) {
    const r = {};
    for (let n = 0; n < e.length; n++) gn(e[n]) || r[e[n]] || (this.ar(t, e[n]), r[e[n]] = 1);
  }
  ar(t, e) {
    if (!this.picking) return;
    if (this.lr || (this.lr = new ur()), !this.Ji && (this.hr(), !this.Ji)) return void console.warn(`Plugin at ${this.pluginIndex} doesn't support outline.`);
    const r = this.getUniformValues(this.getMap(), this.Xi);
    this.Yi(r);
    const n = this.ur(e);
    if (n.length) for (let s = 0; s < n.length; s++) {
      const o = n[s].geometry.properties.feaIdPickingMap;
      if (o) {
        const a = o[e];
        if (a) {
          const l = {};
          this.lr.setMeshes(n[s]);
          for (let h = 0; h < a.length; h++) {
            const u = a[h];
            if (!l[u]) {
              l[u] = 1, r.highlightPickingId = u;
              for (let c = 0; c < this.Ji.length; c++) this.renderer.render(this.Ji[c], r, this.lr, t);
            }
          }
        }
      }
    }
  }
  ur(t) {
    const e = [], r = this.scene.getMeshes();
    for (let n = 0; n < r.length; n++) {
      const s = r[n], o = s.geometry.properties.feaIdPickingMap;
      o && o[t] !== void 0 && e.push(s);
    }
    return e;
  }
  outlineAll(t) {
    if (!this.picking) return;
    if (!this.Ji && (this.hr(), !this.Ji)) return void console.warn(`Plugin at ${this.pluginIndex} doesn't support outline.`);
    const e = this.getUniformValues(this.getMap(), this.Xi);
    this.Yi(e), e.highlightPickingId = -1;
    for (let r = 0; r < this.Ji.length; r++) this.renderer.render(this.Ji[r], e, this.scene, t);
  }
  hr() {
    if (!this.picking) return;
    const t = this.layer.getRenderer().canvas;
    this.Ji = [];
    for (let e = 0; e < this.picking.length; e++) {
      const r = this.picking[e].getPickingVert(), n = {
        ENABLE_PICKING: 1,
        HAS_PICKING_ID: 1
      }, s = this.picking[e].getUniformDeclares().slice(0);
      s.uPickingId !== void 0 && (n.HAS_PICKING_ID = 2), this.Ji[e] = new qe({
        vert: r,
        frag: `precision highp float;
uniform float highlightPickingId;
varying float vPickingId;
void main() {
  if(highlightPickingId < .0 || floor(highlightPickingId + .5) == floor(vPickingId + .5)) {
    gl_FragColor = vec4(1.);
  } else {
    discard;
  }
}`,
        uniforms: s,
        defines: n,
        extraCommandProps: {
          viewport: {
            x: 0,
            y: 0,
            width: () => t.width,
            height: () => t.height
          },
          depth: {
            enable: !0,
            mask: !1,
            func: "always"
          },
          blend: {
            enable: !0,
            func: {
              src: "src alpha",
              dst: "one minus src alpha"
            },
            equation: "add"
          }
        }
      }), this.Ji[e].filter = this.picking[e].filter;
    }
  }
  hasIBL() {
    const t = this.getMap().getLightManager();
    return !!(t && t.getAmbientResource());
  }
  updateIBLDefines(t) {
    const e = t.shaderDefines;
    let r = !1;
    this.hasIBL() ? e[["HAS_IBL_LIGHTING"]] || (e.HAS_IBL_LIGHTING = 1, r = !0) : e[["HAS_IBL_LIGHTING"]] && (delete e.HAS_IBL_LIGHTING, r = !0), r && (t.shaderDefines = e);
  }
  getIBLRes() {
    const t = this.layer.getRenderer().canvas;
    return vB(t);
  }
  createIBLTextures() {
    const t = this.layer.getRenderer().canvas;
    gB(t, this.regl, this.getMap()), this.setToRedraw(!0), this.layer.fire("iblupdated");
  }
  disposeIBLTextures() {
    const t = this.layer.getRenderer().canvas;
    mB(t, this.getMap());
  }
  evaluateInFnTypeConfig(t, e, r, n, s) {
    let o = this.cr;
    o || (o = this.cr = {});
    const a = function(h) {
      let u = 0;
      const c = h && h.length || 0;
      if (!c) return u;
      let f;
      for (let d = 0; d < c; d++) f = h.codePointAt(d), u = (u << 5) - u + f, u &= u;
      return u;
    }(JSON.stringify(t));
    let l = o[a];
    return l || (l = o[a] = s ? ln(t) : he(t)), l(r.getZoom(), n);
  }
  highlight(t) {
    this.te = t, this.dr = this.layer.getRenderer().getFrameTimestamp(), this.setToRedraw(!0);
  }
  cancelAllHighlight() {
    this.te = null, this.dr = this.layer.getRenderer().getFrameTimestamp(), this.setToRedraw(!0);
  }
  pr(t, e) {
    const { featureIds: r, pickingIdIndiceMap: n } = e;
    t.properties.aFeaIds = r, t.properties.pickingIdIndiceMap = n;
  }
  Gi(t) {
    if (t && t.properties.isHalo) return;
    const { pickingIdIndiceMap: e } = t.geometry.properties, r = this.te ? function(n, s, o) {
      const { aPickingId: a, feaIdPickingMap: l, features: h } = n.geometry.properties, u = /* @__PURE__ */ new Map(), c = o.keys();
      for (const f of c) {
        const d = o.get(f);
        if (d) if (gn(d.id)) {
          if (d.filter && a) {
            let p = null;
            for (let g = 0; g < a.length; g++) {
              a[g] !== p && (p = a[g]);
              const m = h[p];
              d.filter(m && m.feature, s) && u.set(p, d);
            }
          }
        } else {
          const p = l[d.id];
          if (!p || !p.length) continue;
          for (let g = 0; g < p.length; g++) u.set(p[g], d);
        }
      }
      return u;
    }(t, this.layer, this.te) : null;
    zg.highlightMesh(this.regl, t, r, this.dr, e);
  }
  Bi(t, e, r, n, s) {
    let o = r.aAnchor;
    if (!o) {
      const { aPosition: l } = e;
      o = r.aAnchor = l.slice(0);
    }
    let a = r.aTerrainAltitude;
    a || (a = r.aTerrainAltitude = new Float32Array(o.length / n), a.fill(xl)), this.mr(a, o, s.tileInfo, 0, a.length - 1), e.aTerrainAltitude ? a.dirty && this.yr(t, a) : e.aTerrainAltitude = a, a.dirty = !1;
  }
  yr(t, e) {
    t && t.updateData && t.updateData("aTerrainAltitude", e);
  }
  mr(t, e, r, n, s) {
    const { res: o, extent: a, extent2d: l, id: h } = r, u = this.pluginIndex, c = h + "-" + u;
    if (r.completeTerrainQuery || (r.completeTerrainQuery = []), r.completeTerrainQuery[u]) return;
    if (!r.completeTerrainQuery[u] && this.Zi && this.Zi.has(c)) {
      const C = this.Zi.getAndRemove(c);
      return this.Zi.add(c, C), t.set(C.altitudeData), r.terrainTileInfos = C.terrainTileInfos, t.dirty = !0, void (r.completeTerrainQuery[u] = !0);
    }
    const f = this.layer, d = f.getMap(), p = f.getRenderer(), g = p && p.getTerrainHelper();
    let m = r.terrainTileInfos;
    m || (m = r.terrainTileInfos = this.layer.queryTerrainTiles(r)), r.terrainQueryStatus || (r.terrainQueryStatus = []);
    let v = !1, _ = [];
    for (let C = 0; C < r.terrainTileInfos.length; C++) if (_[C] = +g.isTerrainTileLoaded(r.terrainTileInfos[C].id), _[C] && r.terrainQueryStatus[u] && !r.terrainQueryStatus[u][C]) {
      v = !0;
      break;
    }
    if (!v && r.terrainQueryStatus[u]) return;
    const y = f.constructor;
    if (d.isInteracting()) {
      const C = p.getFrameTimestamp();
      y.altitudeQueryFrameTimestamp !== C && (y.altitudeQueryFrameTimestamp = C, y.altitudeQueryFrameTime = 0);
      const k = f.options.altitudeQueryTimeLimitPerFrame;
      if (y.altitudeQueryFrameTime > k) return;
    }
    const x = performance.now();
    r.terrainQueryStatus[u] = _;
    const { xmin: w, ymax: b } = l, T = yB.set(w, b), A = this.layer.getTileSize().width / r.extent, M = e.length / t.length;
    let S = t.queryResult;
    S || (S = t.queryResult = /* @__PURE__ */ new Map());
    let P = !0;
    for (let C = n; C <= s; C++) {
      let k = e[C * M];
      k < 0 ? k = 0 : k > a && (k = a);
      let O = e[C * M + 1];
      O < 0 ? O = 0 : O > a && (O = a);
      const R = k + O * a;
      let I, D, z = S.get(R);
      if (z || z === 0) t[C] !== z && (t[C] = z, t.dirty = !0);
      else {
        for (let H = 0; H < m.length; H++) if (PP(m[H], w + A * k, b - A * O, o)) {
          I = m[H];
          break;
        }
        I && (g.getRenderer().isTileCached(I.id) || t[C] === xl) && (Xb.set(k, O), D = this.layer.queryTilePointTerrain(Xb, I, T, a, o)), z = t[C], D && (z = D[0] === null ? xl : D[0], qb[0] = z, z = qb[0]), t[C] !== z && (t[C] = z, t.dirty = !0), D && D[1] ? S.set(R, z) : P = !1;
      }
    }
    y.altitudeQueryFrameTime = (y.altitudeQueryFrameTime || 0) + (performance.now() - x), r.completeTerrainQuery[u] = P, P && (this.Zi || (this.Zi = new Tv(4 * this.layer.options.maxCacheSize)), this.Zi.add(c, {
      altitudeData: t,
      terrainTileInfos: m
    }));
  }
}
function bB(i, t) {
  const e = i && i.getCommandKey(this.regl) || "", r = t && t.getCommandKey(this.regl) || "";
  return e.localeCompare(r);
}
function wB(i, t) {
  return i.properties.level - t.properties.level;
}
class vo extends jy {
  createGeometry(t, e) {
    if (!t.data) return {
      geometry: null,
      symbolIndex: t.symbolIndex
    };
    t.iconAtlas && t.iconAtlas.image && (t.iconAtlas.image.dataType = t.type, t.iconAtlas.image.type = "icon"), t.glyphAtlas && t.glyphAtlas.image && (t.glyphAtlas.image.type = "glyph");
    const r = In({}, t.data), n = {
      primitive: this.getPrimitive(),
      positionSize: t.positionSize
    };
    r.aAltitude && (n.altitudeAttribute = "aAltitude");
    const s = new er(r, t.indices, 0, n);
    return s.properties = {
      features: e
    }, t.iconAtlas && (s.properties.iconAtlas = t.iconAtlas.image, s.properties.iconPositions = t.iconAtlas.positions), t.glyphAtlas && (s.properties.glyphAtlas = t.glyphAtlas.image), wl(e) || (s.properties.aFeaIds = t.featureIds, this.pr(s, t)), t.markerPlacement && (s.properties.markerPlacement = t.markerPlacement), t.textPlacement && (s.properties.textPlacement = t.textPlacement), In(s.properties, t.properties), {
      geometry: s,
      symbolIndex: t.symbolIndex
    };
  }
  getRayCastData(t, e) {
    const { features: r, aFeaIds: n } = t.geometry.properties;
    return !r || !n ? null : r[n[e]];
  }
  getPrimitive() {
    return "triangles";
  }
  getRenderFBO(t) {
    return t && t.renderTarget && t.renderTarget.fbo;
  }
  supportRenderMode(t) {
    return t === "noAa";
  }
  drawDebugAtlas(t) {
    if (document.getElementById("MAPTALKS_ICON_DEBUG")) {
      const e = document.getElementById("MAPTALKS_ICON_DEBUG");
      let r;
      if (e.width = t.width, e.height = t.height, e.style.width = t.width + "px", e.style.height = t.height + "px", t.format === "alpha") {
        r = new Uint8ClampedArray(4 * t.data.length);
        for (let s = 0; s < t.data.length; s++) r[4 * s + 3] = t.data[s];
      } else r = new Uint8ClampedArray(t.data);
      const n = e.getContext("2d");
      n.imageSmoothingEnabled = !1, n.putImageData(new ImageData(r, t.width, t.height), 0, 0);
    }
  }
}
var EP = `#include <gl2_vert>
#ifdef HAS_ALTITUDE
attribute vec2 aPosition;
attribute float aAltitude;
#else
attribute vec3 aPosition;
#endif
uniform mat4 projViewModelMatrix;
#include <fbo_picking_vert>
#include <vt_position_vert>
void main() {
  vec3 c = unpackVTPosition();
  gl_Position = projViewModelMatrix * vec4(c, 1.);
  fbo_picking_setData(gl_Position.w, true);
}`;
function Vu(i, t, e, r) {
  if (r) {
    const o = pM.resizeToPowerOfTwo(t.data, t.width, t.height);
    t.data = o;
  }
  const n = t, s = {
    width: n.width,
    height: n.height,
    data: n.data,
    format: n.format,
    mag: "linear",
    min: r ? "linear mipmap linear" : "linear",
    flipY: e,
    premultiplyAlpha: !0
  };
  if (t.type === "icon") {
    const o = t.dataType !== "point" ? "repeat" : "clamp";
    s.wrapS = o, s.wrapT = o;
  }
  return i.texture(s);
}
const wm = [0, 0], Tm = [];
function OP(i) {
  if (!i.properties.iconPositions) return wm;
  let t, e = 0;
  for (const o in i.properties.iconPositions) if (t = o, e++, e > 1) return wm;
  if (!t) return wm;
  const r = i.properties.iconPositions[t], n = r.displaySize[0], s = r.displaySize[1];
  return Tm[0] = n, Tm[1] = s, Tm;
}
const TB = pn([]), Di = {
  polygonFill: [1, 1, 1, 1],
  polygonOpacity: 1,
  uvScale: [1, 1],
  uvOffset: [0, 0],
  patternWidth: [0, 0],
  patternOffset: [0, 0]
}, AB = [], ph = new lt(0, 0), Da = new lt(0, 0), Jb = new lt(0, 0), Kb = [];
class ap extends vo {
  static getBloomSymbol() {
    return ["polygonBloom"];
  }
  prepareSymbol(t) {
    const e = t.polygonFill;
    Array.isArray(e) && (e.length === 3 && e.push(1), t.polygonFill = e.map((r) => 255 * r));
  }
  supportRenderMode(t) {
    return this.sceneConfig.antialias || this.sceneConfig.antialias === void 0 ? t === "fxaa" || t === "fxaaBeforeTaa" : super.supportRenderMode(t);
  }
  isBloom(t) {
    return !!this.getSymbol(t.properties.symbolIndex)[ap.getBloomSymbol()[0]];
  }
  forbiddenTerrainUpscale() {
    return !0;
  }
  needPolygonOffset() {
    return !0;
  }
  getAnalysisMeshes() {
    return this.isVisible() ? this.scene.getMeshes().filter((t) => t.properties.level === 0) : AB;
  }
  createMesh(t, e, r) {
    const n = this.getMap(), { tilePoint: s } = r, { geometry: o, symbolIndex: a, ref: l } = t, h = this.layer instanceof Pn, u = this.layer.getTileSize().width, c = o.properties.tileExtent / u, f = o.properties.tileResolution, d = n.pointAtResToCoord(ph.set(s[0], s[1]), f), p = {
      tileExtent: o.properties.tileExtent,
      tileRatio: c
    }, g = this.getSymbol(a), m = this.getSymbolDef(a);
    if (Ft(m.polygonPatternFileOrigin) && this.gr(m, t, h ? [0, 0] : s, f), (Ft(m.polygonPatternFileWidth) || Ft(m.polygonPatternFileWidth)) && this.vr(m, t, h ? c : 1, d, f), m.uvOffsetInMeter && Ft(m.uvOffset) && this.xr(m, t, d, f), ue(p, "polygonFill", g, "polygonFill", Di.polygonFill, fi(this.colorCache)), ue(p, "polygonOpacity", g, "polygonOpacity", Di.polygonOpacity), ue(p, "uvScale", g, "uvScale", Di.uvScale), l === void 0) {
      const w = this.getFnTypeConfig(a);
      Ns(o, m, w), o.generateBuffers(this.regl);
    }
    const v = o.properties.iconAtlas;
    if (v && o.data.aTexInfo) {
      const w = [];
      Object.defineProperty(p, "uvOrigin", {
        enumerable: !0,
        get: () => {
          const A = p.tileScale;
          if (o.data.aPatternOrigin) return w[0] = s[0] * A % 2048, w[1] = s[1] * A % 2048, w;
          const M = g.polygonPatternFileOrigin;
          return M ? (ph.set(M[0], M[1]), n.coordToPointAtRes(ph, f, Da), we(w, s[0] - Da.x, s[1] - Da.y)) : (w[0] = s[0] * A % 2048, w[1] = s[1] * A % 2048, w);
        }
      });
      const b = [];
      Object.defineProperty(p, "patternWidth", {
        enumerable: !0,
        get: () => {
          if (o.data.aPatternWidth) return Di.patternWidth;
          const A = m.polygonPatternFileWidth, M = m.polygonPatternFileHeight;
          if (!A && !M) return Di.patternWidth;
          const [S, P] = this.br(Kb, A, M, h ? c : 1, d, f);
          return we(b, S, P);
        }
      }), Object.defineProperty(p, "uvOffset", {
        enumerable: !0,
        get: () => o.data.aPatternOffset || m.uvOffsetInMeter ? Di.uvOffset : g.uvOffset || Di.uvOffset
      });
      const T = [];
      Object.defineProperty(p, "patternOffset", {
        enumerable: !0,
        get: () => {
          if (o.data.aPatternOffset || !m.uvOffsetInMeter) return Di.uvOffset;
          const A = m.uvOffset;
          if (!A) return Di.uvOffset;
          const M = ns(n, A[0], d, f), S = ns(n, A[1], d, f);
          return we(T, M, S);
        }
      }), Object.defineProperty(p, "tileScale", {
        enumerable: !0,
        get: function() {
          const A = m.polygonPatternFileWidth, M = m.polygonPatternFileHeight;
          return A || M ? 1 : o.properties.tileResolution / n.getResolution();
        }
      }), p.polygonPatternFile = Vu(this.regl, v, !1, !1), p.atlasSize = [v.width, v.height], this.drawDebugAtlas(v);
    }
    const _ = new Nr(p, Di), y = new tn(o, _, {
      castShadow: !1,
      picking: !0
    }), x = {};
    return v && o.data.aTexInfo && (x.HAS_PATTERN = 1), v && o.data.aTexCoord && (x.HAS_TEX_COORD = 1, x.INVALID_TEX_COORD = wH + ".0"), o.data.aAltitude && (x.HAS_ALTITUDE = 1), o.data.aColor && (x.HAS_COLOR = 1), o.data.aOpacity && (x.HAS_OPACITY = 1), o.data.aUVScale && (x.HAS_UV_SCALE = 1), o.data.aUVOffset && (x.HAS_UV_OFFSET = 1), o.data.aPatternOrigin && (x.HAS_PATTERN_ORIGIN = 1), o.data.aPatternWidth && (x.HAS_PATTERN_WIDTH = 1), o.data.aPatternOffset && (x.HAS_PATTERN_OFFSET = 1), h && (x.IS_VT = 1), y.setDefines(x), y.setLocalTransform(e), y.properties.symbolIndex = a, y;
  }
  vr(t, e, r, n, s) {
    if (!(e = e && e.geometry)) return;
    const o = e.properties.features;
    if (wl(o)) return;
    const a = t.polygonPatternFileWidth, l = t.polygonPatternFileHeight, h = he(t.polygonPatternFileOrigin);
    let u, c;
    Ft(a) && (u = he(a)), Ft(l) && (c = he(l));
    const { aPickingId: f, aPatternOrigin: d } = e.data, p = f.length, g = new Float32Array(2 * p);
    let m, v, _;
    for (let y = 0, x = f.length; y < x; y++) {
      let w, b;
      if (f[y] === m) {
        g[2 * y] = v, g[2 * y + 1] = _;
        continue;
      }
      const T = o[f[y]];
      if (w = u ? u(null, T.feature.properties) : a, b = c ? c(null, T.feature.properties) : l, m = f[y], w || b) {
        let A = n;
        if (d) {
          const P = h(null, T.feature.properties);
          P && (A = Jb.set(P[0], P[1]));
        }
        const [M, S] = this.br(Kb, w, b, r, A, s);
        v = g[2 * y] = M, _ = g[2 * y + 1] = S;
      } else v = g[2 * y] = 0, _ = g[2 * y + 1] = 0;
    }
    e.data.aPatternWidth = g;
  }
  xr(t, e, r, n) {
    if (!(e = e && e.geometry)) return;
    const s = e.properties.features;
    if (wl(s)) return;
    const o = this.getMap();
    let a = Ft(t.uvOffsetInMeter) && ln(t.uvOffsetInMeter);
    const l = he(t.uvOffset), h = he(t.polygonPatternFileOrigin), { aPickingId: u, aPatternOrigin: c } = e.data, f = u.length, d = new Float32Array(2 * f);
    let p, g, m;
    for (let v = 0, _ = u.length; v < _; v++) {
      if (u[v] === p) {
        d[2 * v] = g, d[2 * v + 1] = m;
        continue;
      }
      const y = s[u[v]], x = l(null, y.feature.properties);
      let w = !0;
      if (a && (w = a(null, y.feature.properties)), p = u[v], x && w) {
        let b = r;
        if (c) {
          const M = h(null, y.feature.properties);
          M && (b = Jb.set(M[0], M[1]));
        }
        const T = ns(o, x[0], b, n), A = ns(o, x[0], b, n);
        g = d[2 * v] = T, m = d[2 * v + 1] = A;
      } else g = d[2 * v] = 0, m = d[2 * v + 1] = 0;
    }
    e.data.aPatternOffset = d;
  }
  gr(t, e, r, n) {
    if (!(e = e && e.geometry)) return;
    const s = e.properties.features;
    if (wl(s)) return;
    const o = this.getMap(), a = he(t.polygonPatternFileOrigin), l = e.data.aPickingId, h = l.length, u = new Float32Array(2 * h);
    let c, f, d;
    for (let p = 0, g = l.length; p < g; p++) {
      if (l[p] === c) {
        u[2 * p] = f, u[2 * p + 1] = d;
        continue;
      }
      c = l[p];
      const m = a(null, s[c].feature.properties);
      m ? (ph.set(m[0], m[1]), o.coordToPointAtRes(ph, n, Da), f = u[2 * p] = Da.x, d = u[2 * p + 1] = Da.y) : (f = u[2 * p] = r[0], d = u[2 * p + 1] = r[1]);
    }
    e.data.aPatternOrigin = u;
  }
  createFnTypeConfig(t, e) {
    const r = ln(e.polygonFill), n = he(e.polygonOpacity), s = he(e.uvScale), o = he(e.uvOffset), a = new Uint8Array(1), l = new Uint16Array(2), h = new Uint8Array(2);
    return [{
      attrName: "aColor",
      symbolName: "polygonFill",
      type: Uint8Array,
      width: 4,
      define: "HAS_COLOR",
      evaluate: (u, c) => {
        let f = r(t.getZoom(), u);
        return Ft(f) && (f = this.evaluateInFnTypeConfig(f, c, t, u, !0)), Array.isArray(f) || (f = this.colorCache[f] = this.colorCache[f] || Zi(f).unitArray()), f = Yo(f), f;
      }
    }, {
      attrName: "aOpacity",
      symbolName: "polygonOpacity",
      type: Uint8Array,
      width: 1,
      define: "HAS_OPACITY",
      evaluate: (u, c) => {
        let f = n(t.getZoom(), u);
        return Ft(f) && (f = this.evaluateInFnTypeConfig(f, c, t, u)), a[0] = 255 * f, a[0];
      }
    }, {
      attrName: "aUVScale",
      symbolName: "uvScale",
      type: Uint16Array,
      width: 2,
      define: "HAS_UV_SCALE",
      evaluate: (u) => {
        const c = s(t.getZoom(), u);
        return l[0] = 255 * c[0], l[1] = 255 * c[1], l;
      }
    }, {
      attrName: "aUVOffset",
      symbolName: "uvOffset",
      type: Uint8Array,
      width: 2,
      define: "HAS_UV_OFFSET",
      evaluate: (u) => {
        const c = o(t.getZoom(), u);
        return h[0] = 255 * c[0], h[1] = 255 * c[1], h;
      }
    }];
  }
  paint(t) {
    this.isShadowIncludeChanged(t) && (this.shader.dispose(), this.Ar(t)), super.paint(t);
  }
  isEnableStencil(t) {
    const e = this.layer.getRenderer();
    return !(t && t.isRenderingTerrain && this.isTerrainSkin() || !e.isEnableTileStencil || !e.isEnableTileStencil()) && this.layer.getJSONType() === "VectorTileLayer";
  }
  init(t) {
    const e = this.regl, r = this.canvas, n = {
      x: (a, l) => l.viewport ? l.viewport.x : 0,
      y: (a, l) => l.viewport ? l.viewport.y : 0,
      width: (a, l) => l.viewport ? l.viewport.width : r ? r.width : 1,
      height: (a, l) => l.viewport ? l.viewport.height : r ? r.height : 1
    };
    this.renderer = new hn(e);
    const s = this.layer.getRenderer(), o = {
      viewport: n,
      stencil: {
        enable: () => this.isEnableStencil(t),
        func: {
          cmp: () => s.isEnableTileStencil && s.isEnableTileStencil() ? "=" : "<=",
          ref: (a, l) => s.isEnableTileStencil && s.isEnableTileStencil() ? l.stencilRef : l.level
        },
        op: {
          fail: "keep",
          zfail: "keep",
          zpass: () => s.isEnableTileStencil && s.isEnableTileStencil() ? "zero" : "replace"
        }
      },
      depth: {
        enable: !0,
        range: this.sceneConfig.depthRange || [0, 1],
        mask: (a, l) => {
          if (!gn(this.sceneConfig.depthMask)) return !!this.sceneConfig.depthMask;
          if (l.hasSSRGround) return !0;
          if (l.meshConfig.transparent) return !1;
          const h = l.polygonOpacity;
          return !(zy(h) && h < 1);
        },
        func: this.sceneConfig.depthFunc || "<="
      },
      blend: {
        enable: !0,
        func: this.getBlendFunc(),
        equation: "add"
      },
      polygonOffset: {
        enable: !0,
        offset: this.getPolygonOffset()
      }
    };
    if (this.Ar(t, o), this.pickingFBO) {
      const a = [];
      this.picking = [new Oi(this.renderer, {
        vert: EP,
        uniforms: [{
          name: "projViewModelMatrix",
          type: "function",
          fn: function(l, h) {
            return Jt(a, h.projViewMatrix, h.modelMatrix), a;
          }
        }],
        extraCommandProps: o
      }, this.pickingFBO, this.getMap())];
    }
  }
  Ar(t, e) {
    const r = [], n = [{
      name: "projViewModelMatrix",
      type: "function",
      fn: function(o, a) {
        return Jt(r, a.projViewMatrix, a.modelMatrix), r;
      }
    }], s = {};
    this.fillIncludes(s, n, t), this.shader = new qe({
      vert: `#define SHADER_NAME FILL
#ifdef HAS_ALTITUDE
attribute vec2 aPosition;
attribute float aAltitude;
#else
attribute vec3 aPosition;
#endif
#ifdef HAS_COLOR
attribute vec4 aColor;
varying vec4 vColor;
#endif
#ifdef HAS_OPACITY
attribute float aOpacity;
varying float vOpacity;
#endif
uniform mat4 projViewModelMatrix;
#ifndef IS_VT
uniform mat4 modelMatrix;
#endif
#ifdef HAS_PATTERN
#ifdef HAS_TEX_COORD
attribute vec2 aTexCoord;
#endif
attribute vec4 aTexInfo;
uniform vec2 patternWidth;
uniform vec2 patternOffset;
uniform vec2 uvOrigin;
uniform vec2 uvScale;
#ifdef IS_VT
uniform float tileRatio;
uniform float tileScale;
#else
uniform float glScale;
#endif
#ifdef HAS_UV_SCALE
attribute vec2 aUVScale;
varying vec2 vUVScale;
#endif
#ifdef HAS_UV_OFFSET
attribute vec2 aUVOffset;
varying vec2 vUVOffset;
#endif
#ifdef HAS_PATTERN_WIDTH
attribute vec2 aPatternWidth;
#endif
#ifdef HAS_PATTERN_ORIGIN
attribute vec2 aPatternOrigin;
#endif
#ifdef HAS_PATTERN_OFFSET
attribute vec2 aPatternOffset;
#endif
varying vec2 vTexCoord;
varying vec4 vTexInfo;
vec2 c(vec2 d, vec2 e) {
  
#ifdef IS_VT
float f = d.x / e.x;
  float h = d.y / e.y;
  return vec2(f, h);
#else
float i = glScale;
#ifdef HAS_PATTERN_WIDTH
float j = sign(length(aPatternWidth));
  i = mix(glScale, 1., j);
#endif
vec2 k = uvOrigin;
#ifdef HAS_PATTERN_ORIGIN
k = aPatternOrigin;
#endif
#ifdef HAS_PATTERN_OFFSET
vec2 l = aPatternOffset;
#else
vec2 l = patternOffset;
#endif
k += l;
  float f = (d.x - k.x) * i / e.x;
  float h = (d.y - k.y) * i / e.y;
  return vec2(f, -h);
#endif
}
vec2 m(vec4 n, vec2 o) {
  
#ifdef IS_VT
#ifdef HAS_PATTERN_OFFSET
vec2 l = aPatternOffset;
#else
vec2 l = patternOffset;
#endif
vec2 k = uvOrigin + l;
#ifdef HAS_PATTERN_ORIGIN
k = k - aPatternOrigin * tileScale;
#endif
float j = sign(length(patternWidth));
  vec2 A = mix(o, patternWidth, j);
#ifdef HAS_PATTERN_WIDTH
A = aPatternWidth;
#endif
vec2 B = k * vec2(1., -1.) / A;
  return mod(B, 1.) + c(n.xy * tileScale / tileRatio, A);
#else
vec2 A = o;
#ifdef HAS_PATTERN_WIDTH
float j = sign(length(aPatternWidth));
  A = mix(o, aPatternWidth, j);
#endif
vec4 C = modelMatrix * n;
  return c(C.xy, A);
#endif
}
#endif
#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
#include <vsm_shadow_vert>
#endif
#include <vt_position_vert>
#include <highlight_vert>
void main() {
  vec3 D = unpackVTPosition();
  vec4 n = vec4(D, 1.);
  gl_Position = projViewModelMatrix * n;
#ifdef HAS_PATTERN
vec2 o = aTexInfo.zw + 1.;
  vTexInfo = vec4(aTexInfo.xy, o);
#ifdef HAS_TEX_COORD
if(aTexCoord.x == INVALID_TEX_COORD) {
    vTexCoord = m(n, o);
  } else {
    vTexCoord = aTexCoord;
  }
#else
vTexCoord = m(n, o);
#endif
#ifdef HAS_UV_SCALE
vUVScale = aUVScale / 255.;
#endif
#ifdef HAS_UV_OFFSET
vUVOffset = aUVOffset / 255.;
#endif
#endif
#ifdef HAS_COLOR
vColor = aColor / 255.;
#endif
highlight_setVarying();
#ifdef HAS_OPACITY
vOpacity = aOpacity / 255.;
#endif
#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
shadow_computeShadowPars(n);
#endif
}`,
      frag: `#define SHADER_NAME FILL
precision mediump float;
#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
#include <vsm_shadow_frag>
#endif
#ifdef HAS_PATTERN
#ifdef HAS_UV_SCALE
varying vec2 vUVScale;
#else
uniform highp vec2 uvScale;
#endif
#ifdef HAS_UV_OFFSET
varying vec2 vUVOffset;
#else
uniform vec2 uvOffset;
#endif
#endif
#ifdef HAS_PATTERN
uniform sampler2D polygonPatternFile;
uniform vec2 atlasSize;
varying vec2 vTexCoord;
varying vec4 vTexInfo;
vec2 c() {
  
#ifdef HAS_UV_SCALE
vec2 d = vUVScale;
#else
vec2 d = uvScale;
#endif
#ifdef HAS_UV_OFFSET
vec2 e = vUVOffset;
#else
vec2 e = uvOffset;
#endif
vec2 f = mod(vTexCoord * d + e, 1.);
  vec2 h = vTexInfo.xy;
  vec2 i = vTexInfo.zw;
  return (h + f * i) / atlasSize;
}
#endif
#ifdef HAS_COLOR
varying vec4 vColor;
#else
uniform vec4 polygonFill;
#endif
#include <highlight_frag>
#ifdef HAS_OPACITY
varying float vOpacity;
#else
uniform lowp float polygonOpacity;
#endif
uniform float layerOpacity;
uniform float tileExtent;
void main() {
  
#ifdef HAS_COLOR
vec4 j = vColor;
#else
vec4 j = polygonFill;
#endif
#ifdef HAS_PATTERN
if(vTexInfo.z * vTexInfo.w > 1.) {
    vec2 f = c();
    j = texture2D(polygonPatternFile, f);
  }
#endif
#ifdef HAS_OPACITY
gl_FragColor = j * vOpacity;
#else
gl_FragColor = j * polygonOpacity;
#endif
gl_FragColor *= layerOpacity;
#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
float k = shadow_computeShadow();
  gl_FragColor.rgb = shadow_blend(gl_FragColor.rgb, k);
#endif
gl_FragColor = highlight_blendColor(gl_FragColor);
}`,
      uniforms: n,
      defines: s,
      extraCommandProps: e
    });
  }
  getUniformValues(t, e) {
    const r = e && e.isRenderingTerrainSkin, n = {
      projViewMatrix: r ? TB : t.projViewMatrix,
      glScale: e && e.isRenderingTerrainSkin ? 1 : 1 / t.getGLScale(),
      viewport: r && e && e.viewport,
      hasSSRGround: e && e.hasSSRGround
    };
    return this.setIncludeUniformValues(n, e), n;
  }
  br(t, e, r, n, s, o) {
    let a, l;
    const h = this.getMap();
    return e && (a = ns(h, e, s, o)), r && (l = ns(h, r, s, o, 1)), a = a || l, l = l || a, t[0] = a, t[1] = l, t;
  }
}
var Q0 = `#define SHADER_NAME LINE
#define AA_CLIP_LIMIT 2.0
#define AA_LINE_WIDTH 16.0
#define DEVICE_PIXEL_RATIO 1.0
#define ANTIALIASING 1.0 / DEVICE_PIXEL_RATIO / 2.0
#define EXTRUDE_SCALE 63.0
#define EXTRUDE_MOD 64.0
#define MAX_LINE_DISTANCE 65535.0
#ifdef PICKING_MODE
#include <gl2_vert>
#endif
#ifdef HAS_ALTITUDE
attribute vec2 aPosition;
attribute float aAltitude;
#else
attribute vec3 aPosition;
#endif
#if defined(HAS_PATTERN) || defined(HAS_DASHARRAY)
attribute vec3 aExtrude;
#else
attribute vec2 aExtrude;
#endif
#if defined(HAS_PATTERN) || defined(HAS_DASHARRAY) || defined(HAS_GRADIENT) || defined(HAS_TRAIL)
attribute float aLinesofar;
varying highp float vLinesofar;
#endif
uniform float cameraToCenterDistance;
#if defined(HAS_STROKE_WIDTH)
attribute float aLineStrokeWidth;
#else
uniform float lineStrokeWidth;
#endif
uniform mat4 positionMatrix;
uniform mat4 projViewModelMatrix;
uniform mat4 modelMatrix;
uniform float tileResolution;
uniform float resolution;
uniform float tileRatio;
uniform float isRenderingTerrain;
#if defined(HAS_LINE_DX) || defined(HAS_LINE_DY)
attribute vec2 aLineDxDy;
#endif
#ifndef HAS_LINE_DX
uniform float lineDx;
#endif
#ifndef HAS_LINE_DY
uniform float lineDy;
#endif
uniform vec2 canvasSize;
uniform float layerScale;
varying vec2 vNormal;
varying vec2 vWidth;
varying float vGammaScale;
#ifndef ENABLE_TILE_STENCIL
varying vec2 vPosition;
#endif
#ifdef USE_LINE_OFFSET
attribute vec2 aExtrudeOffset;
#endif
#ifdef HAS_LINE_WIDTH
attribute float aLineWidth;
#else
uniform float lineWidth;
#endif
#ifndef PICKING_MODE
#ifndef HAS_GRADIENT
#ifdef HAS_COLOR
attribute vec4 aColor;
varying vec4 vColor;
#endif
#ifdef HAS_PATTERN
#if defined(HAS_PATTERN_ANIM) || defined(HAS_PATTERN_GAP)
attribute vec2 aLinePattern;
#endif
#ifdef HAS_PATTERN_ANIM
varying float vLinePatternAnimSpeed;
#endif
#ifdef HAS_PATTERN_GAP
varying float vLinePatternGap;
#endif
attribute vec4 aTexInfo;
varying vec4 vTexInfo;
#endif
#ifdef HAS_DASHARRAY
#ifdef HAS_DASHARRAY_ATTR
attribute vec4 aDasharray;
varying vec4 vDasharray;
#endif
#ifdef HAS_DASHARRAY_COLOR
attribute vec4 aDashColor;
varying vec4 vDashColor;
#endif
#endif
#endif
#ifdef HAS_STROKE_COLOR
attribute vec4 aStrokeColor;
varying vec4 vStrokeColor;
#endif
#ifdef HAS_OPACITY
attribute float aOpacity;
varying float vOpacity;
#endif
#ifdef HAS_GRADIENT
attribute float aGradIndex;
varying float vGradIndex;
#endif
#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
#include <vsm_shadow_vert>
#endif
#include <highlight_vert>
#else
#include <fbo_picking_vert>
#endif
varying vec3 vVertex;
#include <vt_position_vert>
void main() {
  vec3 c = unpackVTPosition();
  float d = mod(abs(aExtrude.x), 2.);
  float e = mod(abs(aExtrude.y), 2.);
  vNormal = vec2(d, e * 2. - 1.);
  vec4 f = vec4(c, 1.);
  vec4 h = projViewModelMatrix * positionMatrix * f;
  if(isRenderingTerrain == 1.) {
    vVertex = (positionMatrix * f).xyz;
  } else {
    vVertex = (modelMatrix * positionMatrix * f).xyz;
  }
#ifdef HAS_STROKE_WIDTH
float i = aLineStrokeWidth / 2. * layerScale;
#else
float i = lineStrokeWidth;
#endif
#ifdef HAS_LINE_WIDTH
float j = aLineWidth / 2. * layerScale;
#else
float j = lineWidth * layerScale;
#endif
float k = j / 2. + i;
  float l = sign(i) * j / 2.;
  float m = l + sign(l) * ANTIALIASING;
  float n = k + sign(k) * ANTIALIASING;
#ifdef USE_LINE_OFFSET
vec2 o = lineOffset * (vNormal.y * (aExtrude.xy - aExtrudeOffset) + aExtrudeOffset);
  vec2 u = (n * aExtrude.xy + o) / EXTRUDE_SCALE;
#else
vec2 v = aExtrude.xy / EXTRUDE_SCALE;
  vec2 u = n * v;
#endif
float A = tileResolution / resolution;
  vec4 B = vec4(c + vec3(u, .0) * tileRatio / A, 1.);
  gl_Position = projViewModelMatrix * positionMatrix * B;
  if(isRenderingTerrain == .0) {
    float C = min(AA_CLIP_LIMIT / canvasSize.x, AA_CLIP_LIMIT / canvasSize.y);
    float D = distance(gl_Position.xy / gl_Position.w, h.xy / h.w) - C;
    if(D * j < .0) {
      float E = -D / C;
      float F = E * E * E * E * AA_LINE_WIDTH;
      u += F * v;
      n += F / 6.;
      B = vec4(c + vec3(u, .0) * tileRatio / A, 1.);
      gl_Position = projViewModelMatrix * positionMatrix * B;
    }
  }
#ifdef HAS_LINE_DX
float G = aLineDxDy[0];
#else
float G = lineDx;
#endif
#ifdef HAS_LINE_DY
float H = aLineDxDy[1];
#else
float H = lineDy;
#endif
float I = gl_Position.w;
  gl_Position.xy += vec2(G, H) * 2. / canvasSize * I;
#ifndef PICKING_MODE
vWidth = vec2(n, m);
  if(isRenderingTerrain == 1.) {
    vGammaScale = 1.;
  } else {
    vGammaScale = I / cameraToCenterDistance;
  }
#ifndef ENABLE_TILE_STENCIL
vPosition = c.xy;
#ifdef USE_LINE_OFFSET
vPosition += tileRatio * o / EXTRUDE_SCALE;
#endif
#endif
#if defined(HAS_PATTERN) || defined(HAS_DASHARRAY) || defined(HAS_GRADIENT)
#ifdef HAS_GRADIENT
vLinesofar = aLinesofar / MAX_LINE_DISTANCE;
  vGradIndex = aGradIndex;
#else
float J = aLinesofar - k * aExtrude.z / EXTRUDE_SCALE / A * tileRatio;
  vLinesofar = J / tileRatio * A;
#endif
#endif
#ifndef HAS_GRADIENT
#ifdef HAS_COLOR
vColor = aColor;
#endif
#ifdef HAS_DASHARRAY
#ifdef HAS_DASHARRAY_ATTR
vDasharray = aDasharray;
#endif
#ifdef HAS_DASHARRAY_COLOR
vDashColor = aDashColor / 255.;
#endif
#endif
#ifdef HAS_PATTERN
vTexInfo = vec4(aTexInfo.xy, aTexInfo.zw + 1.);
#ifdef HAS_PATTERN_ANIM
vLinePatternAnimSpeed = aLinePattern[0] / 127.;
#endif
#ifdef HAS_PATTERN_GAP
vLinePatternGap = aLinePattern[1] / 10.0;
#endif
#endif
#endif
#ifdef HAS_STROKE_COLOR
vStrokeColor = aStrokeColor;
#endif
#ifdef HAS_OPACITY
vOpacity = aOpacity / 255.;
#endif
#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
shadow_computeShadowPars(B);
#endif
highlight_setVarying();
#else
fbo_picking_setData(I, true);
#endif
}`;
const MB = pn([]), SB = [];
class Uu extends vo {
  static getBloomSymbol() {
    return ["lineBloom"];
  }
  prepareSymbol(t) {
    const e = t.lineColor;
    Array.isArray(e) && (e.length === 3 && e.push(1), t.lineColor = e.map((s) => 255 * s));
    const r = t.lineStrokeColor;
    Array.isArray(r) && (r.length === 3 && r.push(1), t.lineStrokeColor = r.map((s) => 255 * s));
    const n = t.lineDashColor;
    Array.isArray(n) && (n.length === 3 && n.push(1), t.lineDashColor = n.map((s) => 255 * s));
  }
  isAnimating() {
    if (this.wr) return !0;
    const t = this.getSymbols(), e = this.sceneConfig.trailAnimation;
    if (e && e.enable) return !0;
    for (let r = 0; r < t.length; r++) if (t[r].linePatternFile && t[r].linePatternAnimSpeed) return !0;
    return !1;
  }
  needToRedraw() {
    return !!super.needToRedraw() || !!this.isAnimating();
  }
  isBloom(t) {
    return !!this.getSymbol(t.properties.symbolIndex)[Uu.getBloomSymbol()[0]];
  }
  needPolygonOffset() {
    return !0;
  }
  createMesh(t, e) {
    if (!t.geometry) return null;
    const { geometry: r, symbolIndex: n, ref: s } = t, o = this.getSymbolDef(n);
    s === void 0 && Ns(r, o, this.getFnTypeConfig(n));
    const a = this.getSymbol(n), l = {
      tileResolution: r.properties.tileResolution,
      tileRatio: r.properties.tileRatio,
      tileExtent: r.properties.tileExtent
    };
    this.setLineUniforms(a, l), ue(l, "lineColor", a, "lineColor", "#fff", fi(this.colorCache)), ue(l, "linePatterGapColor", a, "linePatterGapColor", [0, 0, 0, 0], fi(this.colorCache)), ue(l, "lineStrokeColor", a, "lineStrokeColor", [0, 0, 0, 0], fi(this.colorCache)), ue(l, "lineDasharray", a, "lineDasharray", [0, 0, 0, 0], (p) => {
      let g;
      if (p && p.length) {
        const m = p;
        p.length === 1 ? g = [m[0], m[0], m[0], m[0]] : p.length === 2 ? g = [m[0], m[1], m[0], m[1]] : p.length === 3 ? g = [m[0], m[1], m[2], m[2]] : p.length === 4 ? g = p : p.length > 4 && (g = p.slice(0, 4));
      }
      return g || [0, 0, 0, 0];
    }), ue(l, "lineDashColor", a, "lineDashColor", [0, 0, 0, 0], fi(this.colorCache));
    const h = r.properties.iconAtlas, u = this.layer instanceof Pn;
    h && (l.linePatternFile = Vu(this.regl, h, !1, !1), l.atlasSize = h ? [h.width, h.height] : [0, 0], l.flipY = u ? -1 : 1, this.drawDebugAtlas(h)), s === void 0 && r.generateBuffers(this.regl);
    const c = new Nr(l), f = new tn(r, c, {
      castShadow: !1,
      picking: !0
    });
    f.setLocalTransform(e), f.positionMatrix = this.getAltitudeOffsetMatrix();
    const d = {};
    return h && (d.HAS_PATTERN = 1), f.properties.symbolIndex = n, this._r(f, d), r.data.aColor && (d.HAS_COLOR = 1), r.data.aStrokeColor && (d.HAS_STROKE_COLOR = 1), this.setMeshDefines(d, r, o), r.data.aAltitude && (d.HAS_ALTITUDE = 1), f.setDefines(d), f;
  }
  addMesh(...t) {
    delete this.wr;
    const e = t[0];
    Array.isArray(e) && e.forEach((r) => {
      this.Sr(r);
    }), super.addMesh(...t);
  }
  Sr(t) {
    if (!t.geometry.aLineWidth && t.material.get("lineWidth") <= 0 || !t.geometry.aOpacity && t.material.get("lineOpacity") <= 0) return;
    const e = t.defines;
    this._r(t, e), t.setDefines(e), t.geometry.properties.hasPatternAnim && (this.wr = 1);
  }
  _r(t, e) {
    const r = t.geometry, n = this.getSymbol(t.properties.symbolIndex);
    r.data.aDasharray || Array.isArray(n.lineDasharray) && n.lineDasharray.reduce((s, o) => s + o, 0) > 0 ? (e.HAS_DASHARRAY = 1, r.data.aDasharray && (e.HAS_DASHARRAY_ATTR = 1), r.data.aDashColor && (e.HAS_DASHARRAY_COLOR = 1)) : e.HAS_DASHARRAY && delete e.HAS_DASHARRAY;
  }
  setLineUniforms(t, e) {
    ue(e, "lineWidth", t, "lineWidth", 2), ue(e, "lineOpacity", t, "lineOpacity", 1), ue(e, "lineStrokeWidth", t, "lineStrokeWidth", 0), ue(e, "lineBlur", t, "lineBlur", 0.7), ue(e, "lineOffset", t, "lineOffset", 0), ue(e, "lineDx", t, "lineDx", 0), ue(e, "lineDy", t, "lineDy", 0), ue(e, "linePatternAnimSpeed", t, "linePatternAnimSpeed", 0), ue(e, "linePatternGap", t, "linePatternGap", 0);
  }
  setMeshDefines(t, e, r) {
    e.data.aOpacity && (t.HAS_OPACITY = 1), e.data.aLineWidth && (t.HAS_LINE_WIDTH = 1), e.data.aLineStrokeWidth && (t.HAS_STROKE_WIDTH = 1), rs(r.lineDx) && (t.HAS_LINE_DX = 1), rs(r.lineDy) && (t.HAS_LINE_DY = 1), rs(r.linePatternAnimSpeed) && (t.HAS_PATTERN_ANIM = 1), rs(r.linePatternGap) && (t.HAS_PATTERN_GAP = 1);
  }
  paint(t) {
    this.isShadowIncludeChanged(t) && (this.shader.dispose(), this.createShader(t)), super.paint(t);
  }
  createFnTypeConfig(t, e) {
    const r = ln(e.lineColor), n = ln(e.aLinePatternAnimSpeed), s = ln(e.aLinePatternGap), o = this.createShapeFnTypeConfigs(t, e), a = new Int8Array(2);
    return [{
      attrName: "aColor",
      symbolName: "lineColor",
      type: Uint8Array,
      width: 4,
      define: "HAS_COLOR",
      evaluate: (l, h) => {
        let u = r(t.getZoom(), l);
        return Ft(u) && (u = this.evaluateInFnTypeConfig(u, h, t, l, !0)), Array.isArray(u) || (u = this.colorCache[u] = this.colorCache[u] || Zi(u).unitArray()), u = Yo(u), u;
      }
    }, {
      attrName: "aLinePattern",
      symbolName: "linePatternAnimSpeed",
      type: Int8Array,
      width: 2,
      related: ["linePatternGap"],
      define: "HAS_LINE_PATTERN",
      evaluate: (l, h, u, c) => {
        let f = n(t.getZoom(), l);
        return gn(f) && (f = 0), f !== 0 && (h.properties.hasPatternAnim = 1), a[0] = f / 127, a[1] = u[c + 1], a;
      }
    }, {
      attrName: "aLinePattern",
      symbolName: "linePatternGap",
      type: Int8Array,
      width: 2,
      related: ["linePatternAnimSpeed"],
      define: "HAS_LINE_PATTERN",
      evaluate: (l, h, u, c) => {
        let f = s(t.getZoom(), l);
        return gn(f) && (f = 0), a[1] = 10 * f, a[0] = u[c], a;
      }
    }].concat(o);
  }
  createShapeFnTypeConfigs(t, e) {
    const r = he(e.lineWidth), n = he(e.lineOpacity), s = he(e.lineStrokeWidth), o = he(e.lineDx), a = he(e.lineDy), l = new Uint16Array(1), h = new Int8Array(1);
    return [{
      attrName: "aLineWidth",
      symbolName: "lineWidth",
      type: Uint8Array,
      width: 1,
      define: "HAS_LINE_WIDTH",
      evaluate: (u, c) => {
        let f = r(t.getZoom(), u);
        return Ft(f) && (f = this.evaluateInFnTypeConfig(f, c, t, u)), l[0] = Math.round(2 * f), l[0];
      }
    }, {
      attrName: "aLineStrokeWidth",
      symbolName: "lineStrokeWidth",
      type: Uint8Array,
      width: 1,
      define: "HAS_STROKE_WIDTH",
      evaluate: (u) => {
        const c = s(t.getZoom(), u);
        return l[0] = Math.round(2 * c), l[0];
      }
    }, {
      attrName: "aLineDxDy",
      symbolName: "lineDx",
      type: Int8Array,
      width: 2,
      define: "HAS_LINE_DX",
      evaluate: (u) => {
        const c = o(t.getZoom(), u);
        return h[0] = c, h[0];
      }
    }, {
      attrName: "aLineDxDy",
      symbolName: "lineDy",
      type: Int8Array,
      width: 2,
      define: "HAS_LINE_DY",
      evaluate: (u) => {
        const c = a(t.getZoom(), u);
        return h[0] = c, h[0];
      }
    }, {
      attrName: "aOpacity",
      symbolName: "lineOpacity",
      type: Uint8Array,
      width: 1,
      define: "HAS_OPACITY",
      evaluate: (u, c) => {
        let f = n(t.getZoom(), u);
        return Ft(f) && (f = this.evaluateInFnTypeConfig(f, c, t, u)), l[0] = 255 * f, l[0];
      }
    }];
  }
  updateSceneConfig(t) {
    t.trailAnimation && this.createShader(this.Mr);
  }
  init(t) {
    const e = this.regl;
    this.renderer = new hn(e), this.createShader(t), this.pickingFBO && (this.picking = [new Oi(this.renderer, {
      vert: `#define PICKING_MODE 1
` + Q0,
      uniforms: [{
        name: "projViewModelMatrix",
        type: "function",
        fn: function(r, n) {
          const s = [];
          return Jt(s, n.projViewMatrix, n.modelMatrix), s;
        }
      }],
      extraCommandProps: this.getExtraCommandProps()
    }, this.pickingFBO, this.getMap())]);
  }
  createShader(t) {
    this.Mr = t;
    const e = [], r = {};
    this.fillIncludes(r, e, t), this.sceneConfig.trailAnimation && this.sceneConfig.trailAnimation.enable && (r.HAS_TRAIL = 1);
    const n = [];
    e.push({
      name: "projViewModelMatrix",
      type: "function",
      fn: function(s, o) {
        return Jt(n, o.projViewMatrix, o.modelMatrix), n;
      }
    }), this.shader = new qe({
      vert: Q0,
      frag: `#define SHADER_NAME LINE
#define DEVICE_PIXEL_RATIO 1.0
precision highp float;
#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
#include <vsm_shadow_frag>
#endif
uniform lowp float blendSrcIsOne;
uniform lowp float lineBlur;
uniform float isRenderingTerrain;
#ifdef HAS_COLOR
varying vec4 vColor;
#else
uniform lowp vec4 lineColor;
#endif
#include <highlight_frag>
#ifdef HAS_STROKE_COLOR
varying vec4 vStrokeColor;
#else
uniform lowp vec4 lineStrokeColor;
#endif
#ifdef HAS_OPACITY
varying float vOpacity;
#else
uniform lowp float lineOpacity;
#endif
uniform float layerOpacity;
#ifdef HAS_PATTERN
uniform sampler2D linePatternFile;
uniform vec2 atlasSize;
uniform float flipY;
#ifdef HAS_PATTERN_ANIM
varying float vLinePatternAnimSpeed;
#else
uniform float linePatternAnimSpeed;
#endif
#ifdef HAS_PATTERN_GAP
varying float vLinePatternGap;
#else
uniform float linePatternGap;
#endif
uniform vec4 linePatterGapColor;
varying vec4 vTexInfo;
vec2 c(vec2 d) {
  vec2 e = mod(d, 1.);
  vec2 f = vTexInfo.xy;
  vec2 h = vTexInfo.zw;
  return (f + e * h) / atlasSize;
}
#endif
varying vec2 vNormal;
varying vec2 vWidth;
varying float vGammaScale;
#ifndef ENABLE_TILE_STENCIL
varying vec2 vPosition;
#endif
uniform float tileExtent;
#ifdef HAS_DASHARRAY
#ifdef HAS_DASHARRAY_ATTR
varying vec4 vDasharray;
#else
uniform vec4 lineDasharray;
#endif
#ifdef HAS_DASHARRAY_COLOR
varying vec4 vDashColor;
#else
uniform vec4 lineDashColor;
#endif
#endif
#if defined(HAS_PATTERN) || defined(HAS_DASHARRAY) || defined(HAS_GRADIENT) || defined(HAS_TRAIL)
varying highp float vLinesofar;
#endif
#ifdef HAS_TRAIL
uniform float trailSpeed;
uniform float trailLength;
uniform float trailCircle;
#endif
#if defined(HAS_TRAIL) || defined(HAS_PATTERN)
uniform float currentTime;
#endif
float i(float j, float k) {
  float l = k / 2.;
  float m = abs(j - l);
  float n = (.1 + 1. / DEVICE_PIXEL_RATIO) * vGammaScale;
  return clamp(min(m + n, l - m) / n, .0, 1.);
}
varying vec3 vVertex;
uniform vec3 cameraPosition;
uniform float cameraToCenterDistance;
void main() {
  
#ifndef ENABLE_TILE_STENCIL
float o = sign(tileExtent - min(tileExtent, abs(vPosition.x))) * sign(1. + sign(vPosition.x)) * sign(tileExtent - min(tileExtent, abs(vPosition.y))) * sign(1. + sign(vPosition.y));
  if(o == .0) {
    discard;
  }
#endif
#if defined(HAS_PATTERN) || defined(HAS_DASHARRAY) || defined(HAS_GRADIENT) || defined(HAS_TRAIL)
float u = vLinesofar;
#endif
float v = length(vNormal) * vWidth.s;
#ifdef HAS_PATTERN
vec2 h = vTexInfo.zw;
  float A = sign(h.x * h.y);
  float B = mix(lineBlur, .0, A);
#else
float B = lineBlur;
#endif
float n = (B + 1. / DEVICE_PIXEL_RATIO) * vGammaScale;
  float C = clamp(min(v - (vWidth.t - n), vWidth.s - v) / n, .0, 1.);
#ifdef HAS_COLOR
vec4 D = vColor / 255.;
#else
vec4 D = lineColor;
#endif
#ifdef HAS_PATTERN
if(A == 1.) {
    
#ifdef HAS_PATTERN_GAP
float E = vLinePatternGap;
#else
float E = linePatternGap;
#endif
#ifdef HAS_PATTERN_ANIM
float F = vLinePatternAnimSpeed;
#else
float F = linePatternAnimSpeed;
#endif
float G = h.x * vWidth.s * 2. / h.y;
    float H = G * (1. + E);
    u += mod(currentTime * -F * .2, H);
    float I = mod(u / H, 1.);
    float J = mod((flipY * vNormal.y + 1.) / 2., 1.);
    vec4 K = texture2D(linePatternFile, c(vec2(I * (1. + E), J)));
    float L = clamp(sign(1. / (1. + E) - I) + .000001, .0, 1.);
    K = mix(linePatterGapColor, K, L);
    D *= K;
  }
#endif
#ifdef HAS_DASHARRAY
#ifdef HAS_DASHARRAY_ATTR
vec4 M = vDasharray;
#else
vec4 M = lineDasharray;
#endif
#ifdef HAS_DASHARRAY_COLOR
vec4 N = vDashColor;
#else
vec4 N = lineDashColor;
#endif
float k = M[0] + M[1] + M[2] + M[3];
  float j = mod(u, k);
  float O = max(sign(M[0] - j), .0);
  float P = j - M[0] - M[1];
  float Q = max(sign(P), .0) * max(sign(M[2] - P), .0);
  float R = O + Q;
  float S = i(j, M[0]);
  float T = i(P, M[2]);
  float U = S * O + T * Q;
  D = D * (1. - U) + N * U;
#endif
#ifdef HAS_STROKE_COLOR
vec4 V = vStrokeColor / 255.;
#else
vec4 V = lineStrokeColor;
#endif
V = mix(D, V, sign(vWidth.t));
  D = V * C + max(sign(vWidth.t - v), .0) * D * (1. - C);
#ifdef HAS_TRAIL
float W = mod(u - currentTime * trailSpeed * .1, trailCircle);
  float X = W < trailLength ? mix(.0, 1., W / trailLength) : .0;
  D *= X;
#endif
#ifdef HAS_OPACITY
float Y = vOpacity;
#else
float Y = lineOpacity;
#endif
gl_FragColor = D * Y * layerOpacity;
#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
float Z = shadow_computeShadow();
  gl_FragColor.rgb = shadow_blend(gl_FragColor.rgb, Z);
#endif
float ba;
  if(isRenderingTerrain == 1.) {
    ba = 1.;
  } else {
    ba = clamp(cameraToCenterDistance * 1.5 / distance(vVertex, cameraPosition), .0, 1.);
  }
  gl_FragColor *= ba;
  gl_FragColor = highlight_blendColor(gl_FragColor);
}`,
      uniforms: e,
      defines: r,
      extraCommandProps: this.getExtraCommandProps()
    });
  }
  getExtraCommandProps() {
    const t = this.layer.getRenderer().isEnableTileStencil && this.layer.getRenderer().isEnableTileStencil(), e = this.canvas;
    return {
      viewport: {
        x: (r, n) => n.viewport ? n.viewport.x : 0,
        y: (r, n) => n.viewport ? n.viewport.y : 0,
        width: (r, n) => n.viewport ? n.viewport.width : e ? e.width : 1,
        height: (r, n) => n.viewport ? n.viewport.height : e ? e.height : 1
      },
      stencil: {
        enable: !1,
        func: {
          cmp: () => t ? "=" : "<=",
          ref: (r, n) => t ? n.stencilRef : n.level
        },
        op: {
          fail: "keep",
          zfail: "keep",
          zpass: () => t ? "zero" : "replace"
        }
      },
      depth: {
        enable: !0,
        range: this.sceneConfig.depthRange || [0, 1],
        mask: this.sceneConfig.depthMask || !1,
        func: this.sceneConfig.depthFunc || "<="
      },
      blend: {
        enable: !0,
        func: this.getBlendFunc(),
        equation: "add"
      },
      polygonOffset: {
        enable: !0,
        offset: this.getPolygonOffset()
      }
    };
  }
  getUniformValues(t, e) {
    const r = e && e.isRenderingTerrainSkin, n = this.layer.getTileSize().width, s = r ? MB : t.projViewMatrix, o = t.viewMatrix, a = t.cameraToCenterDistance, l = t.getResolution(), h = we(SB, t.width, t.height);
    r && we(h, n, n);
    const u = this.getBlendFunc().src(), c = this.sceneConfig.trailAnimation || {}, f = {
      layerScale: this.layer.options.styleScale || 1,
      projViewMatrix: s,
      viewMatrix: o,
      cameraToCenterDistance: a,
      resolution: l,
      canvasSize: h,
      trailSpeed: c.speed || 1,
      trailLength: c.trailLength || 500,
      trailCircle: c.trailCircle || 1e3,
      currentTime: this.layer.getRenderer().getFrameTimestamp() || 0,
      blendSrcIsOne: +!(u !== 1 && u !== "one"),
      cameraPosition: t.cameraPosition,
      viewport: r && e && e.viewport,
      isRenderingTerrain: +!!r
    };
    return this.setIncludeUniformValues(f, e), f;
  }
}
class kP extends Uu {
  postCreateGeometry(t) {
    const { symbolIndex: e, geometry: r } = t, { features: n } = r.properties, s = this.getSymbol(e).lineGradientProperty, o = r.data.aPickingId, a = new Uint8Array(o.length), l = [];
    let h = o[0];
    const u = n[h].feature.properties;
    l.push(u && u[s] || 0);
    for (let c = 1; c < o.length; c++) o[c] !== h && (h = o[c], l.push(u && u[s] || 0)), a[c] = l.length - 1;
    r.data.aGradIndex = a, r.properties.gradients = l;
  }
  createMesh(t, e) {
    const { geometry: r, symbolIndex: n, ref: s } = t, o = this.getSymbolDef(n);
    s === void 0 && Ns(r, o, this.getFnTypeConfig(n));
    const a = {
      tileResolution: r.properties.tileResolution,
      tileRatio: r.properties.tileRatio,
      tileExtent: r.properties.tileExtent
    }, l = this.getSymbol(n);
    this.setLineUniforms(l, a);
    const h = r.properties.gradients;
    let u = 2 * h.length;
    RP(u) || (u = IP(u));
    const c = this.regl.texture({
      width: 256,
      height: u,
      data: CB(h),
      format: "rgba",
      mag: "linear",
      min: "linear",
      flipY: !1
    });
    a.lineGradientTexture = c, a.lineGradientTextureHeight = c.height, s === void 0 && r.generateBuffers(this.regl);
    const f = new Nr(a), d = new tn(r, f, {
      castShadow: !1,
      picking: !0
    });
    d.setLocalTransform(e);
    const p = {
      HAS_GRADIENT: 1
    };
    return r.data.aAltitude && (p.HAS_ALTITUDE = 1), this.setMeshDefines(p, r, o), d.setDefines(p), d.properties.symbolIndex = n, d;
  }
  createFnTypeConfig(t, e) {
    return this.createShapeFnTypeConfigs(t, e);
  }
  createShader(t) {
    this.Mr = t;
    const e = [], r = {};
    this.fillIncludes(r, e, t), this.sceneConfig.trailAnimation && this.sceneConfig.trailAnimation.enable && (r.HAS_TRAIL = 1);
    const n = [];
    e.push({
      name: "projViewModelMatrix",
      type: "function",
      fn: function(s, o) {
        return Jt(n, o.projViewMatrix, o.modelMatrix), n;
      }
    }), this.shader = new qe({
      vert: Q0,
      frag: `#define SHADER_NAME LINE_GRADIENT
#define DEVICE_PIXEL_RATIO 1.0
#define MAX_LINE_COUNT 128.0
precision mediump float;
#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
#include <vsm_shadow_frag>
#endif
#ifdef HAS_OPACITY
varying float vOpacity;
#else
uniform lowp float lineOpacity;
#endif
uniform float layerOpacity;
uniform lowp float lineBlur;
uniform float lineGradientTextureHeight;
uniform float tileExtent;
uniform sampler2D lineGradientTexture;
varying vec2 vNormal;
varying vec2 vWidth;
varying float vGammaScale;
varying highp float vLinesofar;
varying float vGradIndex;
#ifndef ENABLE_TILE_STENCIL
varying vec2 vPosition;
#endif
#ifdef HAS_TRAIL
uniform float trailSpeed;
uniform float trailLength;
uniform float trailCircle;
uniform float currentTime;
#endif
#include <highlight_frag>
void main() {
  
#ifndef ENABLE_TILE_STENCIL
float c = sign(tileExtent - min(tileExtent, abs(vPosition.x))) * sign(1. + sign(vPosition.x)) * sign(tileExtent - min(tileExtent, abs(vPosition.y))) * sign(1. + sign(vPosition.y));
  if(c == .0) {
    discard;
  }
#endif
float d = length(vNormal) * vWidth.s;
  float e = (lineBlur + 1. / DEVICE_PIXEL_RATIO) * vGammaScale;
  float f = clamp(min(d - (vWidth.t - e), vWidth.s - d) / e, .0, 1.);
  float h = vLinesofar;
  vec4 i = texture2D(lineGradientTexture, vec2(h, (vGradIndex * 2. + .5) / lineGradientTextureHeight)) * f;
  i *= max(sign(MAX_LINE_COUNT - vGradIndex), .0);
#ifdef HAS_TRAIL
float j = mod(h - currentTime * trailSpeed * .1, trailCircle);
  float k = j < trailLength ? mix(.0, 1., j / trailLength) : .0;
  i *= k;
#endif
#ifdef HAS_OPACITY
float l = vOpacity;
#else
float l = lineOpacity;
#endif
gl_FragColor = i * l * layerOpacity;
#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
float m = shadow_computeShadow();
  gl_FragColor.rgb = shadow_blend(gl_FragColor.rgb, m);
#endif
gl_FragColor = highlight_blendColor(gl_FragColor);
}`,
      uniforms: e,
      defines: r,
      extraCommandProps: this.getExtraCommandProps()
    });
  }
}
function CB(i) {
  i.length > 128 && (console.warn("Line count in a tile exceeds maximum limit (128) for line-gradient render plugin."), i = i.slice(0, 128));
  const t = document.createElement("canvas"), e = t.getContext("2d");
  t.width = 256, t.height = 2 * i.length, RP(t.height) || (t.height = IP(2 * i.length));
  for (let r = 0; r < i.length; r++) {
    const n = i[r], s = e.createLinearGradient(0, 0, 256, 0);
    for (let a = 0; a < n.length; a += 2) s.addColorStop(+n[a], n[a + 1]);
    e.fillStyle = s;
    const o = r % 256;
    e.fillRect(0, 2 * o, 256, 2 * o + 2);
  }
  return e.canvas;
}
function RP(i) {
  return (i & i - 1) == 0 && i !== 0;
}
function IP(i) {
  return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
}
class wd {
  constructor(t) {
    this.N = t || [], this.properties = {};
  }
  set meshes(t) {
    this.N = t;
  }
  get meshes() {
    return this.N;
  }
}
const Fa = 224, PB = 600, rf = 100, EB = new Uint8Array(1), La = [], OB = {
  collides: 0,
  boxes: []
}, Qb = [], za = [];
class DP extends vo {
  createGeometry(...t) {
    const e = super.createGeometry(...t);
    if (!e || !e.geometry) return e;
    const { geometry: r } = e, n = t[0];
    r.properties.collideIds = n.featureIds && n.featureIds.length && n.isIdUnique ? n.featureIds : n.data.aPickingId;
    const s = this.layer instanceof Pn;
    return r.properties.uniqueCollideIds = Ff(r.properties.collideIds, !s), e;
  }
  supportRenderMode(t) {
    const e = this.sceneConfig.renderToPointRenderTarget;
    return e || e === void 0 ? t === "point" : t === "fxaa" || t === "fxaaAfterTaa";
  }
  addMesh(t, e, r) {
    if (t && !this.isEnableCollision()) {
      let n = t;
      Array.isArray(n) || (Qb[0] = t, n = Qb);
      for (let s = 0; s < n.length; s++) {
        const o = n[s].defines;
        delete o.ENABLE_COLLISION, n[s].setDefines(o);
        const { elements: a, visElemts: l } = n[s].geometry.properties;
        l && l.count !== void 0 && l.count !== a.length && (n[s].geometry.setElements(a), l.count = a.length);
      }
    }
    return super.addMesh(t, e, r);
  }
  startMeshCollision(t) {
    const { meshKey: e } = t.properties, { renderer: r } = this.Pr, n = r.isForeground(t instanceof wd ? t.meshes[0] : t);
    if (t.properties.isForeground = n, t instanceof wd && t.meshes.length) for (let s = 0; s < t.meshes.length; s++) t.meshes[s].properties.isForeground = n;
    this.Tr = performance.now(), this.kr = this.Or(), this.Ir = this.Fr(e);
  }
  endMeshCollision(t) {
    const e = this.Cr.tags[t];
    if (this.kr && e && this.Ir) {
      const r = this.getMap();
      this.Er || (this.Er = new lt(0, 0), this.Dr = new lt(0, 0)), e.anchor0 = r.containerPointToCoord(this.Nr, this.Er), e.anchor1 = r.containerPointToCoord(this.Lr, this.Dr), e.anchor0.z = r.getZoom(), e.anchor0.width = r.width, e.anchor0.height = r.height, e.anchor0.pitch = r.getPitch();
    }
    this.getMap().collisionFrameTime += performance.now() - this.Tr;
  }
  Fr(t) {
    const e = this.getMap(), r = e.getZoom(), n = e.getPitch(), [s, o] = this.Rr(t);
    return !s || !o || s.z !== r || s.width !== e.width || s.height !== e.height || s.pitch !== n || s.distanceTo(this.Nr) > 3 || o.distanceTo(this.Lr) > 3;
  }
  Hr() {
    const t = this.getMap();
    this.zr = {}, this.Nr = new Y(t.width / 3, t.height / 2), this.Lr = new Y(2 * t.width / 3, t.height / 2), delete this.kr, this.Cr || (this.Cr = {
      tags: {}
    }), this.Pr = {
      layer: this.layer,
      renderer: this.layer.getRenderer(),
      frameTimestamp: this.layer.getRenderer().getFrameTimestamp(),
      map: this.getMap(),
      zoom: t.getZoom(),
      collisionTags: this.Cr.tags,
      isEnableUniquePlacement: this.isEnableUniquePlacement()
    };
  }
  Vr() {
  }
  Ur(t, e) {
    const r = this.Cr;
    return r.tags[t] && r.tags[t][e];
  }
  jr(t, e, r) {
    const n = this.Cr;
    n.tags[t] = n.tags[t] || [], n.tags[t][e] = r;
  }
  Or() {
    const t = this.getMap();
    if (!t.isInteracting()) return !0;
    const e = this.layer.options.collisionFrameLimit;
    return t.collisionFrameTime <= e;
  }
  Rr(t) {
    const e = "__meshAnchorKey".trim(), r = this.Cr.tags[t];
    if (r && r.anchor0) {
      const { anchor0: n, anchor1: s } = r, o = n[e] = n[e] || n.x + "," + n.y, a = s[e] = s[e] || s.x + "," + s.y;
      let l = this.zr[o], h = this.zr[a];
      if (!l || !h) {
        const u = this.getMap();
        l = this.zr[o] = u.coordToContainerPoint(n), h = this.zr[a] = u.coordToContainerPoint(s);
      }
      return l.z = n.z, La[0] = l, La[1] = h, l.width = n.width, l.height = n.height, La;
    }
    return La[0] = La[1] = null, La;
  }
  updateBoxCollisionFading(t, e, r, n, s) {
    const { layer: o, renderer: a, zoom: l, collisionTags: h, isEnableUniquePlacement: u } = this.Pr, { meshKey: c, isForeground: f } = e.properties;
    if (u && this.Br(c, s)) return !1;
    const d = r.length;
    let p = h[c] && h[c][s];
    const g = p, m = this.Gr && p;
    if (!(m && p.collides !== 0) && t) {
      const x = m && p.collides === 0;
      if (this.kr || x) if ((this.Ir || p && p.z !== l) && (p = null), p) {
        if (p.boxes && p.boxes.length) {
          const { boxes: w, isAllowOverlap: b } = p;
          let T = 0;
          if (!b) {
            let A = 0;
            for (let M = 0; M < w.length; M++) if (!T) {
              const S = this.isCollides(w[M]);
              if (S === -1) A++;
              else if (S === 1) {
                T = 1;
                break;
              }
            }
            A === w.length && (T = -1);
          }
          p.collides = T;
        }
      } else {
        p = g || {
          collides: 0,
          boxes: []
        }, p.boxes.length = 0, p.z = l;
        let w = 0;
        for (let b = 0; b < d; b++) {
          const { mesh: T, allElements: A, boxCount: M, start: S, end: P } = r[b], C = this.Wr(T, A, M, S, P, n, s);
          C.isAllowOverlap && (p.isAllowOverlap = 1), w === 0 && (w = C.collides), C.boxes && p.boxes.push(...C.boxes);
        }
        p.collides = w, this.jr(c, s, p);
      }
    }
    let v = t && p && p.collides === 0, _ = 1, y = !1;
    if (this.sceneConfig.fading) {
      const x = this.Xr(e);
      if (this.Yr) x[s] = v ? 1 : -1;
      else if (f && delete e.$r, _ = this.qr(f, v, x, s), f ? (_ > 0 && (v = !0), y = this.isBoxFading(e, s), y && this.setToRedraw()) : v || (this.Jr(x, s), _ = 0), v) {
        const w = e.$r;
        if (w && _ === 1 && x[s] > 0) {
          let { fadeOutDelay: b, fadingDuration: T } = this.sceneConfig;
          gn(T) && (T = Fa), gn(b) && (b = rf);
          const A = _d(1 - (a.getFrameTimestamp() - w - b) / T, 0, 1);
          _ *= A, A > 0 && this.setToRedraw();
        }
      }
    }
    if (p && o.options.debugCollision && this.addCollisionDebugBox(p.boxes, p.collides ? 0 : 1), v || y) {
      const { mesh: x, start: w } = r[0], b = this.getSymbol(x.properties.symbolIndex);
      !this.Zr(b, x, w) && p && p.boxes && this.Kr(p.boxes, x);
    }
    if (v) {
      const x = EB[0] = 255 * _;
      for (let w = 0; w < d; w++) {
        const { mesh: b, allElements: T, start: A, end: M, boxIndex: S } = r[w];
        this.setCollisionOpacity(b, T, x, A, M, S);
      }
    }
    return v && _ > 0;
  }
  isMeshIterable() {
    return !0;
  }
  setCollisionOpacity(t, e, r, n, s) {
    const o = e[n], a = e[s - 1];
    this.Qr(t, r, o, a);
  }
  Qr(t, e, r, n) {
    const { aOpacity: s } = t.geometry.properties;
    if (!s) return;
    const o = r;
    if (s[o] !== e) {
      const a = n;
      for (let l = o; l <= a; l++) s[l] = e;
      s.dirty = !0;
    }
  }
  isBoxFading(t, e) {
    const { frameTimestamp: r } = this.Pr;
    let n = this.sceneConfig.fadingDuration;
    return gn(n) && (n = Fa), r - Math.abs(this.Xr(t)[e]) < n;
  }
  Wr(t, e, r, n, s, o, a) {
    const l = this.getSymbol(t.properties.symbolIndex), h = this.Zr(l, t, e[n]), u = this.ts(l, t, e[n]);
    if (!this.isEnableCollision() || h && u) return OB;
    const c = this.isBoxCollides(t, e, r, n, s, o, a);
    return u && (c.collides = 0, c.isAllowOverlap = 1), c;
  }
  Zr(t, e, r) {
    if (!this.isEnableCollision()) return !0;
    const n = e.geometry.properties.aOverlap;
    if (!n) return +t[this.propIgnorePlacement] == 1;
    const s = n[r], o = s % 8;
    return s < 2 ? +t[this.propIgnorePlacement] == 1 : o % 2;
  }
  ts(t, e, r) {
    if (!this.isEnableCollision()) return !0;
    const n = e.geometry.properties.aOverlap;
    if (!n) return +t[this.propAllowOverlap] == 1;
    const s = n[r], o = s >> 2;
    return s < 2 ? +t[this.propAllowOverlap] == 1 : o % 2;
  }
  Kr(t) {
    if (Array.isArray(t[0])) for (let e = 0; e < t.length; e++) this.insertCollisionBox(t[e]);
    else this.insertCollisionBox(t);
  }
  qr(t, e, r, n) {
    let { fadingDuration: s, fadeInDelay: o, fadeOutDelay: a } = this.sceneConfig;
    gn(s) && (s = Fa), gn(o) && (o = PB), gn(a) && (a = rf);
    const { frameTimestamp: l } = this.Pr;
    let h = r[n], u = e ? 1 : 0;
    if (!h) return e && t && (r[n] = l + o), 0;
    if (l < Math.abs(h) && (!e && h > 0 || e && h < 0)) {
      const c = l - s;
      r[n] = h = e ? c : -c;
    }
    return l - Math.abs(h) < s ? u = h > 0 ? (l - h) / s : 1 - (l + h) / s : e ? (h < 0 && (r[n] = h = l + o), u = (l - h) / s) : (h > 0 && (r[n] = h = -(l + a)), u = 1 - (l + h) / s), (u < 0 || u > 1) && (u = _d(u, 0, 1)), u;
  }
  Xr(t) {
    this.es || (this.es = {});
    const { meshKey: e } = t.properties;
    if (!this.es[e]) {
      const { frameTimestamp: r } = this.Pr;
      this.es[e] = {
        timestamp: r
      };
    }
    return this.es[e];
  }
  ns(t) {
    if (!this.rs) return void (this.rs = t);
    const e = this.scene.getMeshes();
    if (e && e.length) {
      for (let r = 0; r < e.length; r++) {
        const n = this.Xr(e[r]);
        n.timestamp < this.rs ? delete e[r]._fading_timestamps : n.timestamp = t;
      }
      this.rs = t;
    }
  }
  Jr(t, e) {
    if (!t) return;
    const { frameTimestamp: r } = this.Pr;
    let { fadingDuration: n } = this.sceneConfig;
    gn(n) && (n = Fa), t[e] = -(r - n - 1);
  }
  deleteMesh(t, e) {
    if (t) {
      if (Array.isArray(t)) for (let r = 0; r < t.length; r++) {
        const n = t[r].properties.meshKey;
        this.Cr && delete this.Cr.tags[n], this.es && delete this.es[n];
      }
      else {
        const r = t.properties.meshKey;
        this.Cr && delete this.Cr.tags[r], this.es && delete this.es[r];
      }
      super.deleteMesh(t, e);
    }
  }
  delete(t) {
    this.ss && (this.ss.geometry.dispose(), this.os.dispose(), this.ss.dispose(), delete this.ss, delete this.os, delete this.as), delete this.Cr, super.delete(t);
  }
  isCollides(t) {
    const e = this.layer, r = e.getMap(), n = r.getDevicePixelRatio();
    if (Sl(za, t, 1 / n), r.isOffscreen(za)) return -1;
    const s = e.getCollisionIndex(), o = this.sceneConfig.collisionBufferSize || e.options.collisionBufferSize || 0;
    return o && (t = Am(za, t, o)), +s.collides(t);
  }
  insertCollisionBox(t) {
    const e = this.layer, r = e.getCollisionIndex(), n = this.sceneConfig.collisionBufferSize || e.options.collisionBufferSize || 0;
    let s = t;
    n && (s = t.ls = t.ls || [], t = Am(s, t, n)), r.insertBox(s);
  }
  addCollisionDebugBox(t, e) {
    if (t && t.length) if (Array.isArray(t[0])) for (let r = 0; r < t.length; r++) {
      const n = t[r];
      this.hs(n, e);
    }
    else this.hs(t, e);
  }
  hs(t, e) {
    if (!t) return;
    const r = this.us = this.us || {
      aPosition: [],
      aVisible: [],
      indices: []
    }, n = this.sceneConfig.collisionBufferSize || this.layer.options.collisionBufferSize || 0;
    n && (t = Am(za, t, n));
    const s = this.getMap(), o = s.getDevicePixelRatio();
    if (Sl(za, t, 1 / o), s.isOffscreen(za)) return;
    const a = r.aPosition.length / 2;
    r.aPosition.push(t[0], t[1], t[2], t[1], t[2], t[3], t[0], t[3]), r.aVisible.push(e, e, e, e), r.indices.push(a, a + 1, a + 1, a + 2, a + 2, a + 3, a + 3, a);
  }
  updateCollision(t) {
    super.updateCollision(t), this.Hr(), this.cs(), this.fs && this.fs.length && (this.ds(), this.fs && (this.setToRedraw(), this.scene.addMesh(this.fs))), (this.getMap().isZooming() || this.fs && this.fs.length) && (this.ps(), this.ms(this.scene.getMeshes()));
  }
  paint(t) {
    const e = super.paint(t);
    return this.ys(t), this.kr === !1 && this.setToRedraw(), e;
  }
  shouldIgnoreBackground() {
    return !this.getMap().isZooming() && !this.fs;
  }
  cs() {
    const t = this.getMap(), e = t.isZooming();
    if (!e && this.Gr) {
      const r = this.layer.getRenderer();
      this.fs = this.scene.getMeshes().filter((n) => !r.isForeground(n) && !n.properties.isLinePlacement);
    } else e && !this.Gr && (this.gs = t.getResolution());
    if (e) this.vs && (clearTimeout(this.vs), delete this.Yr, delete this.vs), this.Yr = this.gs && t.getResolution() > this.gs;
    else if (this.Gr && !this.vs) {
      let { fadeOutDelay: r, fadingDuration: n } = this.sceneConfig;
      gn(r) && (r = rf), gn(n) && (n = Fa), this.vs = setTimeout(() => {
        delete this.Yr, delete this.vs;
      }, r + n + 1);
    }
    this.Gr = e;
  }
  ys(t) {
    if (!this.us || !this.layer.options.debugCollision) return;
    this.as || this.xs();
    const { aPosition: e, aVisible: r, indices: n } = this.us;
    if (!this.ss) {
      const o = new er({
        aPosition: [],
        aVisible: []
      }, [], 0, {
        positionSize: 2,
        primitive: "lines"
      });
      this.ss = new tn(o), this.bs = new ur(), this.bs.addMesh(this.ss);
    }
    const s = this.ss.geometry;
    s.updateData("aPosition", new Float32Array(e)), s.updateData("aVisible", new Uint8Array(r)), s.setElements(n), this.as.render(this.os, {
      size: [this.canvas.width, this.canvas.height]
    }, this.bs, this.getRenderFBO(t)), delete this.us;
  }
  xs() {
    const t = this.regl;
    this.as = new hn(t);
    const e = this.canvas, r = {
      x: 0,
      y: 0,
      width: () => e ? e.width : 1,
      height: () => e ? e.height : 1
    };
    this.os = new qe({
      vert: `attribute vec2 aPosition;
attribute float aVisible;
uniform vec2 size;
varying vec4 vColor;
void main() {
  vec2 c = (aPosition / size - .5) * 2. * vec2(1., -1.);
  gl_Position = vec4(c, .0, 1.);
  vColor = mix(vec4(1., .0, .0, 1.5) * .5, vec4(.0, 1., .0, 1.) * .4, aVisible);
}`,
      frag: `precision mediump float;
varying vec4 vColor;
void main() {
  gl_FragColor = vec4(vColor.rgb, .5);
}`,
      uniforms: ["size"],
      extraCommandProps: {
        viewport: r,
        depth: {
          enable: !1
        },
        blend: {
          enable: !0,
          func: {
            src: "src alpha",
            dst: "one minus src alpha"
          },
          equation: "add"
        }
      }
    });
  }
  ds() {
    let { fadeOutDelay: t, fadingDuration: e } = this.sceneConfig;
    gn(t) && (t = rf), gn(e) && (e = Fa);
    const r = this.layer.getRenderer(), n = r.getCurrentTileZoom(), s = r.getFrameTimestamp(), o = [];
    for (let a = 0; a < this.fs.length; a++) {
      const l = this.fs[a], h = l.properties.tile;
      !l.$r && r.isBackTile(h.id) && (l.$r = s);
      const u = h.z - n > 0 ? 2 * (h.z - n) - 1 : 2 * (n - h.z);
      l.properties.level = u, r.isForeground(l) || l.$r && s - l.$r > t + e ? delete l.$r : o.push(l);
    }
    delete this.fs, o.length && (this.fs = o);
  }
  isEnableCollision() {
    return this.layer.options.collision && !!this.sceneConfig.collision;
  }
  isEnableUniquePlacement() {
    return this.isEnableCollision() && this.sceneConfig.uniquePlacement;
  }
  isMeshUniquePlaced(t) {
    return this.isMeshIterable(t);
  }
  ps() {
    if (!this.isEnableUniquePlacement()) return;
    const t = this.scene.getMeshes(), e = (r, n, s, o) => {
      const { start: a, end: l } = n[0], h = r.geometry.properties, u = h.elements;
      let c = h.uniquePlacements;
      if (c || (c = h.uniquePlacements = []), c[o] === void 0) {
        const f = this.getUniqueEntryKey(r, u[a], o);
        c[o] = f ? {
          key: f,
          index: o,
          start: u[a],
          end: u[l - 1]
        } : null;
      }
    };
    for (let r = 0; r < t.length; r++) {
      const n = t[r];
      this.isMeshUniquePlaced(n) && this.forEachBox(n, e);
    }
  }
  ms(t) {
    if (!this.isEnableUniquePlacement()) return;
    const e = this.getMap().getZoom();
    let r = !this.As || this.ws !== e;
    if (!r) {
      for (let o = 0; o < t.length; o++) if (!this.As[t[o].properties.meshKey]) {
        r = !0;
        break;
      }
    }
    if (!r) return;
    this.ws = e, this._s = {}, this.As = {}, t = t.sort(RB);
    const n = this.getMap().getGLScale(), s = {};
    for (let o = 0; o < t.length; o++) {
      const a = t[o];
      if (!a.geometry) continue;
      const { meshKey: l } = a.properties;
      this.As[l] = 1;
      const { uniquePlacements: h } = a.geometry.properties;
      if (h) for (let u = 0; u < h.length; u++) {
        if (!h[u]) continue;
        const { key: c, index: f } = h[u], d = this.Xr(a), p = kB(c, n), g = s[p];
        if (g) {
          const m = g.length, v = g[m - 3].properties.meshKey, _ = g[m - 2], y = g[m - 1];
          this._s[v] = this._s[v] || {}, this._s[v][y] = 1, this.Ss(d, f, _, y), g.push(a, d, f);
        } else s[p] = [a, d, f];
      }
    }
    for (const o in s) {
      const a = s[o];
      if (a.length <= 6) continue;
      const l = a.length, h = a[l - 2][a[l - 1]];
      if (a[1][a[2]] !== h) for (let u = 0; u < l - 6; u += 3)
        a[u + 1][a[u + 2]] = h;
    }
  }
  Ss(t, e, r, n) {
    if (r[n] !== void 0) if (t[e] === void 0) t[e] = r[n];
    else {
      let s = t[e];
      Math.abs(r[n]) > Math.abs(s) ? t[e] = r[n] : r[n] = t[e];
    }
    else t[e] !== void 0 && (r[n] = t[e]);
  }
  Br(t, e) {
    return this._s && this._s[t] && this._s[t][e];
  }
  Ms(t, e) {
    const { symbolIndex: r } = t.properties, n = r.type || 0;
    let s = t.properties._collidesBoxes;
    s || (s = t.properties._collidesBoxes = []);
    let o = s[r.index];
    o || (o = t.properties._collidesBoxes = []), o[n] || (o[n] = []), o = o[n];
    const a = e / 6;
    if (!o[a]) {
      const l = [];
      o[a] = {
        boxes: l,
        collision: {
          boxes: l
        }
      };
    }
    return o[a];
  }
  Ps(t) {
    let e = this.Ts;
    if (e || (e = this.Ts = []), !e[t]) {
      e[t] = [];
      for (let r = 0; r < t; r++) e[t][r] = {};
    }
    return e[t];
  }
  ks(t) {
    return !t || !t.geometry ? !0 : !t.geometry.properties.glyphAtlas || !t.material.get("isHalo") || t.geometry.data.aTextHaloRadius && t.geometry.properties.hasHalo ? !1 : t.geometry.data.aTextHaloRadius && !t.geometry.properties.hasHalo ? !0 : !this.getSymbol(t.geometry.properties.symbolIndex).textHaloRadius;
  }
}
function kB(i, t) {
  return Math.round(i[0] / t / 10) * Math.round(i[1] / t / 10) * (i[2] ? Math.round(i[2] / 10) : 1) + "-" + i[3];
}
function RB(i, t) {
  const e = t.properties.level - i.properties.level;
  return e === 0 ? i.properties.meshKey - t.properties.meshKey : e;
}
function Am(i, t, e) {
  return i[0] = t[0] - e, i[1] = t[1] - e, i[2] = t[2] + e, i[3] = t[3] + e, i;
}
var tw = `#include <gl2_vert>
#define SHADER_NAME MARKER
#define RAD 0.0174532925
#ifdef HAS_ALTITUDE
attribute vec2 aPosition;
attribute float aAltitude;
#else
attribute vec3 aPosition;
#endif
attribute vec2 aShape;
attribute vec2 aTexCoord;
#ifdef ENABLE_COLLISION
attribute float aOpacity;
#endif
#ifdef HAS_OPACITY
attribute float aColorOpacity;
#endif
#ifdef HAS_MARKER_WIDTH
attribute float aMarkerWidth;
#else
uniform float markerWidth;
#endif
#ifdef HAS_MARKER_HEIGHT
attribute float aMarkerHeight;
#else
uniform float markerHeight;
#endif
#ifdef HAS_MARKER_DX
attribute float aMarkerDx;
#else
uniform float markerDx;
#endif
#ifdef HAS_MARKER_DY
attribute float aMarkerDy;
#else
uniform float markerDy;
#endif
#if defined(HAS_PITCH_ALIGN)
attribute float aPitchAlign;
#else
uniform float pitchWithMap;
#endif
#if defined(HAS_ROTATION_ALIGN)
attribute float aRotationAlign;
#else
uniform float rotateWithMap;
#endif
uniform float flipY;
#ifdef HAS_ROTATION
attribute float aRotation;
#else
uniform float markerRotation;
#endif
#ifdef HAS_PAD_OFFSET
attribute float aPadOffsetX;
attribute float aPadOffsetY;
#endif
uniform float cameraToCenterDistance;
uniform mat4 positionMatrix;
uniform mat4 projViewModelMatrix;
uniform float markerPerspectiveRatio;
uniform vec2 iconSize;
uniform vec2 texSize;
uniform vec2 canvasSize;
uniform float mapPitch;
uniform float mapRotation;
uniform float zoomScale;
uniform float tileRatio;
uniform float layerScale;
uniform float isRenderingTerrain;
#include <vt_position_vert>
#ifndef PICKING_MODE
varying vec2 vTexCoord;
varying float vOpacity;
#include <highlight_vert>
#else
#include <fbo_picking_vert>
#endif
void main() {
  vec3 c = unpackVTPosition();
#ifdef HAS_MARKER_WIDTH
float d = aMarkerWidth;
#else
float d = markerWidth;
#endif
#ifdef HAS_MARKER_HEIGHT
float e = aMarkerHeight;
#else
float e = markerHeight;
#endif
#ifdef HAS_MARKER_DX
float f = aMarkerDx;
#else
float f = markerDx;
#endif
#ifdef HAS_MARKER_DY
float h = aMarkerDy;
#else
float h = markerDy;
#endif
#if defined(HAS_PITCH_ALIGN)
float i = aPitchAlign;
#else
float i = pitchWithMap;
#endif
#if defined(HAS_ROTATION_ALIGN)
float j = aRotationAlign;
#else
float j = rotateWithMap;
#endif
gl_Position = projViewModelMatrix * positionMatrix * vec4(c, 1.);
  float k = gl_Position.w;
  float l;
  if(isRenderingTerrain == 1. && i == 1.) {
    l = 1.;
  } else {
    float m = (1. - cameraToCenterDistance / k) * markerPerspectiveRatio;
    l = clamp(.5 + .5 * (1. - m), .0, 4.);
  }
#ifdef HAS_ROTATION
float n = -aRotation / 9362. - mapRotation * j;
#else
float n = -markerRotation - mapRotation * j;
#endif
if(i == 1.) {
    n += mapRotation;
  }
  float o = sin(n);
  float u = cos(n);
  mat2 v = mat2(u, -1. * o, o, u);
  vec2 A = (aShape / 10.0);
  if(i == 1. && flipY == .0) {
    A *= vec2(1., -1.);
  }
#ifdef HAS_PAD_OFFSET
A = (A / iconSize * vec2(d, e) + vec2(aPadOffsetX - 1., aPadOffsetY)) * layerScale;
#else
A = A / iconSize * vec2(d, e) * layerScale;
#endif
A = v * A;
  if(i == .0) {
    vec2 B = A * 2. / canvasSize;
    gl_Position.xy += B * l * k;
  } else {
    float C;
    if(isRenderingTerrain == 1.) {
      C = 1.;
    } else {
      C = k / cameraToCenterDistance;
    }
    vec2 B = A;
    gl_Position = projViewModelMatrix * positionMatrix * vec4(c + vec3(B, .0) * tileRatio / zoomScale * C * l, 1.);
  }
  gl_Position.xy += vec2(f, -h) * 2. / canvasSize * k;
#ifndef PICKING_MODE
vTexCoord = aTexCoord / texSize;
#ifdef ENABLE_COLLISION
vOpacity = aOpacity / 255.;
#else
vOpacity = 1.;
#endif
#ifdef HAS_OPACITY
vOpacity *= aColorOpacity / 255.;
#endif
highlight_setVarying();
#else
#ifdef ENABLE_COLLISION
bool D = aOpacity == 255.;
#else
bool D = true;
#endif
fbo_picking_setData(gl_Position.w, D);
#endif
}`;
const sf = [], of = [], af = [], lf = [], Tl = [], Al = [];
function tv(i, t, e, r, n, s, o, a, l, h, u, c, f, d) {
  const { tileRatio: p, tileResolution: g } = l, m = p / (g / h.getResolution()) * (u / h.cameraToCenterDistance) * c;
  ui(e, e, m), ui(r, r, m), ui(n, n, m), ui(s, s, m), ne(sf, e[0], e[1], f ? e[2] / d : 0), ne(of, r[0], r[1], f ? r[2] / d : 0), ne(af, n[0], n[1], f ? n[2] / d : 0), ne(lf, s[0], s[1], f ? s[2] / d : 0), qr(sf, sf, t), qr(of, of, t), qr(af, af, t), qr(lf, lf, t), is(e, sf, o, h.width, h.height), is(r, of, o, h.width, h.height), is(n, af, o, h.width, h.height), is(s, lf, o, h.width, h.height), we(Tl, Math.min(e[0], r[0], n[0], s[0]), Math.min(e[1], r[1], n[1], s[1])), we(Al, Math.max(e[0], r[0], n[0], s[0]), Math.max(e[1], r[1], n[1], s[1])), Sr(i, Tl[0] + a[0], Tl[1] + a[1], Al[0] + a[0], Al[1] + a[1]);
}
function ev(i, t, e, r, n, s, o, a) {
  a !== 1 && (ui(e, e, a), ui(r, r, a), ui(n, n, a), ui(s, s, a)), we(Tl, Math.min(e[0], r[0], n[0], s[0]), Math.min(e[1], r[1], n[1], s[1])), we(Al, Math.max(e[0], r[0], n[0], s[0]), Math.max(e[1], r[1], n[1], s[1])), Sr(i, t[0] + Tl[0] + o[0], t[1] + Tl[1] - o[1], t[0] + Al[0] + o[0], t[1] + Al[1] - o[1]);
}
function Gy(i, t, e, r, n) {
  t -= e * r, n === 1 && (t += e);
  const s = Math.sin(t), o = Math.cos(t);
  return _R(i, o, -s, s, o);
}
const IB = [], DB = [], FB = [], LB = [], zB = [], NB = [], HB = [], BB = [], Zs = [1, -1], jB = [1, 1];
function GB(i, t, e, r, n) {
  const s = t.material.uniforms, o = n.cameraToCenterDistance, a = t.geometry.properties, l = this.getSymbol(a.symbolIndex), h = t.geometry.desc.positionSize, u = a.aAnchor, c = ne(IB, u[e * h], u[e * h + 1], h === 2 ? 0 : u[e * h + 2]), { aTerrainAltitude: f } = a;
  if (f) {
    const st = 100 * f[2 * e];
    st && (c[2] += st);
  }
  let d = is(DB, c, r, n.width, n.height);
  const p = d[2];
  let g = 1;
  s.markerPerspectiveRatio && (g = _d(0.5 + 0.5 * (1 - (1 - o / p) * s.markerPerspectiveRatio), 0, 4));
  const { aShape: m, aMarkerDx: v, aMarkerDy: _, aMarkerWidth: y, aMarkerHeight: x, aPitchAlign: w, aRotationAlign: b, aRotation: T } = a, A = v ? v[e] : l.markerDx, M = _ ? _[e] : l.markerDy, S = w ? w[e] : s.pitchWithMap, P = b ? b[e] : s.rotateWithMap, C = we(BB, A || 0, -(M || 0));
  let k = we(LB, m[2 * e] / 10, m[2 * e + 1] / 10), O = we(zB, m[2 * e + 2] / 10, m[2 * e + 3] / 10), R = we(NB, m[2 * e + 4] / 10, m[2 * e + 5] / 10), I = we(HB, m[2 * e + 6] / 10, m[2 * e + 7] / 10);
  s.flipY === 0 && S === 1 && (or(k, k, Zs), or(O, O, Zs), or(R, R, Zs), or(I, I, Zs));
  const [D, z] = OP(t.geometry);
  let H = y ? y[e] : l.markerWidth;
  gn(H) && (H = D || 15);
  let G = x ? x[e] : l.markerHeight;
  gn(G) && (G = z || 15);
  const $ = we(jB, H / 2048, G / 2048);
  dc(k, k, $), dc(O, O, $), dc(R, R, $), dc(I, I, $);
  const K = -(T ? T[e] / 9362 : -(l.markerRotation || 0) * Math.PI / 180), dt = n.getBearing() * Math.PI / 180;
  if (dt * P || K) {
    const st = Gy(FB, K, dt, P, S);
    k = Bi(k, k, st), O = Bi(O, O, st), R = Bi(R, R, st), I = Bi(I, I, st);
  }
  S === 1 ? tv(i, c, k, O, R, I, r, C, s, n, p, g) : (or(k, k, Zs), or(O, O, Zs), or(R, R, Zs), or(I, I, Zs), ev(i, d, k, O, R, I, C, g));
  const it = this.getMap().getDevicePixelRatio();
  return it !== 1 && (i[0] *= it, i[1] *= it, i[2] *= it, i[3] *= it), i;
}
const VB = [], Mm = [], Sm = [], Cm = [], Pm = [], UB = [], Xs = [1, -1];
function Em(i, t, e, r, n, s, o, a, l) {
  const h = r.material.uniforms, u = l.cameraToCenterDistance, c = r.geometry.properties, f = this.getSymbol(c.symbolIndex), d = f.textPlacement === "line" && !Cu(f), p = e[2];
  let g = 1;
  h.textPerspectiveRatio && (g = _d(0.5 + 0.5 * (1 - (1 - u / p) * h.textPerspectiveRatio), 0, 4));
  const { aTextDx: m, aTextDy: v, aPitchAlign: _, aRotationAlign: y, aRotation: x } = r.geometry.properties, w = m ? m[o] : f.textDx, b = v ? v[o] : f.textDy, T = _ ? _[o] : h.pitchWithMap, A = y ? y[o] : h.rotateWithMap, M = we(UB, w || 0, -(b || 0));
  if (d) {
    const { aOffset: P, aShape: C } = c, k = P.length !== C.length;
    let O, R, I, D;
    if (k ? (O = ne(Mm, P[3 * o] / 10, P[3 * o + 1] / 10, P[3 * o + 2] / 10), R = ne(Sm, P[3 * o + 3] / 10, P[3 * o + 4] / 10, P[3 * o + 5] / 10), I = ne(Cm, P[3 * o + 6] / 10, P[3 * o + 7] / 10, P[3 * o + 8] / 10), D = ne(Pm, P[3 * o + 9] / 10, P[3 * o + 10] / 10, P[3 * o + 11] / 10)) : (O = we(Mm, P[2 * o] / 10, P[2 * o + 1] / 10), R = we(Sm, P[2 * o + 2] / 10, P[2 * o + 3] / 10), I = we(Cm, P[2 * o + 4] / 10, P[2 * o + 5] / 10), D = we(Pm, P[2 * o + 6] / 10, P[2 * o + 7] / 10)), T === 1) {
      const z = Rl(l.getResolution(), l);
      tv(i, t, O, R, I, D, a, M, h, l, p, g, k, z);
    } else or(O, O, Xs), or(R, R, Xs), or(I, I, Xs), or(D, D, Xs), ev(i, e, O, R, I, D, M, g);
  } else {
    const { aShape: P } = c;
    let C = we(Mm, P[2 * o] / 10, -P[2 * o + 1] / 10), k = we(Sm, P[2 * o + 2] / 10, -P[2 * o + 3] / 10), O = we(Cm, P[2 * o + 4] / 10, -P[2 * o + 5] / 10), R = we(Pm, P[2 * o + 6] / 10, -P[2 * o + 7] / 10);
    h.flipY === 0 && T === 1 && (or(C, C, Xs), or(k, k, Xs), or(O, O, Xs), or(R, R, Xs));
    const I = x ? x[o] / 9362 : (f.textRotation || 0) * Math.PI / 180, D = d ? 0 : l.getBearing() * Math.PI / 180;
    if (I || D) {
      const H = Gy(VB, I, D, A, T);
      C = Bi(C, C, H), k = Bi(k, k, H), O = Bi(O, O, H), R = Bi(R, R, H);
    }
    const z = n / 24;
    ui(C, C, z), ui(k, k, z), ui(O, O, z), ui(R, R, z), T === 1 ? tv(i, t, C, k, O, R, a, M, h, l, p, g) : ev(i, e, C, k, O, R, M, g);
  }
  s = s || 0, i[0] -= s + 1, i[1] -= s + 1, i[2] += s + 1, i[3] += s + 1;
  const S = this.getMap().getDevicePixelRatio();
  return S !== 1 && (i[0] *= S, i[1] *= S, i[2] *= S, i[3] *= S), i;
}
function FP(i, t, e) {
  const r = t.geometry.desc.positionSize, { aAnchor: n, aAltitude: s, aTerrainAltitude: o } = t.geometry.properties, a = e * r;
  if (s ? ne(i, n[a], n[a + 1], s[e]) : r === 3 ? Er.unpackPosition(i, n[a], n[a + 1], n[a + 2]) : ne(i, n[a], n[a + 1], 0), o) {
    const l = 100 * o[2 * e];
    l && (i[2] += l);
  }
  return i;
}
const fr = {
  textFill: [0, 0, 0, 1],
  textOpacity: 1,
  textPitchAlignment: 0,
  textRotationAlignment: 0,
  textHaloRadius: 0,
  textHaloFill: [1, 1, 1, 1],
  textHaloBlur: 0,
  textHaloOpacity: 1,
  textPerspectiveRatio: 0,
  textSize: 14,
  textDx: 0,
  textDy: 0,
  textRotation: 0
};
function LP(i, t, e, r, n, s, o, a, l) {
  const h = [];
  if (t.isDisposed() || t.data.aPosition.length === 0) return h;
  const u = t.properties.glyphAtlas;
  if (!u || r.textSize === 0 || r.textOpacity === 0) return h;
  if (Ns(t, r, s), !t.properties.aCount) {
    $B.call(this, t, o || l, a);
    const { aTextSize: m, aTextDx: v, aTextDy: _, aPitchAlign: y, aRotationAlign: x, aRotation: w, aOverlap: b, aAltitude: T } = t.data;
    if (m) {
      const A = (mn + "aTextSize").trim();
      t.properties.aTextSize = t.properties[A] || new m.constructor(m);
    }
    if (v) {
      const A = (mn + "aTextDx").trim();
      t.properties.aTextDx = t.properties[A] || new v.constructor(v);
    }
    if (_) {
      const A = (mn + "aTextDy").trim();
      t.properties.aTextDy = t.properties[A] || new _.constructor(_);
    }
    if (y) {
      const A = (mn + "aPitchAlign").trim();
      t.properties.aPitchAlign = t.properties[A] || new y.constructor(y);
    }
    if (x) {
      const A = (mn + "aRotationAlign").trim();
      t.properties.aRotationAlign = t.properties[A] || new x.constructor(x);
    }
    if (w) {
      const A = (mn + "aRotation").trim();
      t.properties.aRotation = t.properties[A] || new w.constructor(w);
    }
    if (b) {
      const A = (mn + "aOverlap").trim();
      t.properties.aOverlap = t.properties[A] || new b.constructor(b);
    }
    if (T) {
      const A = (mn + "aAltitude").trim();
      t.properties.aAltitude = t.properties[A] || new T.constructor(T);
    }
  }
  const c = Vu(i, u, !1), f = {
    flipY: 0,
    tileResolution: t.properties.tileResolution,
    tileRatio: t.properties.tileRatio,
    texture: c,
    texSize: [u.width, u.height]
  };
  ew(t, f, n);
  let d = !1;
  n.textOpacity < 1 && (d = !0), t.properties.memorySize = t.getMemorySize(), t.generateBuffers(i, {
    excludeElementsInVAO: !0
  });
  const p = new Nr(f, fr), g = new tn(t, p, {
    disableVAO: !0,
    transparent: d,
    castShadow: !1,
    picking: !0
  });
  if (g.setLocalTransform(e), g.setUniform("alphaTest", 0.01), f.isHalo && (g.properties.isHalo = !0), o && g.setDefines({
    ENABLE_COLLISION: 1
  }), h.push(g), f.isHalo) {
    const m = {
      flipY: 0,
      tileResolution: t.properties.tileResolution,
      tileRatio: t.properties.tileRatio,
      texture: c,
      texSize: [u.width, u.height],
      isHalo: 0
    };
    ew(t, m, n);
    const v = new Nr(m, fr), _ = new tn(t, v, {
      disableVAO: !0,
      transparent: d,
      castShadow: !1,
      picking: !0
    });
    _.setUniform("alphaTest", 0.01), _.properties.haloMesh = g, Object.defineProperty(_.properties, "textSize", {
      enumerable: !0,
      get: function() {
        return m.textSize;
      }
    }), o && _.setDefines({
      ENABLE_COLLISION: 1
    }), _.setLocalTransform(e), h.push(_);
  }
  return h.forEach((m) => {
    const v = m.defines || {};
    t.data.aTextFill && (v.HAS_TEXT_FILL = 1), t.data.aTextSize && (v.HAS_TEXT_SIZE = 1), t.data.aColorOpacity && (v.HAS_OPACITY = 1), t.data.aTextHaloFill && m.material.uniforms.isHalo && (v.HAS_TEXT_HALO_FILL = 1), t.data.aTextHaloRadius && m.material.uniforms.isHalo && (v.HAS_TEXT_HALO_RADIUS = 1), t.data.aTextHaloOpacity && m.material.uniforms.isHalo && (v.HAS_TEXT_HALO_OPACITY = 1), t.data.aTextDx && (v.HAS_TEXT_DX = 1), t.data.aTextDy && (v.HAS_TEXT_DY = 1), t.data.aPitchAlign && (v.HAS_PITCH_ALIGN = 1), t.data.aRotationAlign && (v.HAS_ROTATION_ALIGN = 1), t.data.aRotation && (v.HAS_ROTATION = 1), t.data.aAltitude && (v.HAS_ALTITUDE = 1), t.properties.aOffset && t.properties.aShape && t.properties.aOffset.length !== t.properties.aShape.length && (v.HAS_OFFSET_Z = 1), m.setDefines(v), m.properties.symbolIndex = t.properties.symbolIndex;
  }), h;
}
function $B(i, t, e) {
  const r = this.getSymbol(i.properties.symbolIndex), n = i.properties.textPlacement === "line" && !Cu(r), { aPosition: s, aShape: o } = i.data, a = s.length / i.desc.positionSize;
  if (i.properties.aPickingId = i.data.aPickingId, i.properties.aCount = i.data.aCount, delete i.data.aCount, (t || n) && (i.properties.aAnchor = s, i.properties.aShape = o), i.properties.visElemts || (i.properties.elements = i.elements, i.properties.visElemts = new i.elements.constructor(i.elements.length)), n) {
    const { aVertical: l, aSegment: h, aGlyphOffset: u, aPitchRotation: c } = i.data, f = !!c;
    i.properties.aGlyphOffset = u, i.properties.aPitchRotation = c, i.properties.aSegment = h, i.properties.aVertical = l, delete i.data.aSegment, delete i.data.aVertical, delete i.data.aGlyphOffset, delete i.data.aPitchRotation;
    const d = o.length / 2 * (f ? 3 : 2);
    i.data.aOffset = {
      usage: "dynamic",
      data: new Int16Array(d)
    }, i.properties.aOffset = new Int16Array(d);
  }
  if (t) {
    i.data.aOpacity = {
      usage: "dynamic",
      data: new Uint8Array(a)
    }, i.properties.aOpacity = new Uint8Array(a), e && (i.properties.aOpacity.fill(255, 0), i.data.aOpacity.data.fill(255, 0));
    const { aTextHaloRadius: l } = i.data;
    if (l && !i.properties.aTextHaloRadius) {
      const h = (mn + "aTextHaloRadius").trim();
      i.properties.aTextHaloRadius = i.properties[h] || new l.constructor(l);
    }
  }
}
function ew(i, t, e) {
  t.isHalo === void 0 && (t.isHalo = 1), ue(t, "textOpacity", e, "textOpacity", fr.textOpacity), ue(t, "textFill", e, "textFill", fr.textFill, fi()), ue(t, "textHaloFill", e, "textHaloFill", fr.textHaloFill, fi()), ue(t, "textHaloBlur", e, "textHaloBlur", fr.textHaloBlur), ue(t, "textHaloRadius", e, "textHaloRadius", fr.textHaloRadius), ue(t, "textHaloOpacity", e, "textHaloOpacity", fr.textHaloOpacity), ue(t, "textPerspectiveRatio", e, "textPerspectiveRatio", fr.textPerspectiveRatio, (r) => i.properties.textPlacement === "line" ? 1 : r), ue(t, "rotateWithMap", e, "textRotationAlignment", fr.textRotationAlignment, (r) => +(r === "map")), ue(t, "pitchWithMap", e, "textPitchAlignment", fr.textPitchAlignment, (r) => +(r === "map")), ue(t, "textSize", e, "textSize", fr.textSize), ue(t, "textDx", e, "textDx", fr.textDx), ue(t, "textDy", e, "textDy", fr.textDy), ue(t, "textRotation", e, "textRotation", fr.textRotation, (r) => r * Math.PI / 180);
}
function zP(i, t) {
  const e = [];
  return {
    uniforms: [{
      name: "projViewModelMatrix",
      type: "function",
      fn: function(r, n) {
        return Jt(e, n.projViewMatrix, n.modelMatrix);
      }
    }, {
      name: "zoomScale",
      type: "function",
      fn: function(r, n) {
        return n.tileResolution / n.resolution;
      }
    }],
    extraCommandProps: {
      viewport: {
        x: 0,
        y: 0,
        width: () => i ? i.width : 1,
        height: () => i ? i.height : 1
      },
      stencil: {
        enable: !1,
        mask: 255,
        func: {
          cmp: "<",
          ref: (r, n) => 2 * n.level + (n.isHalo || 0) + 1,
          mask: 255
        },
        op: {
          fail: "keep",
          zfail: "keep",
          zpass: "replace"
        }
      },
      blend: {
        enable: !0,
        func: {
          src: "one",
          dst: "one minus src alpha"
        },
        equation: "add"
      },
      depth: {
        enable: !0,
        range: t.depthRange || [0, 1],
        func: t.depthFunc || "always",
        mask: !1
      },
      polygonOffset: {
        enable: !0,
        offset: this.getPolygonOffset()
      }
    }
  };
}
function NP(i, t) {
  const e = he(t.textFill), r = he(t.textSize), n = he(t.textHaloFill), s = he(t.textHaloRadius), o = he(t.textHaloOpacity), a = he(t.textDx), l = he(t.textDy), h = he(t.textOpacity), u = ln(t.textPitchAlignment), c = ln(t.textRotationAlignment), f = he(t.textRotation), d = ln(t.textAllowOverlapFn), p = ln(t.textIgnorePlacement), g = {}, m = new Int16Array(1), v = new Uint16Array(1);
  return [{
    attrName: "aTextFill",
    symbolName: "textFill",
    define: "HAS_TEXT_FILL",
    type: Uint8Array,
    width: 4,
    evaluate: (_, y) => {
      let x = e(i.getZoom(), _);
      return Ft(x) && (x = this.evaluateInFnTypeConfig(x, y, i, _, !0)), Array.isArray(x) || (x = g[x] = g[x] || Zi(x).unitArray()), x = Yo(x), x;
    }
  }, {
    attrName: "aTextSize",
    symbolName: "textSize",
    define: "HAS_TEXT_SIZE",
    type: Uint8Array,
    width: 1,
    evaluate: (_, y) => {
      let x = r(i.getZoom(), _) || fr.textSize;
      return Ft(x) && (x = this.evaluateInFnTypeConfig(x, y, i, _)), m[0] = x, m[0];
    }
  }, {
    attrName: "aTextHaloFill",
    symbolName: "textHaloFill",
    define: "HAS_TEXT_HALO_FILL",
    type: Uint8Array,
    width: 4,
    evaluate: (_) => {
      let y = n(i.getZoom(), _);
      return Array.isArray(y) || (y = g[y] = g[y] || Zi(y).unitArray()), y = Yo(y), y;
    }
  }, {
    attrName: "aTextHaloRadius",
    symbolName: "textHaloRadius",
    define: "HAS_TEXT_HALO_RADIUS",
    type: Uint8Array,
    width: 1,
    evaluate: (_) => {
      const y = s(i.getZoom(), _);
      return m[0] = y, m[0];
    }
  }, {
    attrName: "aTextHaloOpacity",
    symbolName: "textHaloOpacity",
    define: "HAS_TEXT_HALO_OPACITY",
    type: Uint8Array,
    width: 1,
    evaluate: (_) => {
      const y = o(i.getZoom(), _);
      return m[0] = y, m[0];
    }
  }, {
    attrName: "aTextDx",
    symbolName: "textDx",
    define: "HAS_TEXT_DX",
    type: Uint8Array,
    width: 1,
    evaluate: (_, y) => {
      let x = a(i.getZoom(), _);
      return Ft(x) && (x = this.evaluateInFnTypeConfig(x, y, i, _)), m[0] = x, m[0];
    }
  }, {
    attrName: "aTextDy",
    symbolName: "textDy",
    define: "HAS_TEXT_DY",
    type: Uint8Array,
    width: 1,
    evaluate: (_, y) => {
      let x = l(i.getZoom(), _);
      return Ft(x) && (x = this.evaluateInFnTypeConfig(x, y, i, _)), m[0] = x, m[0];
    }
  }, {
    attrName: "aColorOpacity",
    symbolName: "textOpacity",
    define: "HAS_OPACITY",
    type: Uint8Array,
    width: 1,
    evaluate: (_, y) => {
      let x = h(i.getZoom(), _);
      return Ft(x) && (x = this.evaluateInFnTypeConfig(x, y, i, _)), m[0] = 255 * x, m[0];
    }
  }, {
    attrName: "aPitchAlign",
    symbolName: "textPitchAlignment",
    type: Uint8Array,
    width: 1,
    define: "HAS_PITCH_ALIGN",
    evaluate: (_) => +(u(i.getZoom(), _) === "map")
  }, {
    attrName: "aRotationAlign",
    symbolName: "textRotationAlignment",
    type: Uint8Array,
    width: 1,
    define: "HAS_ROTATION_ALIGN",
    evaluate: (_) => +(c(i.getZoom(), _) === "map")
  }, {
    attrName: "aRotation",
    symbolName: "textRotation",
    type: Uint16Array,
    width: 1,
    define: "HAS_ROTATION",
    evaluate: (_) => {
      const y = xP(f(i.getZoom(), _), 0, 360) * Math.PI / 180;
      return v[0] = 9362 * y, v[0];
    }
  }, {
    attrName: "aOverlap",
    symbolName: "textAllowOverlap",
    type: Uint8Array,
    width: 1,
    evaluate: (_) => {
      let y = d(i.getZoom(), _) || 0, x = (p ? p(i.getZoom(), _) : t.textIgnorePlacement) || 0;
      return y = 1 << 3 + 4 * y, x = (p ? 2 : 0) + x, y + x;
    }
  }, {
    attrName: "aOverlap",
    symbolName: "textIgnorePlacement",
    type: Uint8Array,
    width: 1,
    evaluate: (_) => {
      let y = (d ? d(i.getZoom(), _) : t.textAllowOverlap) || 0, x = p(i.getZoom(), _) || 0;
      return y = (d ? 8 : 0) + 4 * y, x = 1 << 1 + x, y + x;
    }
  }];
}
const WB = [], ZB = [], XB = [], gh = [];
function nv(i, t, e, r, n, s, o) {
  i = i === 1 ? 1 : 0;
  const a = this.getMap(), l = t.geometry.properties, h = this.getSymbol(l.symbolIndex), u = l.textPlacement === "line" && !Cu(h), { aTextSize: c, aTextHaloRadius: f, aShape: d } = l;
  let p = c ? c[e[n]] : t.properties.textSize;
  p == null && (p = fr.textSize);
  const g = f ? f[e[n]] : t.properties.textHaloRadius, m = FP(XB, t, e[n]), { aProjectedAnchor: v } = t.geometry.properties;
  let _ = gh;
  const y = 3 * e[n];
  v && v[y] !== -999999 ? (gh[0] = v[y], gh[1] = v[y + 1], gh[2] = v[y + 2]) : _ = is(gh, m, o, a.width, a.height);
  const x = r, { boxes: w, collision: b } = this.Ms(t, n);
  let T = 0;
  if (u || t.material.uniforms.rotateWithMap === 1 || h.textRotation) {
    let A = 0;
    for (let M = n; M < n + 6 * x; M += 6) {
      const S = w[T] = w[T] || [];
      T++;
      const P = Em.call(this, S, m, _, t, p, g, e[M], o, a);
      if (!i) {
        const C = this.isCollides(P);
        C === 1 ? i = 1 : C === -1 && A++;
      }
    }
    A === x && (i = -1);
  } else {
    let A = e[n], M = d[2 * A + 1];
    for (let S = n; S < s; S += 6) {
      const P = d[2 * e[S] + 1];
      if (M !== P || S === s - 6) {
        const C = e[S === s - 6 ? S : S - 6], k = Em.call(this, WB, m, _, t, p, g, A, o, a), O = Em.call(this, ZB, m, _, t, p, g, C, o, a), R = w[T] = w[T] || [];
        T++, R[0] = Math.min(k[0], O[0]), R[1] = Math.min(k[1], O[1]), R[2] = Math.max(k[2], O[2]), R[3] = Math.max(k[3], O[3]), A = e[S], M = P, !i && this.isCollides(R) && (i = 1);
      }
    }
  }
  return b.collides = i, b;
}
function HP(i, t) {
  const e = function(r, n) {
    const { aPickingId: s, features: o } = r.geometry.properties, a = s[n], l = o && o[a] && o[a].feature;
    return l && l.label;
  }(i, t);
  return e ? function(r, n, s) {
    if (!s) return null;
    const o = r.localTransform, a = FP(qB, r, n);
    Sr(Om, a[0], a[1], a[2], 1);
    const l = ho(Om, Om, o);
    let h = 0;
    for (const u of s) h += u.codePointAt(0);
    return [Math.floor(l[0]), Math.floor(l[1]), Math.floor(l[2]), h];
  }(i, t, e) : null;
}
const qB = [], Om = [];
var Td = `#define SHADER_NAME TEXT_VERT
#define RAD 0.0174532925
#ifdef HAS_ALTITUDE
attribute vec2 aPosition;
attribute float aAltitude;
#else
attribute vec3 aPosition;
#endif
attribute vec2 aShape;
attribute vec2 aTexCoord;
#ifdef ENABLE_COLLISION
attribute float aOpacity;
#endif
#ifdef HAS_OPACITY
attribute float aColorOpacity;
#endif
#ifdef HAS_TEXT_SIZE
attribute float aTextSize;
#else
uniform float textSize;
#endif
#ifdef HAS_TEXT_DX
attribute float aTextDx;
#else
uniform float textDx;
#endif
#ifdef HAS_TEXT_DY
attribute float aTextDy;
#else
uniform float textDy;
#endif
#if defined(HAS_PITCH_ALIGN)
attribute float aPitchAlign;
#else
uniform float pitchWithMap;
#endif
#if defined(HAS_ROTATION_ALIGN)
attribute float aRotationAlign;
#else
uniform float rotateWithMap;
#endif
uniform float flipY;
#if defined(HAS_ROTATION)
attribute float aRotation;
#else
uniform float textRotation;
#endif
uniform float cameraToCenterDistance;
uniform mat4 positionMatrix;
uniform mat4 projViewModelMatrix;
uniform float textPerspectiveRatio;
uniform vec2 texSize;
uniform vec2 canvasSize;
uniform float glyphSize;
uniform float mapPitch;
uniform float mapRotation;
uniform float zoomScale;
uniform float tileRatio;
uniform float layerScale;
uniform float isRenderingTerrain;
#ifndef PICKING_MODE
varying vec2 vTexCoord;
varying float vGammaScale;
varying float vSize;
varying float vOpacity;
#ifdef HAS_TEXT_FILL
attribute vec4 aTextFill;
varying vec4 vTextFill;
#endif
#ifdef HAS_TEXT_HALO_FILL
attribute vec4 aTextHaloFill;
varying vec4 vTextHaloFill;
#endif
#ifdef HAS_TEXT_HALO_RADIUS
attribute float aTextHaloRadius;
varying float vTextHaloRadius;
#endif
#ifdef HAS_TEXT_HALO_OPACITY
attribute float aTextHaloOpacity;
varying float vTextHaloOpacity;
#endif
#include <highlight_vert>
#else
#include <fbo_picking_vert>
#endif
#include <vt_position_vert>
void main() {
  vec3 c = unpackVTPosition();
#ifdef HAS_TEXT_SIZE
float d = aTextSize * layerScale;
#else
float d = textSize * layerScale;
#endif
#ifdef HAS_TEXT_DX
float e = aTextDx;
#else
float e = textDx;
#endif
#ifdef HAS_TEXT_DY
float f = aTextDy;
#else
float f = textDy;
#endif
#if defined(HAS_PITCH_ALIGN)
float h = aPitchAlign;
#else
float h = pitchWithMap;
#endif
#if defined(HAS_ROTATION_ALIGN)
float i = aRotationAlign;
#else
float i = rotateWithMap;
#endif
vec2 j = aShape / 10.0;
  if(h == 1. && flipY == .0) {
    j = j * vec2(1., -1.);
  }
  vec2 k = aTexCoord;
  gl_Position = projViewModelMatrix * positionMatrix * vec4(c, 1.);
  float l = gl_Position.w;
  float m;
  if(isRenderingTerrain == 1. && h == 1.) {
    m = 1.;
  } else {
    float n = (1. - cameraToCenterDistance / l) * textPerspectiveRatio;
    m = clamp(.5 + .5 * (1. - n), .0, 4.);
  }
#ifdef HAS_ROTATION
float o = -aRotation / 9362. - mapRotation * i;
#else
float o = -textRotation - mapRotation * i;
#endif
if(h == 1.) {
    
#ifdef REVERSE_MAP_ROTATION_ON_PITCH
o += mapRotation;
#else
o -= mapRotation;
#endif
  }
  float u = sin(o);
  float v = cos(o);
  mat2 A = mat2(v, -1. * u, u, v);
  j = A * (j / glyphSize * d);
  float B;
  if(isRenderingTerrain == 1.) {
    B = 1.;
  } else {
    B = l / cameraToCenterDistance;
  }
  if(h == .0) {
    vec2 C = j * 2. / canvasSize;
    gl_Position.xy += C * m * l;
  } else {
    float D;
    if(isRenderingTerrain == 1.) {
      D = tileRatio / zoomScale;
    } else {
      D = tileRatio / zoomScale * B * m;
    }
    vec2 C = j;
    gl_Position = projViewModelMatrix * positionMatrix * vec4(c + vec3(C, .0) * D, 1.);
  }
  gl_Position.xy += vec2(e, -f) * 2. / canvasSize * l;
#ifndef PICKING_MODE
if(h == .0) {
    vGammaScale = mix(1., B, textPerspectiveRatio);
  } else {
    vGammaScale = B + mapPitch / 4.;
  }
  vTexCoord = k / texSize;
  vGammaScale = clamp(vGammaScale, .0, 1.);
  vSize = d;
#ifdef ENABLE_COLLISION
vOpacity = aOpacity / 255.;
#else
vOpacity = 1.;
#endif
#ifdef HAS_OPACITY
vOpacity *= aColorOpacity / 255.;
#endif
#ifdef HAS_TEXT_FILL
vTextFill = aTextFill / 255.;
#endif
#ifdef HAS_TEXT_HALO_FILL
vTextHaloFill = aTextHaloFill / 255.;
#endif
#ifdef HAS_TEXT_HALO_RADIUS
vTextHaloRadius = aTextHaloRadius;
#endif
#ifdef HAS_TEXT_HALO_OPACITY
vTextHaloOpacity = aTextHaloOpacity;
#endif
highlight_setVarying();
#else
#ifdef ENABLE_COLLISION
bool E = aOpacity == 255.;
#else
bool E = true;
#endif
fbo_picking_setData(gl_Position.w, E);
#endif
}`, rv = `#define SHADER_NAME TEXT_FRAG
#define HAS_HIGHLIGHT_COLOR_POINT 1
#define SDF_PX 8.0
#define DEVICE_PIXEL_RATIO 1.0
#define EDGE_GAMMA 0.105 / DEVICE_PIXEL_RATIO
precision mediump float;
uniform sampler2D texture;
uniform float textOpacity;
uniform highp float gammaScale;
uniform int isHalo;
uniform highp float textHaloBlur;
uniform float alphaTest;
#ifdef HAS_TEXT_HALO_OPACITY
varying float vTextHaloOpacity;
#else
uniform float textHaloOpacity;
#endif
uniform float layerOpacity;
varying vec2 vTexCoord;
varying float vSize;
varying float vGammaScale;
varying float vOpacity;
#ifdef HAS_TEXT_FILL
varying vec4 vTextFill;
#else
uniform vec4 textFill;
#endif
#ifdef HAS_TEXT_HALO_FILL
varying vec4 vTextHaloFill;
#else
uniform vec4 textHaloFill;
#endif
#ifdef HAS_TEXT_HALO_RADIUS
varying float vTextHaloRadius;
#else
uniform highp float textHaloRadius;
#endif
#include <highlight_frag>
void main() {
  
#ifdef HAS_TEXT_FILL
vec4 c = vTextFill;
#else
vec4 c = textFill;
#endif
float d = vSize / 24.;
  lowp vec4 e = c;
  highp float f = EDGE_GAMMA / (d * gammaScale);
  lowp float h = 185. / 256.;
  if(isHalo == 1) {
    
#ifdef HAS_TEXT_HALO_FILL
vec4 i = vTextHaloFill;
#else
vec4 i = textHaloFill;
#endif
#ifdef HAS_TEXT_HALO_RADIUS
float j = vTextHaloRadius;
#else
float j = textHaloRadius;
#endif
e = i;
    f = (textHaloBlur * 1.19 / SDF_PX + EDGE_GAMMA) / (d * gammaScale);
    h = (6. - j / d) / SDF_PX;
#ifdef HAS_TEXT_HALO_OPACITY
float k = vTextHaloOpacity / 255.;
#else
float k = textHaloOpacity;
#endif
e *= k * 1.25;
  }
  float l = texture2D(texture, vTexCoord).a;
  highp float m = f * vGammaScale * .7;
  float n = clamp(smoothstep(h - m, h + m, l), .0, 1.);
  gl_FragColor = e * (n * textOpacity * vOpacity * layerOpacity);
  if(gl_FragColor.a < alphaTest) {
    discard;
  }
  gl_FragColor = highlight_blendColor(gl_FragColor);
}`;
const Na = new Uint16Array(1), hf = new Int8Array(1);
function YB(i, t, e) {
  Ns(i, t, e), function(r) {
    const { aMarkerWidth: n, aMarkerHeight: s, aMarkerDx: o, aMarkerDy: a, aPitchAlign: l, aRotationAlign: h, aRotation: u, aOverlap: c } = r.data;
    if (n) {
      const f = (mn + "aMarkerWidth").trim();
      r.properties.aMarkerWidth = r.properties[f] || new n.constructor(n);
    }
    if (s) {
      const f = (mn + "aMarkerHeight").trim();
      r.properties.aMarkerHeight = r.properties[f] || new s.constructor(s);
    }
    if (o) {
      const f = (mn + "aMarkerDx").trim();
      r.properties.aMarkerDx = r.properties[f] || new o.constructor(o);
    }
    if (a) {
      const f = (mn + "aMarkerDy").trim();
      r.properties.aMarkerDy = r.properties[f] || new a.constructor(a);
    }
    if (l) {
      const f = (mn + "aPitchAlign").trim();
      r.properties.aPitchAlign = r.properties[f] || new l.constructor(l);
    }
    if (h) {
      const f = (mn + "aRotationAlign").trim();
      r.properties.aRotationAlign = r.properties[f] || new h.constructor(h);
    }
    if (u) {
      const f = (mn + "aRotation").trim();
      r.properties.aRotation = r.properties[f] || new u.constructor(u);
    }
    if (c) {
      const f = (mn + "aOverlap").trim();
      r.properties.aOverlap = r.properties[f] || new c.constructor(c);
    }
  }(i);
}
function JB(i, t) {
  const e = he(t.markerWidth), r = he(t.markerHeight), n = he(t.markerDx), s = he(t.markerDy), o = he(t.markerOpacity), a = he(t.markerTextFit), l = ln(t.markerPitchAlignment), h = ln(t.markerRotationAlignment), u = he(t.markerRotation), c = ln(t.markerAllowOverlapFn), f = ln(t.markerIgnorePlacement), d = new Int16Array(1), p = new Uint16Array(1);
  return [{
    attrName: "aMarkerWidth",
    symbolName: "markerWidth",
    type: Uint16Array,
    width: 1,
    define: "HAS_MARKER_WIDTH",
    evaluate: (g, m, v, _) => {
      const y = v[_], x = t.markerTextFit, w = a ? a(i.getZoom(), g) : x;
      if (w === "both" || w === "width") return y;
      let b = e(i.getZoom(), g);
      return Ft(b) && (b = this.evaluateInFnTypeConfig(b, m, i, g)), d[0] = b, d[0];
    }
  }, {
    attrName: "aMarkerHeight",
    symbolName: "markerHeight",
    type: Uint16Array,
    width: 1,
    define: "HAS_MARKER_HEIGHT",
    evaluate: (g, m, v, _) => {
      const y = v[_], x = t.markerTextFit, w = a ? a(i.getZoom(), g) : x;
      if (w === "both" || w === "height") return y;
      let b = r(i.getZoom(), g);
      return Ft(b) && (b = this.evaluateInFnTypeConfig(b, m, i, g)), d[0] = b, d[0];
    }
  }, {
    attrName: "aMarkerDx",
    symbolName: "markerDx",
    type: Uint8Array,
    width: 1,
    define: "HAS_MARKER_DX",
    evaluate: (g, m) => {
      let v = n(i.getZoom(), g);
      return Ft(v) && (v = this.evaluateInFnTypeConfig(v, m, i, g)), d[0] = v, d[0];
    }
  }, {
    attrName: "aMarkerDy",
    symbolName: "markerDy",
    type: Uint8Array,
    width: 1,
    define: "HAS_MARKER_DY",
    evaluate: (g, m) => {
      let v = s(i.getZoom(), g);
      return Ft(v) && (v = this.evaluateInFnTypeConfig(v, m, i, g)), d[0] = v, d[0];
    }
  }, {
    attrName: "aColorOpacity",
    symbolName: "markerOpacity",
    type: Uint8Array,
    width: 1,
    define: "HAS_OPACITY",
    evaluate: (g, m) => {
      let v = o(i.getZoom(), g);
      return Ft(v) && (v = this.evaluateInFnTypeConfig(v, m, i, g)), d[0] = 255 * v, d[0];
    }
  }, {
    attrName: "aPitchAlign",
    symbolName: "markerPitchAlignment",
    type: Uint8Array,
    width: 1,
    define: "HAS_PITCH_ALIGN",
    evaluate: (g) => +(l(i.getZoom(), g) === "map")
  }, {
    attrName: "aRotationAlign",
    symbolName: "markerRotationAlignment",
    type: Uint8Array,
    width: 1,
    define: "HAS_ROTATION_ALIGN",
    evaluate: (g) => +(h(i.getZoom(), g) === "map")
  }, {
    attrName: "aRotation",
    symbolName: "markerRotation",
    type: Uint16Array,
    width: 1,
    define: "HAS_ROTATION",
    evaluate: (g) => {
      const m = xP(u(i.getZoom(), g), 0, 360) * Math.PI / 180;
      return p[0] = 9362 * m, p[0];
    }
  }, {
    attrName: "aOverlap",
    symbolName: "markerAllowOverlap",
    type: Uint8Array,
    width: 1,
    evaluate: (g) => {
      let m = c(i.getZoom(), g) || 0, v = (f ? f(i.getZoom(), g) : t.markerIgnorePlacement) || 0;
      return m = 1 << 3 + 4 * m, v = (f ? 2 : 0) + v, m + v;
    }
  }, {
    attrName: "aOverlap",
    symbolName: "markerIgnorePlacement",
    type: Uint8Array,
    width: 1,
    evaluate: (g) => {
      let m = (c ? c(i.getZoom(), g) : t.markerAllowOverlap) || 0, v = f(i.getZoom(), g) || 0;
      return m = (c ? 8 : 0) + 4 * m, v = 2 + v, m + v;
    }
  }];
}
function KB(i, t, e, r) {
  if (!e || !r || r === "none") return;
  const n = function(s, o, a) {
    let l = s.properties.textFitFn;
    Ft(a) && (l = s.properties.textFitFn = ln(a));
    const h = a !== "none", u = [], c = s.getElements(), f = s.data.aPickingId;
    let d, p, g;
    o && (d = o.getElements(), p = o.data.aPickingId, g = o.data.aCount);
    const m = s.properties.features;
    let v;
    if (o) {
      let b = d[0];
      v = {
        pickingId: p[b],
        start: 0,
        end: 6 * g[b]
      };
    }
    let _ = !1, y = !1, x = 0;
    const w = /* @__PURE__ */ new Set();
    for (let b = 0; b < c.length; b += 6) {
      const T = c[b], A = f[T];
      if (!_ && v) for (; v.pickingId < A && v.end < d.length; ) {
        const C = v.end, k = d[C];
        v.start = C, v.end = C + 6 * g[k], v.pickingId = p[k];
      }
      if (!_ && v && v.pickingId < A && (_ = !0, !h)) {
        if (!y) return [];
        for (let C = b; C < c.length; C += 6) u[x++] = [-1, -1];
        return u;
      }
      const M = m[A] && m[A].feature, S = M && M.properties || {}, P = l ? l(null, S) : a;
      if (v && A === v.pickingId) {
        u[x++] = [v.start, v.end];
        const C = v.end, k = d[C];
        v.start = C, v.end = C + 6 * g[k], v.pickingId = p[k], y = !0;
      } else if (P && P !== "none") for (let C = b; C < b + 6; C++) w.add(C);
      else u[x++] = [-1, -1];
    }
    if (w.size) if (w.size === c.length) s.setElements([]);
    else {
      const b = [];
      for (let T = 0; T < c.length; T++) w.has(T) || b.push(c[T]);
      s.setElements(new c.constructor(b));
    }
    return y ? u : [];
  }(t, e, r);
  if (t.getElements().length && n.length && (t.properties.labelIndex = n, n.length && r && r !== "none" && e)) {
    const s = function(o, a) {
      const l = [], h = o.properties.labelIndex, { aShape: u } = a.data;
      let c = !1;
      for (let f = 0; f < h.length; f++) {
        const [d, p] = h[f];
        if (d === -1) l.push(0, 0, 0, 0);
        else {
          c = !0;
          let g = 1 / 0, m = 1 / 0, v = -1 / 0, _ = -1 / 0;
          const y = a.elements;
          for (let x = d; x < p; x++) {
            const w = y[x], b = u[2 * w], T = u[2 * w + 1];
            b < g && (g = b), b > v && (v = b), T < m && (m = T), T > _ && (_ = T);
          }
          l.push(g, m, v, _);
        }
      }
      return c ? l : [];
    }(t, e);
    s.length && (t.properties.labelShape = s, QB.call(this, i, t, e));
  }
}
function QB(i, t) {
  const e = this.getSymbolDef(t.properties.symbolIndex), r = e.markerTextFit, n = t.properties;
  let s = r === "both" || r === "width", o = r === "both" || r === "height";
  if (Ft(e.markerTextFit)) {
    let d = t.properties.textFitFn;
    d || (d = t.properties.textFitFn = he(e.markerTextFit));
    const { features: p } = t.properties, g = t.properties.elements || t.elements, { aPickingId: m } = t.data, v = [], _ = [];
    let y = !0;
    for (let x = 0; x < g.length; x += 6) {
      const w = p[m[g[x]]], b = (w && w.feature || {}).properties || {};
      let T = d(null, b);
      Ft(T) && (T = (b.textFitFn = b.textFitFn || he(T))(null, b)), T === "both" ? (v.push(x / 6), _.push(x / 6)) : T === "width" ? (y = !1, v.push(x / 6)) : T === "height" && (y = !1, _.push(x / 6));
    }
    y ? (n.fitIcons = v, s = !0, o = !0) : (v.length && (n.fitWidthIcons = v, s = !0), _.length && (n.fitHeightIcons = _, o = !0));
  }
  n.aPickingId || (n.aPickingId = new t.data.aPickingId.constructor(t.data.aPickingId));
  const { aMarkerWidth: a, aMarkerHeight: l, aPickingId: h } = n, u = h.length;
  if (s) if (a) {
    const d = t.data.aMarkerWidth;
    t.data.aMarkerWidth = new Uint16Array(d), n.aMarkerWidth = new Uint16Array(d);
    const p = (mn + "aMarkerWidth").trim();
    n[p] && (n[p] = n.aMarkerWidth);
  } else {
    const d = this.getSymbol(t.properties.symbolIndex).markerWidth || 0;
    n.aMarkerWidth = new Uint16Array(u), n.aMarkerWidth.fill(d), d && (n.aMarkerWidth.dirty = !0), t.data.aMarkerWidth = new Uint16Array(u);
  }
  if (o) if (l) {
    const d = t.data.aMarkerHeight;
    t.data.aMarkerHeight = new Uint16Array(d), n.aMarkerHeight = new Uint16Array(d);
    const p = (mn + "aMarkerHeight").trim();
    n[p] && (n[p] = n.aMarkerHeight);
  } else {
    const d = this.getSymbol(t.properties.symbolIndex).markerHeight || 0;
    n.aMarkerHeight = new Uint16Array(u), n.aMarkerHeight.fill(d), d && (n.aMarkerHeight.dirty = !0), t.data.aMarkerHeight = new Uint16Array(u);
  }
  const c = this.getSymbolDef(t.properties.textGeo.properties.symbolIndex), f = he(c.textSize);
  BP.call(this, i, t), (!Ft(c.textSize) || f.isZoomConstant && f.isFeatureConstant) && (n.isFitConstant = !0);
}
const nw = [0, 0, 0, 0];
function BP(i, t) {
  const e = t.properties.textGeo;
  if (!e) return;
  const r = e.properties, n = t.properties;
  if (n.isFitConstant || !n.labelShape || !n.labelShape.length) return;
  const s = this.getSymbolDef(t.properties.symbolIndex), o = this.getSymbolDef(e.properties.symbolIndex).textSize;
  let a;
  Ft(o) && (a = r.Os ? r.Os : r.Os = he(o));
  const l = s.markerTextFitPadding || nw;
  let h;
  Ft(l) && (h = n.Is ? n.Is : n.Is = ln(l));
  const u = i.getZoom(), { fitIcons: c, fitWidthIcons: f, fitHeightIcons: d } = n, { aMarkerWidth: p, aMarkerHeight: g, labelShape: m } = n, v = n.elements || t.elements, { features: _, aPickingId: y } = n, x = (T, A, M, S) => {
    const P = m[4 * A], C = m[4 * A + 1], k = m[4 * A + 2], O = m[4 * A + 3];
    if (!(P || C || k || O)) return;
    const R = y[T], I = _[R] && _[R].feature, D = I && I.properties || {};
    let z = a ? a(u, D) : o;
    Ft(z) && (z = (D.textSizeFn = D.textSizeFn || he(z))(u, D)), z /= 24;
    let H, G, $ = h && h(u, D) || l;
    if (Ft($) && ($ = (D.fitPaddingFn = D.fitPaddingFn || ln($))(u, D)), $ = $ || nw, $[0] === $[2] && $[1] === $[3] || (H = n.aPadOffsetX, G = n.aPadOffsetY, H || (H = n.aPadOffsetX = new Int8Array(p.length), G = n.aPadOffsetY = new Int8Array(p.length))), p && M) {
      const K = Math.abs((k - P) / 10 * z) + ($[1] + $[3] || 0);
      if (Na[0] = K, p[T] !== Na[0] && (Nh(p, Na[0], T, T + 4), p.dirty = !0), H) {
        const dt = ($[1] + $[3]) / 2 - $[3];
        hf[0] = dt, H[T] !== hf[0] && (Nh(H, dt, T, T + 4), H.dirty = !0);
      }
    }
    if (g && S) {
      const K = Math.abs((O - C) / 10 * z) + ($[0] + $[2] || 0);
      if (Na[0] = K, g[T] !== Na[0] && (Nh(g, Na[0], T, T + 4), g.dirty = !0), G) {
        const dt = $[0] - ($[0] + $[2]) / 2;
        hf[0] = dt, G[T] !== hf[0] && (Nh(G, dt, T, T + 4), G.dirty = !0);
      }
    }
  };
  if (c || f || d) {
    if (c) for (let T = 0; T < c.length; T++) {
      const A = c[T];
      x(v[6 * A], A, !0, !0);
    }
    else if (f || d) {
      if (f) for (let T = 0; T < f.length; T++) {
        const A = f[T];
        x(v[6 * A], A, !0, !1);
      }
      if (d) for (let T = 0; T < d.length; T++) {
        const A = d[T];
        x(v[6 * A], A, !1, !0);
      }
    }
  } else for (let T = 0; T < v.length; T += 6) {
    const A = T / 6;
    x(v[T], A, !0, !0);
  }
  const { aPadOffsetX: w, aPadOffsetY: b } = n;
  w && (t.data.aPadOffsetX = w, t.data.aPadOffsetY = b);
}
const tj = function(i) {
  const t = this.layer.getRenderer();
  return !this.ks(i) && t.isForeground(i) && !!i.geometry.properties.iconAtlas && !i.geometry.properties.isEmpty;
}, ej = function(i) {
  const t = this.layer.getRenderer();
  return !(this.ks(i) || t.isForeground(i) || !i.geometry.properties.iconAtlas || i.geometry.properties.isEmpty);
}, nj = function(i) {
  const t = this.layer.getRenderer();
  return !this.ks(i) && t.isForeground(i) && !!i.geometry.properties.glyphAtlas;
}, rj = function(i) {
  const t = this.layer.getRenderer();
  return !this.ks(i) && !t.isForeground(i) && !!i.geometry.properties.glyphAtlas;
}, ij = [], rw = {
  collides: -1
}, sj = [2048, 2048], oj = pn([]), aj = [];
class jP extends DP {
  static getBloomSymbol() {
    return ["markerBloom", "textBloom"];
  }
  constructor(t, e, r, n, s, o) {
    super(t, e, r, n, s, o), this.propAllowOverlap = "markerAllowOverlap", this.propIgnorePlacement = "markerIgnorePlacement", this.Qi = {}, this.isLabelCollides = nv.bind(this), this.Fs = tj.bind(this), this.Cs = ej.bind(this), this.Es = nj.bind(this), this.Ds = rj.bind(this), this.Ns = [];
  }
  needToRefreshTerrainTileOnZooming() {
    for (let t = 0; t < this.symbolDef.length; t++) {
      const e = this.symbolDef[t].markerPitchAlignment;
      if (e === "map" || Ft(e) || Xh.isExpression(e)) return !0;
    }
    return !1;
  }
  isTerrainVector() {
    return this.layer.options.awareOfTerrain && !this.needToRefreshTerrainTileOnZooming();
  }
  isTerrainSkin() {
    return super.isTerrainSkin() && this.needToRefreshTerrainTileOnZooming();
  }
  setTextShaderDefines(t) {
    this.Ls = t;
  }
  createFnTypeConfig(t, e) {
    return {
      icon: JB.call(this, t, e),
      text: NP.call(this, t, e)
    };
  }
  startFrame(...t) {
    return this.Ns.length = 0, super.startFrame(...t);
  }
  createGeometry(t, e) {
    return t && t.empty && (t.data = {
      aPosition: new Uint8Array(t.data.aPosition),
      aPickingId: t.data.aPickingId
    }), super.createGeometry(t, e);
  }
  postCreateGeometry(t, e) {
    const { geometry: r, symbolIndex: n } = t, s = this.getSymbolDef(n), o = this.getFnTypeConfig(n);
    if (this.Rs(r)) r.properties.iconAtlas ? this.drawDebugAtlas(r.properties.iconAtlas) : r.properties.isEmpty = !0, YB(r, s, o.icon);
    else if (this.Hs(r) && Cu(s)) {
      const a = e[e.length - 1];
      if (a) {
        const { geometry: l, symbolIndex: h } = a;
        if (l && h.index === n.index) {
          const u = this.getMap(), c = s.markerTextFit;
          l.properties.textGeo = r, KB.call(this, u, l, r, c);
        }
      }
    }
  }
  prepareCollideIndex(t) {
    const { collideIds: e, elements: r, aCount: n } = t.properties;
    if (!e) return;
    const s = e, o = {};
    if (!r) return void (t.properties.collideBoxIndex = o);
    let a = 0, l = r[0], h = 0, u = s[l], c = 1;
    n && (c = n[r[h]]);
    for (let f = 0; f <= r.length; f += 6) l = r[f], s[l] === u && f !== r.length || (o[u] = [h, f, (f - h) / (6 * c), a++], u = s[l], h = f, n && (c = n[r[h]]));
    t.properties.collideBoxIndex = o;
  }
  createMesh(t, e, r, n) {
    const s = this.isEnableCollision(), o = this.layer, { geometry: a, symbolIndex: l } = t;
    a.properties.symbolIndex = l;
    const h = this.getSymbolDef(l), u = this.getSymbol(l), c = this.getFnTypeConfig(l), f = [];
    if (this.Rs(a)) {
      const d = function(p, g, m, v, _, y, x, w) {
        if (g.isDisposed() || g.data.aPosition.length === 0) return null;
        const b = g.properties.iconAtlas;
        if (!b && !g.properties.isEmpty) return null;
        const T = {
          flipY: 0,
          tileResolution: g.properties.tileResolution,
          tileRatio: g.properties.tileRatio
        };
        //!geometry.properties.aShape 以避免重复创建collision数据
        if (!g.properties.aShape) {
          const { aPosition: k, aShape: O } = g.data, R = g.data.aPosition.length / g.desc.positionSize, I = new Uint8Array(R);
          w && I.fill(255, 0), g.data.aOpacity = {
            usage: "dynamic",
            data: I
          }, g.properties.aOpacity = new Uint8Array(R), w && g.properties.aOpacity.fill(255, 0), g.properties.aAnchor = k, g.properties.aShape = O;
        }
        g.properties.visElemts || (g.properties.elements = g.elements, g.properties.visElemts = new g.elements.constructor(g.elements.length));
        const [A, M] = OP(g);
        ue(T, "markerOpacity", _, "markerOpacity", 1), ue(T, "markerPerspectiveRatio", _, "markerPerspectiveRatio", _.markerTextFit ? 0 : 1), ue(T, "markerWidth", _, "markerWidth", A || 15), ue(T, "markerHeight", _, "markerHeight", M || 15), ue(T, "markerDx", _, "markerDx", 0), ue(T, "markerDy", _, "markerDy", 0), ue(T, "markerRotation", _, "markerRotation", 0, (k) => k * Math.PI / 180), ue(T, "pitchWithMap", _, "markerPitchAlignment", 0, (k) => k === "map" ? 1 : 0), ue(T, "rotateWithMap", _, "markerRotationAlignment", 0, (k) => k === "map" ? 1 : 0), T.iconTex = b ? Vu(p, b, !1) : null, T.texSize = b ? [b.width, b.height] : [0, 0], g.generateBuffers(p, {
          excludeElementsInVAO: !0
        });
        const S = new Nr(T), P = new tn(g, S, {
          disableVAO: !0,
          transparent: !0,
          castShadow: !1,
          picking: !0
        }), C = {};
        return x && (C.ENABLE_COLLISION = 1), g.data.aMarkerWidth && (C.HAS_MARKER_WIDTH = 1), g.data.aMarkerHeight && (C.HAS_MARKER_HEIGHT = 1), g.data.aColorOpacity && (C.HAS_OPACITY = 1), g.data.aMarkerDx && (C.HAS_MARKER_DX = 1), g.data.aMarkerDy && (C.HAS_MARKER_DY = 1), g.data.aPitchAlign && (C.HAS_PITCH_ALIGN = 1), g.data.aRotationAlign && (C.HAS_ROTATION_ALIGN = 1), g.data.aRotation && (C.HAS_ROTATION = 1), g.data.aPadOffsetX && (C.HAS_PAD_OFFSET = 1), g.data.aAltitude && (C.HAS_ALTITUDE = 1), P.setDefines(C), P.setUniform("alphaTest", 0.01), P.setLocalTransform(m), P.properties.symbolIndex = g.properties.symbolIndex, P;
      }(this.regl, a, e, 0, u, c.icon, o.options.collision, !s, this.isEnableUniquePlacement());
      d && (d.positionMatrix = this.getAltitudeOffsetMatrix(), delete d.geometry.properties.glyphAtlas, f.push(d));
    } else if (this.Hs(a)) {
      const d = LP.call(this, this.regl, a, e, h, u, c.text, o.options.collision, !s, this.isEnableUniquePlacement());
      d.length && (d.forEach((p) => {
        p.positionMatrix = this.getAltitudeOffsetMatrix(), delete p.geometry.properties.iconAtlas;
      }), f.push(...d));
    }
    return a.properties.markerPlacement === "line" && this.zs(a, n), a.properties.markerPlacement === "line" && f.forEach((d) => d.properties.isLinePlacement = !0), this.prepareCollideIndex(a), f;
  }
  zs(t, e) {
    const r = this.layer instanceof Pn, { collideIds: n } = t.properties, s = new Uint16Array(n.length);
    if (this.Rs(t)) {
      let o = 0;
      for (let a = 0; a < n.length; a += 4) s.fill(o++, a, a + 4);
      t.properties.collideIds = s, t.properties.uniqueCollideIds = Ff(s, !r), e.markerCollideMap = {
        old: n,
        new: s
      };
    } else if (this.Hs(t)) {
      const { collideIds: o, aCount: a } = t.properties;
      if (!a) return;
      if (e.markerCollideMap) {
        const { markerCollideMap: l } = e;
        let h = l.new[l.new.length - 1], u = 0, c = o[0], f = e.markerCollideMap.old.indexOf(c), d = a[0];
        for (let p = 0; p < o.length; ) {
          const g = o[p];
          c !== g && (c = g, f = e.markerCollideMap.old.indexOf(c), u = 0);
          const m = f === -1 ? ++h : e.markerCollideMap.new[f + 4 * u], v = p + 4 * d;
          o.fill(m, p, v), p += 4 * d, u++, v < o.length && (d = a[v]);
        }
        t.properties.uniqueCollideIds = Ff(o, !r);
      } else {
        let l = 0, h = a[0];
        for (let u = 0; u < o.length; ) {
          const c = u + 4 * h;
          o.fill(l++, u, c), u += 4 * h, c < o.length && (h = a[c]);
        }
        t.properties.uniqueCollideIds = Ff(o, !r);
      }
    }
  }
  addMesh(t) {
    if (this.isEnableCollision() && t.length > 0) {
      const r = new wd(t);
      r.properties.uniqueCollideIds = t[0].geometry.properties.uniqueCollideIds, r.properties.meshKey = t[0].properties.meshKey, r.properties.level = t[0].properties.level, this.Ns.push(r);
    }
    for (let r = 0; r < t.length; r++) {
      if (!this.isMeshIterable(t[r])) continue;
      const n = t[r].geometry, { symbolIndex: s } = n.properties;
      Cu(this.getSymbolDef(s)) && BP.call(this, this.getMap(), n);
    }
    const e = this.getMap().getZoom();
    for (let r = 0; r < t.length; r++) {
      if (!this.isMeshIterable(t[r])) continue;
      const n = t[r].geometry, { symbolIndex: s } = n.properties, o = this.getSymbolDef(s), a = this.getFnTypeConfig(s);
      SP(this.regl, o, s.type === 0 ? a.icon : a.text, t[r], e);
      const { aMarkerWidth: l, aMarkerHeight: h, aPadOffsetX: u, aPadOffsetY: c } = n.properties;
      l && l.dirty && (n.updateData("aMarkerWidth", l), l.dirty = !1), h && h.dirty && (n.updateData("aMarkerHeight", h), h.dirty = !1), u && u.dirty && (n.updateData("aPadOffsetX", u), u.dirty = !1), c && c.dirty && (n.updateData("aPadOffsetY", c), c.dirty = !1);
    }
    super.addMesh(...arguments);
  }
  updateCollision(t) {
    if (!this.isEnableCollision()) return;
    super.updateCollision(t);
    const e = this.scene.getMeshes();
    e && e.length ? (this.Vs(t.timestamp), this.Ns = [], this.Vr()) : this.Vr();
  }
  callCurrentTileShader(t, e) {
    this.shader.filter = e.sceneFilter ? [this.Fs, e.sceneFilter] : this.Fs, this.callRenderer(this.shader, t, e), this.Us.filter = e.sceneFilter ? [this.Es, e.sceneFilter] : this.Es, this.callRenderer(this.Us, t, e);
  }
  callBackgroundTileShader(t, e) {
    this.shader.filter = e.sceneFilter ? [this.Cs, e.sceneFilter] : this.Cs, this.callRenderer(this.shader, t, e), this.Us.filter = e.sceneFilter ? [this.Ds, e.sceneFilter] : this.Ds, this.callRenderer(this.Us, t, e);
  }
  isMeshIterable(t) {
    return t && t.geometry && !t.geometry.properties.isEmpty && t.material && !t.material.get("isHalo") && this.isMeshVisible(t) && !(this.shouldIgnoreBackground() && !this.layer.getRenderer().isForeground(t));
  }
  Vs() {
    if (!this.isEnableCollision()) return;
    let t = this.Ns;
    t && t.length && this.js(t);
  }
  Bs(t, e, r, n) {
    return this.updateBoxCollisionFading(!0, t, e, r, n);
  }
  isEnableUniquePlacement() {
    return this.isEnableCollision() && this.sceneConfig.uniquePlacement === !0;
  }
  js(t) {
    const e = this.layer.getRenderer();
    t = t.sort(lj);
    for (let r = 0; r < t.length; r++) {
      const n = t[r];
      if (!n || !n.meshes.length) continue;
      let s = !1;
      if (n.meshes.length === 1) s = this.isMeshIterable(n.meshes[0]);
      else for (let l = 0; l < n.meshes.length; l++) if (this.isMeshIterable(n.meshes[l])) {
        s = !0;
        break;
      }
      if (!s) continue;
      const o = e.isForeground(n.meshes[0]);
      if (this.shouldIgnoreBackground() && !o) continue;
      const a = n.properties.meshKey;
      this.startMeshCollision(n), this.Gs(n), this.forEachBox(n, this.Bs), this.Ws(n), this.endMeshCollision(a);
      for (let l = 0; l < n.meshes.length; l++) this.Xs(n.meshes[l]);
    }
  }
  Xs(t) {
    const e = t && t.geometry && t.geometry.properties.aOpacity;
    e && e.dirty && (t.geometry.updateData("aOpacity", e), e.dirty = !1);
  }
  forEachBox(t, e) {
    const r = t.properties.uniqueCollideIds;
    if (!r) return;
    const n = {
      boxIndex: 0
    }, s = r.length;
    for (let o = 0; o < s; o++) this.Ys(t, r[o], e, n);
  }
  Ys(t, e, r, n) {
    const s = this.getMap(), { collideBoxIndex: o } = t.meshes[0].geometry.properties;
    if (!(o && o[e])) return !1;
    const a = Jt(ij, s.projViewMatrix, t.meshes[0].localTransform);
    let l, h = !1;
    const u = t.meshes;
    let c = 0;
    for (let d = 0; d < u.length; d++) {
      if (!this.isMeshIterable(u[d])) continue;
      const { collideBoxIndex: p } = u[d].geometry.properties;
      p[e] && c++;
    }
    if (!c) return !1;
    l = this.Ps(c);
    let f = 0;
    for (let d = 0; d < u.length; d++) {
      const p = u[d];
      if (!this.isMeshIterable(p)) continue;
      h = !0;
      const g = u[d].geometry.properties, { elements: m, aCount: v, collideBoxIndex: _ } = g, y = _[e];
      if (!y) continue;
      const [x, w, b] = y;
      let T = 1;
      v && (T = v[m[x]]);
      const A = x + 0 * T * 6;
      l[f].mesh = u[d], l[f].start = A, l[f].end = w, l[f].boxCount = g.glyphAtlas ? T : b, l[f].allElements = m, f++;
    }
    return h ? (r.call(this, t, l, a, n.boxIndex++) && this.$s(t, e), !0) : !1;
  }
  Gs(t) {
    const e = t.meshes;
    for (let r = 0; r < e.length; r++) {
      const n = e[r], s = n && n.geometry;
      s && (s.properties.visElemts.count = 0);
    }
  }
  $s(t, e) {
    const r = t.meshes;
    for (let n = 0; n < r.length; n++) {
      const s = r[n];
      if (s.properties.isHalo) continue;
      const o = s && s.geometry;
      if (!o || o.properties.isEmpty) continue;
      const { collideBoxIndex: a, elements: l, visElemts: h } = o.properties, u = a[e];
      if (!u) continue;
      const [c, f] = u;
      let d = h.count;
      for (let p = c; p < f; p++) h[d++] = l[p];
      h.count = d;
    }
  }
  Ws(t) {
    const e = t.meshes;
    for (let r = 0; r < e.length; r++) {
      const n = e[r], s = n && n.geometry;
      if (!s) continue;
      const { visElemts: o } = s.properties;
      s.setElements(o, o.count);
    }
  }
  isBoxCollides(t, e, r, n, s, o) {
    if (this.Hs(t.geometry)) return nv.call(this, 0, t, e, r, n, s, o);
    if (t.geometry.properties.isEmpty) return rw;
    const { aTerrainAltitude: a } = t.geometry.properties;
    if (a && a[2 * e[n]] === xl)
      return rw;
    const l = this.getMap(), { boxes: h, collision: u } = this.Ms(t, n);
    let c = 0, f = 0, d = 0;
    for (let p = n; p < s; p += 6) {
      const g = h[d] = h[d] || [];
      d++;
      const m = GB.call(this, g, t, e[p], o, l);
      if (!c) {
        const v = this.isCollides(m);
        v === 1 ? c = 1 : v === -1 && f++;
      }
    }
    return f === r && (c = -1), u.collides = c, u;
  }
  deleteMesh(t, e) {
    t && (t instanceof wd && (t = t.meshes), e && (Array.isArray(t) ? t.forEach((r) => {
      r && r.material && delete r.material.uniforms.iconTex;
    }) : t.material && delete t.material.uniforms.iconTex), super.deleteMesh(t, e));
  }
  isBloom(t) {
    const e = t && t.material && !gn(t.material.get("markerOpacity")), r = this.getSymbol(t.properties.symbolIndex);
    return !!(e ? r.markerBloom : r.textBloom);
  }
  init() {
    const t = this.regl, e = this.canvas;
    this.renderer = new hn(t);
    const r = {
      viewport: {
        x: (a, l) => l.viewport ? l.viewport.x : 0,
        y: (a, l) => l.viewport ? l.viewport.y : 0,
        width: (a, l) => l.viewport ? l.viewport.width : e ? e.width : 1,
        height: (a, l) => l.viewport ? l.viewport.height : e ? e.height : 1
      },
      blend: {
        enable: !0,
        func: this.getBlendFunc(),
        equation: "add"
      },
      depth: {
        enable: !0,
        range: () => this.sceneConfig.depthRange || [0, 1],
        func: () => this.sceneConfig.depthFunc || "always",
        mask: !!gn(this.sceneConfig.depthMask) || this.sceneConfig.depthMask
      },
      polygonOffset: {
        enable: !0,
        offset: this.getPolygonOffset()
      }
    };
    this.shader = new qe({
      vert: tw,
      frag: `#define SHADER_NAME MARKER
#define HAS_HIGHLIGHT_COLOR_POINT 1
precision mediump float;
#include <gl2_frag>
uniform float alphaTest;
uniform sampler2D iconTex;
uniform lowp float markerOpacity;
uniform lowp float blendSrcIsOne;
uniform float layerOpacity;
#include <highlight_frag>
varying vec2 vTexCoord;
varying float vOpacity;
void main() {
  vec4 c = texture2D(iconTex, vTexCoord) * markerOpacity * vOpacity * layerOpacity;
  if(c.a < .05) {
    discard;
  }
  glFragColor = c;
  glFragColor = highlight_blendColor(glFragColor);
  if(glFragColor.a < alphaTest) {
    discard;
  }
  glFragColor = highlight_blendColor(glFragColor);
#if __VERSION__ == 100
gl_FragColor = glFragColor;
#endif
}`,
      uniforms: [{
        name: "projViewModelMatrix",
        type: "function",
        fn: function(a, l) {
          return Jt([], l.projViewMatrix, l.modelMatrix);
        }
      }, {
        name: "zoomScale",
        type: "function",
        fn: function(a, l) {
          return l.tileResolution / l.resolution;
        }
      }],
      extraCommandProps: r
    }), this.shader.version = 300;
    const { uniforms: n, extraCommandProps: s } = zP.call(this, e, this.sceneConfig), o = this.Ls || {};
    if (this.Us = new qe({
      vert: Td,
      frag: rv,
      uniforms: n,
      extraCommandProps: s,
      defines: o
    }), this.pickingFBO) {
      const a = new Oi(this.renderer, {
        vert: `#define PICKING_MODE 1
` + tw,
        uniforms: [{
          name: "projViewModelMatrix",
          type: "function",
          fn: function(h, u) {
            return Jt([], u.projViewMatrix, u.modelMatrix);
          }
        }, {
          name: "zoomScale",
          type: "function",
          fn: function(h, u) {
            return u.tileResolution / u.resolution;
          }
        }],
        extraCommandProps: r
      }, this.pickingFBO, this.getMap());
      a.filter = (h) => !!h.geometry.properties.iconAtlas;
      const l = new Oi(this.renderer, {
        vert: `#define PICKING_MODE 1
` + Td,
        uniforms: n,
        extraCommandProps: s
      }, this.pickingFBO, this.getMap());
      l.filter = (h) => !!h.geometry.properties.glyphAtlas, this.picking = [a, l];
    }
  }
  getUniformValues(t, e) {
    const r = e && e.isRenderingTerrainSkin, n = this.layer.getTileSize().width, s = r ? oj : t.projViewMatrix, o = t.cameraToCenterDistance, a = we(aj, t.width, t.height);
    r && we(a, n, n);
    const l = this.getBlendFunc(), h = Yr.isFunction(l.src) ? l.src() : l.src;
    return {
      layerScale: this.layer.options.styleScale || 1,
      mapPitch: t.getPitch() * Math.PI / 180,
      mapRotation: t.getBearing() * Math.PI / 180,
      projViewMatrix: s,
      cameraToCenterDistance: o,
      canvasSize: a,
      iconSize: sj,
      resolution: t.getResolution(),
      glyphSize: 24,
      gammaScale: 1,
      blendSrcIsOne: +!(h !== "one" && h !== 1),
      viewport: r && e && e.viewport,
      isRenderingTerrain: +!!r
    };
  }
  getUniqueEntryKey(t, e) {
    if (!this.Hs(t.geometry)) return null;
    const { elements: r } = t.geometry.properties;
    return HP(t, r[e]);
  }
  Rs(t) {
    const { symbolIndex: e } = t.properties;
    return e.type === 0;
  }
  Hs(t) {
    const { symbolIndex: e } = t.properties;
    return e.type === 1;
  }
}
function lj(i, t) {
  return i.properties.level - t.properties.level || i.properties.meshKey - t.properties.meshKey;
}
const hj = [], uj = [], cj = [];
function iv(i, t, e, r, n, s, o, a, l, h, u, c, f) {
  const { aGlyphOffset: d, aSegment: p, aTextDx: g, aTextDy: m, symbolIndex: v } = t.geometry.properties, _ = this.getSymbol(v), y = g ? g[n] : _.textDx, x = m ? m[n] : _.textDy, w = we(cj, y || 0, x || 0), b = we(hj, d[2 * n], d[2 * n + 1]), T = ne(uj, p[3 * n], p[3 * n + 1], p[3 * n + 2]);
  return function(A, M, S, P, C, k, O, R, I, D, z, H, G, $, K, dt, it, st) {
    K || (K = P);
    const pt = M.geometry.properties.line, Ht = k[0] * H, Rt = G ? Ht - O : Ht + O;
    let Tt = Rt > 0 ? 1 : -1, $t = 0;
    G && (Tt *= -1, $t = Math.PI), Tt < 0 && ($t += Math.PI);
    const Wt = D + z, re = Math.abs(Rt);
    let ie = Tt > 0 ? I : I + 1, Kt = nf.convert(P), fe = nf.convert(P), Xt = nf.convert(C), Re = nf.convert(C), Oe = 0, oe = 0;
    for (; Oe + oe <= re; ) {
      if (ie += Tt, ie < D || ie >= Wt) return null;
      fe.x = Kt.x, fe.y = Kt.y, Re.x = Xt.x, Re.y = Xt.y, Kt.x = S[3 * ie], Kt.y = S[3 * ie + 1], Xt.x = pt[3 * ie], Xt.y = pt[3 * ie + 1], Oe += oe, oe = fe.dist(Kt) / $;
    }
    const nr = (re - Oe) / oe, Ke = dt && dt.getRenderer(), Ye = Ke && Ke.getTerrainHelper(), We = M.properties.tile.terrainTileInfos;
    if (!st && Ye) {
      const { extent: $e } = M.properties.tile, be = dt.getTileSize().width / $e, Ee = dt.getMap();
      let Ze = Xt.sub(Re).mult(nr)._i(Re);
      Kt = bm(uB, Ee, M, Xt, be, dt, it, We), fe = bm(cB, Ee, M, Re, be, dt, it, We), Ze = bm(fB, Ee, M, Ze, be, dt, it, We);
      const yn = $t + Math.atan2(Kt[1] - fe[1], Kt[0] - fe[0]);
      return A[0] = (Ze[0] - K[0]) / $, A[1] = (Ze[1] - K[1]) / $, A[2] = yn, A;
    }
    const bn = Kt.sub(fe), wn = bn.mult(nr)._i(fe);
    wn._i(bn.Ci().Ei().Ti(R * Tt));
    const On = $t + Math.atan2(Kt.y - fe.y, Kt.x - fe.x);
    return A[0] = (wn.x - P[0]) / $, A[1] = (wn.y - P[1]) / $, A[2] = On, A;
  }(i, t, r, s, o, b, w[0], w[1], T[0], T[1], T[2], e / 24, l, a, h, u, c, f);
}
const qs = [], Ys = [];
function fj(i, t, e, r, n, s, o, a, l, h, u, c) {
  const { aVertical: f } = e.geometry.properties, d = f[s];
  let p, g, m = iv.call(this, qs, e, r, n, s, a, l, h, !1);
  if (!m || (Jn(i, m), m = iv.call(this, Ys, e, r, n, o, a, l, h, !1), !m)) return null;
  if (Jn(t, m), c && (Bi(qs, qs, c), Bi(Ys, Ys, c)), d) {
    const v = Math.abs(Ys[1] - qs[1]), _ = Math.abs(Ys[0] - qs[0]) * u;
    g = qs[0] > Ys[0] ? 1 : 0, v > _ ? (p = 1, g = qs[1] < Ys[1] ? 0 : 1) : p = 0;
  } else p = 0, g = qs[0] > Ys[0] ? 1 : 0;
  return 2 * g + p;
}
var iw = `#define SHADER_NAME TEXT_LINE
#ifdef HAS_ALTITUDE
attribute vec2 aPosition;
attribute float aAltitude;
#else
attribute vec3 aPosition;
#endif
attribute vec2 aTexCoord;
#ifdef HAS_OFFSET_Z
attribute vec3 aOffset;
uniform float altitudeScale;
#else
attribute vec2 aOffset;
#endif
#ifdef ENABLE_COLLISION
attribute float aOpacity;
#endif
#ifdef HAS_OPACITY
attribute float aColorOpacity;
#endif
#ifdef HAS_TEXT_SIZE
attribute float aTextSize;
#else
uniform float textSize;
#endif
#ifdef HAS_TEXT_DX
attribute float aTextDx;
#else
uniform float textDx;
#endif
#ifdef HAS_TEXT_DY
attribute float aTextDy;
#else
uniform float textDy;
#endif
#if defined(HAS_PITCH_ALIGN)
attribute float aPitchAlign;
#else
uniform float pitchWithMap;
#endif
uniform float zoomScale;
uniform float cameraToCenterDistance;
uniform mat4 projViewModelMatrix;
uniform float textPerspectiveRatio;
uniform float mapPitch;
uniform vec2 texSize;
uniform vec2 canvasSize;
uniform float tileRatio;
uniform float layerScale;
uniform float isRenderingTerrain;
uniform float textPitchFilter;
#ifndef PICKING_MODE
varying vec2 vTexCoord;
varying float vGammaScale;
varying float vSize;
varying float vOpacity;
#ifdef HAS_TEXT_FILL
attribute vec4 aTextFill;
varying vec4 vTextFill;
#endif
#ifdef HAS_TEXT_HALO_FILL
attribute vec4 aTextHaloFill;
varying vec4 vTextHaloFill;
#endif
#ifdef HAS_TEXT_HALO_RADIUS
attribute float aTextHaloRadius;
varying float vTextHaloRadius;
#endif
#ifdef HAS_TEXT_HALO_OPACITY
attribute float aTextHaloOpacity;
varying float vTextHaloOpacity;
#endif
#include <highlight_vert>
#else
#include <fbo_picking_vert>
#endif
#include <vt_position_vert>
void main() {
  vec3 c = unpackVTPosition();
#ifdef HAS_TEXT_DX
float d = aTextDx;
#else
float d = textDx;
#endif
#ifdef HAS_TEXT_DY
float e = aTextDy;
#else
float e = textDy;
#endif
#ifdef HAS_TEXT_SIZE
float f = aTextSize * layerScale;
#else
float f = textSize * layerScale;
#endif
#ifdef HAS_PITCH_ALIGN
float h = aPitchAlign;
#else
float h = pitchWithMap;
#endif
gl_Position = projViewModelMatrix * vec4(c, 1.);
  float i = gl_Position.w;
  float j = i / cameraToCenterDistance;
  float k;
  if(isRenderingTerrain == 1.) {
    k = 1.;
  } else {
    float l = (1. - cameraToCenterDistance / i) * textPerspectiveRatio;
    k = clamp(.5 + .5 * (1. - l), .0, 4.);
  }
#ifdef HAS_OFFSET_Z
vec3 m = aOffset / 10.0;
  m[2] /= altitudeScale;
#else
vec3 m = vec3(aOffset / 10.0, .0);
#endif
vec2 n = aTexCoord;
  if(h == 1.) {
    float o;
    if(isRenderingTerrain == 1.) {
      o = tileRatio;
    } else {
      o = tileRatio / zoomScale * j * k;
    }
    m.xy *= o;
    gl_Position = projViewModelMatrix * vec4(c + m, 1.);
  } else {
    gl_Position.xy += m.xy * 2. / canvasSize * k * i;
  }
  gl_Position.xy += vec2(d, -e) * 2. / canvasSize * i;
  if(textPitchFilter > .0) {
    if(textPitchFilter == 1. && h == .0 || textPitchFilter == 2. && h == 1.) {
      gl_Position = vec4(-9999., -9999., .0, 1.);
    }
  }
#ifndef PICKING_MODE
if(h == 1.) {
    vGammaScale = j + mapPitch / 4.;
  } else {
    vGammaScale = mix(1., j, textPerspectiveRatio);
  }
  vGammaScale = clamp(vGammaScale, .0, 1.);
  vTexCoord = n / texSize;
  vSize = f;
#ifdef ENABLE_COLLISION
vOpacity = aOpacity / 255.;
#else
vOpacity = 1.;
#endif
#ifdef HAS_OPACITY
vOpacity *= aColorOpacity / 255.;
#endif
#ifdef HAS_TEXT_FILL
vTextFill = aTextFill / 255.;
#endif
#ifdef HAS_TEXT_HALO_FILL
vTextHaloFill = aTextHaloFill / 255.;
#endif
#ifdef HAS_TEXT_HALO_RADIUS
vTextHaloRadius = aTextHaloRadius;
#endif
#ifdef HAS_TEXT_HALO_OPACITY
vTextHaloOpacity = aTextHaloOpacity;
#endif
highlight_setVarying();
#else
#ifdef ENABLE_COLLISION
bool u = aOpacity == 255.;
#else
bool u = true;
#endif
fbo_picking_setData(gl_Position.w, u);
#endif
}`;
const dj = function(i) {
  const t = this.layer.getRenderer();
  return !this.ks(i) && t.isTileNearCamera(i) && i.geometry.properties.textPlacement !== "line";
}, pj = function(i) {
  const t = this.layer.getRenderer();
  return !this.ks(i) && !t.isForeground(i) && i.geometry.properties.textPlacement !== "line";
}, gj = function(i) {
  const t = this.layer.getRenderer();
  return !this.ks(i) && t.isTileNearCamera(i) && i.geometry.properties.textPlacement === "line";
}, mj = function(i) {
  const t = this.layer.getRenderer(), e = i.properties.tile.z, r = t.getCurrentTileZoom();
  return !this.ks(i) && !t.isForeground(i) && i.geometry.properties.textPlacement === "line" && e < r;
}, vj = [0, 0, 3], sw = [], yj = [], _j = [], uf = [], xj = [], bj = [], gs = [], ts = [], ow = [1, -1], ms = new Int16Array(3), wj = [], aw = [], km = [], Rm = [], Tj = [], lw = [], hw = [], uw = {}, cw = {}, Aj = {}, Mj = [], Sj = [], Cj = pn([]), fw = [];
class Vy extends DP {
  static getBloomSymbol() {
    return ["textBloom"];
  }
  constructor(t, e, r, n, s, o) {
    super(t, e, r, n, s, o), this.propAllowOverlap = "textAllowOverlap", this.propIgnorePlacement = "textIgnorePlacement", this.colorCache = {}, this.qs = dj.bind(this), this.Js = pj.bind(this), this.Zs = gj.bind(this), this.Ks = mj.bind(this), this.isLabelCollides = nv.bind(this), this.Qs();
  }
  prepareRender(...t) {
    super.prepareRender(...t);
    const e = this.scene.getMeshes();
    if (e && e.length) for (let r = 0; r < e.length; r++) {
      if (e[r].properties.isHalo) continue;
      const { haloMesh: n } = e[r].properties;
      n.dirtyDefines && e[r].setDefines(n.defines);
    }
  }
  updateSymbol(...t) {
    this.to = void 0, this.eo = void 0;
    const e = super.updateSymbol(...t);
    return this.Qs(), e;
  }
  isTerrainVector() {
    if (!super.isTerrainSkin()) return !1;
    if (this.to !== void 0) return this.to;
    for (let t = 0; t < this.symbolDef.length; t++)
      if (this.symbolDef[t].textPitchAlignment !== "map") return this.to = !0, !0;
    return this.to = !1, !1;
  }
  isTerrainSkin() {
    if (!super.isTerrainSkin()) return !1;
    if (this.eo !== void 0) return this.eo;
    for (let t = 0; t < this.symbolDef.length; t++) {
      const e = this.symbolDef[t].textPitchAlignment;
      if (e === "map" || Ft(e) || Xh.isExpression(e)) return this.eo = !0, !0;
    }
    return this.eo = !1, !1;
  }
  Qs() {
    this.no = [];
    for (let t = 0; t < this.symbolDef.length; t++) {
      const e = this.symbolDef[t];
      if (Xh.isExpression(e.textName)) {
        const r = Xh.createExpression(e.textName, "string");
        this.no[t] = (n, s) => {
          let o;
          uw.zoom = n, cw.properties = s;
          try {
            o = r.evaluateWithoutErrorHandling(uw, cw, Aj, null, Mj);
          } catch {
            o = null;
          }
          return o;
        };
      } else Ft(e.textName) && (this.no[t] = he(e.textName));
    }
  }
  shouldDeleteMeshOnUpdateSymbol(t) {
    if (!Array.isArray(t)) return (t.textHaloRadius === 0 || this.symbolDef[0].textHaloRadius === 0) && t.textHaloRadius !== this.symbolDef[0].textHaloRadius;
    for (let e = 0; e < t.length; e++) if (t[e] && (t[e].textHaloRadius === 0 || this.symbolDef[e].textHaloRadius === 0) && t[e].textHaloRadius !== this.symbolDef[e].textHaloRadius) return !0;
    return !1;
  }
  createFnTypeConfig(t, e) {
    return NP(t, e);
  }
  isBloom(t) {
    return !!this.getSymbol(t.properties.symbolIndex)[Vy.getBloomSymbol()[0]];
  }
  createGeometry(t, e, r) {
    const n = t;
    if (!n.glyphAtlas) return null;
    const s = super.createGeometry(n, e);
    if (!s || !s.geometry) return null;
    const { geometry: o } = s;
    return o.properties.glyphAtlas && this.drawDebugAtlas(o.properties.glyphAtlas), o && n.lineVertex && (o.properties.line = n.lineVertex, o.properties.line.id = r), s;
  }
  createMesh(t, e, { tileVectorTransform: r }) {
    const n = this.isEnableCollision(), s = this.isEnableUniquePlacement(), { geometry: o, symbolIndex: a } = t;
    o.properties.symbolIndex = a;
    const l = this.getSymbol(a), h = this.getSymbolDef(a), u = this.getFnTypeConfig(a), c = LP.call(this, this.regl, o, e, h, l, u, this.layer.options.collision, !n, s);
    return c.length && (o.properties.textPlacement === "line" ? this.io = !0 : this.ro = !0), c.forEach((f) => {
      f.positionMatrix = this.getAltitudeOffsetMatrix(), f.properties.tileVectorTransform = r;
    }), c;
  }
  updateCollision(t) {
    super.updateCollision(t);
    const e = this.scene.getMeshes();
    e && e.length ? (this.so = {}, this.oo(t.timestamp), this.Vr()) : this.Vr();
  }
  callCurrentTileShader(t, e) {
    this.shader.filter = e.sceneFilter ? [this.qs, e.sceneFilter] : this.qs, this.callRenderer(this.shader, t, e), this.ao.filter = e.sceneFilter ? [this.Zs, e.sceneFilter] : this.Zs, this.callRenderer(this.ao, t, e);
  }
  callBackgroundTileShader(t, e) {
    this.shader.filter = e.sceneFilter ? [this.Js, e.sceneFilter] : this.Js, this.callRenderer(this.shader, t, e), this.ao.filter = e.sceneFilter ? [this.Ks, e.sceneFilter] : this.Ks, this.callRenderer(this.ao, t, e);
  }
  callRenderer(t, e, r) {
    r && r.isRenderingTerrain && Ft(this.symbolDef.textPitchAlignment) && (r.isRenderingTerrainSkin ? e.textPitchFilter = 1 : e.textPitchFilter = 2), super.callRenderer(t, e, r);
  }
  oo() {
    let t = this.scene.getMeshes();
    if (!t || !t.length) return;
    const e = -this.getMap().getBearing() * Math.PI / 180, r = xR(_j, e), n = (a, l, h, u) => {
      const { start: c, end: f, mesh: d, allElements: p } = l[0];
      if (this.updateBoxCollisionFading(!0, d, l, h, u)) {
        let g = a.count;
        for (let m = c; m < f; m++) a[g++] = p[m];
        a.count = g;
      }
    }, s = this.isEnableCollision(), o = this.layer.getRenderer();
    t = t.sort(Pj);
    for (let a = 0; a < t.length; a++) {
      const l = t[a];
      if (!this.isMeshIterable(l)) continue;
      if (!o.isTileNearCamera(l)) {
        const { visElemts: f } = l.geometry.properties;
        f && (f.count = 0), l.geometry.setElements(f, 0);
        continue;
      }
      const h = l.geometry, u = this.getSymbol(l.properties.symbolIndex);
      l.properties.textHaloRadius = gn(u.textHaloRadius) ? fr.textHaloRadius : u.textHaloRadius;
      const c = l.properties.meshKey;
      if (h.properties.textPlacement === "line") {
        if (!h.properties.line) continue;
        s && this.startMeshCollision(l), this.lo(l, r);
        const { aOffset: f, aOpacity: d } = h.properties;
        f.dirty && (h.updateData("aOffset", f), f.dirty = !1), d && d.dirty && (h.updateData("aOpacity", d), d.dirty = !1), s && this.endMeshCollision(c);
      } else if (s) {
        this.startMeshCollision(l);
        const { elements: f, aOpacity: d, visElemts: p } = h.properties;
        p.count = 0, this.forEachBox(l, (v, _, y, x, w) => {
          n(p, _, y, x);
        }), d && d.dirty && h.updateData("aOpacity", d);
        const g = p.count === f.length && h.count === f.length, m = !p.count && !h.count;
        g || m || h.setElements(p, p.count), this.endMeshCollision(c);
      }
    }
  }
  isMeshIterable(t) {
    return t.isValid() && t.material && !t.material.get("isHalo") && !(this.shouldIgnoreBackground() && !this.layer.getRenderer().isForeground(t));
  }
  isMeshUniquePlaced(t) {
    return this.isMeshIterable(t) ? this.getSymbol(t.properties.symbolIndex).textPlacement !== "line" : !1;
  }
  getUniqueEntryKey(t, e) {
    return HP(t, e);
  }
  lo(t, e) {
    const r = this.getMap(), n = t.geometry, s = n.properties;
    let o = s.line;
    if (!o) return;
    const a = r.getPitch(), l = r.getBearing(), { lineTextPitch: h, lineTextBearing: u } = t.properties, c = t.material.uniforms.pitchWithMap === 1, f = s.elements;
    if (!c) {
      const _ = Jt(sw, r.projViewMatrix, t.localTransform), y = o.id + "-" + _.join();
      let x;
      this.so[y] ? o = this.so[y] : (x = s.projectedLine = s.projectedLine || new Array(o.length), o = this.ho(x, o, _, r.width, r.height), this.so[y] = x);
    }
    const d = this.isEnableCollision(), p = n.properties.visElemts = n.properties.visElemts || new f.constructor(f.length), g = n.properties.visCache = n.properties.visCache || [];
    d && (p.count = 0);
    const m = h === void 0 || !r.isInteracting() || Math.abs(a - h) > 2 || Math.abs(l - u) > 2;
    m && (this.Ir = !0), this.forEachBox(t, (_, y, x, w) => {
      const { start: b, end: T } = y[0];
      let A = g[w];
      if ((A === void 0 || m) && (A = this.uo(_, f, b, T, o, x, c ? e : null, w)), g[w] = A, d && (A = this.updateBoxCollisionFading(A, _, y, x, w), A)) {
        let M = p.count;
        for (let S = b; S < T; S++) p[M++] = f[S];
        p.count = M;
      }
    }), m && (t.properties.lineTextPitch = a, t.properties.lineTextBearing = l);
    const v = t.geometry.properties.aAltitude;
    v && v.dirty && (n.updateData("aAltitude", v), v.dirty = !1), !d || p.count === f.length && n.count === p.count || n.setElements(p, p.count);
  }
  ho(t, e, r, n, s) {
    return function(o, a, l, h, u) {
      for (let c = 0; c < a.length; c += 3) Sr(Zr, a[c], a[c + 1], a[c + 2], 1), is(Zr, Zr, l, h, u), o[c] = Zr[0], o[c + 1] = Zr[1], o[c + 2] = a[c + 2];
      return o;
    }(t, e, r, n, s);
  }
  forEachBox(t, e) {
    const r = this.getMap(), n = Jt(sw, r.projViewMatrix, t.properties.tileVectorTransform), { collideIds: s, aCount: o, features: a, elements: l } = t.geometry.properties, h = s;
    if (!h) return;
    const u = this.isEnableUniquePlacement(), c = this.Ps(1);
    c[0].allElements = l, c[0].mesh = t;
    let f = 0, d = l[0], p = 0, g = h[d];
    for (let m = 0; m <= l.length; m += 6) if (d = l[m], h[d] !== g || m === l.length) {
      const v = a[g] && a[g].feature;
      if (u && this.isMeshUniquePlaced(t) && v && !v.label) {
        const x = v.properties || {}, { symbolIndex: w } = t.properties, b = w && this.no[w.index] ? this.no[w.index](t.properties.z, x) : this.getSymbol(t.properties.symbolIndex).textName, T = SN.resolveText(b, x);
        v.label = T;
      }
      const _ = m, y = o[l[p]];
      for (let x = p; x < _; x += 6 * y) c[0].start = x, c[0].end = x + 6 * y, c[0].boxCount = y, e.call(this, t, c, n, f++);
      g = h[d], p = m;
    }
  }
  uo(t, e, r, n, s, o, a) {
    const l = this.layer.getRenderer(), h = t.material.uniforms, u = h.pitchWithMap === 1, c = !u && l.getTerrainHelper && l.getTerrainHelper(), f = this.isEnableCollision(), d = this.getMap(), p = t.geometry, g = p.desc.positionSize, { aShape: m, aOffset: v, aAnchor: _, aAltitude: y, aPitchRotation: x } = p.properties;
    let { aProjectedAnchor: w } = p.properties;
    w || (w = p.properties.aProjectedAnchor = new Array(_.length / g * 3));
    const b = p.properties.aTextSize, T = !a, A = e[r], M = A * g;
    let S;
    S = p.data.aAltitude ? ne(uf, _[M], _[M + 1], y[A]) : Er.unpackPosition(uf, _[M], _[M + 1], _[M + 2]);
    const P = is(xj, S, o, d.width, d.height), C = p.properties.aTerrainAltitude;
    let k;
    if (C) {
      const it = C[A];
      if (it === xl) return w[3 * A] = -999999, w[3 * A + 1] = -999999, w[3 * A + 2] = -999999, !1;
      it ? (k = ne(Sj, ...S), k[2] = 100 * it, k = is(k, k, o, d.width, d.height)) : k = P;
    } else k = P;
    const O = d.getDevicePixelRatio();
    if (Sl(fw, k, 1 / O), d.isOffscreen(fw)) return f || Im(v, e, r, n), w[3 * A] = -999999, w[3 * A + 1] = -999999, w[3 * A + 2] = -999999, !1;
    T && (S = P), w[3 * A] = k[0], w[3 * A + 1] = k[1], w[3 * A + 2] = k[2];
    const R = T ? 1 : p.properties.tileExtent / this.layer.getTileSize().width;
    let I = !0;
    const D = e[r], z = e[n - 1], H = b ? b[D] : t.properties.textSize, G = this.co(t, H, s, D, z, S, uf, R, a);
    if (G === null) return Im(v, e, r, n), !1;
    const $ = z - D <= 3, K = Math.floor(G / 2), dt = G % 2;
    for (let it = r; it < n; it += 6) {
      const st = e[it];
      let pt;
      if (pt = K || it !== r || $ || c ? K || it !== n - 6 || $ || c ? iv.call(this, yj, t, H, s, st, S, uf, R, K, k, this.layer, o, u) : hw : lw, !pt) {
        I = !1, f || Im(v, e, r, n);
        break;
      }
      let Ht = pt[2];
      dt && (Ht -= Math.PI / 2);
      const Rt = Gy(bj, Ht, 0, h.rotateWithMap, h.pitchWithMap), Tt = v.length > m.length;
      let $t;
      if (Tt) {
        ne(Rm, x[3 * st], x[3 * st + 1], 0);
        const Wt = mo(Rm, Rm), re = -x[3 * st + 2];
        if (re) {
          const ie = JA(wj, Wt, re);
          Bh(aw, vj), qA(km, ie), $t = Jt(km, km, aw);
        }
      }
      for (let Wt = 0; Wt < 4; Wt++) {
        const re = 2 * (st + Wt);
        we(gs, m[re] / 10, m[re + 1] / 10), ui(gs, gs, H / 24), Bi(gs, gs, Rt), u ? (or(gs, gs, ow), I_(ts, gs, pt), Tt && (ts[2] = 0, $t && fl(ts, ts, $t))) : (or(ts, pt, ow), I_(ts, gs, ts)), ms[0] = 10 * ts[0], ms[1] = 10 * ts[1], Tt && (ms[2] = 10 * ts[2]);
        const ie = (Tt ? 3 : 2) * (st + Wt);
        (v[ie] !== ms[0] || v[ie + 1] !== ms[1] || Tt && v[ie + 2] !== ms[2]) && (v.dirty = !0, v[ie] = ms[0], v[ie + 1] = ms[1], Tt && (v[ie + 2] = ms[2]));
      }
    }
    return I;
  }
  co(t, e, r, n, s, o, a, l, h) {
    const u = s - n <= 3, c = this.getMap();
    return u ? 0 : fj.call(this, lw, hw, t, e, r, n, s, o, a, l, c.width / c.height, h);
  }
  isBoxCollides(t, e, r, n, s, o) {
    return this.isLabelCollides(0, t, e, r, n, s, o);
  }
  deleteMesh(t, e) {
    t && (e && (Array.isArray(t) ? t.forEach((r) => {
      r && r.material && delete r.material.uniforms.texture;
    }) : t.material && delete t.material.uniforms.texture), super.deleteMesh(t, e));
  }
  delete() {
    super.delete(), this.ao.dispose(), delete this.so, this.fo && this.fo.dispose();
  }
  needClearStencil() {
    return !0;
  }
  init() {
    const t = this.regl;
    this.renderer = new hn(t);
    const { uniforms: e, extraCommandProps: r } = zP.call(this, this.canvas, this.sceneConfig), n = this.canvas, s = {
      x: (a, l) => l.viewport ? l.viewport.x : 0,
      y: (a, l) => l.viewport ? l.viewport.y : 0,
      width: (a, l) => l.viewport ? l.viewport.width : n ? n.width : 1,
      height: (a, l) => l.viewport ? l.viewport.height : n ? n.height : 1
    };
    r.viewport = s, this.shader = new qe({
      vert: Td,
      frag: rv,
      uniforms: e,
      extraCommandProps: r
    });
    let o = r;
    if (this.layer.getRenderer().isEnableWorkAround("win-intel-gpu-crash") && (o = In({}, r), o.stencil = In({}, r.stencil), o.stencil.enable = !0), this.ao = new qe({
      vert: iw,
      frag: rv,
      uniforms: e,
      extraCommandProps: o
    }), this.pickingFBO) {
      const a = new Oi(this.renderer, {
        vert: `#define PICKING_MODE 1
` + Td,
        uniforms: e,
        extraCommandProps: {
          viewport: this.pickingViewport
        }
      }, this.pickingFBO, this.getMap());
      a.filter = (h) => {
        const u = h.properties.symbolIndex;
        return this.getSymbol(u).textPlacement !== "line";
      };
      const l = new Oi(this.renderer, {
        vert: `#define PICKING_MODE 1
` + iw,
        uniforms: e,
        extraCommandProps: {
          viewport: this.pickingViewport
        }
      }, this.pickingFBO, this.getMap());
      l.filter = (h) => h.geometry.properties.textPlacement === "line", this.picking = [a, l];
    }
  }
  getUniformValues(t, e) {
    const r = e && e.isRenderingTerrainSkin, n = this.layer.getTileSize().width, s = r ? Cj : t.projViewMatrix, o = t.cameraToCenterDistance, a = we(Tj, t.width, t.height);
    r && we(a, n, n);
    const l = Rl(t.getResolution(), t);
    return {
      layerScale: this.layer.options.styleScale || 1,
      mapPitch: t.getPitch() * Math.PI / 180,
      mapRotation: t.getBearing() * Math.PI / 180,
      projViewMatrix: s,
      viewMatrix: t.viewMatrix,
      cameraToCenterDistance: o,
      canvasSize: a,
      glyphSize: 24,
      gammaScale: 1 * (this.layer.options.textGamma || 1),
      resolution: t.getResolution(),
      altitudeScale: l,
      viewport: r && e && e.viewport,
      textPitchFilter: 0,
      isRenderingTerrain: +!!r
    };
  }
}
function Im(i, t, e, r) {
  for (let n = e; n < r; n += 6) {
    const s = t[n];
    for (let o = 0; o < 4; o++) {
      const a = 3 * (s + o);
      (i[a] || i[a + 1] || i[a + 2]) && (i.dirty = !0, i[a] = 0, i[a + 1] = 0, i[a + 2] = 0);
    }
  }
}
function Pj(i, t) {
  const e = i.properties.level - t.properties.level;
  return e === 0 ? i.properties.meshKey - t.properties.meshKey : e;
}
var dw = `#define SHADER_NAME NATIVE_POINT
#include <gl2_vert>
#ifdef HAS_ALTITUDE
attribute vec2 aPosition;
attribute float aAltitude;
#else
attribute vec3 aPosition;
#endif
#ifdef HAS_COLOR
attribute vec4 aColor;
varying vec4 vColor;
#endif
uniform mat4 positionMatrix;
uniform mat4 projViewModelMatrix;
uniform float markerSize;
#ifdef PICKING_MODE
#include <fbo_picking_vert>
#endif
#include <vt_position_vert>
void main() {
  vec3 c = unpackVTPosition();
  gl_Position = projViewModelMatrix * positionMatrix * vec4(c, 1.);
  gl_PointSize = markerSize;
#ifdef HAS_COLOR
vColor = aColor / 255.;
#endif
#ifdef PICKING_MODE
fbo_picking_setData(gl_Position.w, true);
#endif
}`;
const Ej = {
  markerFill: [0, 0, 0],
  markerOpacity: 1,
  markerSize: 10
};
class Oj extends vo {
  getPrimitive() {
    return "points";
  }
  isTerrainSkin() {
    return !1;
  }
  isTerrainVector() {
    return this.layer.options.awareOfTerrain;
  }
  createMesh(t, e) {
    const { geometry: r, symbolIndex: n, ref: s } = t, o = this.getSymbol(n);
    s === void 0 && (Ns(r, this.getSymbolDef(n), this.getFnTypeConfig(n)), r.generateBuffers(this.regl));
    const a = {};
    ue(a, "markerOpacity", o, "markerOpacity", 1), ue(a, "markerSize", o, "markerSize", 10), ue(a, "markerFill", o, "markerFill", "#000", fi(this.colorCache, 3));
    const l = new Nr(a, Ej);
    l.createDefines = () => o.markerType !== "square" ? {
      USE_CIRCLE: 1
    } : null, l.appendDefines = (c) => (o.markerType !== "square" && (c.USE_CIRCLE = 1), c);
    const h = new tn(r, l, {
      castShadow: !1,
      picking: !0
    }), u = {};
    return h.geometry.data.aAltitude && (u.HAS_ALTITUDE = 1), r.data.aColor && (u.HAS_COLOR = 1), h.setDefines(u), h.positionMatrix = this.getAltitudeOffsetMatrix(), h.setLocalTransform(e), h.properties.symbolIndex = n, h;
  }
  createFnTypeConfig(t, e) {
    const r = ln(e.markerFill);
    return [{
      attrName: "aColor",
      symbolName: "markerFill",
      type: Uint8Array,
      width: 4,
      define: "HAS_COLOR",
      evaluate: (n, s) => {
        let o = r(t.getZoom(), n);
        return Ft(o) && (o = this.evaluateInFnTypeConfig(o, s, t, n, !0)), Array.isArray(o) || (o = this.colorCache[o] = this.colorCache[o] || Zi(o).unitArray()), o = Yo(o), o;
      }
    }];
  }
  init() {
    const t = this.regl;
    this.renderer = new hn(t);
    const e = [], r = {
      vert: dw,
      frag: `#define SHADER_NAME NATIVE_POINT
precision mediump float;
#include <gl2_frag>
#ifdef USE_CIRCLE
#if __VERSION__ == 100
#ifdef GL_OES_standard_derivatives
#define STANDARD_DERIVATIVES_ENABLED 1
#extension GL_OES_standard_derivatives : enable
#endif
#else
#define STANDARD_DERIVATIVES_ENABLED 1
#endif
#endif
#ifdef HAS_COLOR
varying vec4 vColor;
#else
uniform vec3 markerFill;
#endif
uniform float markerOpacity;
uniform float layerOpacity;
void main() {
  float c = 1.;
#ifdef USE_CIRCLE
float r = .0, d = .0;
  vec2 e = 2. * gl_PointCoord - 1.;
  r = dot(e, e);
  if(r > 1.) {
    discard;
  }
#ifdef STANDARD_DERIVATIVES_ENABLED
d = fwidth(r);
  c = 1. - smoothstep(1. - d, 1. + d, r);
#endif
#endif
#ifdef HAS_COLOR
vec4 f = vColor;
#else
vec4 f = vec4(markerFill, 1.);
#endif
glFragColor = f * markerOpacity * c * layerOpacity;
#if __VERSION__ == 100
gl_FragColor = glFragColor;
#endif
}`,
      uniforms: [{
        name: "projViewModelMatrix",
        type: "function",
        fn: function(n, s) {
          return Jt(e, s.projViewMatrix, s.modelMatrix), e;
        }
      }],
      defines: null,
      extraCommandProps: {
        viewport: {
          x: 0,
          y: 0,
          width: () => this.canvas ? this.canvas.width : 1,
          height: () => this.canvas ? this.canvas.height : 1
        },
        depth: {
          enable: !0,
          mask: !1,
          range: this.sceneConfig.depthRange || [0, 1],
          func: this.sceneConfig.depthFunc || "always"
        },
        blend: {
          enable: !0,
          func: this.getBlendFunc(),
          equation: "add"
        }
      }
    };
    if (this.shader = new qe(r), this.shader.version = 300, this.pickingFBO) {
      const n = [];
      this.picking = [new Oi(this.renderer, {
        vert: `#define PICKING_MODE 1
` + dw,
        uniforms: [{
          name: "projViewModelMatrix",
          type: "function",
          fn: function(s, o) {
            return Jt(n, o.projViewMatrix, o.modelMatrix), n;
          }
        }],
        extraCommandProps: {
          viewport: this.pickingViewport
        }
      }, this.pickingFBO, this.getMap())];
    }
  }
  getUniformValues(t) {
    return {
      projViewMatrix: t.projViewMatrix
    };
  }
}
var pw = `#define SHADER_NAME NATIVE_LINE
#ifdef HAS_ALTITUDE
attribute vec2 aPosition;
attribute float aAltitude;
#else
attribute vec3 aPosition;
#endif
uniform mat4 projViewModelMatrix;
#ifndef PICKING_MODE
#if defined(HAS_COLOR)
attribute vec4 aColor;
varying vec4 vColor;
#endif
#else
#include <fbo_picking_vert>
#endif
#include <vt_position_vert>
void main() {
  vec3 c = unpackVTPosition();
  gl_Position = projViewModelMatrix * vec4(c, 1.);
#ifndef PICKING_MODE
#if defined(HAS_COLOR)
vColor = aColor / 255.;
#endif
#else
fbo_picking_setData(gl_Position.w, true);
#endif
}`;
const kj = pn([]);
class Rj extends vo {
  constructor(t, e, r, n, s, o) {
    if (super(t, e, r, n, s, o), this.primitive = "lines", Ft(this.symbolDef.lineColor)) {
      const a = e.getMap(), l = ln(this.symbolDef.lineColor);
      this.colorSymbol = (h) => l(a.getZoom(), h);
    }
  }
  needPolygonOffset() {
    return !0;
  }
  createMesh(t, e) {
    const { geometry: r, symbolIndex: n, ref: s } = t, o = this.getSymbol(n), a = this.getMeshUniforms(r, o);
    s === void 0 && r.generateBuffers(this.regl);
    const l = new Nr(a), h = new tn(r, l, {
      castShadow: !1,
      picking: !0
    });
    h.setLocalTransform(e), h.properties.symbolIndex = n;
    const u = {};
    return h.geometry.data.aAltitude && (u.HAS_ALTITUDE = 1), h.setDefines(u), h;
  }
  getMeshUniforms(t, e) {
    const r = {};
    return ue(r, "lineColor", e, "lineColor", "#000", fi(this.colorCache)), ue(r, "lineOpacity", e, "lineOpacity", 1), r;
  }
  init(t) {
    const e = this.layer.getRenderer().isEnableTileStencil() && (!t || !t.isRenderingTerrain || !this.isTerrainSkin()), r = this.regl;
    this.renderer = new hn(r);
    const n = this.canvas, s = {
      x: (h, u) => u.viewport ? u.viewport.x : 0,
      y: (h, u) => u.viewport ? u.viewport.y : 0,
      width: (h, u) => u.viewport ? u.viewport.width : n ? n.width : 1,
      height: (h, u) => u.viewport ? u.viewport.height : n ? n.height : 1
    }, o = [{
      name: "projViewModelMatrix",
      type: "function",
      fn: function(h, u) {
        const c = [];
        return Jt(c, u.projViewMatrix, u.modelMatrix), c;
      }
    }], a = this.sceneConfig.depthRange, l = {
      vert: pw,
      frag: `#define SHADER_NAME NATIVE_LINE
precision mediump float;
uniform float lineOpacity;
uniform vec4 lineColor;
uniform float layerOpacity;
#if defined(HAS_COLOR)
varying vec4 vColor;
#endif
void main() {
  gl_FragColor = lineColor * lineOpacity;
#if defined(HAS_COLOR)
gl_FragColor *= vColor;
#endif
gl_FragColor *= layerOpacity;
}`,
      uniforms: o,
      defines: null,
      extraCommandProps: {
        viewport: s,
        stencil: {
          enable: !0,
          mask: 255,
          func: {
            cmp: () => e ? "=" : "<=",
            ref: (h, u) => e ? u.stencilRef : u.level,
            mask: 255
          },
          op: {
            fail: "keep",
            zfail: "keep",
            zpass: "replace"
          }
        },
        depth: {
          enable: !0,
          range: a || [0, 1],
          func: this.sceneConfig.depthFunc || "<="
        },
        blend: {
          enable: !0,
          func: this.getBlendFunc(),
          equation: "add"
        },
        polygonOffset: {
          enable: !0,
          offset: this.getPolygonOffset()
        }
      }
    };
    this.shader = new qe(l), this.pickingFBO && (this.picking = [new Oi(this.renderer, {
      vert: `#define PICKING_MODE 1
` + pw,
      uniforms: o,
      extraCommandProps: {
        viewport: this.pickingViewport
      }
    }, this.pickingFBO, this.getMap())]);
  }
  getUniformValues(t, e) {
    const r = e && e.isRenderingTerrainSkin;
    return {
      projViewMatrix: r ? kj : t.projViewMatrix,
      viewport: r && e && e.viewport
    };
  }
  getPrimitive() {
    return "lines";
  }
}
const cf = [1, 1, 1], Dm = [1, 1, 1, 1], gw = [0, 0], Ij = [1, 1], Dj = [], mw = new lt(0, 0), Fm = new lt(0, 0), Fj = [], Lj = [];
class GP extends jy {
  supportRenderMode(t) {
    return this.isAnimating() ? t === "fxaa" || t === "fxaaAfterTaa" : t === "taa" || t === "fxaa";
  }
  isTerrainSkin() {
    return !1;
  }
  isTerrainVector() {
    return this.layer.options.awareOfTerrain;
  }
  isAnimating() {
    return !1;
  }
  createMesh(t, e, { tilePoint: r }) {
    if (!this.material) return this.setToRedraw(), null;
    const { geometry: n, symbolIndex: s } = t, o = this.layer instanceof Pn, a = new tn(n, this.material);
    if (this.sceneConfig.animation) {
      cf[2] = 0.01;
      const w = [];
      $o(w, cf), Jt(w, e, w), e = w;
    }
    const l = this.getSymbolDef(s), h = this.getFnTypeConfig(s);
    Ns(n, l, h);
    const u = this.getShader(), c = u.getGeometryDefines ? u.getGeometryDefines(n) : {}, f = this.getSymbol(s), d = fi(this.colorCache);
    if (n.data.aExtrude) {
      c.IS_LINE_EXTRUSION = 1;
      const { tileResolution: w, tileRatio: b } = n.properties, T = this.getMap();
      Object.defineProperty(a.uniforms, "linePixelScale", {
        enumerable: !0,
        get: function() {
          return b * T.getResolution() / w;
        }
      }), ue(a.uniforms, "lineWidth", f, "lineWidth", 4), ue(a.uniforms, "lineOpacity", f, "lineOpacity", 1), ue(a.uniforms, "lineColor", f, "lineColor", "#fff", d), Object.defineProperty(a.uniforms, "lineHeight", {
        enumerable: !0,
        get: () => {
          const A = this.dataConfig.defaultAltitude * (this.dataConfig.altitudeScale || 1);
          return zy(A) ? A : 0;
        }
      });
    } else {
      ue(a.uniforms, "polygonFill", f, "polygonFill", Dm, d), ue(a.uniforms, "polygonOpacity", f, "polygonOpacity", 1);
      const w = [];
      Object.defineProperty(a.uniforms, "vertexColorsOfType", {
        enumerable: !0,
        get: () => {
          const b = d(f.bottomPolygonFill || Dm), T = d(f.topPolygonFill || Dm);
          w[0] = b[0], w[1] = b[1], w[2] = b[2], w[3] = b[3], w[4] = T[0], w[5] = T[1], w[6] = T[2], w[7] = T[3];
          const A = a.geometry.properties.vertexColors;
          if (A) {
            let M = 8;
            w.length = 8 + A.length;
            for (let S = 0; S < A.length; S++) w[M++] = A[S][0], w[M++] = A[S][1], w[M++] = A[S][2], w[M++] = A[S][3];
          }
          return w;
        }
      });
    }
    if (n.data.aColor && (c.HAS_COLOR = 1), n.data.aOpacity && (c.HAS_OPACITY = 1), n.data.aLineWidth && (c.HAS_LINE_WIDTH = 1), n.data.aLineHeight && (c.HAS_LINE_HEIGHT = 1), n.data.aTerrainAltitude && (c.HAS_TERRAIN_ALTITUDE = 1), n.data.aVertexColorType) {
      const w = a.geometry.properties.vertexColors;
      let b = 2;
      w && (b += w.length), c.VERTEX_TYPES_COUNT = b;
    }
    if (n.data.aOpacity) {
      const w = n.data.aOpacity;
      for (let b = 0; b < w.length; b++) if (w[b] < 255) {
        n.properties.hasAlpha = !0;
        break;
      }
    }
    c.HAS_MIN_ALTITUDE = 1, c.HAS_LAYER_OPACITY = 1, n.generateBuffers(this.regl), a.setDefines(c), a.setPositionMatrix(this.getAltitudeOffsetMatrix()), a.setLocalTransform(e), (n.properties.maxAltitude <= 0 || a.properties.level >= 3) && (a.castShadow = !1), a.setUniform("maxAltitude", a.geometry.properties.maxAltitude), Object.defineProperty(a.uniforms, "minAltitude", {
      enumerable: !0,
      get: () => this.layer.options.altitude || 0
    });
    const { tileResolution: p } = n.properties, g = this.getMap(), m = this.layer.getRenderer(), v = g.pointAtResToCoord(new Y(r), p), _ = function(w, b, T, A, M) {
      return w.pointAtResToDistance(b, 0, A, T);
    }(g, 1, v, p), y = [];
    Object.defineProperty(a.uniforms, "uvOrigin", {
      enumerable: !0,
      get: () => this.do(y, s, r, p, _, o)
    }), a.setUniform("uvOffset", [0, 0]), Object.defineProperty(a.uniforms, "hasAlpha", {
      enumerable: !0,
      get: () => {
        const w = this.getSymbol(s);
        return n.properties.hasAlpha || w.polygonOpacity < 1 || w.lineOpacity < 1 || a.material && (a.material.uniforms.baseColorTexture || a.material.uniforms.emissiveTexture);
      }
    });
    const x = this.layer.getMap().getMaxNativeZoom();
    return Object.defineProperty(a.uniforms, "stencilRef", {
      enumerable: !0,
      get: () => m.isForeground(a) ? 0 : x - a.properties.tile.z
    }), a.properties.symbolIndex = s, a;
  }
  do(t, e, r, n, s, o) {
    if (this.dataConfig.topUVMode === 1) return t[0] = 0, t[1] = 0, t;
    const a = this.getMap(), l = this.getSymbol(e).material;
    let h = r;
    !this.dataConfig.side && l && l.textureOrigin && (mw.set(l.textureOrigin[0], l.textureOrigin[1]), a.coordToPointAtRes(mw, n, Fm), h = we(Fj, r[0] - Fm.x, r[1] - Fm.y));
    const u = !!l && l.uvOffsetInMeter;
    let c = l && l.uvOffset || gw;
    const f = this.getUVOffsetAnim();
    f && (c = this.getUVOffset(f));
    const d = l && l.uvScale || Ij;
    let p = this.dataConfig.side ? 0 : h[0], g = this.dataConfig.side ? 0 : h[1];
    const m = l && l.textureWidth || hP, v = m * d[1] / d[0];
    u && (p += c[0] / s, g += c[1] / s);
    const _ = u ? 0 : c[0], y = u ? 0 : c[1], x = we(t, p * s * d[0] / m + _, g * s * d[1] / v + y);
    return o || (x[1] *= -1), x;
  }
  callShader(t, e) {
    const r = this.sceneConfig.cullFace;
    this.sceneConfig.cullFace = "front", this.callBackgroundTileShader(t, e), r === void 0 ? delete this.sceneConfig.cullFace : this.sceneConfig.cullFace = r, super.callShader(t, e);
  }
  getShadowMeshes() {
    if (!this.isVisible()) return Dj;
    this.shadowCount = this.scene.getMeshes().length;
    const t = this.scene.getMeshes().filter((e) => e.properties.level === 0);
    for (let e = 0; e < t.length; e++) {
      const r = t[e];
      r.material !== this.material && r.setMaterial(this.material);
    }
    return t;
  }
  getUVOffsetAnim() {
    const t = this.getSymbols()[0];
    return t.material && t.material.uvOffsetAnim;
  }
  getUVOffset(t) {
    const e = this.getSymbols()[0], r = e.material && e.material.uvOffset || gw, n = !!e.material && e.material.uvOffsetInMeter, s = performance.now() / 1e3, o = we(Lj, r[0], r[1]);
    return o[0] = s * t[0], o[1] = s * t[0], n || (o[0] %= 1, o[1] %= 1), o;
  }
  needPolygonOffset() {
    return this.po;
  }
  startFrame(...t) {
    return delete this.po, super.startFrame(...t);
  }
  addMesh(t, e) {
    t.forEach((r) => {
      this.Sr(r, e);
    }), super.addMesh(...arguments);
  }
  Sr(t, e) {
    if (e !== null) {
      const r = t.localTransform;
      e === 0 && (e = 0.01), cf[2] = e, $o(r, cf), Jt(r, t.properties.tileTransform, r), t.setLocalTransform(r);
    } else t.setLocalTransform(t.properties.tileTransform);
    t.material !== this.material && t.setMaterial(this.material), t.geometry.properties.maxAltitude <= 0 && (this.po = !0), this.getSymbol(t.properties.symbolIndex).ssr ? t.ssr = 1 : t.ssr = 0;
  }
  deleteMaterial() {
    this.material && (this.material.dispose(), delete this.material);
  }
  deleteMesh(t, e) {
    if (t) if (this.scene.removeMesh(t), Array.isArray(t)) for (let r = 0; r < t.length; r++) e || (t[r].geometry.dispose(), delete t[r].geometry.properties.layer), t[r].dispose();
    else e || (t.geometry.dispose(), delete t.geometry.properties.layer), t.dispose();
  }
  updateDataConfig(t, e) {
    return !(this.dataConfig.type === "line-extrusion" && !t.altitudeProperty && !e.altitudeProperty);
  }
  createFnTypeConfig(t, e) {
    const r = ln(e.polygonFill || e.lineColor), n = he(e.polygonOpacity || e.lineOpacity), s = he(e.lineWidth), o = new Uint8Array(1), a = new Uint16Array(1), l = e.polygonFill ? "polygonFill" : e.lineColor ? "lineColor" : "polygonFill", h = e.polygonOpacity ? "polygonOpacity" : e.lineOpacity ? "lineOpacity" : "polygonOpacity";
    return [{
      attrName: "aColor",
      type: Uint8Array,
      width: 4,
      symbolName: l,
      define: "HAS_COLOR",
      evaluate: (u, c) => {
        let f = r(t.getZoom(), u);
        return Ft(f) && (f = this.evaluateInFnTypeConfig(f, c, t, u, !0)), Array.isArray(f) || (f = this.colorCache[f] = this.colorCache[f] || Zi(f).unitArray()), f = Yo(f), f;
      }
    }, {
      attrName: "aOpacity",
      type: Uint8Array,
      width: 1,
      symbolName: h,
      evaluate: (u, c) => {
        let f = n(t.getZoom(), u);
        return Ft(f) && (f = this.evaluateInFnTypeConfig(f, c, t, u, !1)), o[0] = 255 * f, o[0] < 255 && (c.properties.hasAlpha = !0), o[0];
      }
    }, {
      attrName: "aLineWidth",
      type: Uint8Array,
      width: 1,
      symbolName: "lineWidth",
      define: "HAS_LINE_WIDTH",
      evaluate: (u) => {
        const c = s(t.getZoom(), u);
        return a[0] = Math.round(2 * c), a[0];
      }
    }];
  }
  updateSymbol(t, e) {
    let r = !1;
    t && t.material && (r = function(s, o) {
      for (const a in o) if (zj[a] && o[a] !== s[a] && (!s[a] || !o[a])) return !0;
      return !1;
    }(this.symbolDef[0].material || {}, t.material));
    const n = super.updateSymbol(t, e);
    return t && t.material && this.si(t.material), r || n;
  }
  tr(t, e) {
    return vw(t) !== vw(e);
  }
}
function vw(i) {
  if (!i || !i.material) return !1;
  for (const t in i.material) if (t.indexOf("Texture") > 0 && i.material[t]) return !0;
  return !1;
}
const zj = {
  normalTexture: 1,
  bumpTexture: 1
};
class VP extends GP {
  createGeometry(t) {
    const e = t.data, r = this.getSymbols()[0];
    if (r.material && r.material.extrusionOpacity) {
      const s = new Uint8Array(e.aPosition.length / 3);
      for (let o = 0; o < e.aPosition.length; o += 3) e.aPosition[o + 2] > 0 ? s[o / 3] = 0 : s[o / 3] = 1;
      e.aExtrusionOpacity = s;
    }
    const n = new er(e, t.indices);
    return In(n.properties, t.properties), this.pr(n, t), {
      geometry: n,
      symbolIndex: {
        index: 0
      }
    };
  }
  updateSceneConfig(t) {
    let e;
    if (this.sceneConfig.cullFace !== t.cullFace && (e = !0), In(this.sceneConfig, t), e) {
      const r = this.getShaderConfig();
      this.shader.dispose(), this.shader = new ix(r);
    }
    this.setToRedraw();
  }
  getShader() {
    return this.shader;
  }
  delete(t) {
    this.getMap().off("updatelights", this.mo, this), super.delete(t), this.material.dispose();
  }
  init() {
    this.getMap().on("updatelights", this.mo, this);
    const t = this.regl;
    this.renderer = new hn(t);
    const e = this.getShaderConfig();
    this.shader = new ix(e), this.si();
    const r = {
      vert: this.getPickingVert(),
      uniforms: ["projViewMatrix", "modelMatrix", "positionMatrix", {
        name: "projViewModelMatrix",
        type: "function",
        fn: function(n, s) {
          return Jt([], s.projViewMatrix, s.modelMatrix);
        }
      }],
      extraCommandProps: {
        viewport: this.pickingViewport
      }
    };
    this.picking = [new Oi(this.renderer, r, this.layer.getRenderer().pickingFBO, this.getMap())];
  }
  mo() {
    this.setToRedraw();
  }
  getShaderConfig() {
    const t = this.canvas, e = {
      x: 0,
      y: 0,
      width: () => t ? t.width : 1,
      height: () => t ? t.height : 1
    };
    return {
      extraCommandProps: {
        cull: {
          enable: () => this.sceneConfig.cullFace === void 0 || !!this.sceneConfig.cullFace,
          face: () => {
            let r = this.sceneConfig.cullFace;
            return r === !0 && (r = "back"), r || "back";
          }
        },
        stencil: {
          enable: !0,
          func: {
            cmp: "<=",
            ref: (r, n) => n.level
          },
          op: {
            fail: "keep",
            zfail: "keep",
            zpass: "replace"
          }
        },
        depth: {
          enable: !0,
          range: this.sceneConfig.depthRange || [0, 1],
          func: this.sceneConfig.depthFunc || "<="
        },
        blend: {
          enable: !0,
          func: this.getBlendFunc(),
          equation: "add"
        },
        viewport: e,
        polygonOffset: {
          enable: !0,
          offset: this.getPolygonOffset()
        }
      }
    };
  }
  si() {
    this.material && this.material.dispose();
    const t = this.layer instanceof Pn, e = this.getSymbols()[0].material, r = {};
    for (const n in e) xd(e, n) && (r[n] = e[n], n === "uvRotation" && (r[n] = r[n] * Math.PI / 180, t || (r[n] *= -1)));
    this.material = new ay(r);
  }
  getUniformValues(t, e) {
    const r = t.viewMatrix, n = t.projMatrix, s = t.cameraPosition, o = this.yo(), a = In({
      viewMatrix: r,
      projMatrix: n,
      cameraPosition: s,
      projViewMatrix: t.projViewMatrix
    }, o);
    e && e.jitter ? a.halton = e.jitter : a.halton = [0, 0];
    const l = this.layer.getRenderer().canvas;
    return a.outSize = [l.width, l.height], a;
  }
  getPickingVert() {
    return `
            attribute vec3 aPosition;
            uniform mat4 projViewModelMatrix;
            uniform mat4 modelMatrix;
            uniform mat4 positionMatrix;
            //引入fbo picking的vert相关函数
            #include <fbo_picking_vert>
            #include <get_output>
            void main()
            {
                mat4 localPositionMatrix = getPositionMatrix();
                vec4 localPosition = getPosition(aPosition);

                gl_Position = projViewModelMatrix * localPositionMatrix * localPosition;
                //传入gl_Position的depth值
                fbo_picking_setData(gl_Position.w, true);
            }
        `;
  }
  yo() {
    const t = this.getMap().getLightManager(), e = t && t.getAmbientLight() || {}, r = t && t.getDirectionalLight() || {};
    return {
      ambientColor: e.color || [0.2, 0.2, 0.2],
      light0_diffuse: [...r.color || [0.1, 0.1, 0.1], 1],
      lightSpecular: r.specular || [0.8, 0.8, 0.8],
      light0_viewDirection: r.direction || [1, 1, -1]
    };
  }
}
const ff = [1, 1, 1];
class Nj extends jy {
  createGeometry(t) {
    const { data: e, indices: r } = t, n = new er(e, r, 0, {
      primitive: "lines"
    });
    return n.generateBuffers(this.regl), {
      geometry: n,
      symbolIndex: {
        index: 0
      }
    };
  }
  createMesh(t, e) {
    const { geometry: r } = t, n = new tn(r);
    if (n.castShadow = !1, this.sceneConfig.animation) {
      ff[2] = 0.01;
      const s = [];
      $o(s, ff), Jt(s, e, s), e = s;
    }
    return n.setLocalTransform(e), n.properties.symbolIndex = {
      index: 0
    }, n;
  }
  addMesh(t, e) {
    if (!t.length) return this;
    let r;
    e !== null ? (e === 0 && (e = 0.01), r = t[0].localTransform, ff[2] = e, $o(r, ff), Jt(r, t[0].properties.tileTransform, r)) : r = t[0].properties.tileTransform;
    for (let n = 0; n < t.length; n++) t[n].setLocalTransform(r);
    return this.scene.addMesh(t), this;
  }
  init() {
    const t = this.regl;
    this.scene = new ur(), this.renderer = new hn(t);
    const e = {
      x: 0,
      y: 0,
      width: () => this.canvas ? this.canvas.width : 1,
      height: () => this.canvas ? this.canvas.height : 1
    }, r = {
      vert: `
    attribute vec3 aPosition;
    attribute vec4 aColor;

    uniform mat4 projViewModelMatrix;
    uniform vec2 outSize;

    varying vec4 vColor;

    void main()
    {
        gl_Position = projViewModelMatrix * vec4(aPosition, 1.0);
        vColor = aColor / 255.0;
    }
`,
      frag: `
    #ifdef GL_ES
        precision lowp float;
    #endif

    uniform float opacity;

    varying vec4 vColor;

    void main()
    {
        gl_FragColor = vColor * opacity;
    }
`,
      uniforms: [{
        name: "projViewModelMatrix",
        type: "function",
        fn: function(n, s) {
          const o = [];
          return Jt(o, s.projViewMatrix, s.modelMatrix), o;
        }
      }],
      extraCommandProps: {
        stencil: {
          enable: !0,
          func: {
            cmp: "<=",
            ref: (n, s) => s.level
          },
          op: {
            fail: "keep",
            zfail: "keep",
            zpass: "replace"
          }
        },
        blend: {
          enable: !0,
          func: this.getBlendFunc(),
          equation: "add"
        },
        viewport: e
      }
    };
    this.shader = new qe(r);
  }
  getUniformValues(t) {
    const e = this.sceneConfig.opacity || 0.3, r = this.layer.getRenderer().canvas;
    return {
      projViewMatrix: t.projViewMatrix,
      outSize: [r.width, r.height],
      opacity: e
    };
  }
}
const { getPBRUniforms: Hj } = Kn.PBRUtils;
class Uy extends GP {
  constructor(...t) {
    super(...t), this.vo = new Hd(null, this.layer.getURLModifier()), this.scene.sortFunction = this.sortByCommandKey;
  }
  supportRenderMode(t) {
    return this.getSymbols()[0].ssr ? t === "fxaa" || t === "fxaaAfterTaa" : super.supportRenderMode(t);
  }
  isAnimating() {
    const t = this.xo();
    if (t && (t[0] || t[1])) return !0;
  }
  needToRedraw() {
    const t = this.xo();
    return !(!t || !t[0] && !t[1]) || super.needToRedraw();
  }
  xo() {
    const t = this.getSymbols()[0];
    return t.material && t.material.uvOffsetAnim;
  }
  createGeometry(t) {
    if (!t.data || !t.data.aPosition || !t.data.aPosition.length) return null;
    const e = {
      uv0Attribute: "aTexCoord0"
    };
    t.aAltitude && (e.altitudeAttribute = "aAltitude");
    const r = new er(t.data, t.indices, 0, e);
    return In(r.properties, t.properties), t.vertexColors && (r.properties.vertexColors = t.vertexColors), this.material.uniforms.normalTexture && !r.data[r.desc.tangentAttribute] && r.data[r.desc.uv0Attribute] && (r.data[r.desc.normalAttribute] || r.createNormal(), r.createTangent()), this.pr(r, t), {
      geometry: r,
      symbolIndex: {
        index: 0
      }
    };
  }
  paint(t) {
    const e = !!t.shadow;
    t.states && t.states.includesChanged && (this.shader.dispose(), delete this.shader, this.bo.dispose(), delete this.bo, this.Ar(t));
    let r = !!t.ssr && this.getSymbols()[0].ssr;
    const n = this.shader, s = n.shaderDefines;
    if (r) {
      const o = In({}, s, t.ssr.defines);
      n.shaderDefines = o;
    }
    if (t.onlyUpdateDepthInTaa && (this.shader = this.bo, !r && this.Ao && (this.shader = n, this.setToRedraw(!0))), this.updateIBLDefines(n), super.paint(t), this.shadowCount !== void 0 && e) {
      const o = this.scene.getMeshes().length;
      this.shadowCount !== o && this.setToRedraw();
    }
    this.shader = n, r && (n.shaderDefines = s), delete this.shadowCount, this.Ao = r;
  }
  updateSceneConfig(t) {
    In(this.sceneConfig, t), this.setToRedraw();
  }
  delete() {
    super.delete(), this.disposeIBLTextures(), this.material.dispose(), this.bo && (this.bo.dispose(), delete this.bo);
  }
  init(t) {
    this.getMap().on("updatelights", this.wo, this), this.createIBLTextures(), this.Mr = this.Mr || t;
    const e = this.regl;
    this.renderer = new hn(e), this._o = this.So.bind(this), this.Mo = this.disposeCachedTexture.bind(this), this.Po = this.To.bind(this), this.si(), this.Ar(t);
    const r = {
      vert: `
                #include <gl2_vert>
                attribute vec3 aPosition;
                uniform mat4 projViewModelMatrix;
                uniform mat4 positionMatrix;
                //引入fbo picking的vert相关函数
                #include <line_extrusion_vert>
                #include <get_output>
                #include <fbo_picking_vert>
                void main() {
                    mat4 localPositionMatrix = getPositionMatrix();
                    #ifdef IS_LINE_EXTRUSION
                        vec3 linePosition = getLineExtrudePosition(aPosition);
                        vec4 localVertex = getPosition(linePosition);
                    #else
                        vec4 localVertex = getPosition(aPosition);
                    #endif

                    gl_Position = projViewModelMatrix * localPositionMatrix * localVertex;
                    fbo_picking_setData(gl_Position.w, true);
                }
            `,
      uniforms: [{
        name: "projViewModelMatrix",
        type: "function",
        fn: (n, s) => Jt([], s.projViewMatrix, s.modelMatrix)
      }],
      extraCommandProps: {
        viewport: this.pickingViewport,
        depth: {
          enable: !0,
          range: this.sceneConfig.depthRange || [0, 1],
          func: this.sceneConfig.depthFunc || "<=",
          mask: !!gn(this.sceneConfig.depthMask) || this.sceneConfig.depthMask
        }
      }
    };
    this.picking = [new Oi(this.renderer, r, this.layer.getRenderer().pickingFBO, this.getMap())];
  }
  Ar(t) {
    const e = {
      x: 0,
      y: 0,
      width: () => this.canvas ? this.canvas.width : 1,
      height: () => this.canvas ? this.canvas.height : 1
    }, r = {}, n = [];
    n.push(...Gd.getUniformDeclares()), this.fillIncludes(r, n, t);
    const s = {
      cull: {
        enable: () => this.sceneConfig.cullFace === void 0 || !!this.sceneConfig.cullFace,
        face: () => this.sceneConfig.cullFace || "back"
      },
      stencil: {
        enable: (a, l) => l.hasAlpha === void 0 || !!l.hasAlpha,
        func: {
          cmp: "<=",
          ref: (a, l) => l.stencilRef
        },
        op: {
          fail: "keep",
          zfail: "keep",
          zpass: "replace"
        }
      },
      viewport: e,
      depth: {
        enable: !0,
        range: this.sceneConfig.depthRange || [0, 1],
        func: this.sceneConfig.depthFunc || "<="
      },
      blend: {
        enable: (a, l) => l.hasAlpha === void 0 || !!l.hasAlpha,
        func: this.getBlendFunc(),
        equation: "add"
      },
      polygonOffset: {
        enable: !0,
        offset: this.getPolygonOffset()
      }
    }, o = {
      uniforms: n,
      defines: this.ko(r),
      extraCommandProps: s
    };
    this.shader = new Kn.StandardShader(o), o.frag = `
            precision mediump float;
            #include <gl2_frag>
            void main() {
                glFragColor = vec4(0.0);
                #if __VERSION__ == 100
                    gl_FragColor = glFragColor;
                #endif
            }
        `, this.bo = new Kn.StandardShader(o);
  }
  So({ resources: t }) {
    for (let e = 0; e < t.length; e++) this.addCachedTexture(t[e].url, t[e].data);
    this.setToRedraw(!0);
  }
  To() {
    this.setToRedraw(!0);
  }
  si(t) {
    if (t) {
      const a = this.getSymbols()[0].material;
      a && In(a, t);
    }
    const e = this.layer instanceof Pn, r = this.dataConfig, n = t || this.getSymbols()[0].material, s = {};
    let o = !1;
    for (const a in n) if (xd(n, a)) if (a.indexOf("Texture") > 0) {
      let l = n[a];
      if (!l) {
        s[a] = void 0;
        continue;
      }
      const h = typeof l == "string" ? l : l.url, u = this.getCachedTexture(h);
      u ? u.then ? h === l ? l = {
        promise: u,
        wrap: "repeat"
      } : l.promise = u : h === l ? l = {
        data: u,
        wrap: "repeat"
      } : l.data = u : h === l && (l = {
        url: h,
        wrap: "repeat"
      }), l.flipY = !r.upsideUpTexture, l.min = "linear mipmap linear", l.mag = "linear", s[a] = new Bd(l, this.vo), s[a].once("complete", this._o), s[a].once("disposed", this.Mo), s[a].promise && this.addCachedTexture(h, s[a].promise), o = !0;
    } else s[a] = n[a], a === "uvRotation" && (s[a] = Math.PI * s[a] / 180, e || (s[a] *= -1));
    if (s.alphaTest === void 0 && this.getMaterialClazz && (s.alphaTest = 0.05), this.material) {
      for (let a in s) this.material.set(a, s[a]);
      this.setToRedraw(!0);
    } else this.material = new Kn.StandardMaterial(s), this.material.once("complete", this.Po);
    o || this.To();
  }
  getShader() {
    return this.shader;
  }
  getUniformValues(t, e) {
    const { iblTexes: r, dfgLUT: n } = this.getIBLRes(), s = Hj(t, r, n, e && e.ssr, e && e.jitter);
    return this.setIncludeUniformValues(s, e), s;
  }
  ko(t) {
    return this.hasIBL() ? t.HAS_IBL_LIGHTING = 1 : delete t.HAS_IBL_LIGHTING, t;
  }
  wo() {
    if (!this.shader) return;
    const t = this.shader.shaderDefines;
    this.ko(t), this.shader.shaderDefines = t;
  }
}
var yw = `#include <gl2_vert>
#define EXTRUDE_SCALE 63.0
#define EXTRUDE_MOD 64.0
#define MAX_LINE_DISTANCE 65535.0
uniform mat4 projViewModelMatrix;
uniform vec2 centiMeterToLocal;
#ifdef HAS_ALTITUDE
attribute vec2 aPosition;
attribute float aAltitude;
#else
attribute vec3 aPosition;
#endif
attribute vec4 aTubeNormal;
#ifdef HAS_LINE_WIDTH
attribute float aLineWidth;
#else
uniform float lineWidth;
#endif
#include <vt_position_vert>
#ifdef PICKING_MODE
#include <fbo_picking_vert>
#else
uniform mat4 modelViewMatrix;
uniform mat3 modelNormalMatrix;
uniform mat4 modelMatrix;
#if defined(HAS_PATTERN)
uniform float resolution;
uniform float tileResolution;
uniform float tileRatio;
attribute float aLinesofar;
varying highp float vLinesofar;
attribute vec4 aTexInfo;
varying vec4 vTexInfo;
varying float vNormalY;
varying float vPatternHeight;
attribute float aNormalDistance;
#if defined(HAS_PATTERN_ANIM)
attribute float aLinePatternAnimSpeed;
varying float vLinePatternAnimSpeed;
#endif
#if defined(HAS_PATTERN_GAP)
attribute float aLinePatternGap;
varying float vLinePatternGap;
#endif
#endif
#ifdef HAS_COLOR
attribute vec4 aColor;
varying vec4 vColor;
#endif
#ifdef HAS_OPACITY
attribute float aOpacity;
#endif
varying float vOpacity;
varying vec3 vModelNormal;
varying vec4 vViewVertex;
varying vec3 vModelVertex;
#endif
#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
#include <vsm_shadow_vert>
#endif
#include <highlight_vert>
void main() {
  
#ifdef HAS_LINE_WIDTH
float c = aLineWidth;
#else
float c = lineWidth;
#endif
float d = c / 2.;
  vec3 e = aTubeNormal.xyz / EXTRUDE_SCALE;
  vec3 f = unpackVTPosition();
  vec4 h = vec4(f, 1.);
  h.xy += e.xy * d * centiMeterToLocal;
  h.z += e.z * d;
  gl_Position = projViewModelMatrix * h;
#ifdef PICKING_MODE
fbo_picking_setData(gl_Position.w, true);
#else
vViewVertex = modelViewMatrix * h;
  vec3 i = normalize(e);
  vModelNormal = modelNormalMatrix * i;
  vModelVertex = (modelMatrix * h).xyz;
#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)
shadow_computeShadowPars(h);
#endif
#ifdef HAS_COLOR
vColor = aColor / 255.;
#endif
#ifdef HAS_OPACITY
vOpacity = aOpacity / 255.;
#else
vOpacity = 1.;
#endif
#ifdef HAS_PATTERN
float j = tileResolution / resolution;
  float k = aLinesofar - d * centiMeterToLocal.y * aNormalDistance / EXTRUDE_SCALE;
  vLinesofar = k / tileRatio * j;
  vTexInfo = vec4(aTexInfo.xy, aTexInfo.zw + 1.);
  vPatternHeight = c * centiMeterToLocal.x / tileRatio * j;
  vNormalY = aTubeNormal.w / EXTRUDE_SCALE;
#if defined(HAS_PATTERN_ANIM)
vLinePatternAnimSpeed = aLinePatternAnimSpeed / 127.;
#endif
#if defined(HAS_PATTERN_GAP)
vLinePatternGap = aLinePatternGap / 10.0;
#endif
#endif
highlight_setVarying();
#endif
}`;
const { getPBRUniforms: Bj } = Kn.PBRUtils;
class UP extends vo {
  needToRedraw() {
    return super.needToRedraw() || this.isAnimating();
  }
  isTerrainSkin() {
    return !1;
  }
  isTerrainVector() {
    return !0;
  }
  supportRenderMode(t) {
    return this.isAnimating() ? t === "fxaa" || t === "fxaaAfterTaa" : t === "taa" || t === "fxaa";
  }
  isAnimating() {
    if (this.wr) return !0;
    const t = this.getSymbols();
    for (let e = 0; e < t.length; e++) if (t[e].linePatternFile && t[e].linePatternAnimSpeed) return !0;
    return !1;
  }
  isBloom(t) {
    return !!this.getSymbol(t.properties.symbolIndex).lineBloom;
  }
  createMesh(t, e) {
    if (!t.geometry) return null;
    const r = this.getMap(), { geometry: n, symbolIndex: s, ref: o } = t, a = this.getSymbolDef(s);
    o === void 0 && Ns(n, a, this.getFnTypeConfig(s));
    const l = this.getSymbol(s), { tileResolution: h, tileRatio: u } = n.properties, c = {
      tileResolution: h,
      tileRatio: u
    };
    ue(c, "lineColor", l, "lineColor", "#fff", fi(this.colorCache)), ue(c, "linePatternGapColor", l, "linePatternGapColor", [1, 1, 1, 1], fi(this.colorCache)), ue(c, "lineWidth", l, "lineWidth", 2, (y) => Ol.getTubeSizeScale(this.dataConfig.metric) * y), ue(c, "lineOpacity", l, "lineOpacity", 1), ue(c, "linePatternAnimSpeed", l, "linePatternAnimSpeed", 0), ue(c, "linePatternGap", l, "linePatternGap", 0), ue(c, "metallicFactor", l, "metallicFactor", 0), ue(c, "roughnessFactor", l, "roughnessFactor", 0.4), ue(c, "emissiveFactor", l, "emissiveFactor", [0, 0, 0]), ue(c, "uvScale", l, "uvScale", [1, 1]);
    const f = n.properties.iconAtlas, d = this.layer instanceof Pn;
    f && (c.linePatternFile = Vu(this.regl, f, !1), c.atlasSize = f ? [f.width, f.height] : [0, 0], c.flipY = d ? -1 : 1, this.drawDebugAtlas(f)), o === void 0 && n.generateBuffers(this.regl), c.alphaTest = -1;
    const p = new Kn.StandardMaterial(c), g = new tn(n, p, {
      castShadow: !1,
      picking: !0
    }), m = r.distanceToPointAtRes(100, 100, n.properties.tileResolution)._multi(u / 1e4).toArray();
    g.setUniform("centiMeterToLocal", m);
    const v = r.getResolution(r.getMaxNativeZoom());
    g.setUniform("animSpeedScale", h / v), g.setLocalTransform(e);
    const _ = {
      IS_LINE_EXTRUSION: 1,
      HAS_LAYER_OPACITY: 1
    };
    return this.dataConfig.type === "square-tube" && (_.IS_SQUARE_TUBE = 1), f && (_.HAS_PATTERN = 1), g.properties.symbolIndex = s, n.data.aColor && (_.HAS_COLOR = 1), this.setMeshDefines(_, n, a), n.data.aAltitude && (_.HAS_ALTITUDE = 1), g.setDefines(_), g;
  }
  setMeshDefines(t, e, r) {
    e.data.aOpacity && (t.HAS_OPACITY = 1), e.data.aLineWidth && (t.HAS_LINE_WIDTH = 1), rs(r.linePatternAnimSpeed) && (t.HAS_PATTERN_ANIM = 1), rs(r.linePatternGap) && (t.HAS_PATTERN_GAP = 1);
  }
  paint(t) {
    t.states && t.states.includesChanged.shadow && (this.shader.dispose(), this.createShader(t)), super.paint(t);
  }
  init(t) {
    this.getMap().on("updatelights", this.wo, this), this.createIBLTextures();
    const e = this.regl;
    if (this.renderer = new hn(e), this.createShader(t), this.pickingFBO) {
      const r = [];
      this.picking = [new Oi(this.renderer, {
        vert: `#define PICKING_MODE 1
` + yw,
        uniforms: [{
          name: "projViewModelMatrix",
          type: "function",
          fn: function(n, s) {
            const o = [];
            return Jt(o, s.projViewMatrix, s.modelMatrix), o;
          }
        }, {
          name: "modelNormalMatrix",
          type: "function",
          fn: (n, s) => au(r, s.modelMatrix)
        }],
        extraCommandProps: this.getExtraCommandProps()
      }, this.pickingFBO, this.getMap())];
    }
  }
  createShader(t) {
    this.Mr = t;
    const e = [], r = {};
    this.fillIncludes(r, e, t), e.push({
      name: "projViewModelMatrix",
      type: "function",
      fn: function(n, s) {
        const o = [];
        return Jt(o, s.projViewMatrix, s.modelMatrix), o;
      }
    }), this.shader = new Kn.StandardShader({
      vert: yw,
      uniforms: e,
      defines: this.ko(r),
      extraCommandProps: this.getExtraCommandProps()
    });
  }
  getExtraCommandProps() {
    const t = this.canvas, e = {
      x: 0,
      y: 0,
      width: () => t ? t.width : 1,
      height: () => t ? t.height : 1
    }, r = this.sceneConfig.depthRange;
    return {
      viewport: e,
      stencil: {
        enable: !0,
        func: {
          cmp: () => "<=",
          ref: (n, s) => s.level
        },
        op: {
          fail: "keep",
          zfail: "keep",
          zpass: "replace"
        }
      },
      cull: {
        enable: () => !!this.sceneConfig.cullFace,
        face: this.sceneConfig.cullFace || "back"
      },
      depth: {
        enable: !0,
        range: r || [0, 1],
        mask: this.sceneConfig.depthMask || !0,
        func: this.sceneConfig.depthFunc || "<="
      },
      blend: {
        enable: !0,
        func: this.getBlendFunc(),
        equation: "add"
      },
      polygonOffset: {
        enable: !0,
        offset: this.getPolygonOffset()
      }
    };
  }
  getUniformValues(t, e) {
    const { iblTexes: r, dfgLUT: n } = this.getIBLRes(), s = Bj(t, r, n, null, e && e.jitter), o = t.projViewMatrix, a = t.viewMatrix;
    return s.projViewMatrix = o, s.viewMatrix = a, s.resolution = t.getResolution(), s.currentTime = this.layer.getRenderer().getFrameTimestamp() || 0, this.setIncludeUniformValues(s, e), s;
  }
  createFnTypeConfig(t, e) {
    const r = ln(e.lineColor), n = ln(e.aLinePatternAnimSpeed), s = ln(e.aLinePatternGap), o = this.createShapeFnTypeConfigs(t, e), a = new Int8Array(2);
    return [{
      attrName: "aColor",
      symbolName: "lineColor",
      type: Uint8Array,
      width: 4,
      define: "HAS_COLOR",
      evaluate: (l, h) => {
        let u = r(t.getZoom(), l);
        return Ft(u) && (u = this.evaluateInFnTypeConfig(u, h, t, l, !0)), Array.isArray(u) || (u = this.colorCache[u] = this.colorCache[u] || Zi(u).unitArray()), u = Yo(u), u;
      }
    }, {
      attrName: "aLinePattern",
      symbolName: "linePatternAnimSpeed",
      type: Int8Array,
      width: 2,
      related: ["linePatternGap"],
      define: "HAS_LINE_PATTERN",
      evaluate: (l, h, u, c) => {
        let f = n(t.getZoom(), l);
        return gn(f) && (f = 0), f !== 0 && (h.properties.hasPatternAnim = 1), a[0] = f / 127, a[1] = u[c + 1], a;
      }
    }, {
      attrName: "aLinePattern",
      symbolName: "linePatternGap",
      type: Int8Array,
      width: 2,
      related: ["linePatternAnimSpeed"],
      define: "HAS_LINE_PATTERN",
      evaluate: (l, h, u, c) => {
        let f = s(t.getZoom(), l);
        return gn(f) && (f = 0), a[1] = 10 * f, a[0] = u[c], a;
      }
    }].concat(o);
  }
  createShapeFnTypeConfigs(t, e) {
    const r = he(e.lineWidth), n = he(e.lineOpacity), s = new Uint16Array(1);
    return [{
      attrName: "aLineWidth",
      symbolName: "lineWidth",
      type: Uint8Array,
      width: 1,
      define: "HAS_LINE_WIDTH",
      evaluate: (o, a) => {
        let l = r(t.getZoom(), o);
        return Ft(l) && (l = this.evaluateInFnTypeConfig(l, a, t, o)), s[0] = Math.round(2 * l), s[0];
      }
    }, {
      attrName: "aOpacity",
      symbolName: "lineOpacity",
      type: Uint8Array,
      width: 1,
      define: "HAS_OPACITY",
      evaluate: (o, a) => {
        let l = n(t.getZoom(), o);
        return Ft(l) && (l = this.evaluateInFnTypeConfig(l, a, t, o)), s[0] = 255 * l, s[0];
      }
    }];
  }
  ko(t) {
    return this.hasIBL() ? t.HAS_IBL_LIGHTING = 1 : delete t.HAS_IBL_LIGHTING, t;
  }
  wo() {
    if (!this.shader) return;
    const t = this.shader.shaderDefines;
    this.ko(t), this.shader.shaderDefines = t;
  }
  delete() {
    super.delete(), this.disposeIBLTextures(), this.shader && (this.shader.dispose(), delete this.shader);
  }
}
const df = [], jj = [], Gj = [], Vj = [], Uj = [], $j = [0, 0, 0], Wj = [0, 0, 0], Zj = [1, 1, 1], _w = [], Xj = [1, 1, 1, 1], Js = [], xw = [1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1], $P = (i) => class extends i {
  constructor(t, e, r, n, s, o) {
    super(t, e, r, n, s, o), this.Oo = !1, this.scene.sortFunction = this.sortByCommandKey;
    const a = n.fetchOptions || {};
    a.referrer = window && window.location.href, this.Io = new BD(t, {
      fetchOptions: a,
      urlModifier: (l) => {
        const h = e.getURLModifier();
        return h && h(l) || l;
      }
    }), this.Fo(), this.Co();
  }
  isAnimating() {
    const t = this.getSymbols();
    for (let e = 0; e < t.length; e++)
      if (t[e] && this.Eo[e] && this.Do(e)) return !0;
    return !1;
  }
  createGeometry(t, e) {
    const { data: r, positionSize: n } = t;
    return {
      geometry: {
        properties: In({}, t.properties),
        data: r,
        positionSize: n,
        features: e
      },
      symbolIndex: t.symbolIndex
    };
  }
  getFnTypeConfig() {
    return _w;
  }
  createMesh(t, e, { tileTranslationMatrix: r, tileExtent: n }, { timestamp: s }) {
    if (!this.Oo) return null;
    const o = this.getMap(), { geometry: a } = t, { positionSize: l, features: h } = a, { aPosition: u, aPickingId: c, aXYRotation: f, aZRotation: d, aAltitude: p } = a.data, g = u.length / l;
    if (g === 0) return null;
    const m = {
      instance_vectorA: new Float32Array(4 * g),
      instance_vectorB: new Float32Array(4 * g),
      instance_vectorC: new Float32Array(4 * g),
      aPickingId: []
    }, v = this.No(m, r, n, a.properties.z, u, p, f, d, l, c, h);
    a.data.aTerrainAltitude && (m.aTerrainAltitude = a.data.aTerrainAltitude);
    const _ = {};
    for (const A in m) _[A] = {
      buffer: this.regl.buffer({
        dimension: m[A].length / g,
        data: m[A]
      }),
      divisor: 1
    };
    const y = this.Lo(), x = this.Ro(), w = pn([]);
    os(w, w, [x, x, x]);
    const b = [], T = this.getSymbols();
    for (let A = 0; A < T.length; A++) {
      const M = T[A], S = this.Ho[A];
      if (!S) continue;
      const P = this.Eo[A][0], { fixSizeOnZoom: C } = M;
      let k = pn([]);
      y || (k = this.zo(k));
      let O = 0;
      S.forEach((D) => {
        const { geometry: z, nodeMatrix: H } = D;
        Jt(Js, xw, H), Jt(Js, k, Js);
        const G = Jt(Js, w, Js), $ = z.boundingBox.copy();
        $.transform(G);
        const K = this.Vo($, M);
        Math.abs(K) > Math.abs(O) && (O = K);
      });
      const R = [0, 0, O], I = S.map((D, z) => {
        const { geometry: H, materialInfo: G, morphWeights: $, extraInfo: K, nodeIndex: dt } = D;
        M.alphaTest && (G.alphaTest = M.alphaTest);
        const it = new (this.getMaterialClazz(G))(G), st = {}, pt = new _M(_, g, H, it, {
          transparent: !1,
          picking: !0
        });
        if (P.hasSkinAnimation()) {
          const Wt = this.Uo(pt, A, 0)[dt];
          pt.setUniform("jointTexture", Wt.jointTexture), pt.setUniform("jointTextureSize", Wt.jointTextureSize), pt.setUniform("numJoints", Wt.numJoints), pt.setUniform("skinAnimation", +this.Do(A)), pt.properties.startTime = s, st.HAS_SKIN = 1;
        }
        $ && (pt.setUniform("morphWeights", $), st.HAS_MORPH = 1), pt.setUniform("hasAlpha", K.alphaMode && K.alphaMode.toUpperCase() === "BLEND"), ue(pt.uniforms, "polygonFill", M, "markerFill", Xj, fi(this.colorCache)), ue(pt.uniforms, "polygonOpacity", M, "markerOpacity", 1);
        const Ht = [];
        pt.setPositionMatrix(() => {
          const Wt = this.jo(A, z, dt);
          Jt(Ht, xw, Wt), this.zo(k), Jt(Ht, k, Ht), Jt(Ht, w, Ht);
          const re = pn(Js);
          if (O !== 0 && (Bh(re, R), Jt(Ht, re, Ht)), zy(C)) {
            const ie = o.getGLScale() / o.getGLScale(C);
            return ne(df, ie, ie, ie), $o(re, df), Jt(re, re, Ht);
          }
          return Ht;
        });
        const Rt = this.layer.getRenderer().getZScale(), Tt = [], $t = [];
        return pt.setLocalTransform(() => {
          const Wt = this.layer.options.altitude || 0;
          return Jn($t, v), $t[2] += 100 * Wt * Rt, ss(Tt, r, $t), Tt;
        }), H.generateBuffers(this.regl, {
          excludeElementsInVAO: !0
        }), m.instance_color && (st.HAS_INSTANCE_COLOR = 1), m.aTerrainAltitude && (st.HAS_INSTANCE_TERRAIN_ALTITUDE = 1, pt.setUniform("terrainAltitudeScale", 100 * this.layer.getRenderer().getZScale())), st.HAS_LAYER_OPACITY = 1, In(pt.properties, a.properties), pt.setDefines(st), pt.properties.symbolIndex = {
          index: A
        }, pt;
      });
      b.push(...I);
    }
    return b.insContext = {
      instanceData: m,
      tileTranslationMatrix: r,
      tileExtent: n,
      aPosition: u,
      positionSize: l
    }, b;
  }
  jo(t, e, r) {
    const n = t, s = this.Ho[n][e];
    return this.Do(t) && this.Bo && this.Bo[r] || s.nodeMatrix;
  }
  Uo(t, e, r) {
    if (!this.Eo) return;
    const n = this.Eo[e][0];
    this.Go || (this.Go = {}), this.Bo = {}, this.Go[t.uuid] || (this.Go[t.uuid] = {});
    const s = this.getSymbols()[e], o = this.Wo[e], { loop: a, speed: l, animationName: h } = s, u = h || o.animations[0].name;
    return n.updateAnimation(r, a || !1, l || 1, u, t.properties.startTime || 0, this.Bo, this.Go[t.uuid]), this.Go[t.uuid];
  }
  Vo(t, e) {
    const r = e.anchorZ || "center";
    let n = 0;
    const s = t.max[2] - t.min[2];
    return r === "bottom" ? n = s / 2 : r === "top" && (n = -s / 2), n;
  }
  addMesh(t, e, r) {
    if (!t || t[0].properties.level > 2) return null;
    const n = r.timestamp;
    for (let s = 0; s < t.length; s++) {
      if (!t[s] || !t[s].geometry) continue;
      t[s].instancedData.aTerrainAltitude && this.Bi(t[s], t[s].instancedData, t[s].properties, 3, r);
      const o = t[s].properties.symbolIndex.index, a = this.Do(o);
      a && this.Uo(t[s], o, n), t[s].setUniform("skinAnimation", +a);
    }
    return this.scene.addMesh(t), this;
  }
  yr(t, e) {
    t && t.updateInstancedData && t.updateInstancedData("aTerrainAltitude", e);
  }
  prepareRender(t) {
    const e = this.getSymbols();
    let r = !1;
    for (let n = 0; n < e.length; n++)
      if (!(!e[n] || !this.Eo[n]) && this.Do(n) && this.Eo[n] && !r) {
        r = !0;
        break;
      }
    r && this.setToRedraw(!0), super.prepareRender(t);
  }
  getShadowMeshes() {
    return this.isVisible() ? (this.shadowCount = this.scene.getMeshes().length, this.scene.getMeshes().filter((t) => t.properties.level === 0)) : _w;
  }
  Do(t) {
    const e = this.getSymbols()[t];
    return !!(e && e.animation && this.Eo[t] && this.Eo[t][0] && this.Eo[t][0].hasSkinAnimation());
  }
  No(t, e, r, n, s, o, a, l, h, u, c) {
    function f(R, I, D, z) {
      t[R][4 * I] = D[z], t[R][4 * I + 1] = D[z + 4], t[R][4 * I + 2] = D[z + 8], t[R][4 * I + 3] = D[z + 12];
    }
    const d = s.length / h, p = this.layer.getTileSize().width / r * this.layer.getRenderer().getTileGLScale(n), g = this.layer.getRenderer().getZScale(), m = 100 * (this.dataConfig.altitudeOffset || 0);
    let v = 1 / 0, _ = 1 / 0, y = 1 / 0, x = -1 / 0, w = -1 / 0, b = -1 / 0;
    const T = [], A = [];
    for (let R = 0; R < d; R++) {
      o ? ne(A, s[R * h], s[R * h + 1], o[R]) : Er.unpackPosition(A, s[R * h], s[R * h + 1], s[R * h + 2]);
      const I = ne(T, A[0] * p, -A[1] * p, (A[2] + m) * g);
      I[0] < v && (v = I[0]), I[0] > x && (x = I[0]), I[1] < _ && (_ = I[1]), I[1] > w && (w = I[1]), I[2] < y && (y = I[2]), I[2] > b && (b = I[2]);
    }
    const M = (v + x) / 2, S = (_ + w) / 2, P = (y + b) / 2, C = [], k = this.Lo(), O = [0, 0, 1];
    for (let R = 0; R < d; R++) {
      o ? ne(A, s[R * h], s[R * h + 1], o[R]) : Er.unpackPosition(A, s[R * h], s[R * h + 1], s[R * h + 2]);
      const I = A[0], D = A[1], z = ne(T, I * p - M, -D * p - S, (A[2] + m) * g - P), H = a && a[R] || 0, G = l && l[R] || 0;
      if (H || G) {
        AR(C, G, O);
        const $ = ne(df, I, D, 0), K = mo($, hi($, $, O));
        TR(C, C, H, K);
        const dt = Bh(Js, z);
        Jt(C, dt, C);
      } else Bh(C, z);
      if (k) {
        const $ = this.zo(Js, c, u, R);
        Jt(C, C, $);
      }
      f("instance_vectorA", R, C, 0), f("instance_vectorB", R, C, 1), f("instance_vectorC", R, C, 2), t.aPickingId[R] = R;
    }
    return ne(T, M, S, P), T;
  }
  Ro() {
    if (!this.Xo) {
      const t = this.getMap();
      this.Xo = 100 * Rl(t.getGLRes(), t);
    }
    return this.Xo;
  }
  zo(t, e, r, n) {
    const s = this.getMap(), o = this.symbolDef[0], a = this.Ro();
    let l = o.translationX || 0, h = o.translationY || 0, u = o.translationZ || 0, c = o.rotationX || 0, f = o.rotationY || 0, d = o.rotationZ || 0, p = o.scaleX || 1, g = o.scaleY || 1, m = o.scaleZ || 1;
    const v = r && r[n], _ = e && e[v], y = s.getZoom(), x = _ && _.feature && _.feature.properties, w = this.Yo(y, x);
    this.$o && (l = this.$o(y, x)), this.qo && (h = this.qo(y, x)), this.Jo && (u = this.Jo(y, x));
    const b = ne(jj, l * a, h * a, u * a);
    this.Zo && (c = this.Zo(y, x)), this.Ko && (f = this.Ko(y, x)), this.Qo && (d = this.Qo(y, x));
    const T = ne(Gj, c, f, d);
    this.ta && (p = this.ta(y, x)), this.ea && (g = this.ea(y, x)), this.na && (m = this.na(y, x));
    const A = ne(Vj, p * w, g * w, m * w);
    return this.ia(t, b, T, A);
  }
  Yo(t, e) {
    const r = this.symbolDef[0];
    let n = this.ra ? this.ra(t, e) : r.modelHeight;
    if (Yn(n)) return 1;
    const s = this.sa[0];
    return n / Math.abs(s.max[1] - s.min[1]);
  }
  getShaderConfig() {
    const t = super.getShaderConfig();
    return t.positionAttribute = "POSITION", t.normalAttribute = "NORMAL", t;
  }
  init(t) {
    super.init(t), this.Co();
  }
  Fo() {
    const t = this.symbolDef[0];
    Ft(t.modelHeight) && (this.ra = he(t.modelHeight)), Ft(t.translationX) && (this.$o = he(t.translationX)), Ft(t.translationY) && (this.qo = he(t.translationY)), Ft(t.translationZ) && (this.Jo = he(t.translationZ)), Ft(t.rotationX) && (this.Zo = he(t.rotationX)), Ft(t.rotationY) && (this.Ko = he(t.rotationY)), Ft(t.rotationZ) && (this.Qo = he(t.rotationZ)), Ft(t.scaleX) && (this.ta = he(t.scaleX)), Ft(t.scaleY) && (this.ea = he(t.scaleY)), Ft(t.scaleZ) && (this.na = he(t.scaleZ));
  }
  Lo() {
    return !!(this.ra && !this.ra.isFeatureConstant || this.$o && !this.$o.isFeatureConstant || this.qo && !this.qo.isFeatureConstant || this.Jo && !this.Jo.isFeatureConstant || this.Zo && !this.Zo.isFeatureConstant || this.Ko && !this.Ko.isFeatureConstant || this.Qo && !this.Qo.isFeatureConstant || this.ta && !this.ta.isFeatureConstant || this.ea && !this.ea.isFeatureConstant || this.na && !this.na.isFeatureConstant);
  }
  Co() {
    if (this.Eo) return;
    this.Eo = [], this.Wo = [], this.sa = [], this.Ho = [];
    const t = this.getSymbols();
    this.oa = 0;
    for (let e = 0; e < t.length; e++) {
      const r = t[e].url || "pyramid";
      this.Io.loginGLTF(r);
      const n = this.Io.getGLTF(r);
      if (n.then) n.then((s) => {
        if (!s.gltfPack) return this.oa++, void (this.oa >= t.length && (this.Oo = !0, this.setToRedraw(!0)));
        const { gltfPack: o, json: a, bbox: l } = s;
        this.Eo[e] = [o], this.Ho[e] = o.getMeshesInfo(), this.Wo[e] = a, this.sa[e] = l, this.oa++, this.oa >= t.length && (this.Oo = !0), this.setToRedraw(!0);
      });
      else {
        const { gltfPack: s, json: o, bbox: a } = n;
        s && (this.Eo[e] = [s], this.Ho[e] = s.getMeshesInfo(), this.Wo[e] = o, this.sa[e] = a, this.oa++);
      }
    }
    this.oa >= t.length && (this.Oo = !0);
  }
  getPickingVert() {
    return `
    attribute vec3 aPosition;
    uniform mat4 projViewModelMatrix;
    uniform mat4 modelMatrix;
    uniform mat4 positionMatrix;
    //引入fbo picking的vert相关函数
    #include <fbo_picking_vert>
    #include <get_output>
    void main()
    {
        mat4 localPositionMatrix = getPositionMatrix();
        vec4 localPosition = getPosition(aPosition);

        gl_Position = projViewModelMatrix * localPositionMatrix * localPosition;
        //传入gl_Position的depth值
        fbo_picking_setData(gl_Position.w, true);
    }`;
  }
  deleteMesh(t) {
    if (t) {
      this.scene.removeMesh(t);
      for (let e = 0; e < t.length; e++) {
        const r = this.Go && this.Go[t[e].uuid];
        if (r) {
          for (const n in r) r[n].jointTexture && r[n].jointTexture.destroy();
          delete this.Go[t[e].uuid];
        }
        t[e].disposeInstanceData(), t[e].dispose();
      }
    }
  }
  delete() {
    super.delete();
    const t = this.getSymbols();
    for (let e = 0; e < t.length; e++) {
      const r = t[e].url || "pyramid";
      this.Io.logoutGLTF(r);
    }
    if (this.Go) {
      for (const e in this.Go) {
        const r = this.Go[e];
        for (const n in r) r[n].jointTexture && r[n].jointTexture.destroy();
      }
      delete this.Go;
    }
    delete this.Bo;
  }
  ia(t, e, r, n) {
    const s = ne(df, ...e || $j), o = r || Wj, a = n || Zj, l = Qo(Uj, o[0], o[1], o[2]);
    return Nl(t, l, s, a);
  }
};
class qj extends $P(VP) {
  getMaterialClazz(t) {
    return t.diffuseFactor ? zI : ay;
  }
}
class Yj extends $P(Uy) {
  getMaterialClazz(t) {
    return t.specularGlossinessTexture || t.diffuseTexture ? Kn.StandardSpecularGlossinessMaterial : Kn.StandardMaterial;
  }
}
const { getPBRUniforms: Jj } = Kn.PBRUtils, bw = {
  color: [2.0303, 2.028, 2.028],
  direction: [0, -0.2717, -1]
}, mh = {
  index: 0
}, Kj = [0, 0, 0], pf = [2, 2];
class WP extends vo {
  supportRenderMode(t) {
    return t === "fxaa" || t === "fxaaBeforeTaa";
  }
  needPolygonOffset() {
    return !0;
  }
  isTerrainSkin() {
    return !1;
  }
  isTerrainVector() {
    return !0;
  }
  needToRedraw() {
    return super.needToRedraw() ? !0 : this.getSymbol(mh).animation;
  }
  createMesh(t, e) {
    const { geometry: r } = t;
    r.generateBuffers(this.regl);
    const n = new tn(r, null, {
      castShadow: !1,
      picking: !0
    });
    return n.properties.symbolIndex = mh, n.setLocalTransform(e), n;
  }
  callShader(t, e) {
    super.callShader(t, e), this.transformWater();
    const r = this.aa(this.getMap(), e);
    this.Wi += this.renderer.render(this.la, r, this.ha, this.getRenderFBO(e));
  }
  addMesh(t, e) {
    this.Sr(t, e), super.addMesh(...arguments);
  }
  Sr(t) {
    const e = this.getSymbol(mh).ssr;
    for (let r = 0; r < t.length; r++) t[r].ssr = e ? 1 : 0;
  }
  paint(t) {
    t.states && t.states.includesChanged && (this.shader.dispose(), this.la.dispose(), this.Ar(t));
    const e = !!t.ssr && this.getSymbol(mh).ssr, r = this.la, n = r.shaderDefines;
    if (e) {
      const s = In({}, n, t.ssr.defines);
      r.shaderDefines = s;
    }
    this.updateIBLDefines(r), this.ua.ssr = e ? 1 : 0, super.paint(t), e && (r.shaderDefines = n);
  }
  init(t) {
    this.createIBLTextures();
    const e = this.regl;
    this.renderer = new hn(e), this.createGround(), this.Ar(t), this.pickingFBO && (this.picking = [new Oi(this.renderer, {
      vert: EP,
      uniforms: [{
        name: "projViewModelMatrix",
        type: "function",
        fn: function(r, n) {
          const s = [];
          return Jt(s, n.projViewMatrix, n.modelMatrix), s;
        }
      }],
      extraCommandProps: {
        viewport: this.pickingViewport
      }
    }, this.pickingFBO, this.getMap())]), this.ca();
  }
  ca() {
    const t = this.regl;
    this.fa || (this.fa = t.texture(2));
    const e = this.layer.getURLModifier(), r = this.getSymbol({
      index: 0
    }), n = r.texWaveNormal, s = this.getCachedTexture(n), o = this;
    if (s) this.da || (s.isLoading ? setTimeout(() => {
      this.shader && this.ca();
    }, 20) : this.da = this.pa(t, s));
    else {
      const h = new Image();
      h.isLoading = !0, h.onload = function() {
        delete this.isLoading, o.da = o.pa(t, this), o.setToRedraw();
      }, h.onerror = () => {
        console.error("invalid water wave normal texture:" + n);
      }, this.addCachedTexture(n, h), h.src = e && e(n) || n;
    }
    const a = r.texWavePerturbation, l = this.getCachedTexture(a);
    if (l) this.ma || (l.isLoading ? setTimeout(() => {
      this.ca(), this.shader;
    }, 20) : this.ma = this.pa(t, l));
    else {
      const h = new Image();
      h.isLoading = !0, h.onload = function() {
        delete this.isLoading, o.ma = o.pa(t, this), o.setToRedraw();
      }, h.onerror = () => {
        console.error("invalid water wave perturbation texture:" + a);
      }, this.addCachedTexture(a, h), h.src = e && e(a) || a;
    }
  }
  pa(t, e) {
    return this.fa ? t.texture({
      width: e.width,
      height: e.height,
      mag: "linear",
      min: "linear mipmap linear",
      wrapS: "repeat",
      wrapT: "repeat",
      flipY: !0,
      data: e
    }) : null;
  }
  Ar(t) {
    const e = this.canvas, r = [], n = [{
      name: "projViewModelMatrix",
      type: "function",
      fn: function(h, u) {
        const c = [];
        return Jt(c, u.projViewMatrix, u.modelMatrix), c;
      }
    }, {
      name: "modelViewNormalMatrix",
      type: "function",
      fn: (h, u) => {
        const c = Jt([], u.viewMatrix, u.modelMatrix), f = Is(c, c), d = XA(f, f);
        return au([], d);
      }
    }, {
      name: "modelViewMatrix",
      type: "function",
      fn: (h, u) => Jt([], u.viewMatrix, u.modelMatrix)
    }, {
      name: "uEnvironmentTransform",
      type: "function",
      fn: (h, u) => {
        const c = u.environmentOrientation || 0;
        return qv(r, Math.PI * c / 180);
      }
    }], s = {
      TIME_NOISE_TEXTURE_REPEAT: 0.3737
    };
    this.fillIncludes(s, n, t);
    const o = {
      x: 0,
      y: 0,
      width: () => e ? e.width : 1,
      height: () => e ? e.height : 1
    }, a = this.sceneConfig.depthRange;
    this.shader = new qe({
      vert: `
                attribute vec3 aPosition;

                uniform mat4 projViewModelMatrix;

                void main() {
                    gl_Position = projViewModelMatrix * vec4(aPosition, 1.);
                }
            `,
      frag: `
    #define SHADER_NAME WATER_STENCIL
    precision mediump float;
    void main() {
        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
    }
`,
      uniforms: [{
        name: "projViewModelMatrix",
        type: "function",
        fn: function(h, u) {
          const c = [];
          return Jt(c, u.projViewMatrix, u.modelMatrix), c;
        }
      }],
      extraCommandProps: {
        viewport: o,
        colorMask: [!1, !1, !1, !1],
        stencil: {
          enable: !0,
          mask: 255,
          func: {
            cmp: "<=",
            ref: 254,
            mask: 255
          },
          op: {
            fail: "keep",
            zfail: "keep",
            zpass: "replace"
          }
        },
        depth: {
          enable: !0,
          range: a || [0, 1],
          func: this.sceneConfig.depthFunc || "<="
        },
        polygonOffset: {
          enable: !0,
          offset: this.getPolygonOffset()
        }
      }
    });
    const l = {
      viewport: o,
      stencil: {
        enable: !0,
        mask: 255,
        func: {
          cmp: "==",
          ref: 254,
          mask: 255
        },
        op: {
          fail: "keep",
          zfail: "keep",
          zpass: "replace"
        }
      },
      depth: {
        enable: !1
      }
    };
    n.push(...Gd.getUniformDeclares()), this.la = new qe({
      vert: `#define SHADER_NAME WATER
uniform mat4 modelMatrix;
uniform mat4 projViewModelMatrix;
attribute vec3 aPosition;
attribute vec2 aTexCoord;
uniform vec2 uvOffset;
uniform vec2 noiseUvOffset;
uniform vec2 uvScale;
varying vec2 vUv;
varying vec2 vNoiseUv;
varying vec3 vPos;
varying mat3 vTbnMatrix;
#ifdef HAS_SSR
uniform mat4 modelViewMatrix;
varying vec4 vViewVertex;
#endif
#include <highlight_vert>
mat3 c(in vec3 d) {
  vec3 t = normalize(cross(d, vec3(.0, 1., .0)));
  vec3 e = normalize(cross(d, t));
  return mat3(t, e, d);
}
#if defined(HAS_SHADOWING)
#include <vsm_shadow_vert>
#endif
const vec3 f = vec3(0., 0., 1.);
void main(void) {
  vec4 h = vec4(aPosition, 1.);
  vec4 i = modelMatrix * h;
  vPos = i.xyz;
  vTbnMatrix = c(f);
  gl_Position = projViewModelMatrix * h;
  vUv = aTexCoord * uvScale + uvOffset;
  vNoiseUv = aTexCoord * uvScale * TIME_NOISE_TEXTURE_REPEAT + noiseUvOffset;
#ifdef HAS_SSR
vec4 j = modelViewMatrix * h;
  vViewVertex = j;
#endif
#if defined(HAS_SHADOWING)
shadow_computeShadowPars(h);
#endif
highlight_setVarying();
}`,
      frag: `#define SHADER_NAME WATER
precision highp float;
precision highp sampler2D;
#include <hsv_frag>
uniform vec3 hsv;
uniform float contrast;
uniform float layerOpacity;
#if defined(HAS_SHADOWING)
#include <vsm_shadow_frag>
#endif
#include <highlight_frag>
#if defined(HAS_IBL_LIGHTING)
uniform vec3 hdrHSV;
uniform samplerCube prefilterMap;
uniform sampler2D brdfLUT;
uniform float rgbmRange;
uniform mat3 uEnvironmentTransform;
uniform vec3 diffuseSPH[9];
vec3 c(const in vec3 d) {
  vec3 e = uEnvironmentTransform * d;
  float x = e.x;
  float y = e.y;
  float z = e.z;
  vec3 f = (diffuseSPH[0] + diffuseSPH[1] * x + diffuseSPH[2] * y + diffuseSPH[3] * z + diffuseSPH[4] * z * x + diffuseSPH[5] * y * z + diffuseSPH[6] * y * x + diffuseSPH[7] * (3. * z * z - 1.) + diffuseSPH[8] * (x * x - y * y));
  if(length(hdrHSV) > .0) {
    f = hsv_apply(f, hdrHSV);
  }
  return max(f, vec3(.0));
}
vec3 h(const in vec3 i, const in float j, const in float k, const in float l) {
  vec4 rgba = texture2D(brdfLUT, vec2(k, j));
  float b = (rgba[3] * 65280.0 + rgba[2] * 255.);
  float a = (rgba[1] * 65280.0 + rgba[0] * 255.);
  const float m = 1. / 65535.;
  return (i * a + b * l) * m;
}
#else
uniform vec3 ambientColor;
#endif
struct PBRShadingWater {
  float NdotL;
  float NdotV;
  float NdotH;
  float VdotH;
  float LdotH;
  float VdotN;
};
vec3 o(const in vec4 u, const in float v) {
  if(v <= .0)
    return u.rgb;
  return v * u.rgb * u.a;
}
#ifdef HAS_SSR
varying vec4 vViewVertex;
uniform mat3 modelViewNormalMatrix;
uniform sampler2D TextureDepth;
uniform highp vec2 outSize;
uniform float ssrFactor;
uniform float ssrQuality;
uniform sampler2D TextureReflected;
uniform highp mat4 projMatrix;
uniform mat4 invProjMatrix;
uniform vec4 outputFovInfo[2];
uniform mat4 reprojViewProjMatrix;
uniform vec2 cameraNearFar;
float A(const in vec4 B) {
  return B.r + B.g / 255.;
}
float C(const in vec2 D, const in float E) {
  vec3 F = vec3(.06711056, .00583715, 52.9829189);
  return fract(F.z * fract(dot(D.xy + E * vec2(47., 17.) * .695, F.xy))) * .5;
}
vec3 G(const in float H, const in float I, const in vec2 J) {
  float K = min(I - .01, H);
  float L = floor(K);
  float M = min(I, L + 1.);
  float N = pow(2., M);
  vec2 O = 2. * N / J;
  if(K - L > .5)
    N *= 2.;
  return vec3(O, N);
}
vec2 P(const in vec2 Q, const in vec3 R) {
  vec2 S = max(R.xy, min(1. - R.xy, Q));
  return vec2(2. * S.x, R.z - 1. - S.y) / R.z;
}
vec3 T(const in mat4 U, const in vec3 V) {
  vec4 W = U * vec4(V, 1.);
  return vec3(.5 + .5 * W.xy / W.w, W.w);
}
vec3 X(const in float Y, const in vec2 S) {
  return texture2D(TextureReflected, S).rgb;
}
float Z(float ba) {
  highp mat4 U = projMatrix;
  highp float z = ba * 2. - 1.;
  return -U[3].z / (z + U[2].z);
}
float bb(const vec2 S) {
  float ba = A(texture2D(TextureDepth, S));
  return ba;
}
vec3 bc(const in float E, const in vec3 bd, const in vec3 be, const in vec3 bf, const in vec3 bg, const in float bh) {
  vec2 bi;
  bi.x = C(gl_FragCoord.yx, E);
  bi.y = fract(bi.x * 52.9829189);
  bi.y = mix(bi.y, 1., .7);
  float bj = 2. * 3.14159 * bi.x;
  float bk = pow(max(bi.y, .000001), bh / (2. - bh));
  float bl = sqrt(1. - bk * bk);
  vec3 bm = vec3(bl * cos(bj), bl * sin(bj), bk);
  bm = bm.x * bd + bm.y * be + bm.z * bf;
  return normalize((2. * dot(bg, bm)) * bm - bg);
}
float bn(const in float E) {
  return (C(gl_FragCoord.xy, E) - .5);
}
vec3 bo(const in vec3 bp, const in float bq, const in vec3 br) {
  vec3 bs = T(projMatrix, vViewVertex.xyz + br * bq);
  bs.z = 1. / bs.z;
  bs -= bp;
  float bt = min(1., .99 * (1. - bp.x) / max(1e-5, bs.x));
  float bu = min(1., .99 * (1. - bp.y) / max(1e-5, bs.y));
  float bv = min(1., .99 * bp.x / max(1e-5, -bs.x));
  float bw = min(1., .99 * bp.y / max(1e-5, -bs.y));
  return bs * min(bt, bu) * min(bv, bw);
}
float bx(const in vec3 bp, const in vec3 bs, inout float by, inout float bz) {
  float bA = (bz + by) * .5;
  vec3 bB = bp + bs * bA;
  float z = bb(bB.xy);
  float ba = Z(z);
  float bC = -1. / bB.z;
  by = ba > bC ? by : bA;
  bz = ba > bC ? bA : bz;
  return bA;
}
vec4 bD(const in vec3 bp, const in float bq, in float bE, const in vec3 br, const in float j, const in float E) {
  const int bF = 20;
  float bG = 1. / float(bF);
  bE *= bG;
  vec3 bs = bo(bp, bq, br);
  float bH = bG;
  vec3 bI = vec3(.0, bH, 1.);
  vec3 bB;
  float z, ba, bC, bJ, bK, bL;
  bool bM;
  float bN = 1.;
  float bA;
  for(int bO = 0; bO < bF; bO++) {
    bB = bp + bs * bI.y;
    z = bb(bB.xy);
    ba = Z(z);
    bC = -1. / bB.z;
    bJ = bC - ba;
    bJ *= clamp(sign(abs(bJ) - bq * bG * bG), .0, 1.);
    bM = abs(bJ + bE) < bE;
    bK = clamp(bI.x / (bI.x - bJ), .0, 1.);
    bL = bM ? bI.y + bK * bG - bG : 1.;
    bI.z = min(bI.z, bL);
    bI.x = bJ;
    if(bM) {
      float by = bI.y - bG;
      float bz = bI.y;
      bA = bx(bp, bs, by, bz);
      bA = bx(bp, bs, by, bz);
      bA = bx(bp, bs, by, bz);
      bN = bA;
      break;
    }
    bI.y += bG;
  }
  return vec4(bp + bs * bN, 1. - bN);
}
vec3 bP(in vec4 bQ, const in float bR, const in vec3 bS, const in vec3 bT, const in float j) {
  vec4 bU = mix(outputFovInfo[0], outputFovInfo[1], bQ.x);
  bQ.xyz = vec3(mix(bU.xy, bU.zw, bQ.y), 1.) * -1. / bQ.z;
  bQ.xyz = (reprojViewProjMatrix * vec4(bQ.xyz, 1.)).xyw;
  bQ.xy /= bQ.z;
  float bV = clamp(6. - 6. * max(abs(bQ.x), abs(bQ.y)), .0, 1.);
  bQ.xy = .5 + .5 * bQ.xy;
  return vec3(bQ.xy, 1.);
}
vec3 ssr(const in vec3 bS, const in vec3 bT, const in float j, const in vec3 d, const in vec3 bg) {
  float bW = .0;
  vec4 f = vec4(.0);
  float bh = j * j;
  bh = bh * bh;
  vec3 bX = abs(d.z) < .999 ? vec3(.0, .0, 1.) : vec3(1., .0, .0);
  vec3 bd = normalize(cross(bX, d));
  vec3 be = cross(d, bd);
  float bR = ssrFactor * clamp(-4. * dot(bg, d) + 3.8, .0, 1.);
  bR *= clamp(4.7 - j * 5., .0, 1.);
  vec3 bp = T(projMatrix, vViewVertex.xyz);
  bp.z = 1. / bp.z;
  vec3 br = bc(bW, bd, be, d, bg, bh);
  float bq = mix(cameraNearFar.y + vViewVertex.z, -vViewVertex.z - cameraNearFar.x, br.z * .5 + .5);
  float bE = .5 * bq;
  vec4 bQ;
  if(dot(br, d) > .001 && bR > .0) {
    bQ = bD(bp, bq, bE, br, j, bW);
    if(bQ.w > .0)
      return bP(bQ, bR, bS, bT, j);
    
  }
  return vec3(.0);
}
#endif
const vec3 bY = vec3(0., 0., 1.);
uniform mat4 viewMatrix;
uniform sampler2D normalTexture;
uniform sampler2D heightTexture;
uniform vec4 waveParams;
uniform vec2 waterDir;
uniform vec4 waterBaseColor;
uniform vec3 lightDirection;
uniform vec3 lightColor;
uniform vec3 camPos;
uniform float timeElapsed;
varying vec2 vUv;
varying vec2 vNoiseUv;
varying vec3 vPos;
varying mat3 vTbnMatrix;
float bZ(vec3 e, float ca) {
  float cb = max(.015, ca);
  return max((e.x + e.y) * .3303545 / cb + .3303545, .0);
}
const vec2 cc = vec2(6. / 25., 5. / 24.);
vec2 cd(sampler2D ce, vec2 S) {
  return 2. * texture2D(ce, S).rg - 1.;
}
float cf(vec2 S) {
  return texture2D(heightTexture, S).b;
}
vec3 cg(sampler2D ce, vec2 S) {
  return 2. * texture2D(ce, S).rgb - 1.;
}
float ch(vec2 S, float ci) {
  return fract(ci);
}
float cj(vec2 S, float ci) {
  float ck = ch(S, ci);
  return 1. - abs(1. - 2. * ck);
}
vec3 cl(sampler2D cm, vec2 S, float ci, float cn) {
  float co = waveParams[2];
  float cp = waveParams[3];
  vec2 cq = cd(cm, S) * co;
  float ck = ch(S, ci + cn);
  float cr = cj(S, ci + cn);
  vec2 f = S;
  f -= cq * (ck + cp);
  f += cn;
  f += (ci - ck) * cc;
  return vec3(f, cr);
}
const float cs = 7.77;
vec3 ct(sampler2D cu, sampler2D cv, vec2 cw, vec2 cx, float ci) {
  float ca = waveParams[0];
  vec2 cy = ci * -cx;
  float cz = cf(vNoiseUv) * cs;
  vec3 cA = cl(cv, cw + cy, ci + cz, .0);
  vec3 cB = cl(cv, cw + cy, ci + cz, .5);
  vec3 cC = cg(cu, cA.xy) * cA.z;
  vec3 cD = cg(cu, cB.xy) * cB.z;
  vec3 cE = normalize(cC + cD);
  cE.xy *= ca;
  cE.z = sqrt(1. - dot(cE.xy, cE.xy));
  return cE;
}
vec4 cF(vec2 cw, float cG) {
  float cH = waveParams[1];
  vec3 d = ct(normalTexture, heightTexture, cw * cH, waterDir, cG);
  float cI = bZ(d, waveParams[0]);
  return vec4(d, cI);
}
const float cJ = 3.141592653589793;
const float cK = 1. / cJ;
const float cL = .3183098861837907;
const float cM = 1.570796326794897;
const float cN = .4;
float cO = 2.2;
vec3 cP(float cQ, vec3 cR, float l) {
  return cR + (l - cR) * pow(1. - cQ, 5.);
}
float cS(float cT, float j) {
  float cU = j * j;
  float cV = cT * cT;
  float cW = pow((cV * (cU - 1.) + 1.), cO) * cJ;
  return cU / cW;
}
float cX(float cY) {
  return .25 / (cY * cY);
}
vec3 cZ(const vec3 x) {
  return (x * (2.51 * x + .03)) / (x * (2.43 * x + .59) + .14);
}
const float da = 2.2;
const float db = .4545454545;
vec4 dc(vec4 u) {
  return vec4(pow(u.rgb, vec3(db)), u.w);
}
vec3 dd(vec3 u) {
  return pow(u, vec3(da));
}
const vec3 de = vec3(.02, 1., 5.);
const vec2 df = vec2(.02, .1);
const float j = .06;
const float dg = 1.7;
const vec3 dh = vec3(0, .6, .9);
const vec3 di = vec3(.72, .92, 1.);
const float dj = .65;
const float dk = 300000.0;
const float dl = 500000.0;
const float dm = .775;
const float dn = .8;
PBRShadingWater dp;
vec3 dq(in PBRShadingWater dr, float j, vec3 ds, float dt) {
  vec3 du = cP(dr.VdotH, ds, dt);
  float dv = cS(dr.NdotH, j);
  float dw = cX(dr.LdotH);
  float dx = mix(j + .045, j + .385, 1. - dr.VdotH);
  float dy = 1.2;
  float dz = cS(dr.NdotH, dx) * dy;
  return ((dv + dz) * dw) * du;
}
vec3 dA(float dg, float dB, vec3 dh, float dC) {
  return dg * (.075 * dh * pow(dB, 4.) + 50. * pow(dB, 23.)) * dC;
}
vec3 dD(in float bk, in vec3 dE, in vec3 dF) {
  float dG = pow((1. - bk), de[2]);
  return mix(dF, dE, dG);
}
vec3 dH(in vec3 e, in vec3 dI, in float dJ, in float j) {
  
#ifdef HAS_IBL_LIGHTING
vec3 dK = reflect(-dI, e);
  vec4 dL = textureCube(prefilterMap, uEnvironmentTransform * dK);
  float dM = clamp(1. + dot(dK, e), .0, 1.);
  dL *= dM * dM;
  vec3 i = o(dL, rgbmRange);
  vec3 dN = c(e);
  float l = clamp(50.0 * waterBaseColor.g, .0, 1.);
  vec3 dO = h(waterBaseColor.rgb, j, dot(e, dI), l);
  return i * dO + dN;
#else
vec3 dP = dd(di);
  vec3 dQ = dd(dh);
  vec3 di = dD(dJ, dP, dQ);
  return di;
#endif
}
vec3 dR(in vec3 e, in vec3 dI, in vec3 dS, vec3 u, in vec3 dT, in vec3 dU, in float dV, float dW, vec3 dX) {
  float dY = 0.;
  vec3 dZ = dd(u);
  vec3 bm = normalize(dS + dI);
  dp.NdotL = clamp(dot(e, dS), .0, 1.);
  dp.NdotV = clamp(dot(e, dI), .001, 1.);
  dp.VdotN = clamp(dot(dI, e), .001, 1.);
  dp.NdotH = clamp(dot(e, bm), .0, 1.);
  dp.VdotH = clamp(dot(dI, bm), .0, 1.);
  dp.LdotH = clamp(dot(dS, bm), .0, 1.);
  float dJ = max(dot(dU, dI), .0);
  vec3 di = dH(e, dI, dJ, j);
  float ea = max(dot(dU, dS), .0);
  float eb = .1 + ea * .9;
  di *= eb;
  float ec = clamp(dV, .8, 1.);
  vec3 ed = cP(dp.VdotN, vec3(de[0]), de[1]);
  vec3 ee = ed * di * ec;
  vec3 ef = dZ * mix(di, ea * dT * cK, 2. / 3.) * ec;
  vec3 i = vec3(.0);
  if(dJ > .0 && ea > .0) {
    vec3 eg = dq(dp, j, vec3(df[0]), df[1]);
    vec3 eh = dT * cK * dV;
    i = dp.NdotL * eh * eg;
  }
  vec3 cI = vec3(.0);
  if(dJ > .0) {
    cI = dA(dg, dW, dh, eb);
  }
  vec3 ei = vec3(.0);
#ifdef HAS_SSR
float ej = smoothstep(dl, dk, -dX.z);
  mat4 ek = viewMatrix;
  vec4 el = vec4(dX.xyz, 1.);
  vec3 em = normalize(el.xyz);
  vec4 en = ek * vec4(e, .0);
  vec3 eo = normalize(en.xyz);
  vec4 ep = ek * vec4(dU, .0);
  float eq = pow(max(dot(-em, ep.xyz), .0), cN);
  vec3 er = mix(ep.xyz, eo, eq);
  vec3 es = ssr(vec3(.0), vec3(1.), j, normalize(er), -normalize(vViewVertex.xyz));
  if(es.z > .0) {
    vec2 et = smoothstep(.3, .6, abs(vec2(.5) - es.xy));
    dY = dm * clamp(1. - 1.3 * et.y, .0, 1.) * ej;
    vec3 eu = X(.0, es.xy);
    ei = dd(eu) * dY * ed.y * dj;
  }
#endif
float ev = mix(dn, dn * .5, dY);
  return cZ((1. - dY) * ee + ei + ef * ev + i + cI);
}
void main() {
  vec3 dU = bY;
  vec4 ew = cF(vUv, timeElapsed);
  vec3 e = normalize(vTbnMatrix * ew.xyz);
  vec3 dI = -normalize(vPos - camPos);
  vec3 dS = normalize(-lightDirection);
#if defined(HAS_SHADOWING)
float dV = shadow_computeShadow();
#else
float dV = 1.;
#endif
vec4 ex = viewMatrix * vec4(vPos, 1.);
  vec4 ey = vec4(dR(e, dI, dS, waterBaseColor.rgb, lightColor, dU, dV, ew.w, ex.xyz), waterBaseColor.a);
  gl_FragColor = dc(ey);
  if(contrast != 1.) {
    gl_FragColor = contrastMatrix(contrast) * gl_FragColor;
  }
  if(length(hsv) > .0) {
    gl_FragColor = hsv_apply(gl_FragColor, hsv);
  }
  gl_FragColor = highlight_blendColor(gl_FragColor) * layerOpacity;
}`,
      defines: s,
      uniforms: n,
      extraCommandProps: l
    });
  }
  needClearStencil() {
    return !0;
  }
  getUniformValues(t) {
    return {
      projViewMatrix: t.projViewMatrix
    };
  }
  aa(t, e) {
    const { iblTexes: r, dfgLUT: n } = this.getIBLRes(), s = Jj(t, r, n, e && e.ssr, e && e.jitter), o = t.getLightManager();
    let a = o && o.getDirectionalLight() || {};
    const l = o && o.getAmbientLight() || {}, h = this.getSymbol(mh), u = this.ya = this.ya || [], c = this.ga = this.ga || [];
    Sr(c, 0.09, h.uvScale || 3, 0.03, -0.5), In(s, {
      ambientColor: l.color || [0.2, 0.2, 0.2],
      viewMatrix: t.viewMatrix,
      lightDirection: a.direction || bw.direction,
      lightColor: a.color || bw.color,
      camPos: t.cameraPosition,
      timeElapsed: h.animation ? (this.layer.getRenderer().getFrameTimestamp() || 0) / (1 / (h.waterSpeed || 1) * 1e4) : 0,
      normalTexture: this.da || this.fa,
      heightTexture: this.ma || this.fa,
      waveParams: c,
      waterDir: Qj(u, h.waterDirection || 0),
      waterBaseColor: h.waterBaseColor || [0.1451, 0.2588, 0.4863, 1],
      contrast: h.contrast || 1,
      hsv: h.hsv || Kj
    });
    const f = this.layer.getRenderer();
    return s.layerOpacity = f.ne(), this.setIncludeUniformValues(s, e), e && e.ssr && e.ssr.renderUniforms && In(s, e.ssr.renderUniforms), s;
  }
  delete() {
    super.delete(), this.fa && (this.fa.destroy(), delete this.fa), this.da && this.da.destroy(), this.ma && this.ma.destroy(), this.shader && (this.shader.dispose(), delete this.shader), this.la && this.la.dispose(), this.ua && (this.ua.geometry.dispose(), this.ua.material && this.ua.material.dispose(), this.ua.dispose(), delete this.ua), this.disposeIBLTextures();
  }
  createGround() {
    const t = new jd();
    t.data.aTexCoord = new Uint8Array([0, 1, 1, 1, 0, 0, 1, 0]), t.generateBuffers(this.renderer.regl), this.ua = new tn(t, null, {
      castShadow: !1
    }), this.ha = new ur([this.ua]);
  }
  transformWater() {
    const t = this.getMap(), e = $d.getGroundTransform(this.ua.localTransform, t);
    this.ua.setLocalTransform(e);
    const r = t._get2DExtentAtRes(t.getGLRes()), n = r.getWidth(), s = r.getHeight(), o = t.cameraLookAt, a = o[0] - n, l = o[1] + s, h = a / pf[0], u = l / pf[1], c = h % 1, f = u % 1, d = 0.3737 * h % 1, p = 0.3737 * u % 1, g = n / pf[0] * 2, m = s / pf[1] * 2;
    this.ua.setUniform("uvOffset", [c, f]), this.ua.setUniform("noiseUvOffset", [d, p]), this.ua.setUniform("uvScale", [g, -m]);
  }
}
function Qj(i, t) {
  var e;
  return e = t, t = Math.PI * e / 180, i[0] = Math.sin(t), i[1] = Math.cos(t), i;
}
const tG = Hr("fill", ap);
tG.registerAt(on);
const eG = Hr("line", Uu);
eG.registerAt(on);
const nG = Hr("line-gradient", kP);
nG.registerAt(on);
const rG = Hr("icon", jP);
rG.registerAt(on);
const iG = Hr("text", Vy);
iG.registerAt(on);
const sG = Hr("native-line", Rj);
sG.registerAt(on);
Hr("native-point", Oj).registerAt(on);
const oG = Hr("phong", VP);
oG.registerAt(on);
const aG = Hr("wireframe", Nj);
aG.registerAt(on);
const lG = Hr("lit", Uy);
lG.registerAt(on);
const hG = Hr("tube", UP);
hG.registerAt(on);
const uG = Hr("gltf-phong", qj);
uG.registerAt(on);
const cG = Hr("gltf-lit", Yj);
cG.registerAt(on);
const fG = Hr("heatmap", class extends vo {
  createFnTypeConfig(i, t) {
    const e = he(t.heatmapWeight), r = new Int16Array(1);
    return [{
      attrName: "aWeight",
      symbolName: "heatmapWeight",
      type: Int16Array,
      width: 1,
      define: "HAS_HEAT_WEIGHT",
      evaluate: (n) => {
        const s = e(i.getZoom(), n);
        return r[0] = 255 * s, r[0];
      }
    }];
  }
  createMesh(i, t) {
    const { geometry: e, symbolIndex: r, ref: n } = i;
    n === void 0 && Ns(e, this.getSymbolDef(r), this.getFnTypeConfig(r));
    const s = this.getSymbol(r), o = {
      tileRatio: e.properties.tileRatio,
      dataResolution: e.properties.tileResolution
    };
    ue(o, "heatmapIntensity", s, "heatmapIntensity", 1), ue(o, "heatmapRadius", s, "heatmapRadius", 6), ue(o, "heatmapWeight", s, "heatmapWeight", 1), ue(o, "heatmapOpacity", s, "heatmapOpacity", 1), e.generateBuffers(this.regl);
    const a = new Nr(o), l = new tn(e, a, {
      transparent: !0,
      castShadow: !1,
      picking: !0
    }), h = {};
    return e.data.aWeight && (h.HAS_HEAT_WEIGHT = 1), l.setDefines(h), l.setLocalTransform(t), l.properties.symbolIndex = r, l;
  }
  callRenderer(i, t, e) {
    const r = this.getRenderFBO(e);
    this.Wi += this.va.render(this.scene, t, r);
  }
  getUniformValues(i) {
    const t = this.getSymbol({
      index: 0
    }), { projViewMatrix: e } = i;
    return {
      glScale: 1 / i.getGLScale(),
      resolution: i.getResolution(),
      projViewMatrix: e,
      heatmapOpacity: t.heatmapOpacity
    };
  }
  getHeatmapMeshes() {
    return this.scene.getMeshes();
  }
  delete() {
    super.delete(...arguments), this.va.dispose(), delete this.va;
  }
  init() {
    const i = this.regl;
    this.renderer = new hn(i);
    const t = this.getPolygonOffset(), e = this.getSymbols()[0];
    this.va = new BL(this.regl, this.sceneConfig, this.layer, e.heatmapColor, null, t);
  }
});
fG.registerAt(on);
const dG = Hr("water", WP);
dG.registerAt(on), Rn.registerPainter("lit", Uy), Rn.registerPainter("icon", jP), Rn.registerPainter("fill", ap), Rn.registerPainter("line", Uu), Rn.registerPainter("line-gradient", kP), Rn.registerPainter("water", WP), Rn.registerPainter("tube", UP), sd.register("vt_position_vert", `#ifdef HAS_TERRAIN_ALTITUDE
    attribute float aTerrainAltitude;
#endif
uniform float minAltitude;
#ifdef HAS_ALTITUDE
    vec3 unpackVTPosition() {
        float altitude = aAltitude;
        #ifdef HAS_TERRAIN_ALTITUDE
            altitude += aTerrainAltitude * 100.0;
        #endif
        altitude += minAltitude * 100.0;
        return vec3(aPosition, altitude);
    }
#else
    float position_modValue = 16384.0;
    float position_delta = 0.00001;
    vec3 unpackVTPosition() {
        float z = aPosition.z;
        vec2 pos = sign(aPosition.xy + position_delta) * mod(abs(aPosition.xy), position_modValue);
        vec2 highs = floor(abs(aPosition.xy) / position_modValue);
        float altitude = sign(z + position_delta) * (highs.x * 2.0 + highs.y) * pow(2.0, 15.0) + z;
        #ifdef HAS_TERRAIN_ALTITUDE
            altitude += aTerrainAltitude * 100.0;
        #endif
        altitude += minAltitude * 100.0;
        return vec3(pos, altitude);
    }
#endif`), on.VERSION = "0.95.0", Rn.VERSION = "0.95.0";
if (wR(), uo) {
  const i = xe.VERSION;
  if (i.indexOf("1.0.0-beta") >= 0 || i.indexOf("1.0.0-alpha") >= 0) {
    const t = uo.inject(am);
    il("@maptalks/vt", t);
  } else il("@maptalks/vt", function() {
    return uo.inject(am);
  });
} else il("@maptalks/vt", am);
typeof console < "u" && console.log("@maptalks/vt v0.95.0");
const f9 = {
  name: "VVectorTileLayer",
  props: {
    id: String,
    options: {
      type: Object,
      default: () => ({})
    }
  },
  setup(i) {
    const { onMapMounted: t } = Xv();
    let e;
    return t((r) => {
      e = new on(i.id, i.options), e.addTo(r);
    }), sv(() => {
      e.remove();
    }), Tw(i.options.style, (r) => {
      e.setStyle(r);
    }), () => null;
  }
};
function pG(i) {
  return mR({
    url: `/style/get/${i}`,
    method: "GET"
  });
}
const d9 = {
  name: "VPubLayer",
  props: {
    id: String
  },
  setup(i) {
    const { onMapMounted: t } = Xv();
    let e;
    return t((r) => {
      pG(i.id).then((n) => {
        e = new on(i.id, n), e.addTo(r);
      });
    }), sv(() => {
      e.remove();
    }), () => null;
  }
};
export {
  mG as VMap,
  d9 as VPubLayer,
  vG as VTileLayer,
  f9 as VVectorTileLayer
};
